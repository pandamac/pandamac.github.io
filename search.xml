<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>ida_help</title>
    <url>/2020/04/06/tips_about/ida-help/</url>
    <content><![CDATA[<p>[TOC]</p>
<!--toc-->

<a id="more"></a>

<h1 id="IDA-Pro使用技巧总结"><a href="#IDA-Pro使用技巧总结" class="headerlink" title="IDA_Pro使用技巧总结"></a>IDA_Pro使用技巧总结</h1><h2 id="IDA常见命名意义"><a href="#IDA常见命名意义" class="headerlink" title="IDA常见命名意义"></a>IDA常见命名意义</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sub 指令和子函数起点</span><br><span class="line">locret 返回指令</span><br><span class="line">loc 指令</span><br><span class="line">off 数据，包含偏移量</span><br><span class="line">seg 数据，包含段地址值</span><br><span class="line">asc 数据，ASCII字符串</span><br><span class="line">byte 数据，字节（或字节数组）</span><br><span class="line">word 数据，16位数据（或字数组）</span><br><span class="line">dword 数据，32位数据（或双字数组）</span><br><span class="line">qword 数据，64位数据（或4字数组）</span><br><span class="line">flt 浮点数据，32位（或浮点数组）</span><br><span class="line">dbl 浮点数，64位（或双精度数组）</span><br><span class="line">tbyte 浮点数，80位（或扩展精度浮点数）</span><br><span class="line">stru 结构体(或结构体数组)</span><br><span class="line">algn 对齐指示</span><br><span class="line">unk 未处理字节</span><br><span class="line">IDA中有常见的说明符号，如db、dw、dd分别代表了1个字节、2个字节、4个字节</span><br></pre></td></tr></table></figure>

<h2 id="ida-python"><a href="#ida-python" class="headerlink" title="ida python"></a>ida python</h2><p><a href="https://www.hex-rays.com/products/ida/support/idapython_docs/" target="_blank" rel="noopener">https://www.hex-rays.com/products/ida/support/idapython_docs/</a><br>idaapi模块负责访问核心IDA API<br>idc模块负责提供IDA中的所有函数功能<br>idautils模块负责提供大量实用函数，其中许多函数可以生成各种数据库相关对象的python列表</p>
<p>指定judg函数的0-181范围的字节异或0xc</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">judge=0x600B00</span><br><span class="line">for i in range(182):</span><br><span class="line">    addr=0x600B00+i</span><br><span class="line">    byte=get_bytes(addr,1)#获取指定地址的指定字节数</span><br><span class="line">    byte=ord(byte)^0xC</span><br><span class="line">    patch_byte(addr,byte)#打patch修改字节</span><br></pre></td></tr></table></figure>
<p>在菜单栏中file–&gt;script file，加载python脚本</p>
<h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><h3 id="Keypatch"><a href="#Keypatch" class="headerlink" title="Keypatch"></a>Keypatch</h3><h3 id="FRIEND"><a href="#FRIEND" class="headerlink" title="FRIEND"></a>FRIEND</h3><p>重新打开 IDA，点击Edit–&gt;Plugins就可以看到FRIEND插件了。<br>/Users/shellcodepanda/Documents/panda/ida_about//ida_plugin/FRIEND/Configurations/AArch64_armv8arm_k.xml<br>导入后，选择自己想要文档化的内容，并勾选下面三个勾，允许做处理器扩展、允许显示提示、允许显示函数概要。点击 OK。</p>
<h3 id="C-filt"><a href="#C-filt" class="headerlink" title="C++filt"></a>C++filt</h3><p>可以用于显示出c++中复杂的重载后的函数名称</p>
<h3 id="strip"><a href="#strip" class="headerlink" title="strip"></a>strip</h3><p>可用于elf去符号，去符号后仍然保持正常功能但增加了逆向的难度，出题恶人必备</p>
<h3 id="win-tools"><a href="#win-tools" class="headerlink" title="win_tools"></a>win_tools</h3><h4 id="PE-tools："><a href="#PE-tools：" class="headerlink" title="PE tools："></a>PE tools：</h4><p>是一组用于分析Windows系统中正在运行的进程和可执行文件的工具</p>
<h2 id="ida-watch"><a href="#ida-watch" class="headerlink" title="ida watch"></a>ida watch</h2><p>右键AddWatch或直接按Insert键，插入一个寄存器v0，注意大小写；<br>插入时我们需要指定变量的类型，如（String）v1，（char *）v2，（int）v3等形式类似于C++里的类型强转。这样我们才可以看到寄存器的值。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ida调试Dalvik显示局部变量</span><br><span class="line">(Object*)v2</span><br><span class="line">(String)v2</span><br><span class="line">(char*)v2</span><br><span class="line">(int)v2</span><br></pre></td></tr></table></figure>
<h2 id="比较二进制"><a href="#比较二进制" class="headerlink" title="比较二进制"></a>比较二进制</h2><p>/Users/shellcodepanda/Documents/panda/ida_about/ida_plugin/ida比较工具/diaphora_1.2.4_python2_ida_695_to_73/diaphora.py<br>导入后，选择生成sqlite 或者选择另一个进行比较，选择Use slow heuristics. 会比较好点。</p>
<h2 id="ida7-0-中文"><a href="#ida7-0-中文" class="headerlink" title="ida7.0 中文"></a>ida7.0 中文</h2><p>IDA string window显示中文 Options -&gt; Stings -&gt; Unicode C-style(16 bits)<br>ctrol+F5  会导出所有F5 文件 这样搜索中文？</p>
<h2 id="IDA反编译会出现问题IDA-sp-analysis-failed-不能F5"><a href="#IDA反编译会出现问题IDA-sp-analysis-failed-不能F5" class="headerlink" title="IDA反编译会出现问题IDA sp-analysis failed 不能F5"></a>IDA反编译会出现问题IDA sp-analysis failed 不能F5</h2><p><a href="http://bbs.pediy.com/thread-140002.htm" target="_blank" rel="noopener">http://bbs.pediy.com/thread-140002.htm</a><br><a href="http://blog.csdn.net/dj0379/article/details/8699219" target="_blank" rel="noopener">http://blog.csdn.net/dj0379/article/details/8699219</a><br><a href="https://reverseengineering.stackexchange.com/questions/3197/fixing-the-stackpointer-in-ida-when-exception-handlers-are-used" target="_blank" rel="noopener">https://reverseengineering.stackexchange.com/questions/3197/fixing-the-stackpointer-in-ida-when-exception-handlers-are-used</a><br><a href="http://blog.csdn.net/zhangmiaoping23/article/details/43492641" target="_blank" rel="noopener">http://blog.csdn.net/zhangmiaoping23/article/details/43492641</a><br>1.花指令patch</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">分析之后不难发现不能F5的原因,就在于跳转.</span><br><span class="line">一个函数里面的一个跳转在未知的情况下会出现不能F5.</span><br><span class="line">	</span><br><span class="line">.text:00401675 pop ebp</span><br><span class="line">.text:00401676 pop esi</span><br><span class="line">.text:00401677 pop ecx</span><br><span class="line">.text:00401678 retn</span><br><span class="line">.text:00401678 sub_4015ED endp ; sp-analysis failed</span><br><span class="line">.text:00401642 mov eax, offset loc_40164A</span><br><span class="line">.text:00401647 jmp eax</span><br><span class="line">用OD打开之后 改掉代码在保存,然后重新用IDA打开 F5就可以了,sp-analysis failed 也就消失了.</span><br><span class="line">在OD里直接改成 JMP 40164A</span><br></pre></td></tr></table></figure>
<ol>
<li>413238:positive sp value has been found<br><img src="media/15865894340527.jpg" alt=""><br>那我们就去找413238这个地址的地方，提示是说sp指针的值没有被找到，说明是这里出错了，那么就去修改sp的值，修改方法如下：<br><img src="media/15865894821928.jpg" alt=""><br>也可以使用快捷键 Alt+K</li>
<li>xxx: can analysis failed<br><img src="media/15865896765840.jpg" alt=""><br>就尝试着把报错的地址的汇编语句改一哈，改成nop，就可以解决问题</li>
</ol>
<h2 id="IDA显示-thumb"><a href="#IDA显示-thumb" class="headerlink" title="IDA显示 thumb"></a>IDA显示 thumb</h2><p>下断要减1  thumb指令<br>用IDA反汇编NDK程序的时候 发现很多程序都会反汇编错误，那是因为IDA在对 ARM反汇编的时候模式不正确。因为在动态调试 的时候，IDA并没有去解析elf模块中的一些信息，<br>造成了模块信息丢失并且反汇编就会出现错误。 这时我们可以通过更改段寄存器的值来更改反汇编模式，<br>如下图，按 “ALT+G”会出现如下窗口，把 Value 的 0x00 改为 0x01<br>0为ARM  1为 thumb</p>
<h2 id="IDA-快捷键-配置"><a href="#IDA-快捷键-配置" class="headerlink" title="IDA 快捷键_配置"></a>IDA 快捷键_配置</h2><p>ctrl+w：保存ida数据库<br>ctrl+s：选择某个数据段，直接进行跳转<br>ctrl+鼠标滚轮：能够调节流程视图的大小</p>
<p>配置IDA<br>一、ida.cfg<br><strong>SHOW_AUTOCOMMENTS</strong> 表示是否自动生成汇编指令的注释<br><strong>GRAPH_SHOW_LINEPREFIXES</strong> 表示是否在流程控制视图中显示地址<br><strong>VPAGESIZE</strong> 表示内存调整参数，当处理非常大的输入文件时，IDA可能报告内存不足而无法创建新数据库，在这种情况下增大该参数，重新打开输入文件即可解决问题<br><strong>OPCODE_BYTES</strong> 表示要显示的操作码字节数的默认值<br><strong>INDENTATION</strong> 表示指令缩进的距离<br><strong>NameChars</strong> 表示IDA支持的变量命令使用的字符集，默认是数字+字母还有几个特殊符号，如果需要添加就改变该参数<br>二、idagui.cfg<br>这个文件主要配置默认的GUI行为，键盘的快捷键等，这个很少需要修改，不做过多介绍。感兴趣的可以自己打开该文件观察，并不难懂，改改快捷键还是很容易的<br>三、idatui.cfg</p>
<p>；：在反汇编后的界面中写下注释<br>/ ：在反编译后伪代码的界面中写下注释<br>\：在反编译后伪代码的界面中隐藏/显示变量和函数的类型描述，有时候变量特别多的时候隐藏掉类型描述看起来会轻松很多</p>
<p>ctrl+shift+w：拍摄IDA快照<br>由于IDA不提供撤销的功能，如果你不小心按到某个键，导致ida数据库发生了改变，就得重新来过，所以要记得在经常操作的时候，加上快照：file–&gt;take database snapshot<br>加完快照后，会生成一个新的ida数据库文件，本质上是有点像另存的操作<br>生成 b00ks_20200411145256.i64</p>
<p>windows–&gt;reset desktop: 可以恢复初始ida布局</p>
<p>u：undefine，取消定义函数、代码、数据的定义</p>
<p>内存快照<br>创建完函数后，再将sub_401030函数重命名为reg_modify_401030，方便标记。然后，就到了本章重点，点击Debugger -&gt; Take memory snapshot，就可以拍摄内存快照了。<br>拍完快照后，就无需在使用调试了，直接断开远程调试功能。断开远程后，因为拍摄了内存快照，所以off_40E000这些动态变量还是保留着之前的赋值，这就是内存快照的功能，相当于你不用在虚拟机里给样本解密/脱壳，就能直接通过内存快照分析解密/脱壳后的样本。</p>
<p>函数调用图<br>菜单栏中：view–&gt;graphs–&gt;Function calls(快捷键Ctrl+F12)<br><img src="media/15865887458893.jpg" alt=""></p>
<p>导入C语言声明的结构体<br>实际上，IDA有提供一个更方便的创建结构体的方法，就是直接写代码导入<br>在View–&gt;Open Subviews–&gt;Local Types中可以看到本地已有的结构体，在该窗口中右击insert<br>可以添加新的结构体：</p>
<p>ida调试<br>F7 单步步入，遇到函数，将进入函数代码内部<br>F8 单步步过，执行下一条指令，不进入函数代码内部<br>F4 运行到光标处（断点处）<br>F9 继续运行<br>CTRL+F2 终止一个正在运行的调试进程<br>CTRL+F7 运行至返回,直到遇到RETN（或断点）时才停止.</p>
<p>ALT+M   添加标签  记录位置<br>ctrol+M  查看标签<br>IDA  ctrol F5 可以导出 函数名和 伪C代码<br>对光标处<br>C 解析为代码<br>D 解析为数据<br>A 解析为ASCII码字符串<br>U 解析为未定义的内容<br>ALT+T 搜索文本字符串<br>ALT+B 搜索十六进制字节序列</p>
<h2 id="64位参数会在函数中存在两个参数！-IDA中看到4个参数，改参数"><a href="#64位参数会在函数中存在两个参数！-IDA中看到4个参数，改参数" class="headerlink" title="64位参数会在函数中存在两个参数！ IDA中看到4个参数，改参数"></a>64位参数会在函数中存在两个参数！ IDA中看到4个参数，改参数</h2><p>signed int replace_GetRawKBSync_sub_1D060(long long  a1, int a3_11, id *a4)  IDA 中会有4个参数。</p>
<h2 id="IDA-脚本-调用函数"><a href="#IDA-脚本-调用函数" class="headerlink" title="IDA 脚本 调用函数"></a>IDA 脚本 调用函数</h2><p><a href="http://www.hexblog.com/?p=113" target="_blank" rel="noopener">http://www.hexblog.com/?p=113</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Appcall.set_appcall_options(0x0)</span><br><span class="line">api_dlopen = Appcall.proto(LocByName(&quot;_dlopen&quot;),&quot;void *__cdecl dlopen(const char *path, int mode);&quot;)</span><br><span class="line">#print &quot;api_dlopen = %x\n&quot;,hex(api_dlopen)</span><br><span class="line">Message(&quot;Load ssl kill\n&quot;)</span><br><span class="line">remote_sslkill_path = &quot;/Users/panda/Documents/Github/ssl-kill-switch2/layout/SSLKillSwitch.framework/Versions/A/SSLKillSwitch&quot;</span><br><span class="line">api_dlopen(remote_sslkill_path, 1)</span><br><span class="line">RefreshDebuggerMemory()</span><br></pre></td></tr></table></figure>

<h2 id="ida静态分析"><a href="#ida静态分析" class="headerlink" title="ida静态分析"></a>ida静态分析</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">IDA  静态分析</span><br><span class="line">ar_38= -0x38</span><br><span class="line">var_30= -0x30</span><br><span class="line">var_28= -0x28</span><br><span class="line">var_20= -0x20</span><br><span class="line">var_18= -0x18</span><br><span class="line">var_10= -0x10  注意这里是 - not +</span><br><span class="line">STP             X10, X11, [SP,#0xB0+var_60] 看这里   [SP,#0xB0+var_60] = x10   [SP,#0xB0+var_58]=x11</span><br><span class="line">STP             X9, X8, [SP,#0xB0+var_70] </span><br><span class="line">。。。。</span><br><span class="line">STUR            X0, [X29,#var_18]</span><br><span class="line">LDUR            X8, [X29,#var_8]</span><br><span class="line">LDUR            X2, [X29,#var_18]</span><br><span class="line">LDR             X0, [SP,#0xB0+var_58]</span><br><span class="line">LDR             X1, [X0] ; decodeMachOHeader</span><br><span class="line">MOV             X0, X8</span><br><span class="line">BL              _objc_msgSend</span><br></pre></td></tr></table></figure>
<h2 id="android"><a href="#android" class="headerlink" title="android"></a>android</h2><h3 id="导入ida看符号"><a href="#导入ida看符号" class="headerlink" title="导入ida看符号"></a>导入ida看符号</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$JADX_CONSOLE --output-dir-src java_dir app-release/classes.dex</span><br><span class="line">python $make_sig -d java_dir -o method_sig.txt</span><br><span class="line">IDA use py /Users/shellcodepanda/Documents/android_tools/ida_idc_py/jni_helper.py</span><br><span class="line"></span><br><span class="line">dash ``ida_xxxx</span><br><span class="line"></span><br><span class="line">先使用ida打开要分析的程序，等ida自动分析完成，本脚本会根据jni的调用的偏移值在ida中创建两个枚举类型，支持F5插件，</span><br><span class="line">然后扫描用户的函数，根据汇编指令自动分析jni调用点，添加注释，如果遇到无法识别的指令，可以在偏移上面按m键手动设置。</span><br><span class="line">如果未成功自动识别，请按m手动设置。</span><br><span class="line">使用ALT+fn+F7 &#123;ida_jni_path&#125;</span><br></pre></td></tr></table></figure>
<h2 id="iOS"><a href="#iOS" class="headerlink" title="iOS"></a>iOS</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">111</span><br></pre></td></tr></table></figure>
<h2 id="macos"><a href="#macos" class="headerlink" title="macos"></a>macos</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">222</span><br></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://xz.aliyun.com/t/4205#toc-0" target="_blank" rel="noopener">IDA Pro7.0使用技巧总结</a></p>
]]></content>
      <categories>
        <category>tools</category>
        <category>ida</category>
        <category>tips</category>
      </categories>
      <tags>
        <tag>ida</tag>
        <tag>脚本</tag>
        <tag>tips</tag>
      </tags>
  </entry>
  <entry>
    <title>frida-trace扩展信息到burp</title>
    <url>/2020/03/13/frida_about/frida-trace-burp/</url>
    <content><![CDATA[<h1><span id="frida-trace扩展信息到burp">frida-trace扩展信息到burp</span></h1><p>[TOC]</p>
<h2><span id="1-简介">1. 简介</span></h2><p>参考原文<a href="https://cedricvb.be/post/tracing-api-calls-in-burp-with-frida/#prettyPhoto" target="_blank" rel="noopener">Tracing API calls in Burp with Frida</a></p>
<p>利用frida实现一个与burp结合实时修改二进制函数参数返回值插件。</p>
<ol>
<li>可以burp查看frida hook的值，burp有很多非常人性化的界面可以参考。</li>
<li>可以burp修改hook的参数，注入测试<ol>
<li>NSString*</li>
<li>NSData*</li>
<li>byte * or char*<a id="more"></a>

</li>
</ol>
</li>
</ol>
<h2><span id="2-配置">2. 配置</span></h2><h3><span id="21-frida-trace-传输到代理-12700126080">2.1 frida-trace 传输到代理 127.0.0.1:26080</span></h3><ol>
<li>python3 tracer.py -m “+[EncryptUtils AESEncrypt:key:]” -Uf me.pandamac.iOSPentest</li>
<li>python3 tracer.py -m “+[EncryptUtils AESEncrypt:key:]” -f me.pandamac.iOSPentest -D c27808502c1f74e1659074e5154256360fe17f648 </li>
<li>python3 tracer.py -m  “-[EncryptUtils ret_NSData_by_bytes:byNSString:]” -f me.pandamac.iOSPentest -D c7808502c1f74e1659074e5154256360fe17f648</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding:utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> frida_tools <span class="keyword">import</span> tracer</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">BURP_HOST = <span class="string">'localhost'</span></span><br><span class="line">BURP_PORT = <span class="number">26080</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">frida_process_message</span><span class="params">(self, message, data, ui)</span>:</span></span><br><span class="line">    handled = <span class="literal">False</span></span><br><span class="line">    <span class="keyword">if</span> message[<span class="string">'type'</span>] == <span class="string">'input'</span>:</span><br><span class="line">        handled = <span class="literal">True</span></span><br><span class="line">    <span class="keyword">elif</span> message[<span class="string">'type'</span>] == <span class="string">'send'</span>:</span><br><span class="line">        stanza = message[<span class="string">'payload'</span>]</span><br><span class="line">        <span class="keyword">if</span> stanza[<span class="string">'from'</span>] == <span class="string">'/request'</span>:</span><br><span class="line">            req_data = stanza[<span class="string">'payload'</span>]</span><br><span class="line">            print(req_data)</span><br><span class="line">            <span class="comment"># orig_json_data = json.loads(req_data)</span></span><br><span class="line">            <span class="comment"># orig_request_url = orig_json_data.pop(u'orig_request_url')</span></span><br><span class="line">            orig_request_url = <span class="string">'execute'</span></span><br><span class="line">            req = requests.request(<span class="string">'REQUEST'</span>,</span><br><span class="line">                                  <span class="string">'http://%s:%d/'</span> % (BURP_HOST, BURP_PORT),</span><br><span class="line">                                  headers=&#123;</span><br><span class="line">                                      <span class="string">'content-type'</span>: <span class="string">'text/plain'</span>,</span><br><span class="line">                                      <span class="string">'ORIG_REQUEST_URI'</span>: orig_request_url</span><br><span class="line">                                  &#125;,</span><br><span class="line">                                  data=req_data)</span><br><span class="line">            return_content = req.content.decode(<span class="string">'utf-8'</span>)</span><br><span class="line">            <span class="comment"># req = requests.request('REQUEST', 'http://%s:%d/' % (BURP_HOST, BURP_PORT),</span></span><br><span class="line">            <span class="comment">#                        headers=&#123;'content-type':'text/plain', 'ORIG_REQUEST_URI': orig_request_url&#125;,</span></span><br><span class="line">            <span class="comment">#                        data=json.dumps(orig_json_data))</span></span><br><span class="line">            self._script.post(&#123;<span class="string">'type'</span>:<span class="string">'input'</span>, <span class="string">'payload'</span>: return_content&#125;)</span><br><span class="line">            handled = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">elif</span> stanza[<span class="string">'from'</span>] == <span class="string">'/response'</span>:</span><br><span class="line">            req_data = stanza[<span class="string">'payload'</span>].encode(<span class="string">'utf-8'</span>)</span><br><span class="line">            req = requests.request(<span class="string">'RESPONSE'</span>, <span class="string">'http://%s:%d/'</span> % (BURP_HOST, BURP_PORT),</span><br><span class="line">                                   headers=&#123;<span class="string">'content-type'</span>: <span class="string">'text/plain'</span>&#125;,</span><br><span class="line">                                   data=req_data)</span><br><span class="line">            self._script.post(&#123;<span class="string">'type'</span>: <span class="string">'output'</span>, <span class="string">'payload'</span>: req.content.decode(<span class="string">'utf-8'</span>)&#125;)</span><br><span class="line">            handled = <span class="literal">True</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> handled:</span><br><span class="line">        self.__process_message(message, data, ui)</span><br><span class="line"></span><br><span class="line">tracer.Tracer.__process_message = tracer.Tracer._process_message</span><br><span class="line">tracer.Tracer._process_message = frida_process_message</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    tracer.main()</span><br></pre></td></tr></table></figure>
<h3><span id="22-12700126080-重定位到-12700127080">2.2 127.0.0.1:26080 重定位到 127.0.0.1:27080</span></h3><p><img src="https://i.loli.net/2020/03/13/s4Oja7CBWD2umLv.jpg" alt="-w674"></p>
<h3><span id="23-回显server接受信息返回信息">2.3 回显server接受信息,返回信息</span></h3><ul>
<li>如果没有这个，将返回数据为 burp的代理信息给js代码，并不是burp修改后的数据。</li>
<li>相当于将数据修改后发送到127.0.0.1:27080,然后通过requests.request 返回的数据为回显server回显出来的数据。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding: utf-8</span></span><br><span class="line"><span class="keyword">import</span> platform</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> int(platform.python_version_tuple()[<span class="number">0</span>]) &lt; <span class="number">3</span>:</span><br><span class="line">    <span class="keyword">from</span> BaseHTTPServer <span class="keyword">import</span> HTTPServer, BaseHTTPRequestHandler</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">from</span> http.server <span class="keyword">import</span> HTTPServer, BaseHTTPRequestHandler</span><br><span class="line"><span class="keyword">from</span> optparse <span class="keyword">import</span> OptionParser</span><br><span class="line">ECHO_PORT = <span class="number">27080</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RequestHandler</span><span class="params">(BaseHTTPRequestHandler)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">do_REQUEST</span><span class="params">(self)</span>:</span></span><br><span class="line">        request_path = self.path</span><br><span class="line">        print(<span class="string">'Recving request connction...'</span>)</span><br><span class="line">        request_headers = self.headers</span><br><span class="line">        content_length = request_headers.getheaders(<span class="string">'content-length'</span>)</span><br><span class="line">        length = int(content_length[<span class="number">0</span>]) <span class="keyword">if</span> content_length <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        self.send_response(<span class="number">200</span>)</span><br><span class="line">        self.end_headers()</span><br><span class="line">        self.wfile.write(self.rfile.read(length))</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">do_RESPONSE</span><span class="params">(self)</span>:</span></span><br><span class="line">        request_path = self.path</span><br><span class="line">        print(<span class="string">'Recving Response connction...'</span>)</span><br><span class="line">        request_headers = self.headers</span><br><span class="line">        content_length = request_headers.getheaders(<span class="string">'content-length'</span>)</span><br><span class="line">        length = int(content_length[<span class="number">0</span>]) <span class="keyword">if</span> content_length <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        self.send_response(<span class="number">200</span>)</span><br><span class="line">        self.end_headers()</span><br><span class="line"></span><br><span class="line">        self.wfile.write(self.rfile.read(length))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'Listening on localhost: %d'</span> % ECHO_PORT)</span><br><span class="line">    server = HTTPServer((<span class="string">''</span>, ECHO_PORT), RequestHandler)</span><br><span class="line">    server.serve_forever()</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    print(<span class="string">'Staring echo server on port %d'</span> % ECHO_PORT)</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<h3><span id="24-trace-js-测试代码需改参数和返回值">2.4 trace js 测试代码,需改参数和返回值</span></h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Called synchronously when about to call +[EncryptUtils AESEncrypt:key:].</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * @this &#123;object&#125; - Object allowing you to store state for use in onLeave.</span></span><br><span class="line"><span class="comment">   * @param &#123;function&#125; log - Call this function with a string to be presented to the user.</span></span><br><span class="line"><span class="comment">   * @param &#123;array&#125; args - Function arguments represented as an array of NativePointer objects.</span></span><br><span class="line"><span class="comment">   * For example use args[0].readUtf8String() if the first argument is a pointer to a C string encoded as UTF-8.</span></span><br><span class="line"><span class="comment">   * It is also possible to modify arguments by assigning a NativePointer object to an element of this array.</span></span><br><span class="line"><span class="comment">   * @param &#123;object&#125; state - Object allowing you to keep state across function calls.</span></span><br><span class="line"><span class="comment">   * Only one JavaScript function will execute at a time, so do not worry about race-conditions.</span></span><br><span class="line"><span class="comment">   * However, do not use this to store function arguments across onEnter/onLeave, but instead</span></span><br><span class="line"><span class="comment">   * use "this" which is an object for keeping state local to an invocation.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  onEnter: <span class="function"><span class="keyword">function</span> (<span class="params">log, args, state</span>) </span>&#123;</span><br><span class="line">    log(<span class="string">'+[EncryptUtils AESEncrypt:'</span> + args[<span class="number">2</span>] + <span class="string">' key:'</span> + args[<span class="number">3</span>] + <span class="string">']'</span>);</span><br><span class="line">    <span class="keyword">this</span>.args0=args[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">this</span>.args1=args[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">this</span>.args2=args[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">this</span>.args3=args[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> func_name_nstring = ObjC.selectorAsString(<span class="keyword">this</span>.args1);</span><br><span class="line">    send_data=<span class="built_in">JSON</span>.stringify(&#123;</span><br><span class="line">        FH_FUNC_NAME: func_name_nstring,</span><br><span class="line">        FH_ARG_COUNT: <span class="number">3</span>,</span><br><span class="line">        FH_DETAIL_OBJECT: ObjC.Object(<span class="keyword">this</span>.args0).toString(),</span><br><span class="line">        FH_DETAIL_ARG1:   ObjC.Object(<span class="keyword">this</span>.args2).toString(),</span><br><span class="line">        FH_DETAIL_ARG2:   ObjC.Object(<span class="keyword">this</span>.args3).toString(),</span><br><span class="line">        <span class="comment">// FH_DETAIL_RET: ObjC.Object(retval).toString(),</span></span><br><span class="line">    &#125;, <span class="literal">null</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    send(&#123;<span class="attr">from</span>:<span class="string">'/request'</span>, <span class="attr">payload</span>: send_data&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> op = recv(<span class="string">'input'</span>, <span class="function"><span class="keyword">function</span> <span class="title">onMessage</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">        log(<span class="string">"Waiting Input payload"</span>);</span><br><span class="line">        <span class="comment">// log(value.payload);</span></span><br><span class="line">        <span class="comment">// log("Waiting Input recv_data start");</span></span><br><span class="line">        recv_data = <span class="built_in">JSON</span>.parse(value.payload)</span><br><span class="line">        log(recv_data)</span><br><span class="line">        <span class="comment">// log("Waiting Input recv_data end");</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> NSString = ObjC.classes.NSString;</span><br><span class="line">        args[<span class="number">2</span>]  = NSString.alloc().initWithString_(recv_data[<span class="string">"FH_DETAIL_ARG1"</span>]);</span><br><span class="line">        args[<span class="number">3</span>]  = NSString.alloc().initWithString_(recv_data[<span class="string">"FH_DETAIL_ARG2"</span>]);</span><br><span class="line">    &#125;);</span><br><span class="line">    op.wait();</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Called synchronously when about to return from +[EncryptUtils AESEncrypt:key:].</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * See onEnter for details.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * @this &#123;object&#125; - Object allowing you to access state stored in onEnter.</span></span><br><span class="line"><span class="comment">   * @param &#123;function&#125; log - Call this function with a string to be presented to the user.</span></span><br><span class="line"><span class="comment">   * @param &#123;NativePointer&#125; retval - Return value represented as a NativePointer object.</span></span><br><span class="line"><span class="comment">   * @param &#123;object&#125; state - Object allowing you to keep state across function calls.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  onLeave: <span class="function"><span class="keyword">function</span> (<span class="params">log, retval, state</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(retval);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> func_name_nstring = ObjC.selectorAsString(<span class="keyword">this</span>.args1);</span><br><span class="line">    send_data=<span class="built_in">JSON</span>.stringify(&#123;</span><br><span class="line">        FH_FUNC_NAME: func_name_nstring,</span><br><span class="line">        FH_DETAIL_RET: ObjC.Object(retval).toString(),</span><br><span class="line">    &#125;, <span class="literal">null</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    send(&#123;<span class="attr">from</span>:<span class="string">'/response'</span>, <span class="attr">payload</span>: send_data&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> op = recv(<span class="string">'output'</span>, <span class="function"><span class="keyword">function</span> <span class="title">onMessage</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">        log(<span class="string">"Waiting output payload"</span>);</span><br><span class="line">        <span class="comment">// log(value.payload);</span></span><br><span class="line">        <span class="comment">// log("Waiting output recv_data start");</span></span><br><span class="line">        recv_data = <span class="built_in">JSON</span>.parse(value.payload)</span><br><span class="line">        log(recv_data)</span><br><span class="line">        <span class="comment">// log("Waiting output recv_data end");</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> NSString = ObjC.classes.NSString;</span><br><span class="line">        <span class="keyword">var</span> tmp_retval = NSString.alloc().initWithString_(recv_data[<span class="string">"FH_DETAIL_RET"</span>]);</span><br><span class="line">        retval.replace(tmp_retval);</span><br><span class="line">    &#125;);</span><br><span class="line">    op.wait();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2><span id="3测试效果">3.测试效果</span></h2><h3><span id="31-burp接受函数参数包">3.1 burp接受函数参数包</span></h3><p><img src="https://i.loli.net/2020/03/13/vC6QbUEVcH21rfY.jpg" alt="-w468"><br>可以进行修改，然后点击Forward</p>
<h3><span id="32-burp接受函数返回包">3.2 burp接受函数返回包</span></h3><p><img src="https://i.loli.net/2020/03/13/Pni6xCwveEyF9UL.jpg" alt="-w504"><br>可以进行修改，然后点击Forward</p>
<h2><span id="4总结">4.总结</span></h2><ul>
<li>直接测试所有二进制的函数进出返回值，用于测试工作，剩下工作就是编写合适的 js 代码,将trace的函数用于通用。当然也可以不用trace,自己写hook 框架，达到任意修改函数返回值的效果。</li>
<li>如果函数有时间校验的话，可能会出错，这时候用代码实现修改即可。</li>
</ul>
]]></content>
      <categories>
        <category>tools</category>
        <category>frida</category>
      </categories>
      <tags>
        <tag>frida</tag>
        <tag>burp</tag>
      </tags>
  </entry>
  <entry>
    <title>lldb_help</title>
    <url>/2020/02/23/tips_about/lldb-help/</url>
    <content><![CDATA[<p>[TOC]</p>
<a id="more"></a>
<h1><span id="some-gdb-tips">some gdb tips</span></h1><h2><span id="在具体地址下断">在具体地址下断</span></h2><p>break *0x0000000000400448</p>
<h1><span id="some-lldb-tips">some lldb tips</span></h1><h2><span id="通用">通用</span></h2><h3><span id="bug">bug</span></h3><h4><span id="error-process-launch-failed-unable-to-locate-lldb-server">error: process launch failed: unable to locate lldb-server</span></h4><p>sudo ln -s  /usr/bin/lldb-server-3.8 /usr/bin/lldb-server</p>
<h2><span id="加载so-动态库等">加载so 动态库等</span></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  (lldb) expr (void*)dlopen(&quot;/path/to/build/SSLKillSwitch.framework/Versions/A/SSLKillSwitch&quot;, 1)</span><br><span class="line">  (lldb) expr (void*)dlopen(&quot;/Library/MobileSubstrate/DynamicLibraries/Reveal2Loader.dylib&quot;,1)</span><br><span class="line">  (lldb) </span><br><span class="line">  command alias reveal_load_sim expr (void*)dlopen(&quot;/Applications/Reveal.app/Contents/SharedSupport/iOS-Libraries/RevealServer.framework/RevealServer&quot;, 0x2);</span><br><span class="line">  (lldb) expr (void*)dlopen(&quot;/Library/RHRevealLoader/libReveal.dylib&quot;,1)</span><br><span class="line">  (void *) $1 = 0x00007f92e74d10c0</span><br><span class="line">Using DYLD_INSERT_LIBRARIES to inject SSLKillSwitch and start the process.</span><br></pre></td></tr></table></figure>
<h2><span id="lldb-expr-相关">lldb expr 相关</span></h2><p>[xxx setHidden:YES]  show/hide<br>caflush  Force Core Animation to flush. This will ‘repaint’ the UI but also may mess with ongoing animations</p>
<h3><span id="断点相关">断点相关</span></h3><h4><span id="1-对函数下断点">1. 对函数下断点</span></h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">breakpoint <span class="built_in">set</span> -n text: -c ret == YES    //使用-c设置条件断点</span><br><span class="line">breakpoint <span class="built_in">set</span> -f xxx.m -l 38            //使用-f指定文件 使用-l指定文件某一行设置断点</span><br><span class="line">breakpoint <span class="built_in">set</span> -n <span class="string">"-[xxx xxx]"</span>           //根据函数名下断点(调试信息)</span><br><span class="line">breakpoint <span class="built_in">set</span> -a VitrualAddress         //根据虚拟地址下断点</span><br><span class="line"></span><br><span class="line">b isEven, br s -F isEven  //符号断点</span><br><span class="line">breakpoint <span class="built_in">set</span> -f main.m -l 16：在源码文件的某一行断点</span><br><span class="line">b main.m:17。b是_regexp-break的缩写</span><br><span class="line"></span><br><span class="line">breakpoint modify -c <span class="string">'i == 99'</span> 1   //条件断点</span><br><span class="line">断点时附加自定义操作：breakpoint <span class="built_in">command</span> add 1</span><br></pre></td></tr></table></figure>
<h4><span id="2观察断点">2.观察断点</span></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">watchpoint set expression -w write ―- 0xl01801a48 :给某个地址设置观察断点,内存进行写操作时就会触发断点</span><br><span class="line"></span><br><span class="line">// 获取需要监控的内存地址</span><br><span class="line">p (ptrdiff_t)ivar_getOffset((struct Ivar *)class_getInstanceVariable([MyView class], &quot;_layer&quot;))</span><br><span class="line"></span><br><span class="line">(ptrdiff_t) $0 = 8</span><br><span class="line"></span><br><span class="line">watchpoint set expression -- (int *)$myView + 8：监控_layer的地址</span><br><span class="line"></span><br><span class="line">变量监控：watchpoint set variable -w read_write</span><br><span class="line">条件监控：watchpoint modify -c &apos;(global==5)&apos;</span><br></pre></td></tr></table></figure>
<h4><span id="3断点后执行命令">3.断点后执行命令</span></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">b +[Manager performLoginWithUsernameOnEmail: password: preAuthToken: twoFAMethod: confirmReactivation:rememberDevice:fromDeepLink:onComplete:]</span><br><span class="line">Breakpoint 2: where = Snapchat&apos;+[Manager</span><br><span class="line">br com add 2</span><br><span class="line">&gt; po $x2</span><br><span class="line">&gt; po $x3</span><br><span class="line">&gt; c</span><br><span class="line">&gt; po F.viewCFG()</span><br><span class="line">&gt; DONE</span><br></pre></td></tr></table></figure>
<h4><span id="7如何将断点设置在动态库的入口">7.如何将断点设置在动态库的入口</span></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LLDB命令行进行调试时自 动中断在 _dyld_start 处，因为此时dyld已经加载，所以在dyld里面设置一个在所有库中加载并且在constructor 函数执行之前执行的断点，例如initializeMainExecutable</span><br><span class="line">settings set target.process.stop-on-sharedlibrary-events 1</span><br></pre></td></tr></table></figure>
<h4><span id="8插件断点">8.插件断点</span></h4><p>bdisable    用正则查找并关闭一组断点<br>benable    用正则查找并开启一组断点<br>binside    用相对地址设置断点，自动加上 ALSR 偏移<br>bmessage    给某个类的 method 设置断点，同时会在其父类上查找 method<br>pinvocation    打印方法调用堆栈，仅支持x86</p>
<h4><span id="9某个类的所有方法下断点并跟踪打印调用参数">9.某个类的所有方法下断点并跟踪打印调用参数</span></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">command regex bclass &apos;s/(.+)/rb \[%1 /&apos;</span><br><span class="line">rb -&gt; breakpoint set -r %1</span><br><span class="line">bclass ULLoginViewController -&gt; breakpoint set -r \[ULLoginViewController</span><br><span class="line"></span><br><span class="line">br set -r &apos;\[WAChatSessionViewController .*\]&apos;</span><br><span class="line"></span><br><span class="line">如果不在MethodTraCeCcmflg.PliSt文件里面配置需要跟踪的类，那么如下设置:</span><br><span class="line">@interface MethodTrace : NSObject</span><br><span class="line">+ (void)addClassTrace:(NSString*) className;</span><br><span class="line">+ (void)addClassTrace: (NSString *)className methodName: (NSString*) methodName;</span><br><span class="line">+ (void)addClassTrace: (NSString *)className methodList: (NSArray*) methodList;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">e [MethodTrace addClassTrace:@&quot;WAChatDataStore&quot;]</span><br><span class="line">笔者在MethodTrace的代码里面调试了—下，发现 NSLog没有被输出到Xcode的控制台，但是在Console.app里面可以看到NSLog,所以改用printf来输出。</span><br><span class="line">ENABLE_METHODTRACE</span><br></pre></td></tr></table></figure>
<h4><span id="finding-a-class-with-a-click">Finding a class with a click</span></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(lldb) b -[NSView hitTest:]</span><br><span class="line">Breakpoint 1: where = AppKit`-[NSView hitTest:], address = 0x000000010338277b</span><br><span class="line">breakpoint set -n  &quot;-[NSView hitTest:]&quot; -C &quot;real&quot; -G1</span><br><span class="line">b -[NSResponder mouseUp:]</span><br></pre></td></tr></table></figure>
<h4><span id="filter-breakpoints-for-important-content">Filter breakpoints for important content</span></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">breakpoint modify -c &apos;(BOOL)[NSStringFromClass((id)[$rdi class]) containsString:@&quot;IDESourceEditorView&quot;]&apos; -G0</span><br><span class="line">最后-G0说的是修改断点，使其在执行动作后不会自动恢复执行。</span><br><span class="line"></span><br><span class="line">(lldb) breakpoint set -n &quot;-[UIViewController viewDidLoad]&quot; -C &quot;po $arg1&quot; -G1</span><br><span class="line">-G1选项告诉断点在执行命令后自动继续。</span><br></pre></td></tr></table></figure>
<h4><span id="在模块下断">在模块下断</span></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(lldb) rb appendSignal.*_block_invoke -s Commons</span><br></pre></td></tr></table></figure>
<h4><span id="启动后断在">启动后断在</span></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-s ( --stop-at-entry )</span><br><span class="line">            Stop at the entry point of the program when launching a process.</span><br><span class="line"></span><br><span class="line">(lisa)target create tests/binaries/abort</span><br><span class="line">(lisa)process launch -s</span><br></pre></td></tr></table></figure>

<h3><span id="设置lldb-使用python2">设置lldb 使用python2</span></h3><p>defaults write com.apple.dt.lldb DefaultPythonVersion 2</p>
<h3><span id="计算偏移ida地址">计算偏移/ida地址</span></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">p/x 0X000000010095ECCC+0X0000000000038000</span><br><span class="line">(lldb) p/x 0x0000000100e595b4-0x0000000000038000 (long) $18 = 0x0000000100e215b4</span><br><span class="line">查看某个地址所在模块的信息</span><br></pre></td></tr></table></figure>

<h3><span id="读取目标地址的内存指令">读取目标地址的内存指令</span></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">x/10xg 0xl01801a48 这里的x 表示用十六进制来显示结果。&quot;g&quot;代表giant word(8字节)大小。所以就是用十六进制显示 0x101801a48所指恐惧的10个64位的元素内容。常见的大小格式为&quot;b-byte&quot;(1字节),&quot;h-half word&quot;(2字节),&quot;w- word”(4字节),&quot;g-giantword”(8字节)。</span><br></pre></td></tr></table></figure>
<h3><span id="dis-apc-反汇编指定地址">dis-a$pc 反汇编指定地址</span></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">这里是pc寄存器所对应的地址。</span><br></pre></td></tr></table></figure>
<h3><span id="切换分支">切换分支</span></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">f2:切换到当前调用栈为2的位置，也就是bt中的frame #2。</span><br></pre></td></tr></table></figure>
<h3><span id="threadinfo输出当前线程的信息">threadinfo:输出当前线程的信息。</span></h3><h3><span id="b-ptrace-c-xxx满足某个条件之后程序才会中断">b ptrace -c xxx:满足某个条件之后程序才会中断。</span></h3><h3><span id="helpapropos">help/apropos</span></h3><h3><span id="xcode预处理快捷键">xcode预处理快捷键</span></h3><p>单击 Product -&gt; PerformAction -&gt;Preprocess xxxx 可以对文件进行预处理，还可以将代码转换成汇编代码。可以帮助我们理解这些宏的作用</p>
<h3><span id="pdb来排查了一个脚本中的问题">pdb来排查了一个脚本中的问题</span></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(lldb) findclass</span><br><span class="line">error: libarclite_macosx.a(arclite.o) failed to load objfile for /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/arc/libarclite_macosx.a</span><br><span class="line">error: libarclite_macosx.a(arclite.o) failed to load objfile for /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/arc/libarclite_macosx.a</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;/Users/gogleyin/lldb/findclass.py&quot;, line 40, in findclass</span><br><span class="line">    raise AssertionError(&quot;Uhoh... something went wrong, can you figure it out? :]&quot;)</span><br><span class="line">AssertionError: Uhoh... something went wrong, can you figure it out? :]</span><br><span class="line"></span><br><span class="line">(lldb) script import pdb</span><br><span class="line">(lldb) findclass</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;/Users/gogleyin/lldb/findclass.py&quot;, line 40, in findclass</span><br><span class="line">    raise AssertionError(&quot;Uhoh... something went wrong, can you figure it out? :]&quot;)</span><br><span class="line">AssertionError: Uhoh... something went wrong, can you figure it out? :]</span><br><span class="line"></span><br><span class="line">(lldb) script pdb.pm()</span><br><span class="line">&gt; /Users/gogleyin/lldb/findclass.py(40)findclass()</span><br><span class="line">-&gt; raise AssertionError(&quot;Uhoh... something went wrong, can you figure it out? :]&quot;)</span><br><span class="line"></span><br><span class="line">(Pdb) print(codeString)  # 这个东西包含了一段oc代码，用oc runtime来找出runtime的所有类</span><br><span class="line">    @import Foundation;</span><br><span class="line">    int numClasses;</span><br><span class="line">    Class * classes = NULL;</span><br><span class="line">    classes = NULL;</span><br><span class="line">    numClasses = objc_getClassList(NULL, 0);</span><br><span class="line">    NSMutableString *returnString = [NSMutableString string];</span><br><span class="line">    classes = (__unsafe_unretained Class *)malloc(sizeof(Class) * numClasses);</span><br><span class="line">    numClasses = objc_getClassList(classes, numClasses);</span><br><span class="line">    for (int i = 0; i &lt; numClasses; i++) &#123;</span><br><span class="line">      Class c = classes[i];</span><br><span class="line">      [returnString appendFormat:@&quot;%s,&quot;, class_getName(c)];</span><br><span class="line">    &#125;</span><br><span class="line">    free(classes);</span><br><span class="line">    returnString;  # 返回returnString的值给Python脚本</span><br><span class="line"></span><br><span class="line">(Pdb) l 35, 45  # 会列出35到45行代码，注意40行的 -&gt; 表示当前pdb停在的位置</span><br><span class="line"> 35         &apos;&apos;&apos;</span><br><span class="line"> 36</span><br><span class="line"> 37         res = lldb.SBCommandReturnObject()</span><br><span class="line"> 38         debugger.GetCommandInterpreter().HandleCommand(&quot;expression -lobjc -O -- &quot; + codeString, res)</span><br><span class="line"> 39         if res.GetError():</span><br><span class="line"> 40  -&gt;         raise AssertionError(&quot;Uhoh... something went wrong, can you figure it out? :]&quot;)</span><br><span class="line"> 41         elif not res.HasResult():</span><br><span class="line"> 42             raise AssertionError(&quot;There&apos;s no result. Womp womp....&quot;)</span><br><span class="line"> 43</span><br><span class="line"> 44         returnVal = res.GetOutput()</span><br><span class="line"> 45         resultArray = returnVal.split(&quot;,&quot;)</span><br><span class="line"># 嗯，似乎res.GetError()看起来更加有趣，玩一下先</span><br><span class="line"></span><br><span class="line">(Pdb) print res.GetError()</span><br><span class="line">error: &apos;objc_getClassList&apos; has unknown return type; cast the call to its declared return type</span><br><span class="line">error: &apos;objc_getClassList&apos; has unknown return type; cast the call to its declared return type</span><br><span class="line">error: &apos;class_getName&apos; has unknown return type; cast the call to its declared return type</span><br><span class="line"># 到这里可以看到，问题是codeString里面的代码让LLDB迷惑了。</span><br><span class="line"># 实际这种错误在LLDB里面是非常常见的。你需要告诉LLDB一个函数的返回类型，因为它无法知道那是啥。</span><br><span class="line"># 在这个case下， objc_getClassList 和 class_getName 都有未知的返回类型</span><br><span class="line"># Google一下便知这两个函数的签名如下：</span><br><span class="line"> int objc_getClassList(Class *buffer, int bufferCount);</span><br><span class="line">const char * class_getName(Class cls);</span><br><span class="line"># 所有我们需要做的事转换返回类型到正确的值就可以啦。如下：</span><br><span class="line"></span><br><span class="line">codeString = r&apos;&apos;&apos;</span><br><span class="line">@import Foundation;</span><br><span class="line">int numClasses;</span><br><span class="line">Class * classes = NULL;</span><br><span class="line">classes = NULL;</span><br><span class="line">numClasses = (int)objc_getClassList(NULL, 0);</span><br><span class="line">NSMutableString *returnString = [NSMutableString string];</span><br><span class="line">classes = (__unsafe_unretained Class *)malloc(sizeof(Class) *numClasses);</span><br><span class="line">numClasses = (int)objc_getClassList(classes, numClasses);</span><br><span class="line">for (int i = 0; i &lt; numClasses; i++) &#123;</span><br><span class="line">  Class c = classes[i];</span><br><span class="line">  [returnString appendFormat:@&quot;%s,&quot;, (char *)class_getName(c)];</span><br><span class="line">&#125;</span><br><span class="line">free(classes);</span><br><span class="line">returnString;</span><br><span class="line"></span><br><span class="line">--debug选项是定位JIT代码中的问题的非常好的手段,调试lldb 的好方法</span><br><span class="line">expression --debug -lobjc -O --</span><br><span class="line">可以选择使用frame variable命令打印变量</span><br></pre></td></tr></table></figure>

<h3><span id="基本的类">基本的类：</span></h3><ul>
<li>lldb.SBDebugger：在你的脚本中用来访问类的实例的类，非常中心，还处理LLDB命令的输入和输出</li>
<li>lldb.SBTarget：与被调试的可执行文件有关（相关调试文件，磁盘上的文件）。<br>你可以用SBDebugger的实例来获取到当前选择的SBTarget。然后 你就可以通过SBTarget访问大部分其余类。</li>
<li>lldb.SBProcess：SBTarget和SBProcess是一对多的关系：SBTarget管理者一个或多个SBProcess实例。SBProcess处理内存读写还有它自己的线程。</li>
<li>lldb.SBThread：管理对应线程的栈帧和stepping的控制逻辑</li>
<li>lldb.SBFrame：管理局部变量（debug信息有提供的）和当时的寄存器快照</li>
<li>lldb.SBModule：代表着一个可执行文件。</li>
<li>lldb.SBFunction：这代表着一个加载到内存中的函数（或者对应代码），它与SBFrame是一对一的关系。<br>实例是 lldb.debugger/lldb.target…<br><a href="https://lldb.llvm.org/python_reference/index.html" target="_blank" rel="noopener">https://lldb.llvm.org/python_reference/index.html</a><br><img src="pic/1.jpg" alt><br>演示了LLDB Python主要的几个类之间的相互关系<br><img src="pic/2.jpg" alt><br>暂停在某函数时几个类的交互</li>
</ul>
<h2><span id="android">android</span></h2><h2><span id="ios">iOS</span></h2><h3><span id="砸壳">砸壳</span></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Cronet.framework git:(master) X otool -hf Cronet Fat headers</span><br><span class="line">fat_magic 0xcafebabe</span><br><span class="line">nfat_arch 2</span><br><span class="line">architecture 0  cputype 12 cpusubtype 9  capabilities 0x0</span><br><span class="line">	offset 16384 size 2749664 align 2A14 (16384)</span><br><span class="line">architecture 1 cputype 16777228 cpusubtype 0 capabilities 0x0</span><br><span class="line">	offset 2768896 size 3612224 align 2A14 (16384)</span><br><span class="line">Mach header</span><br><span class="line">	magic cputype cpusubtype caps filetype ncmds sizeofcmds flags</span><br><span class="line">	Oxfeedface 12 9 0x00 6 27 3328 0x00118085</span><br><span class="line">Mach header</span><br><span class="line">	magic cputype cpusubtype caps filetype ncmds sizeofcmds flags</span><br><span class="line">	0xfeedfacf 16777228 0 0x00 6 27 3816 0X00118085</span><br><span class="line"></span><br><span class="line">otool -arch arm64 -1 Cronet | grep crypt</span><br><span class="line">cryptoff 16384</span><br><span class="line">cryptsize 3309568</span><br><span class="line">cryptid 1</span><br><span class="line">(lldb) im li Cronet</span><br><span class="line">[0] 188F5BF7-B4C4-36EF-BB9A-976FA870F9D7 0x0000000105920000 /private/var/mobile/Containers/Bundle/Application/3A4C68EB-4059-47D4-ACE6-BE9C492DF205/ Snapchat.app/Frameworks/Cronet.framework/Cronet (0x0000000105920000)</span><br><span class="line">(lldb) memory read --force --outfile ~/Desktop/dumpoutput --binary count 3309568 16384+0x0000000105920000</span><br><span class="line">因为dump出来的文件都没有Mach-0文件头，所以在这里要先把dump出来的数据写回原 来加密的文件，以替换原来加密的部分</span><br><span class="line">2768896(之前获取的ARM64架构的偏移值)+16384(加密数据的偏移值)=2785280(写入的加密数据在文件中的偏移值)</span><br><span class="line">seek=n   Seek n blocks from the beginning of the output before copying.</span><br><span class="line">bs=n     Set both input and output block size to n bytes</span><br><span class="line">conv=value[,value ...]</span><br><span class="line">	notrunc  Do not truncate the output file.</span><br><span class="line">Cronet.framework git:(master) X dd seek=2785280 bs=l conv=notrunc if=/Users/monkey/Desktop/dumpoutput of=./Cronet</span><br><span class="line">3309568+0 records in</span><br><span class="line">3309568+0 records out</span><br><span class="line">3309568 bytes transferred in 4.698067 secs (704453 bytes/sec)</span><br><span class="line">Cronet.framework git:(master) X lipo Cronet -thin arm64 -output Cronet_arm64</span><br><span class="line">MachOView.app 修改Cronet_arm64 crypid 为0</span><br></pre></td></tr></table></figure>
<h3><span id="查询按钮事件">查询按钮事件</span></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">error: error: use of undeclared identifier &apos;UIApplication&apos;</span><br><span class="line">None</span><br><span class="line">(lldb) expression @import UIKit</span><br><span class="line">pviews</span><br><span class="line">   |    |    |    |    |    |    |    |    |    | &lt;UIButtonLabel: 0x101c730a0; frame = (7.5 12.5; 69.5 20.5); text = &apos;所有图书&apos;; opaque = NO; userInteractionEnabled = NO; layer = &lt;_UILabelLayer: 0x174295a90&gt;&gt;</span><br><span class="line">   |    |    |    |    |    |    |    |    |    |    | &lt;_UILabelContentLayer: 0x170425fa0&gt; (layer)</span><br><span class="line">   |    |    |    |    |    |    |    |    | &lt;IMTouchInsetsButton: 0x101c73f60; baseClass = UIButton; frame = (324 5.5; 35 33); opaque = NO; layer = &lt;CALayer: 0x17422d880&gt;&gt;</span><br><span class="line">   |    |    |    |    |    |    |    |    |    | &lt;UIButtonLabel: 0x101c31460; frame = (9 6.5; 35 20.5); text = &apos;选择&apos;; opaque = NO; userInteractionEnabled = NO; layer = &lt;_UILabelLayer: 0x174295360&gt;&gt;</span><br><span class="line"></span><br><span class="line">查看 “登录”按钮UIButtonLabel的响应链</span><br><span class="line">presponder 0x101c31460</span><br><span class="line">(lldb) presponder 0x101c31460</span><br><span class="line">&lt;UIButtonLabel: 0x101c31460; frame = (9 6.5; 35 20.5); text = &apos;选择&apos;; opaque = NO; userInteractionEnabled = NO; layer = &lt;_UILabelLayer: 0x174295360&gt;&gt;</span><br><span class="line">   | &lt;IMTouchInsetsButton: 0x101c73f60; baseClass = UIButton; frame = (324 5.5; 35 33); opaque = NO; layer = &lt;CALayer: 0x17422d880&gt;&gt;</span><br><span class="line">   |    | &lt;IMToolbar: 0x101c1d8b0; baseClass = UIToolbar; frame = (0 20; 375 44); opaque = NO; autoresize = W; tintColor = UIExtendedSRGBColorSpace 0 0.478431 1 1; layer = &lt;CALayer: 0x174224ec0&gt;&gt;</span><br><span class="line">查看“登录”按钮的Action事件</span><br><span class="line">(lldb) pactions 0x101c73f60</span><br><span class="line">&lt;BKLibraryViewController: 0x102817600&gt;: editButtonPressed:</span><br></pre></td></tr></table></figure>
<h3><span id="chisel-打印结构">chisel 打印结构</span></h3><p>brew install chisel –verbose</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt; NSMallocBlock : 0Xl7444b6d0&gt;</span><br><span class="line">(lldb) pblock 0xl7444b6d0</span><br><span class="line"></span><br><span class="line">(lldb) pvc</span><br><span class="line">&lt;ICSplitViewController 0x10079eab0&gt;, state: appeared, view: &lt;UILayoutContainerView 0x1009261c0&gt;</span><br><span class="line">   | &lt;UIMultiColumnViewController 0x10079f410&gt;, state: appeared, view: &lt;UIView 0x1007aee70&gt;</span><br><span class="line"></span><br><span class="line">(lldb) methods 0x10079eab0</span><br><span class="line">&lt;ICSplitViewController: 0x10079eab0&gt;:</span><br><span class="line">in ICSplitViewController:</span><br><span class="line">	Properties:</span><br><span class="line">		@property (nonatomic, getter=isDetailDimmed) BOOL detailDimmed;  (@synthesize detailDimmed = _detailDimmed;)</span><br></pre></td></tr></table></figure>
<h4><span id="对象查找">对象查找</span></h4><p>fv    用正则查找所有类的 view 实例<br>fvc    用正则查找所有类的 view controller 实例<br>findinstances    在内存中查找某个类的所有实例<br>flicker    闪烁某个 view，用于快速定位</p>
<h4><span id="对象分析">对象分析</span></h4><p>pinternals    打印对象内部的所有实例变量<br>pkp    用 -valueForKeyPath:获取对象的数据<br>pmethods    打印类的所有方法<br>poobjc    用 ObjC++ 语言执行和获取表达式的结果，expression -O -l ObjC++ —的缩写<br>pproperties    打印对象或者类的属性<br>pivar    打印对象的某个 ivar<br>wivar    给对象的某个实例变量地址设置 watchpoint，监控变化<br>pclass    打印某个对象的类继承链<br>pbcopy    打印对象并且把结果复制到粘贴板<br>pblock    打印 block 的实现函数地址和签名<br>pactions    打印 UIControl 的 target 和 action</p>
<h4><span id="视图查找">视图查找</span></h4><p>visualize    显示 UIImage, CGImageRef, UIView 或 CALayer 的图片内容，用 Mac 的预览打开，在调试绘图时非常有用<br>taplog    打印触摸到的 view，用于快速定位<br>border    给 view 加上边框，用于定位某个 view 对象<br>unborder    移除 view 或 layer 的边框<br>caflush    修改 UI 后刷新 Core Animation 界面<br>hide    隐藏 view 或 layer<br>show    显示一个 view 或者 layer，相当于执行view.hidden = NO<br>mask    给 view 添加半透明的 mask，可以用来查找被隐藏的 view<br>unmask    移除 view layer 的 mask<br>setinput    给作为 first responder 的 text field 或 text view 输入文本<br>slowanim    减慢动画速度<br>unslowanim    动画速度回复正常<br>present    Present 一个 view controller<br>dismiss    消除 present 出来的 view controller</p>
<h4><span id="视图层级">视图层级</span></h4><p>pvc    循环打印 view controller 的层级<br>pviews    循环打印 view 的层级<br>pca    打印 layer 树<br>vs    在 view 层级中搜索 view<br>ptv    打印最顶层的 table view<br>pcells    打印最顶层 table view 的所有可见的 cell<br>presponder    打印 UIResponder 响应者链</p>
<h4><span id="其他工具">其他工具</span></h4><p>sequence    执行多条命令，用;分隔<br>pjson    打印 NSDictionary 或 NSArray 的 JSON 格式<br>pcurl    用 curl 的格式显示 NSURLRequest (HTTP)<br>pdata    用字符串的形式显示 NSData<br>mwarning    模拟内存警告</p>
<h4><span id="视图调试">视图调试</span></h4><p>alamborder    给有约束错误的 view 加上边框<br>alamunborder    有约束错误的 view 加上边框<br>paltrace    打印 view 的约束信息，相当于调用_autolayoutTrace<br>panim    是否正在执行动画，相当于调用[UIView _isInAnimationBlock]</p>
<h3><span id="nsobject私有方法可以方便查看对象的内容">NSObject私有方法，可以方便查看对象的内容：</span></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">_methodDescription：打印对象或者类的整个继承链上的方法列表，同时显示方法的地址，可以直接用于断点</span><br><span class="line">_shortMethodDescription ：打印对象或者类的方法列表，不显示父类</span><br><span class="line">_ivarDescription：打印对象或者类的所有实例变量和值</span><br></pre></td></tr></table></figure>

<h3><span id="搜索uitextfield的实例对象和cycript中的choose样的">搜索UITextField的实例对象和Cycript中的choose—样的</span></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">search UIButton</span><br><span class="line">search UITextField</span><br><span class="line"># Find all UIViews, ignore subclasses</span><br><span class="line">find UIView  -e</span><br><span class="line"></span><br><span class="line"># Find all instances of UIViews (and subclasses) where tag == 5</span><br><span class="line">find UIView -c &quot;[obj tag] == 5&quot;</span><br></pre></td></tr></table></figure>
<h3><span id="读取内存">读取内存</span></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">memory read --size 4 --format x --count 4 0xbffff3c0</span><br><span class="line">me r -s4 -fx -c4 0xbffff3c0</span><br></pre></td></tr></table></figure>
<h3><span id="查看对象内存关系xcode观看">查看对象内存关系,xcode观看</span></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/Applications/Xcode.app/Contents/SharedFrameworks/LLDB.framework/Versions/A/Resources/Python/lldb/macosx/heap.py</span><br><span class="line">command alias iheap command script import lldb.macosx.heap</span><br><span class="line">&quot;malloc_info&quot;, &quot;ptr_refs&quot;, &quot;cstr_refs&quot;, &quot;find_variable&quot;, and &quot;objc_refs&quot;</span><br><span class="line"></span><br><span class="line">ptr_refs</span><br><span class="line">可以在内存中找出哪些地址引用了某个指针，也就相当于查看某个变量在哪里被引用。</span><br><span class="line"></span><br><span class="line">cstr_refs</span><br><span class="line">在内存中寻找某个C String在哪里被引用。</span><br><span class="line"></span><br><span class="line">find_variable</span><br><span class="line">在当前栈帧上寻找某个局部变量在哪里被引用。</span><br><span class="line"></span><br><span class="line">objc_refs</span><br><span class="line">在内存中寻找某个类的实例。</span><br><span class="line"></span><br><span class="line">为了查看某个对象内存分配的调用堆栈，需要在程序启动的环境变量中设置 MallocSlack Logging。</span><br><span class="line">在环境变量中增加 MallocStackLogging 的值1</span><br><span class="line">单击Xcode调试工具栏上的“Debug Momery Graph”按钮</span><br><span class="line"></span><br><span class="line">malloc_info --stack-history 0x10010d680。可以快速追溯对象的创建来源，</span><br><span class="line">参考iOS逆向：在任意app上开启malloc stack追踪内存来源</span><br><span class="line">https://www.jianshu.com/p/759015369b6f</span><br><span class="line">lldb有一个内存调试工具malloc stack，开启以后就可以查看某个内存地址的malloc和free记录，追踪对象是在哪里创建的。</span><br><span class="line"></span><br><span class="line">这个工具可以打印出对象创建的堆栈，而在逆向时，也经常需要追踪某些方法的调用栈，如果可以随时打印出某个对象的创建记录，也就能直接找到其所在的类和方法，不用再花费大量的时间去打log和动态调试追踪了。</span><br></pre></td></tr></table></figure>
<h3><span id="执行script">执行script</span></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(lldb) e @import UIKit</span><br><span class="line">(lldb) e UIApplication *$app = [UIApplication sharedApplication];</span><br><span class="line">(lldb) e UlWindow *$keyWindow = $app.keyWindow</span><br><span class="line">(lldb) e UlViewController *$root = $keyWindow.rootViewController</span><br><span class="line">(lldb) po $root</span><br><span class="line">&lt;NavigationController: 0xl2c03d200&gt;</span><br><span class="line">(lldb) e [(SCButton *)0xl2bd4b760 setTitle:@&quot;AloneMonkey&quot; forStaterUIControlStateNormal]</span><br><span class="line">(lldb) e (void)[CATransaction flush]</span><br><span class="line">(lldb) c</span><br></pre></td></tr></table></figure>
<h3><span id="在-snapchat模块中查看与login有关的符号信息">在 Snapchat模块中查看与login有关的符号信息</span></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">image lookup -rn login UserLogin</span><br><span class="line"></span><br><span class="line">(lldb) b -[UIView setTail:]</span><br><span class="line">Breakpoint 3: where = UserLogin`-[UIView(Frame) setTail:] at UIView+Frame.m:102, address = 0x0000000100b5ee34</span><br><span class="line">(lldb) il 0x0000000100b5ee34</span><br><span class="line">image lookup -a 0x0000000100b5ee34</span><br></pre></td></tr></table></figure>

<h3><span id="xcode-设置环境变量">xcode 设置环境变量</span></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">打印参数和当前的环境变量, segment加载的详细信息,加载dylib,显示是否加载,各阶段的时间消耗</span><br><span class="line">xcode  DYLD_PRINT_OPTS, DYLD_PRINT_EN, DYLD_PRINT_SEGMENTS</span><br><span class="line"></span><br><span class="line">签名InsertDyUb.dylib,拷贝 InsertDylib.dylib 到Bundle Resources</span><br><span class="line">xcode  设置环境变量DYLD_INSERT_LIBRARIES @executable_path/InsertDylib.dylib</span><br><span class="line"></span><br><span class="line">xcode  设置环境变量 DYLD_PRINT_INTERPOSING 运行 App,日志如下即为hook生效</span><br><span class="line">dyld: interposing 2 tuples onto image: /var/containers/Bundle/Application/AB57C532-19F2-4022-B757-7D211296E64D/AppStart.app/InsertDylib.dylib</span><br><span class="line"></span><br><span class="line">xcode 设置 DYLD_PRINT_STATISTICS,DYLD_PRINT_STATISTICS_DETAILS 打印各阶段的时间消耗。</span><br><span class="line"></span><br><span class="line">@executable_path:表示可执行程序所在的目录，一般是xxx.app</span><br><span class="line">@loader_path:表示每一个被加载的二进制文件的目录。例如，xxxx.plugin/aaa/abc依赖xxx.plugin/bb/ccc.dylib,那么依赖的路径可以写成 @loader_path/../bbb. 这样不管xxx.plugin放在那都能找到ccc.dylib</span><br><span class="line">@rpath:这个变量是在 Xcode build里面设置， Dynamic Libray Install Name设置为(#=@path/xxx/xxx,就可以在使用的工程中设置一个或多个RunPath Search Paths 来指定搜索路径。在运行时，会将@rpath分别替换为Runpath Search Paths中指定的路径来査找动态库。</span><br></pre></td></tr></table></figure>

<h3><span id="ios-分析常见点">iOS 分析常见点</span></h3><p>见整理的xmind</p>
<h2><span id="macos">macos</span></h2><p>查询相关 dash lldb3:<br>记录一些常用的点,基本可以用于iOS 或其他</p>
<h3><span id="调试开启配置">调试开启配置</span></h3><h4><span id="wait-for-pid">wait for pid</span></h4><p>This will tell LLDB to attach to the process named Finder whenever it next launches.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lldb -n Finder -w</span><br><span class="line">process attach --name &quot;Finder&quot; --waitfor</span><br></pre></td></tr></table></figure>
<h4><span id="直接调试启动">直接调试启动</span></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lldb -f /bin/ls</span><br><span class="line">process launch</span><br></pre></td></tr></table></figure>
<h4><span id="将speech框架加载到deleteme流程空间">将Speech框架加载到DeleteMe流程空间</span></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(lldb) process load /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk//System/Library/Frameworks/Speech.framework/Speech</span><br></pre></td></tr></table></figure>

<h4><span id="异常">异常</span></h4><h5><span id="disabling-rootless">Disabling Rootless</span></h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Command + R,start your macOS machine.</span><br><span class="line">csrutil disable &amp;&amp; reboot</span><br></pre></td></tr></table></figure>
<h4><span id="-w工作目录">-w工作目录</span></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">选项在哪里启动来更改当前的工作目录。输入以下内容：</span><br><span class="line">(lldb) process launch -w /Applications</span><br></pre></td></tr></table></figure>
<h4><span id="环境变量">环境变量</span></h4><p>(lldb) process launch -v LSCOLORS=Af -v CLICOLOR=1  – /Applications/</p>
<h4><span id="设置新目标">设置新目标</span></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(lldb) target delete</span><br><span class="line">(lldb) target create /usr/bin/wc</span><br></pre></td></tr></table></figure>


<h3><span id="打印相关">打印相关</span></h3><h4><span id="设置后刷新">设置后刷新</span></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">po [$rdi setHidden:!(BOOL)[$rdi isHidden]]; [CATransaction flush]</span><br></pre></td></tr></table></figure>
<h4><span id="输出模块中的函数">输出模块中的函数</span></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(lldb) image lookup -rn _block_invoke Commons</span><br></pre></td></tr></table></figure>

<h3><span id="调试函数单步相关">调试函数单步相关</span></h3><h4><span id="步入无符号">步入无符号</span></h4><p>(lldb) step -a0<br>This tells LLDB to step in regardless of whether you have the required debug symbols or not.</p>
<h4><span id="pdb调试">pdb调试</span></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def your_first_command(debugger, command, result, internal_dict):</span><br><span class="line">    import pdb; pdb.set_trace()</span><br><span class="line">    print (&quot;hello world&quot;)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>tools</category>
        <category>lldb</category>
        <category>tips</category>
      </categories>
      <tags>
        <tag>脚本</tag>
        <tag>tips</tag>
        <tag>lldb</tag>
      </tags>
  </entry>
  <entry>
    <title>如何创建docset</title>
    <url>/2020/02/22/config/%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BAdocset/</url>
    <content><![CDATA[<ul>
<li><a href="#1-docset">1. docset</a><ul>
<li><a href="#11-%e9%98%85%e8%af%bb%e6%9c%ac%e7%af%87%e6%96%87%e7%ab%a0%e9%9c%80%e6%b1%82">1.1. 阅读本篇文章需求</a></li>
<li><a href="#12-%e4%bb%80%e4%b9%88%e6%98%afdocset">1.2. 什么是docset</a></li>
<li><a href="#13-%e5%93%aa%e9%87%8c%e5%8f%af%e4%bb%a5%e4%b8%8b%e8%bd%bddocset">1.3. 哪里可以下载docset</a></li>
<li><a href="#14-%e4%b8%ba%e4%bb%80%e4%b9%88%e8%a6%81%e8%87%aa%e5%b7%b1%e7%94%9f%e6%88%90docset">1.4. 为什么要自己生成docset</a></li>
<li><a href="#15-%e5%93%aa%e9%87%8c%e8%bd%af%e4%bb%b6%e6%94%af%e6%8c%81docset">1.5. 哪里软件支持docset</a><ul>
<li><a href="#151-dash">1.5.1. dash</a></li>
<li><a href="#152-%e7%b1%bb%e4%bc%bcdash%e7%9a%84%e5%b7%a5%e5%85%b7">1.5.2. 类似dash的工具</a></li>
<li><a href="#153-%e5%ae%98%e6%96%b9%e5%b7%a5%e5%85%b7%e6%94%af%e6%8c%81%e8%87%aa%e5%ae%9a%e4%b9%89docset">1.5.3. 官方工具支持自定义docset</a><ul>
<li><a href="#1531-doc2dash">1.5.3.1. doc2dash</a></li>
<li><a href="#1532-dash-docset-builder">1.5.3.2. dash-docset-builder</a></li>
</ul>
</li>
<li><a href="#154-%e5%ae%98%e6%96%b9%e6%89%8b%e5%8a%a8%e6%96%b9%e6%b3%95%e8%87%aa%e5%ae%9a%e4%b9%89docset">1.5.4. 官方手动方法自定义docset</a></li>
<li><a href="#155-%e8%87%aa%e5%ae%9a%e4%b9%89%e7%94%9f%e6%88%90docset">1.5.5. 自定义生成docset</a><ul>
<li><a href="#1551-%e8%8e%b7%e5%8f%96htm%e5%b9%b6%e7%94%9f%e6%88%90docset">1.5.5.1. 获取htm,并生成docset</a></li>
<li><a href="#1552-%e5%88%9b%e5%bb%ba%e7%b4%a2%e5%bc%95">1.5.5.2. 创建索引</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#16-%e6%80%bb%e7%bb%93">1.6. 总结</a></li>
</ul>
</li>
</ul>
<a id="more"></a>
<h1><span id="1-docset">1. docset</span></h1><h2><span id="11-阅读本篇文章需求">1.1. 阅读本篇文章需求</span></h2><p>1.知道docset是什么，后面会介绍<br>2.知道dash 如何使用，或者知道怎么使用docset</p>
<h2><span id="12-什么是docset">1.2. 什么是docset</span></h2><p><a href="https://kapeli.com/dash_guide" target="_blank" rel="noopener">https://kapeli.com/dash_guide</a><br>Documentation sets, or docsets, consist of collections of HTML files. Dash uses these docsets to store the docs you need. This section describes the various features Dash has to help you acquire and manange docsets.<br><a href="https://fileinfo.com/extension/docset" target="_blank" rel="noopener">https://fileinfo.com/extension/docset</a><br>What is a DOCSET file?<br>Developer file created by Doxygen, a source code documentation system; contains an archive of documentation about a body of source code, which can encompass many different individual source code files and code constructs; used as the storage format for publishing documentation to developers that use the source code.</p>
<h2><span id="13-哪里可以下载docset">1.3. 哪里可以下载docset</span></h2><p>dash.app 可以直接下<br>Docsets can be downloaded Dash’s Preferences &gt; Downloads.</p>
<h2><span id="14-为什么要自己生成docset">1.4. 为什么要自己生成docset</span></h2><p>想定制一些自己查询的文档，这些文档没有别人做好的docset可以下，能找到一些html,但如果每次都查询html又觉得麻烦，所以有了自定义docset的想法。</p>
<h2><span id="15-哪里软件支持docset">1.5. 哪里软件支持docset</span></h2><h3><span id="151-dash">1.5.1. dash</span></h3><p>作为一名程序员，最离不开的就是文档了，大多数情况下我们都是通过文档了解一个陌生的领域。想象一下，打开了一堆文档，在文档中跳来跳去，多么的不优雅！所以Bogdan Popescu一怒之下开发了dash，解放了太多在文档中跳来跳去的码农。<br>自带大量常用文档(iOS/Mac/PHP/Python/Java等)<br>支持用户自定义文档(scrapy/requests/beautifulsoup等)<br>快速搜索文档及 API<br>管理和搜索代码片段<br>无缝插入众多第三方应用(Alfred/Xcode/Terminal等)<br><img src="./pic/73436.png" alt="73436.png"></p>
<h3><span id="152-类似dash的工具">1.5.2. 类似dash的工具</span></h3><p><a href="https://doc2dash.readthedocs.io/en/latest/installation.html#viewer" target="_blank" rel="noopener">https://doc2dash.readthedocs.io/en/latest/installation.html#viewer</a><br>To view the results, you will need a docset viewer, the most commonly known being Dash.app for macOS.<br>Other alternatives have been developed in cooperation with Dash.app’s developer Kapeli:<br>helm-dash for Emacs,<br>velocity for Windows,<br>and zeal for Linux, macOS, and Windows.</p>
<h3><span id="153-官方工具支持自定义docset">1.5.3. 官方工具支持自定义docset</span></h3><h4><span id="1531-doc2dash">1.5.3.1. doc2dash</span></h4><p>Instructions on generating docsets can be found in the Docset Generation Guide.<br>doc2dash is an MIT-licensed extensible Documentation Set generator intended to be used with the Dash.app API browser for macOS or one of its many free clones for all relevant platforms.<br>If you’ve never heard of Dash.app and its likes, you’re missing out: together with doc2dash it’s all your API documentation at your fingertips – even when you’re offline!<br>doc2dash’s documentation lives at Read the Docs, the code on GitHub. It’s tested on Python 2.7, 3.4+, and PyPy. Both Linux and macOS are tested although certain features are only available on macOS.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd docs &amp;&amp; make html</span><br><span class="line">doc2dash html</span><br></pre></td></tr></table></figure>
<p>一些项目有规范的doc文档，可以用doc2dash 来生成docset.</p>
<h4><span id="1532-dash-docset-builder">1.5.3.2. dash-docset-builder</span></h4><p>php写的，功能还是很全，但是不太会调<br><a href="https://github.com/godbout/dash-docset-builder" target="_blank" rel="noopener">https://github.com/godbout/dash-docset-builder</a></p>
<h3><span id="154-官方手动方法自定义docset">1.5.4. 官方手动方法自定义docset</span></h3><p><a href="https://kapeli.com/docsets#copyDocumentation" target="_blank" rel="noopener">https://kapeli.com/docsets#copyDocumentation</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">13.1. Create the Docset Folder#</span><br><span class="line">The docset folder structure can be created using this Terminal command:</span><br><span class="line"></span><br><span class="line">mkdir -p &lt;docset name&gt;.docset/Contents/Resources/Documents/</span><br><span class="line">You can also manually create the docset structure if you want, they&apos;re just folders.</span><br><span class="line"></span><br><span class="line">13.2. Copy the HTML Documentation#</span><br><span class="line">Copy the HTML documentation you already have to this folder:</span><br><span class="line"></span><br><span class="line">&lt;docset name&gt;.docset/Contents/Resources/Documents/</span><br><span class="line">13.3. Create the Info.plist File#</span><br><span class="line">Download and edit this sample Info.plist and place it in the &lt;docset name&gt;.docset/Contents/ folder. Editing should be straightforward, just set the values to whatever name you want for your docset.</span><br><span class="line"></span><br><span class="line">13.4. Create the SQLite Index#</span><br><span class="line">Create a SQLite database in the file &lt;docset name&gt;.docset/Contents/Resources/docSet.dsidx with the following query:</span><br><span class="line"></span><br><span class="line">CREATE TABLE searchIndex(id INTEGER PRIMARY KEY, name TEXT, type TEXT, path TEXT);</span><br><span class="line">Recommended: you can easily prevent adding duplicate entries to the index by also using this query:</span><br><span class="line"></span><br><span class="line">CREATE UNIQUE INDEX anchor ON searchIndex (name, type, path);</span><br><span class="line">13.5. Populate the SQLite Index#</span><br><span class="line">You need to create a script (or application or whatever) that will go through your HTML documentation and add appropriate rows into the SQLite database. Rows can be added using this query:</span><br><span class="line"></span><br><span class="line">INSERT OR IGNORE INTO searchIndex(name, type, path) VALUES (&apos;name&apos;, &apos;type&apos;, &apos;path&apos;);</span><br><span class="line">The values are:</span><br><span class="line"></span><br><span class="line">name is the name of the entry. For example, if you are adding a class, it would be the name of the class. This is the column that Dash searches.</span><br><span class="line">type is the type of the entry. For example, if you are adding a class, it would be &quot;Class&quot;. For a list of types that Dash recognises, see below.</span><br><span class="line">path is the relative path towards the documentation file you want Dash to display for this entry. It can contain an anchor (#). Alternatively, Dash also supports http:// URL entries.</span><br><span class="line"></span><br><span class="line">You can find a few generation script examples here.</span><br><span class="line">[https://kapeli.com/docsets#scriptExamples](https://kapeli.com/docsets#scriptExamples)</span><br></pre></td></tr></table></figure>
<h3><span id="155-自定义生成docset">1.5.5. 自定义生成docset</span></h3><p>因为别的方法无法具体实现想指定的dash xxx 搜索指令，不能很方便的扩展搜索方式，自己实现可以实现任意html生成dash 的方式</p>
<h4><span id="1551-获取htm并生成docset">1.5.5.1. 获取htm,并生成docset</span></h4><p>使用dash 代码片段生成得到指定网页的html,并生成docset格式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line">wget --recursive \</span><br><span class="line">  --html-extension \</span><br><span class="line">  --convert-links \</span><br><span class="line">  --domains ~_~lldb.llvm.org~_~ \</span><br><span class="line">  --restrict-file-names=windows \</span><br><span class="line">  --page-requisites \</span><br><span class="line">  --reject pdf \</span><br><span class="line">  --no-parent ~_~lldb.llvm.org~_~/~_~arm~_~.html</span><br><span class="line"></span><br><span class="line">if [ -d &quot;~_~arm~_~.docset&quot; ]; then</span><br><span class="line">    echo &quot;~_~arm~_~.docset exitst, please delete it&quot;</span><br><span class="line">    return</span><br><span class="line">fi</span><br><span class="line">contents=~_~arm~_~.docset/Contents</span><br><span class="line">res=$contents/Resources</span><br><span class="line">doc=$res/Documents</span><br><span class="line">mkdir -p $doc</span><br><span class="line">cp frida.png ~_~arm~_~.docset/icon.png</span><br><span class="line">mv ~_~arm~_~.html $doc</span><br><span class="line"></span><br><span class="line">rm $res/docSet.dsidx</span><br><span class="line"></span><br><span class="line">cat &gt; $contents/Info.plist &lt;&lt;- &quot;EOF&quot;</span><br><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE plist PUBLIC &quot;-//Apple//DTD PLIST 1.0//EN&quot; &quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;&gt;</span><br><span class="line">&lt;plist version=&quot;1.0&quot;&gt;</span><br><span class="line">&lt;dict&gt;</span><br><span class="line">  &lt;key&gt;CFBundleIdentifier&lt;/key&gt;</span><br><span class="line">  &lt;string&gt;~_~arm~_~&lt;/string&gt;</span><br><span class="line">  &lt;key&gt;CFBundleName&lt;/key&gt;</span><br><span class="line">  &lt;string&gt;~_~arm~_~&lt;/string&gt;</span><br><span class="line">  &lt;key&gt;DocSetPlatformFamily&lt;/key&gt;</span><br><span class="line">  &lt;string&gt;~_~arm~_~&lt;/string&gt;</span><br><span class="line">  &lt;key&gt;dashIndexFilePath&lt;/key&gt;</span><br><span class="line">  &lt;string&gt;~_~arm~_~.html&lt;/string&gt;</span><br><span class="line">  &lt;key&gt;isDashDocset&lt;/key&gt;</span><br><span class="line">  &lt;true/&gt;</span><br><span class="line">&lt;/dict&gt;</span><br><span class="line">&lt;/plist&gt;</span><br><span class="line">EOF</span><br><span class="line">echo &apos;done&apos;</span><br></pre></td></tr></table></figure>
<h4><span id="1552-创建索引">1.5.5.2. 创建索引</span></h4><p>如以下代码创建了 radare2 这个工具的html的docset<br><img src="./pic/355453.png" alt="355453.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import sqlite3</span><br><span class="line"></span><br><span class="line">from pathlib import Path</span><br><span class="line">from bs4 import BeautifulSoup</span><br><span class="line"></span><br><span class="line"># CREATE TABLE searchIndex(id INTEGER PRIMARY KEY, name TEXT, type TEXT, path TEXT);</span><br><span class="line"># CREATE UNIQUE INDEX anchor ON searchIndex (name, type, path);</span><br><span class="line"># INSERT OR IGNORE INTO searchIndex(name, type, path) VALUES (&apos;Exploit&apos;, &apos;Class&apos;, &apos;index.html&apos;);</span><br><span class="line">respath=&quot;~_~arm~_~.docset/Contents/Resources&quot;</span><br><span class="line">conn = sqlite3.connect(&apos;&#123;&#125;/docSet.dsidx&apos;.format(respath))</span><br><span class="line">conn.executescript(&apos;&apos;&apos;</span><br><span class="line">    CREATE TABLE IF NOT EXISTS searchIndex(id INTEGER PRIMARY KEY, name TEXT, type TEXT, path TEXT);</span><br><span class="line">    CREATE UNIQUE INDEX IF NOT EXISTS anchor ON searchIndex (name, type, path);&apos;&apos;&apos;)</span><br><span class="line"></span><br><span class="line">def insert(*args):</span><br><span class="line">    conn.execute(&apos;&apos;&apos;INSERT OR IGNORE INTO searchIndex(name, type, path) VALUES (?, ?, ?);&apos;&apos;&apos;, args)</span><br><span class="line"></span><br><span class="line">filename=&quot;&#123;&#125;/Documents/~_~arm~_~.html&quot;.format(respath)</span><br><span class="line">with open(filename) as fp:</span><br><span class="line">    html = fp.read()</span><br><span class="line">print(&quot;filename=&#123;&#125;&quot;.format(filename))</span><br><span class="line">soup = BeautifulSoup(html)</span><br><span class="line"></span><br><span class="line">relpath = str(Path(filename).relative_to(&quot;&#123;&#125;/Documents&quot;.format(respath)))</span><br><span class="line"></span><br><span class="line"># Rax2 1.12.1</span><br><span class="line"># Rafind2 1.12.2</span><br><span class="line"># Rarun2 1.12.3</span><br><span class="line"># Rabin2 1.12.4</span><br><span class="line"># Radiff2 1.12.5</span><br><span class="line"># Rasm2 1.12.6</span><br><span class="line"># Ragg2 1.12.7</span><br><span class="line"># Rahash2 1.12.8</span><br><span class="line"></span><br><span class="line">type = &quot;Method&quot;</span><br><span class="line"></span><br><span class="line">for subtitle in soup.select(&quot;a&quot;):</span><br><span class="line">    if not subtitle:</span><br><span class="line">        break</span><br><span class="line">    if subtitle == &quot;\n&quot;:</span><br><span class="line">        continue</span><br><span class="line">    if subtitle.text != &quot;Rax2&quot; and subtitle.text != &quot;Rafind2&quot; and subtitle.text != &quot;Rarun2&quot; \</span><br><span class="line">            and subtitle.text != &quot;Rabin2&quot; and subtitle.text != &quot;Radiff2&quot; and subtitle.text != &quot;Rasm2&quot;\</span><br><span class="line">            and subtitle.text != &quot;Ragg2&quot; and subtitle.text != &quot;Rahash2&quot;:</span><br><span class="line">        continue</span><br><span class="line"></span><br><span class="line">    name = subtitle.text</span><br><span class="line">    # path=&apos;%s#%s&apos; % (relpath, name)</span><br><span class="line">    path=&quot;&#123;&#125;&#123;&#125;&quot;.format(relpath,subtitle[&quot;href&quot;].lower())</span><br><span class="line">    print(&quot;&#123;&#125;\t\t&#123;&#125;\t\t&#123;&#125;&quot;.format(name,type,path))</span><br><span class="line">    insert(name, type, path)</span><br><span class="line"></span><br><span class="line">conn.commit()</span><br><span class="line">conn.close()</span><br></pre></td></tr></table></figure>
<h2><span id="16-总结">1.6. 总结</span></h2><p>1.遇到问题多看官网，官网有解决办法，不用你老人家瞎琢磨耽误时间<br>2.看文档细心。</p>
]]></content>
      <categories>
        <category>tools</category>
        <category>dash</category>
      </categories>
      <tags>
        <tag>docset</tag>
        <tag>dash</tag>
      </tags>
  </entry>
</search>
