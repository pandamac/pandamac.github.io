<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>lldb_help</title>
    <url>/2020/02/23/lldb_about/lldb-help/</url>
    <content><![CDATA[<ul>
<li><a href="#some-lldb-tips">some lldb tips</a><ul>
<li><a href="#%e9%80%9a%e7%94%a8">通用</a><ul>
<li><a href="#%e8%ae%a1%e7%ae%97%e5%81%8f%e7%a7%bbida%e5%9c%b0%e5%9d%80">计算偏移/ida地址</a></li>
<li><a href="#%e8%a7%82%e5%af%9f%e6%96%ad%e7%82%b9">观察断点</a></li>
<li><a href="#%e8%af%bb%e5%8f%96%e7%9b%ae%e6%a0%87%e5%9c%b0%e5%9d%80%e7%9a%84%e5%86%85%e5%ad%98%e6%8c%87%e4%bb%a4">读取目标地址的内存指令</a></li>
<li><a href="#dis-apc-%e5%8f%8d%e6%b1%87%e7%bc%96%e6%8c%87%e5%ae%9a%e5%9c%b0%e5%9d%80">dis-a$pc 反汇编指定地址</a></li>
<li><a href="#%e5%88%87%e6%8d%a2%e5%88%86%e6%94%af">切换分支</a></li>
<li><a href="#threadinfo%e8%be%93%e5%87%ba%e5%bd%93%e5%89%8d%e7%ba%bf%e7%a8%8b%e7%9a%84%e4%bf%a1%e6%81%af">threadinfo:输出当前线程的信息。</a></li>
<li><a href="#b-ptrace--c-xxx%e6%bb%a1%e8%b6%b3%e6%9f%90%e4%b8%aa%e6%9d%a1%e4%bb%b6%e4%b9%8b%e5%90%8e%e7%a8%8b%e5%ba%8f%e6%89%8d%e4%bc%9a%e4%b8%ad%e6%96%ad">b ptrace -c xxx:满足某个条件之后程序才会中断。</a></li>
<li><a href="#helpapropos">help/apropos</a></li>
<li><a href="#%e6%96%ad%e7%82%b9%e5%90%8e%e6%89%a7%e8%a1%8c%e5%91%bd%e4%bb%a4">断点后执行命令</a></li>
<li><a href="#xcode%e9%a2%84%e5%a4%84%e7%90%86%e5%bf%ab%e6%8d%b7%e9%94%ae">xcode预处理快捷键</a></li>
<li><a href="#pdb%e6%9d%a5%e6%8e%92%e6%9f%a5%e4%ba%86%e4%b8%80%e4%b8%aa%e8%84%9a%e6%9c%ac%e4%b8%ad%e7%9a%84%e9%97%ae%e9%a2%98">pdb来排查了一个脚本中的问题</a></li>
<li><a href="#%e5%a6%82%e4%bd%95%e5%b0%86%e6%96%ad%e7%82%b9%e8%ae%be%e7%bd%ae%e5%9c%a8%e5%8a%a8%e6%80%81%e5%ba%93%e7%9a%84%e5%85%a5%e5%8f%a3">如何将断点设置在动态库的入口</a></li>
<li><a href="#%e5%9f%ba%e6%9c%ac%e7%9a%84%e7%b1%bb">基本的类：</a></li>
</ul>
</li>
<li><a href="#android">android</a></li>
<li><a href="#ios">iOS</a><ul>
<li><a href="#%e7%a0%b8%e5%a3%b3">砸壳</a></li>
<li><a href="#%e6%9f%a5%e8%af%a2%e6%8c%89%e9%92%ae%e4%ba%8b%e4%bb%b6">查询按钮事件</a></li>
<li><a href="#chisel-%e6%89%93%e5%8d%b0%e7%bb%93%e6%9e%84">chisel 打印结构</a></li>
<li><a href="#%e6%90%9c%e7%b4%a2uitextfield%e7%9a%84%e5%ae%9e%e4%be%8b%e5%af%b9%e8%b1%a1%e5%92%8ccycript%e4%b8%ad%e7%9a%84choose%e6%a0%b7%e7%9a%84">搜索UITextField的实例对象和Cycript中的choose—样的</a></li>
<li><a href="#%e6%9f%a5%e7%9c%8b%e5%af%b9%e8%b1%a1%e5%86%85%e5%ad%98%e5%85%b3%e7%b3%bbxcode%e8%a7%82%e7%9c%8b">查看对象内存关系,xcode观看</a></li>
<li><a href="#%e6%89%a7%e8%a1%8cscript">执行script</a></li>
<li><a href="#%e5%9c%a8-snapchat%e6%a8%a1%e5%9d%97%e4%b8%ad%e6%9f%a5%e7%9c%8b%e4%b8%8elogin%e6%9c%89%e5%85%b3%e7%9a%84%e7%ac%a6%e5%8f%b7%e4%bf%a1%e6%81%af">在 Snapchat模块中查看与login有关的符号信息</a></li>
<li><a href="#%e6%9f%90%e4%b8%aa%e7%b1%bb%e7%9a%84%e6%89%80%e6%9c%89%e6%96%b9%e6%b3%95%e4%b8%8b%e6%96%ad%e7%82%b9%e5%b9%b6%e8%b7%9f%e8%b8%aa%e6%89%93%e5%8d%b0%e8%b0%83%e7%94%a8%e5%8f%82%e6%95%b0">某个类的所有方法下断点并跟踪打印调用参数</a></li>
<li><a href="#xcode-%e8%ae%be%e7%bd%ae%e7%8e%af%e5%a2%83%e5%8f%98%e9%87%8f">xcode 设置环境变量</a></li>
<li><a href="#ios-%e5%88%86%e6%9e%90%e5%b8%b8%e8%a7%81%e7%82%b9">iOS 分析常见点</a></li>
</ul>
</li>
<li><a href="#macos">macos</a></li>
</ul>
</li>
</ul>
<a id="more"></a>
<h1 id="some-lldb-tips"><a href="#some-lldb-tips" class="headerlink" title="some lldb tips"></a>some lldb tips</h1><h2 id="通用"><a href="#通用" class="headerlink" title="通用"></a>通用</h2><h3 id="计算偏移-ida地址"><a href="#计算偏移-ida地址" class="headerlink" title="计算偏移/ida地址"></a>计算偏移/ida地址</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">p/x 0X000000010095ECCC+0X0000000000038000</span><br><span class="line">(lldb) p/x 0x0000000100e595b4-0x0000000000038000 (long) $18 = 0x0000000100e215b4</span><br><span class="line">查看某个地址所在模块的信息</span><br></pre></td></tr></table></figure>
<h3 id="观察断点"><a href="#观察断点" class="headerlink" title="观察断点"></a>观察断点</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">watchpoint set expression -w write ―- 0xl01801a48 :给某个地址设置观察断点,内存进行写操作时就会触发断点</span><br></pre></td></tr></table></figure>
<h3 id="读取目标地址的内存指令"><a href="#读取目标地址的内存指令" class="headerlink" title="读取目标地址的内存指令"></a>读取目标地址的内存指令</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">x/10xg 0xl01801a48 这里的x 表示用十六进制来显示结果。&quot;g&quot;代表giant word(8字节)大小。所以就是用十六进制显示 0x101801a48所指恐惧的10个64位的元素内容。常见的大小格式为&quot;b-byte&quot;(1字节),&quot;h-half word&quot;(2字节),&quot;w- word”(4字节),&quot;g-giantword”(8字节)。</span><br></pre></td></tr></table></figure>
<h3 id="dis-a-pc-反汇编指定地址"><a href="#dis-a-pc-反汇编指定地址" class="headerlink" title="dis-a$pc 反汇编指定地址"></a>dis-a$pc 反汇编指定地址</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">这里是pc寄存器所对应的地址。</span><br></pre></td></tr></table></figure>
<h3 id="切换分支"><a href="#切换分支" class="headerlink" title="切换分支"></a>切换分支</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">f2:切换到当前调用栈为2的位置，也就是bt中的frame #2。</span><br></pre></td></tr></table></figure>
<h3 id="threadinfo-输出当前线程的信息。"><a href="#threadinfo-输出当前线程的信息。" class="headerlink" title="threadinfo:输出当前线程的信息。"></a>threadinfo:输出当前线程的信息。</h3><h3 id="b-ptrace-c-xxx-满足某个条件之后程序才会中断。"><a href="#b-ptrace-c-xxx-满足某个条件之后程序才会中断。" class="headerlink" title="b ptrace -c xxx:满足某个条件之后程序才会中断。"></a>b ptrace -c xxx:满足某个条件之后程序才会中断。</h3><h3 id="help-apropos"><a href="#help-apropos" class="headerlink" title="help/apropos"></a>help/apropos</h3><h3 id="断点后执行命令"><a href="#断点后执行命令" class="headerlink" title="断点后执行命令"></a>断点后执行命令</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">b +[Manager performLoginWithUsernameOnEmail: password: preAuthToken: twoFAMethod: confirmReactivation: rememberDevice:fromDeepLink:onComplete:]</span><br><span class="line">Breakpoint 2: where = Snapchat&apos;+[Manager</span><br><span class="line">br com add 2</span><br><span class="line">&gt; po $x2</span><br><span class="line">&gt; po $x3</span><br><span class="line">&gt; c</span><br><span class="line">&gt; DONE</span><br></pre></td></tr></table></figure>
<h3 id="xcode预处理快捷键"><a href="#xcode预处理快捷键" class="headerlink" title="xcode预处理快捷键"></a>xcode预处理快捷键</h3><p>单击 Product -&gt; PerformAction -&gt;Preprocess xxxx 可以对文件进行预处理，还可以将代码转换成汇编代码。可以帮助我们理解这些宏的作用</p>
<h3 id="pdb来排查了一个脚本中的问题"><a href="#pdb来排查了一个脚本中的问题" class="headerlink" title="pdb来排查了一个脚本中的问题"></a>pdb来排查了一个脚本中的问题</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(lldb) findclass</span><br><span class="line">error: libarclite_macosx.a(arclite.o) failed to load objfile for /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/arc/libarclite_macosx.a</span><br><span class="line">error: libarclite_macosx.a(arclite.o) failed to load objfile for /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/arc/libarclite_macosx.a</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;/Users/gogleyin/lldb/findclass.py&quot;, line 40, in findclass</span><br><span class="line">    raise AssertionError(&quot;Uhoh... something went wrong, can you figure it out? :]&quot;)</span><br><span class="line">AssertionError: Uhoh... something went wrong, can you figure it out? :]</span><br><span class="line"></span><br><span class="line">(lldb) script import pdb</span><br><span class="line">(lldb) findclass</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;/Users/gogleyin/lldb/findclass.py&quot;, line 40, in findclass</span><br><span class="line">    raise AssertionError(&quot;Uhoh... something went wrong, can you figure it out? :]&quot;)</span><br><span class="line">AssertionError: Uhoh... something went wrong, can you figure it out? :]</span><br><span class="line"></span><br><span class="line">(lldb) script pdb.pm()</span><br><span class="line">&gt; /Users/gogleyin/lldb/findclass.py(40)findclass()</span><br><span class="line">-&gt; raise AssertionError(&quot;Uhoh... something went wrong, can you figure it out? :]&quot;)</span><br><span class="line"></span><br><span class="line">(Pdb) print(codeString)  # 这个东西包含了一段oc代码，用oc runtime来找出runtime的所有类</span><br><span class="line">    @import Foundation;</span><br><span class="line">    int numClasses;</span><br><span class="line">    Class * classes = NULL;</span><br><span class="line">    classes = NULL;</span><br><span class="line">    numClasses = objc_getClassList(NULL, 0);</span><br><span class="line">    NSMutableString *returnString = [NSMutableString string];</span><br><span class="line">    classes = (__unsafe_unretained Class *)malloc(sizeof(Class) * numClasses);</span><br><span class="line">    numClasses = objc_getClassList(classes, numClasses);</span><br><span class="line">    for (int i = 0; i &lt; numClasses; i++) &#123;</span><br><span class="line">      Class c = classes[i];</span><br><span class="line">      [returnString appendFormat:@&quot;%s,&quot;, class_getName(c)];</span><br><span class="line">    &#125;</span><br><span class="line">    free(classes);</span><br><span class="line">    returnString;  # 返回returnString的值给Python脚本</span><br><span class="line"></span><br><span class="line">(Pdb) l 35, 45  # 会列出35到45行代码，注意40行的 -&gt; 表示当前pdb停在的位置</span><br><span class="line"> 35         &apos;&apos;&apos;</span><br><span class="line"> 36</span><br><span class="line"> 37         res = lldb.SBCommandReturnObject()</span><br><span class="line"> 38         debugger.GetCommandInterpreter().HandleCommand(&quot;expression -lobjc -O -- &quot; + codeString, res)</span><br><span class="line"> 39         if res.GetError():</span><br><span class="line"> 40  -&gt;         raise AssertionError(&quot;Uhoh... something went wrong, can you figure it out? :]&quot;)</span><br><span class="line"> 41         elif not res.HasResult():</span><br><span class="line"> 42             raise AssertionError(&quot;There&apos;s no result. Womp womp....&quot;)</span><br><span class="line"> 43</span><br><span class="line"> 44         returnVal = res.GetOutput()</span><br><span class="line"> 45         resultArray = returnVal.split(&quot;,&quot;)</span><br><span class="line"># 嗯，似乎res.GetError()看起来更加有趣，玩一下先</span><br><span class="line"></span><br><span class="line">(Pdb) print res.GetError()</span><br><span class="line">error: &apos;objc_getClassList&apos; has unknown return type; cast the call to its declared return type</span><br><span class="line">error: &apos;objc_getClassList&apos; has unknown return type; cast the call to its declared return type</span><br><span class="line">error: &apos;class_getName&apos; has unknown return type; cast the call to its declared return type</span><br><span class="line"># 到这里可以看到，问题是codeString里面的代码让LLDB迷惑了。</span><br><span class="line"># 实际这种错误在LLDB里面是非常常见的。你需要告诉LLDB一个函数的返回类型，因为它无法知道那是啥。</span><br><span class="line"># 在这个case下， objc_getClassList 和 class_getName 都有未知的返回类型</span><br><span class="line"># Google一下便知这两个函数的签名如下：</span><br><span class="line"> int objc_getClassList(Class *buffer, int bufferCount);</span><br><span class="line">const char * class_getName(Class cls);</span><br><span class="line"># 所有我们需要做的事转换返回类型到正确的值就可以啦。如下：</span><br><span class="line"></span><br><span class="line">codeString = r&apos;&apos;&apos;</span><br><span class="line">@import Foundation;</span><br><span class="line">int numClasses;</span><br><span class="line">Class * classes = NULL;</span><br><span class="line">classes = NULL;</span><br><span class="line">numClasses = (int)objc_getClassList(NULL, 0);</span><br><span class="line">NSMutableString *returnString = [NSMutableString string];</span><br><span class="line">classes = (__unsafe_unretained Class *)malloc(sizeof(Class) *numClasses);</span><br><span class="line">numClasses = (int)objc_getClassList(classes, numClasses);</span><br><span class="line">for (int i = 0; i &lt; numClasses; i++) &#123;</span><br><span class="line">  Class c = classes[i];</span><br><span class="line">  [returnString appendFormat:@&quot;%s,&quot;, (char *)class_getName(c)];</span><br><span class="line">&#125;</span><br><span class="line">free(classes);</span><br><span class="line">returnString;</span><br><span class="line"></span><br><span class="line">--debug选项是定位JIT代码中的问题的非常好的手段,调试lldb 的好方法</span><br><span class="line">expression --debug -lobjc -O --</span><br><span class="line">可以选择使用frame variable命令打印变量</span><br></pre></td></tr></table></figure>
<h3 id="如何将断点设置在动态库的入口"><a href="#如何将断点设置在动态库的入口" class="headerlink" title="如何将断点设置在动态库的入口"></a>如何将断点设置在动态库的入口</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LLDB命令行进行调试时自 动中断在 _dyld_start 处，因为此时dyld已经加载，所以在dyld里面设置一个在所有库中加载并且在constructor 函数执行之前执行的断点，例如initializeMainExecutable</span><br><span class="line">settings set target.process.stop-on-sharedlibrary-events 1</span><br></pre></td></tr></table></figure>
<h3 id="基本的类："><a href="#基本的类：" class="headerlink" title="基本的类："></a>基本的类：</h3><ul>
<li>lldb.SBDebugger：在你的脚本中用来访问类的实例的类，非常中心，还处理LLDB命令的输入和输出</li>
<li>lldb.SBTarget：与被调试的可执行文件有关（相关调试文件，磁盘上的文件）。<br>你可以用SBDebugger的实例来获取到当前选择的SBTarget。然后 你就可以通过SBTarget访问大部分其余类。</li>
<li>lldb.SBProcess：SBTarget和SBProcess是一对多的关系：SBTarget管理者一个或多个SBProcess实例。SBProcess处理内存读写还有它自己的线程。</li>
<li>lldb.SBThread：管理对应线程的栈帧和stepping的控制逻辑</li>
<li>lldb.SBFrame：管理局部变量（debug信息有提供的）和当时的寄存器快照</li>
<li>lldb.SBModule：代表着一个可执行文件。</li>
<li>lldb.SBFunction：这代表着一个加载到内存中的函数（或者对应代码），它与SBFrame是一对一的关系。<br>实例是 lldb.debugger/lldb.target…<br><a href="https://lldb.llvm.org/python_reference/index.html" target="_blank" rel="noopener">https://lldb.llvm.org/python_reference/index.html</a><br><img src="./pic/1.jpg" alt=""><br>演示了LLDB Python主要的几个类之间的相互关系<br><img src="./pic/2.jpg" alt=""><br>暂停在某函数时几个类的交互<h2 id="android"><a href="#android" class="headerlink" title="android"></a>android</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="iOS"><a href="#iOS" class="headerlink" title="iOS"></a>iOS</h2><h3 id="砸壳"><a href="#砸壳" class="headerlink" title="砸壳"></a>砸壳</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Cronet.framework git:(master) X otool -hf Cronet Fat headers</span><br><span class="line">fat_magic 0xcafebabe</span><br><span class="line">nfat_arch 2</span><br><span class="line">architecture 0  cputype 12 cpusubtype 9  capabilities 0x0</span><br><span class="line">	offset 16384 size 2749664 align 2A14 (16384)</span><br><span class="line">architecture 1 cputype 16777228 cpusubtype 0 capabilities 0x0</span><br><span class="line">	offset 2768896 size 3612224 align 2A14 (16384)</span><br><span class="line">Mach header</span><br><span class="line">	magic cputype cpusubtype caps filetype ncmds sizeofcmds flags</span><br><span class="line">	Oxfeedface 12 9 0x00 6 27 3328 0x00118085</span><br><span class="line">Mach header</span><br><span class="line">	magic cputype cpusubtype caps filetype ncmds sizeofcmds flags</span><br><span class="line">	0xfeedfacf 16777228 0 0x00 6 27 3816 0X00118085</span><br><span class="line"></span><br><span class="line">otool -arch arm64 -1 Cronet | grep crypt</span><br><span class="line">cryptoff 16384</span><br><span class="line">cryptsize 3309568</span><br><span class="line">cryptid 1</span><br><span class="line">(lldb) im li Cronet</span><br><span class="line">[0] 188F5BF7-B4C4-36EF-BB9A-976FA870F9D7 0x0000000105920000 /private/var/mobile/Containers/Bundle/Application/3A4C68EB-4059-47D4-ACE6-BE9C492DF205/ Snapchat.app/Frameworks/Cronet.framework/Cronet (0x0000000105920000)</span><br><span class="line">(lldb) memory read --force --outfile ~/Desktop/dumpoutput --binary count 3309568 16384+0x0000000105920000</span><br><span class="line">因为dump出来的文件都没有Mach-0文件头，所以在这里要先把dump出来的数据写回原 来加密的文件，以替换原来加密的部分</span><br><span class="line">2768896(之前获取的ARM64架构的偏移值)+16384(加密数据的偏移值)=2785280(写入的加密数据在文件中的偏移值)</span><br><span class="line">seek=n   Seek n blocks from the beginning of the output before copying.</span><br><span class="line">bs=n     Set both input and output block size to n bytes</span><br><span class="line">conv=value[,value ...]</span><br><span class="line">	notrunc  Do not truncate the output file.</span><br><span class="line">Cronet.framework git:(master) X dd seek=2785280 bs=l conv=notrunc if=/Users/monkey/Desktop/dumpoutput of=./Cronet</span><br><span class="line">3309568+0 records in</span><br><span class="line">3309568+0 records out</span><br><span class="line">3309568 bytes transferred in 4.698067 secs (704453 bytes/sec)</span><br><span class="line">Cronet.framework git:(master) X lipo Cronet -thin arm64 -output Cronet_arm64</span><br><span class="line">MachOView.app 修改Cronet_arm64 crypid 为0</span><br></pre></td></tr></table></figure>
<h3 id="查询按钮事件"><a href="#查询按钮事件" class="headerlink" title="查询按钮事件"></a>查询按钮事件</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">error: error: use of undeclared identifier &apos;UIApplication&apos;</span><br><span class="line">None</span><br><span class="line">(lldb) expression @import UIKit</span><br><span class="line">pviews</span><br><span class="line">   |    |    |    |    |    |    |    |    |    | &lt;UIButtonLabel: 0x101c730a0; frame = (7.5 12.5; 69.5 20.5); text = &apos;所有图书&apos;; opaque = NO; userInteractionEnabled = NO; layer = &lt;_UILabelLayer: 0x174295a90&gt;&gt;</span><br><span class="line">   |    |    |    |    |    |    |    |    |    |    | &lt;_UILabelContentLayer: 0x170425fa0&gt; (layer)</span><br><span class="line">   |    |    |    |    |    |    |    |    | &lt;IMTouchInsetsButton: 0x101c73f60; baseClass = UIButton; frame = (324 5.5; 35 33); opaque = NO; layer = &lt;CALayer: 0x17422d880&gt;&gt;</span><br><span class="line">   |    |    |    |    |    |    |    |    |    | &lt;UIButtonLabel: 0x101c31460; frame = (9 6.5; 35 20.5); text = &apos;选择&apos;; opaque = NO; userInteractionEnabled = NO; layer = &lt;_UILabelLayer: 0x174295360&gt;&gt;</span><br><span class="line"></span><br><span class="line">查看 “登录”按钮UIButtonLabel的响应链</span><br><span class="line">presponder 0x101c31460</span><br><span class="line">(lldb) presponder 0x101c31460</span><br><span class="line">&lt;UIButtonLabel: 0x101c31460; frame = (9 6.5; 35 20.5); text = &apos;选择&apos;; opaque = NO; userInteractionEnabled = NO; layer = &lt;_UILabelLayer: 0x174295360&gt;&gt;</span><br><span class="line">   | &lt;IMTouchInsetsButton: 0x101c73f60; baseClass = UIButton; frame = (324 5.5; 35 33); opaque = NO; layer = &lt;CALayer: 0x17422d880&gt;&gt;</span><br><span class="line">   |    | &lt;IMToolbar: 0x101c1d8b0; baseClass = UIToolbar; frame = (0 20; 375 44); opaque = NO; autoresize = W; tintColor = UIExtendedSRGBColorSpace 0 0.478431 1 1; layer = &lt;CALayer: 0x174224ec0&gt;&gt;</span><br><span class="line">查看“登录”按钮的Action事件</span><br><span class="line">(lldb) pactions 0x101c73f60</span><br><span class="line">&lt;BKLibraryViewController: 0x102817600&gt;: editButtonPressed:</span><br></pre></td></tr></table></figure>
<h3 id="chisel-打印结构"><a href="#chisel-打印结构" class="headerlink" title="chisel 打印结构"></a>chisel 打印结构</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt; NSMallocBlock : 0Xl7444b6d0&gt;</span><br><span class="line">(lldb) pblock 0xl7444b6d0</span><br><span class="line"></span><br><span class="line">(lldb) pvc</span><br><span class="line">&lt;ICSplitViewController 0x10079eab0&gt;, state: appeared, view: &lt;UILayoutContainerView 0x1009261c0&gt;</span><br><span class="line">   | &lt;UIMultiColumnViewController 0x10079f410&gt;, state: appeared, view: &lt;UIView 0x1007aee70&gt;</span><br><span class="line"></span><br><span class="line">(lldb) methods 0x10079eab0</span><br><span class="line">&lt;ICSplitViewController: 0x10079eab0&gt;:</span><br><span class="line">in ICSplitViewController:</span><br><span class="line">	Properties:</span><br><span class="line">		@property (nonatomic, getter=isDetailDimmed) BOOL detailDimmed;  (@synthesize detailDimmed = _detailDimmed;)</span><br></pre></td></tr></table></figure>
<h3 id="搜索UITextField的实例对象和Cycript中的choose—样的"><a href="#搜索UITextField的实例对象和Cycript中的choose—样的" class="headerlink" title="搜索UITextField的实例对象和Cycript中的choose—样的"></a>搜索UITextField的实例对象和Cycript中的choose—样的</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">search UIButton</span><br><span class="line">search UITextField</span><br><span class="line"># Find all UIViews, ignore subclasses</span><br><span class="line">find UIView  -e</span><br><span class="line"></span><br><span class="line"># Find all instances of UIViews (and subclasses) where tag == 5</span><br><span class="line">find UIView -c &quot;[obj tag] == 5&quot;</span><br></pre></td></tr></table></figure>
<h3 id="查看对象内存关系-xcode观看"><a href="#查看对象内存关系-xcode观看" class="headerlink" title="查看对象内存关系,xcode观看"></a>查看对象内存关系,xcode观看</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/Applications/Xcode.app/Contents/SharedFrameworks/LLDB.framework/Versions/A/Resources/Python/lldb/macosx/heap.py</span><br><span class="line">command alias iheap command script import lldb.macosx.heap</span><br><span class="line">&quot;malloc_info&quot;, &quot;ptr_refs&quot;, &quot;cstr_refs&quot;, &quot;find_variable&quot;, and &quot;objc_refs&quot;</span><br><span class="line"></span><br><span class="line">为了查看某个对象内存分配的调用堆栈，需要在程序启动的环境变量中设置 MallocSlack Logging。</span><br><span class="line">在环境变量中增加 MallocStackLogging 的值1</span><br><span class="line">单击Xcode调试工具栏上的“Debug Momery Graph”按钮</span><br></pre></td></tr></table></figure>
<h3 id="执行script"><a href="#执行script" class="headerlink" title="执行script"></a>执行script</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(lldb) e @import UIKit</span><br><span class="line">(lldb) e UIApplication *$app = [UIApplication sharedApplication];</span><br><span class="line">(lldb) e UlWindow *$keyWindow = $app.keyWindow</span><br><span class="line">(lldb) e UlViewController *$root = $keyWindow.rootViewController</span><br><span class="line">(lldb) po $root</span><br><span class="line">&lt;NavigationController: 0xl2c03d200&gt;</span><br><span class="line">(lldb) e [(SCButton *)0xl2bd4b760 setTitle:@&quot;AloneMonkey&quot; forStaterUIControlStateNormal]</span><br><span class="line">(lldb) e (void)[CATransaction flush]</span><br><span class="line">(lldb) c</span><br></pre></td></tr></table></figure>
<h3 id="在-Snapchat模块中查看与login有关的符号信息"><a href="#在-Snapchat模块中查看与login有关的符号信息" class="headerlink" title="在 Snapchat模块中查看与login有关的符号信息"></a>在 Snapchat模块中查看与login有关的符号信息</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">image lookup -rn login UserLogin</span><br><span class="line"></span><br><span class="line">(lldb) b -[UIView setTail:]</span><br><span class="line">Breakpoint 3: where = UserLogin`-[UIView(Frame) setTail:] at UIView+Frame.m:102, address = 0x0000000100b5ee34</span><br><span class="line">(lldb) il 0x0000000100b5ee34</span><br><span class="line">image lookup -a 0x0000000100b5ee34</span><br></pre></td></tr></table></figure>
<h3 id="某个类的所有方法下断点并跟踪打印调用参数"><a href="#某个类的所有方法下断点并跟踪打印调用参数" class="headerlink" title="某个类的所有方法下断点并跟踪打印调用参数"></a>某个类的所有方法下断点并跟踪打印调用参数</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">command regex bclass &apos;s/(.+)/rb \[%1 /&apos;</span><br><span class="line">rb -&gt; breakpoint set -r %1</span><br><span class="line">bclass ULLoginViewController -&gt; breakpoint set -r \[ULLoginViewController</span><br><span class="line"></span><br><span class="line">br set -r &apos;\[WAChatSessionViewController .*\]&apos;</span><br><span class="line"></span><br><span class="line">如果不在MethodTraCeCcmflg.PliSt文件里面配置需要跟踪的类，那么如下设置:</span><br><span class="line">@interface MethodTrace : NSObject</span><br><span class="line">+ (void)addClassTrace:(NSString*) className;</span><br><span class="line">+ (void)addClassTrace: (NSString *)className methodName: (NSString*) methodName;</span><br><span class="line">+ (void)addClassTrace: (NSString *)className methodList: (NSArray*) methodList;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">e [MethodTrace addClassTrace:@&quot;WAChatDataStore&quot;]</span><br><span class="line">笔者在MethodTrace的代码里面调试了—下，发现 NSLog没有被输出到Xcode的控制台，但是在Console.app里面可以看到NSLog,所以改用printf来输出。</span><br><span class="line">ENABLE_METHODTRACE</span><br></pre></td></tr></table></figure>
<h3 id="xcode-设置环境变量"><a href="#xcode-设置环境变量" class="headerlink" title="xcode 设置环境变量"></a>xcode 设置环境变量</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">打印参数和当前的环境变量, segment加载的详细信息,加载dylib,显示是否加载,各阶段的时间消耗</span><br><span class="line">xcode  DYLD_PRINT_OPTS, DYLD_PRINT_EN, DYLD_PRINT_SEGMENTS</span><br><span class="line"></span><br><span class="line">签名InsertDyUb.dylib,拷贝 InsertDylib.dylib 到Bundle Resources</span><br><span class="line">xcode  设置环境变量DYLD_INSERT_LIBRARIES @executable_path/InsertDylib.dylib</span><br><span class="line"></span><br><span class="line">xcode  设置环境变量 DYLD_PRINT_INTERPOSING 运行 App,日志如下即为hook生效</span><br><span class="line">dyld: interposing 2 tuples onto image: /var/containers/Bundle/Application/AB57C532-19F2-4022-B757-7D211296E64D/AppStart.app/InsertDylib.dylib</span><br><span class="line"></span><br><span class="line">xcode 设置 DYLD_PRINT_STATISTICS,DYLD_PRINT_STATISTICS_DETAILS 打印各阶段的时间消耗。</span><br><span class="line"></span><br><span class="line">@executable_path:表示可执行程序所在的目录，一般是xxx.app</span><br><span class="line">@loader_path:表示每一个被加载的二进制文件的目录。例如，xxxx.plugin/aaa/abc依赖xxx.plugin/bb/ccc.dylib,那么依赖的路径可以写成 @loader_path/../bbb. 这样不管xxx.plugin放在那都能找到ccc.dylib</span><br><span class="line">@rpath:这个变量是在 Xcode build里面设置， Dynamic Libray Install Name设置为(#=@path/xxx/xxx,就可以在使用的工程中设置一个或多个RunPath Search Paths 来指定搜索路径。在运行时，会将@rpath分别替换为Runpath Search Paths中指定的路径来査找动态库。</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="iOS-分析常见点"><a href="#iOS-分析常见点" class="headerlink" title="iOS 分析常见点"></a>iOS 分析常见点</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">handleLongPressAtPoint函数就是用于处理长按事件的函数</span><br><span class="line">第一响应者实现 canPerformAction:withSender: 来确定当前哪些操 作是被允许的、哪些操作是不被允许的。</span><br></pre></td></tr></table></figure>
<h2 id="macos"><a href="#macos" class="headerlink" title="macos"></a>macos</h2>]]></content>
      <categories>
        <category>lldb</category>
      </categories>
      <tags>
        <tag>lldb</tag>
        <tag>脚本</tag>
      </tags>
  </entry>
  <entry>
    <title>如何创建docset</title>
    <url>/2020/02/22/config/%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BAdocset/</url>
    <content><![CDATA[<ul>
<li><a href="#1-docset">1. docset</a><ul>
<li><a href="#11-%e9%98%85%e8%af%bb%e6%9c%ac%e7%af%87%e6%96%87%e7%ab%a0%e9%9c%80%e6%b1%82">1.1. 阅读本篇文章需求</a></li>
<li><a href="#12-%e4%bb%80%e4%b9%88%e6%98%afdocset">1.2. 什么是docset</a></li>
<li><a href="#13-%e5%93%aa%e9%87%8c%e5%8f%af%e4%bb%a5%e4%b8%8b%e8%bd%bddocset">1.3. 哪里可以下载docset</a></li>
<li><a href="#14-%e4%b8%ba%e4%bb%80%e4%b9%88%e8%a6%81%e8%87%aa%e5%b7%b1%e7%94%9f%e6%88%90docset">1.4. 为什么要自己生成docset</a></li>
<li><a href="#15-%e5%93%aa%e9%87%8c%e8%bd%af%e4%bb%b6%e6%94%af%e6%8c%81docset">1.5. 哪里软件支持docset</a><ul>
<li><a href="#151-dash">1.5.1. dash</a></li>
<li><a href="#152-%e7%b1%bb%e4%bc%bcdash%e7%9a%84%e5%b7%a5%e5%85%b7">1.5.2. 类似dash的工具</a></li>
<li><a href="#153-%e5%ae%98%e6%96%b9%e5%b7%a5%e5%85%b7%e6%94%af%e6%8c%81%e8%87%aa%e5%ae%9a%e4%b9%89docset">1.5.3. 官方工具支持自定义docset</a><ul>
<li><a href="#1531-doc2dash">1.5.3.1. doc2dash</a></li>
<li><a href="#1532-dash-docset-builder">1.5.3.2. dash-docset-builder</a></li>
</ul>
</li>
<li><a href="#154-%e5%ae%98%e6%96%b9%e6%89%8b%e5%8a%a8%e6%96%b9%e6%b3%95%e8%87%aa%e5%ae%9a%e4%b9%89docset">1.5.4. 官方手动方法自定义docset</a></li>
<li><a href="#155-%e8%87%aa%e5%ae%9a%e4%b9%89%e7%94%9f%e6%88%90docset">1.5.5. 自定义生成docset</a><ul>
<li><a href="#1551-%e8%8e%b7%e5%8f%96htm%e5%b9%b6%e7%94%9f%e6%88%90docset">1.5.5.1. 获取htm,并生成docset</a></li>
<li><a href="#1552-%e5%88%9b%e5%bb%ba%e7%b4%a2%e5%bc%95">1.5.5.2. 创建索引</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#16-%e6%80%bb%e7%bb%93">1.6. 总结</a></li>
</ul>
</li>
</ul>
<a id="more"></a>
<h1 id="1-docset"><a href="#1-docset" class="headerlink" title="1. docset"></a>1. docset</h1><h2 id="1-1-阅读本篇文章需求"><a href="#1-1-阅读本篇文章需求" class="headerlink" title="1.1. 阅读本篇文章需求"></a>1.1. 阅读本篇文章需求</h2><p>1.知道docset是什么，后面会介绍<br>2.知道dash 如何使用，或者知道怎么使用docset</p>
<h2 id="1-2-什么是docset"><a href="#1-2-什么是docset" class="headerlink" title="1.2. 什么是docset"></a>1.2. 什么是docset</h2><p><a href="https://kapeli.com/dash_guide" target="_blank" rel="noopener">https://kapeli.com/dash_guide</a><br>Documentation sets, or docsets, consist of collections of HTML files. Dash uses these docsets to store the docs you need. This section describes the various features Dash has to help you acquire and manange docsets.<br><a href="https://fileinfo.com/extension/docset" target="_blank" rel="noopener">https://fileinfo.com/extension/docset</a><br>What is a DOCSET file?<br>Developer file created by Doxygen, a source code documentation system; contains an archive of documentation about a body of source code, which can encompass many different individual source code files and code constructs; used as the storage format for publishing documentation to developers that use the source code.</p>
<h2 id="1-3-哪里可以下载docset"><a href="#1-3-哪里可以下载docset" class="headerlink" title="1.3. 哪里可以下载docset"></a>1.3. 哪里可以下载docset</h2><p>dash.app 可以直接下<br>Docsets can be downloaded Dash’s Preferences &gt; Downloads.</p>
<h2 id="1-4-为什么要自己生成docset"><a href="#1-4-为什么要自己生成docset" class="headerlink" title="1.4. 为什么要自己生成docset"></a>1.4. 为什么要自己生成docset</h2><p>想定制一些自己查询的文档，这些文档没有别人做好的docset可以下，能找到一些html,但如果每次都查询html又觉得麻烦，所以有了自定义docset的想法。</p>
<h2 id="1-5-哪里软件支持docset"><a href="#1-5-哪里软件支持docset" class="headerlink" title="1.5. 哪里软件支持docset"></a>1.5. 哪里软件支持docset</h2><h3 id="1-5-1-dash"><a href="#1-5-1-dash" class="headerlink" title="1.5.1. dash"></a>1.5.1. dash</h3><p>作为一名程序员，最离不开的就是文档了，大多数情况下我们都是通过文档了解一个陌生的领域。想象一下，打开了一堆文档，在文档中跳来跳去，多么的不优雅！所以Bogdan Popescu一怒之下开发了dash，解放了太多在文档中跳来跳去的码农。<br>自带大量常用文档(iOS/Mac/PHP/Python/Java等)<br>支持用户自定义文档(scrapy/requests/beautifulsoup等)<br>快速搜索文档及 API<br>管理和搜索代码片段<br>无缝插入众多第三方应用(Alfred/Xcode/Terminal等)<br><img src="./pic/73436.png" alt="73436.png"></p>
<h3 id="1-5-2-类似dash的工具"><a href="#1-5-2-类似dash的工具" class="headerlink" title="1.5.2. 类似dash的工具"></a>1.5.2. 类似dash的工具</h3><p><a href="https://doc2dash.readthedocs.io/en/latest/installation.html#viewer" target="_blank" rel="noopener">https://doc2dash.readthedocs.io/en/latest/installation.html#viewer</a><br>To view the results, you will need a docset viewer, the most commonly known being Dash.app for macOS.<br>Other alternatives have been developed in cooperation with Dash.app’s developer Kapeli:<br>helm-dash for Emacs,<br>velocity for Windows,<br>and zeal for Linux, macOS, and Windows.</p>
<h3 id="1-5-3-官方工具支持自定义docset"><a href="#1-5-3-官方工具支持自定义docset" class="headerlink" title="1.5.3. 官方工具支持自定义docset"></a>1.5.3. 官方工具支持自定义docset</h3><h4 id="1-5-3-1-doc2dash"><a href="#1-5-3-1-doc2dash" class="headerlink" title="1.5.3.1. doc2dash"></a>1.5.3.1. doc2dash</h4><p>Instructions on generating docsets can be found in the Docset Generation Guide.<br>doc2dash is an MIT-licensed extensible Documentation Set generator intended to be used with the Dash.app API browser for macOS or one of its many free clones for all relevant platforms.<br>If you’ve never heard of Dash.app and its likes, you’re missing out: together with doc2dash it’s all your API documentation at your fingertips – even when you’re offline!<br>doc2dash’s documentation lives at Read the Docs, the code on GitHub. It’s tested on Python 2.7, 3.4+, and PyPy. Both Linux and macOS are tested although certain features are only available on macOS.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd docs &amp;&amp; make html</span><br><span class="line">doc2dash html</span><br></pre></td></tr></table></figure>
<p>一些项目有规范的doc文档，可以用doc2dash 来生成docset.</p>
<h4 id="1-5-3-2-dash-docset-builder"><a href="#1-5-3-2-dash-docset-builder" class="headerlink" title="1.5.3.2. dash-docset-builder"></a>1.5.3.2. dash-docset-builder</h4><p>php写的，功能还是很全，但是不太会调<br><a href="https://github.com/godbout/dash-docset-builder" target="_blank" rel="noopener">https://github.com/godbout/dash-docset-builder</a></p>
<h3 id="1-5-4-官方手动方法自定义docset"><a href="#1-5-4-官方手动方法自定义docset" class="headerlink" title="1.5.4. 官方手动方法自定义docset"></a>1.5.4. 官方手动方法自定义docset</h3><p><a href="https://kapeli.com/docsets#copyDocumentation" target="_blank" rel="noopener">https://kapeli.com/docsets#copyDocumentation</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">13.1. Create the Docset Folder#</span><br><span class="line">The docset folder structure can be created using this Terminal command:</span><br><span class="line"></span><br><span class="line">mkdir -p &lt;docset name&gt;.docset/Contents/Resources/Documents/</span><br><span class="line">You can also manually create the docset structure if you want, they&apos;re just folders.</span><br><span class="line"></span><br><span class="line">13.2. Copy the HTML Documentation#</span><br><span class="line">Copy the HTML documentation you already have to this folder:</span><br><span class="line"></span><br><span class="line">&lt;docset name&gt;.docset/Contents/Resources/Documents/</span><br><span class="line">13.3. Create the Info.plist File#</span><br><span class="line">Download and edit this sample Info.plist and place it in the &lt;docset name&gt;.docset/Contents/ folder. Editing should be straightforward, just set the values to whatever name you want for your docset.</span><br><span class="line"></span><br><span class="line">13.4. Create the SQLite Index#</span><br><span class="line">Create a SQLite database in the file &lt;docset name&gt;.docset/Contents/Resources/docSet.dsidx with the following query:</span><br><span class="line"></span><br><span class="line">CREATE TABLE searchIndex(id INTEGER PRIMARY KEY, name TEXT, type TEXT, path TEXT);</span><br><span class="line">Recommended: you can easily prevent adding duplicate entries to the index by also using this query:</span><br><span class="line"></span><br><span class="line">CREATE UNIQUE INDEX anchor ON searchIndex (name, type, path);</span><br><span class="line">13.5. Populate the SQLite Index#</span><br><span class="line">You need to create a script (or application or whatever) that will go through your HTML documentation and add appropriate rows into the SQLite database. Rows can be added using this query:</span><br><span class="line"></span><br><span class="line">INSERT OR IGNORE INTO searchIndex(name, type, path) VALUES (&apos;name&apos;, &apos;type&apos;, &apos;path&apos;);</span><br><span class="line">The values are:</span><br><span class="line"></span><br><span class="line">name is the name of the entry. For example, if you are adding a class, it would be the name of the class. This is the column that Dash searches.</span><br><span class="line">type is the type of the entry. For example, if you are adding a class, it would be &quot;Class&quot;. For a list of types that Dash recognises, see below.</span><br><span class="line">path is the relative path towards the documentation file you want Dash to display for this entry. It can contain an anchor (#). Alternatively, Dash also supports http:// URL entries.</span><br><span class="line"></span><br><span class="line">You can find a few generation script examples here.</span><br><span class="line">[https://kapeli.com/docsets#scriptExamples](https://kapeli.com/docsets#scriptExamples)</span><br></pre></td></tr></table></figure>
<h3 id="1-5-5-自定义生成docset"><a href="#1-5-5-自定义生成docset" class="headerlink" title="1.5.5. 自定义生成docset"></a>1.5.5. 自定义生成docset</h3><p>因为别的方法无法具体实现想指定的dash xxx 搜索指令，不能很方便的扩展搜索方式，自己实现可以实现任意html生成dash 的方式</p>
<h4 id="1-5-5-1-获取htm-并生成docset"><a href="#1-5-5-1-获取htm-并生成docset" class="headerlink" title="1.5.5.1. 获取htm,并生成docset"></a>1.5.5.1. 获取htm,并生成docset</h4><p>使用dash 代码片段生成得到指定网页的html,并生成docset格式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line">wget --recursive \</span><br><span class="line">  --html-extension \</span><br><span class="line">  --convert-links \</span><br><span class="line">  --domains ~_~lldb.llvm.org~_~ \</span><br><span class="line">  --restrict-file-names=windows \</span><br><span class="line">  --page-requisites \</span><br><span class="line">  --reject pdf \</span><br><span class="line">  --no-parent ~_~lldb.llvm.org~_~/~_~arm~_~.html</span><br><span class="line"></span><br><span class="line">if [ -d &quot;~_~arm~_~.docset&quot; ]; then</span><br><span class="line">    echo &quot;~_~arm~_~.docset exitst, please delete it&quot;</span><br><span class="line">    return</span><br><span class="line">fi</span><br><span class="line">contents=~_~arm~_~.docset/Contents</span><br><span class="line">res=$contents/Resources</span><br><span class="line">doc=$res/Documents</span><br><span class="line">mkdir -p $doc</span><br><span class="line">cp frida.png ~_~arm~_~.docset/icon.png</span><br><span class="line">mv ~_~arm~_~.html $doc</span><br><span class="line"></span><br><span class="line">rm $res/docSet.dsidx</span><br><span class="line"></span><br><span class="line">cat &gt; $contents/Info.plist &lt;&lt;- &quot;EOF&quot;</span><br><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE plist PUBLIC &quot;-//Apple//DTD PLIST 1.0//EN&quot; &quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;&gt;</span><br><span class="line">&lt;plist version=&quot;1.0&quot;&gt;</span><br><span class="line">&lt;dict&gt;</span><br><span class="line">  &lt;key&gt;CFBundleIdentifier&lt;/key&gt;</span><br><span class="line">  &lt;string&gt;~_~arm~_~&lt;/string&gt;</span><br><span class="line">  &lt;key&gt;CFBundleName&lt;/key&gt;</span><br><span class="line">  &lt;string&gt;~_~arm~_~&lt;/string&gt;</span><br><span class="line">  &lt;key&gt;DocSetPlatformFamily&lt;/key&gt;</span><br><span class="line">  &lt;string&gt;~_~arm~_~&lt;/string&gt;</span><br><span class="line">  &lt;key&gt;dashIndexFilePath&lt;/key&gt;</span><br><span class="line">  &lt;string&gt;~_~arm~_~.html&lt;/string&gt;</span><br><span class="line">  &lt;key&gt;isDashDocset&lt;/key&gt;</span><br><span class="line">  &lt;true/&gt;</span><br><span class="line">&lt;/dict&gt;</span><br><span class="line">&lt;/plist&gt;</span><br><span class="line">EOF</span><br><span class="line">echo &apos;done&apos;</span><br></pre></td></tr></table></figure>
<h4 id="1-5-5-2-创建索引"><a href="#1-5-5-2-创建索引" class="headerlink" title="1.5.5.2. 创建索引"></a>1.5.5.2. 创建索引</h4><p>如以下代码创建了 radare2 这个工具的html的docset<br><img src="./pic/355453.png" alt="355453.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import sqlite3</span><br><span class="line"></span><br><span class="line">from pathlib import Path</span><br><span class="line">from bs4 import BeautifulSoup</span><br><span class="line"></span><br><span class="line"># CREATE TABLE searchIndex(id INTEGER PRIMARY KEY, name TEXT, type TEXT, path TEXT);</span><br><span class="line"># CREATE UNIQUE INDEX anchor ON searchIndex (name, type, path);</span><br><span class="line"># INSERT OR IGNORE INTO searchIndex(name, type, path) VALUES (&apos;Exploit&apos;, &apos;Class&apos;, &apos;index.html&apos;);</span><br><span class="line">respath=&quot;~_~arm~_~.docset/Contents/Resources&quot;</span><br><span class="line">conn = sqlite3.connect(&apos;&#123;&#125;/docSet.dsidx&apos;.format(respath))</span><br><span class="line">conn.executescript(&apos;&apos;&apos;</span><br><span class="line">    CREATE TABLE IF NOT EXISTS searchIndex(id INTEGER PRIMARY KEY, name TEXT, type TEXT, path TEXT);</span><br><span class="line">    CREATE UNIQUE INDEX IF NOT EXISTS anchor ON searchIndex (name, type, path);&apos;&apos;&apos;)</span><br><span class="line"></span><br><span class="line">def insert(*args):</span><br><span class="line">    conn.execute(&apos;&apos;&apos;INSERT OR IGNORE INTO searchIndex(name, type, path) VALUES (?, ?, ?);&apos;&apos;&apos;, args)</span><br><span class="line"></span><br><span class="line">filename=&quot;&#123;&#125;/Documents/~_~arm~_~.html&quot;.format(respath)</span><br><span class="line">with open(filename) as fp:</span><br><span class="line">    html = fp.read()</span><br><span class="line">print(&quot;filename=&#123;&#125;&quot;.format(filename))</span><br><span class="line">soup = BeautifulSoup(html)</span><br><span class="line"></span><br><span class="line">relpath = str(Path(filename).relative_to(&quot;&#123;&#125;/Documents&quot;.format(respath)))</span><br><span class="line"></span><br><span class="line"># Rax2 1.12.1</span><br><span class="line"># Rafind2 1.12.2</span><br><span class="line"># Rarun2 1.12.3</span><br><span class="line"># Rabin2 1.12.4</span><br><span class="line"># Radiff2 1.12.5</span><br><span class="line"># Rasm2 1.12.6</span><br><span class="line"># Ragg2 1.12.7</span><br><span class="line"># Rahash2 1.12.8</span><br><span class="line"></span><br><span class="line">type = &quot;Method&quot;</span><br><span class="line"></span><br><span class="line">for subtitle in soup.select(&quot;a&quot;):</span><br><span class="line">    if not subtitle:</span><br><span class="line">        break</span><br><span class="line">    if subtitle == &quot;\n&quot;:</span><br><span class="line">        continue</span><br><span class="line">    if subtitle.text != &quot;Rax2&quot; and subtitle.text != &quot;Rafind2&quot; and subtitle.text != &quot;Rarun2&quot; \</span><br><span class="line">            and subtitle.text != &quot;Rabin2&quot; and subtitle.text != &quot;Radiff2&quot; and subtitle.text != &quot;Rasm2&quot;\</span><br><span class="line">            and subtitle.text != &quot;Ragg2&quot; and subtitle.text != &quot;Rahash2&quot;:</span><br><span class="line">        continue</span><br><span class="line"></span><br><span class="line">    name = subtitle.text</span><br><span class="line">    # path=&apos;%s#%s&apos; % (relpath, name)</span><br><span class="line">    path=&quot;&#123;&#125;&#123;&#125;&quot;.format(relpath,subtitle[&quot;href&quot;].lower())</span><br><span class="line">    print(&quot;&#123;&#125;\t\t&#123;&#125;\t\t&#123;&#125;&quot;.format(name,type,path))</span><br><span class="line">    insert(name, type, path)</span><br><span class="line"></span><br><span class="line">conn.commit()</span><br><span class="line">conn.close()</span><br></pre></td></tr></table></figure>
<h2 id="1-6-总结"><a href="#1-6-总结" class="headerlink" title="1.6. 总结"></a>1.6. 总结</h2><p>1.遇到问题多看官网，官网有解决办法，不用你老人家瞎琢磨耽误时间<br>2.看文档细心。</p>
]]></content>
      <categories>
        <category>tools</category>
        <category>dash</category>
      </categories>
      <tags>
        <tag>docset</tag>
        <tag>dash</tag>
      </tags>
  </entry>
</search>
