<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>frida-trace扩展信息到burp</title>
    <url>/2020/03/13/frida_about/frida-trace-burp/</url>
    <content><![CDATA[<h1 id="frida-trace扩展信息到burp"><a href="#frida-trace扩展信息到burp" class="headerlink" title="frida-trace扩展信息到burp"></a>frida-trace扩展信息到burp</h1><p>[TOC]</p>
<h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h2><p>参考原文<a href="https://cedricvb.be/post/tracing-api-calls-in-burp-with-frida/#prettyPhoto" target="_blank" rel="noopener">Tracing API calls in Burp with Frida</a></p>
<p>利用frida实现一个与burp结合实时修改二进制函数参数返回值插件。</p>
<ol>
<li>可以burp查看frida hook的值，burp有很多非常人性化的界面可以参考。</li>
<li>可以burp修改hook的参数，注入测试<ol>
<li>NSString*</li>
<li>NSData*</li>
<li>byte * or char*<a id="more"></a>

</li>
</ol>
</li>
</ol>
<h2 id="2-配置"><a href="#2-配置" class="headerlink" title="2. 配置"></a>2. 配置</h2><h3 id="2-1-frida-trace-传输到代理-127-0-0-1-26080"><a href="#2-1-frida-trace-传输到代理-127-0-0-1-26080" class="headerlink" title="2.1 frida-trace 传输到代理 127.0.0.1:26080"></a>2.1 frida-trace 传输到代理 127.0.0.1:26080</h3><ol>
<li>python3 tracer.py -m “+[EncryptUtils AESEncrypt:key:]” -Uf me.pandamac.iOSPentest</li>
<li>python3 tracer.py -m “+[EncryptUtils AESEncrypt:key:]” -f me.pandamac.iOSPentest -D c27808502c1f74e1659074e5154256360fe17f648 </li>
<li>python3 tracer.py -m  “-[EncryptUtils ret_NSData_by_bytes:byNSString:]” -f me.pandamac.iOSPentest -D c7808502c1f74e1659074e5154256360fe17f648</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding:utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> frida_tools <span class="keyword">import</span> tracer</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">BURP_HOST = <span class="string">'localhost'</span></span><br><span class="line">BURP_PORT = <span class="number">26080</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">frida_process_message</span><span class="params">(self, message, data, ui)</span>:</span></span><br><span class="line">    handled = <span class="literal">False</span></span><br><span class="line">    <span class="keyword">if</span> message[<span class="string">'type'</span>] == <span class="string">'input'</span>:</span><br><span class="line">        handled = <span class="literal">True</span></span><br><span class="line">    <span class="keyword">elif</span> message[<span class="string">'type'</span>] == <span class="string">'send'</span>:</span><br><span class="line">        stanza = message[<span class="string">'payload'</span>]</span><br><span class="line">        <span class="keyword">if</span> stanza[<span class="string">'from'</span>] == <span class="string">'/request'</span>:</span><br><span class="line">            req_data = stanza[<span class="string">'payload'</span>]</span><br><span class="line">            print(req_data)</span><br><span class="line">            <span class="comment"># orig_json_data = json.loads(req_data)</span></span><br><span class="line">            <span class="comment"># orig_request_url = orig_json_data.pop(u'orig_request_url')</span></span><br><span class="line">            orig_request_url = <span class="string">'execute'</span></span><br><span class="line">            req = requests.request(<span class="string">'REQUEST'</span>,</span><br><span class="line">                                  <span class="string">'http://%s:%d/'</span> % (BURP_HOST, BURP_PORT),</span><br><span class="line">                                  headers=&#123;</span><br><span class="line">                                      <span class="string">'content-type'</span>: <span class="string">'text/plain'</span>,</span><br><span class="line">                                      <span class="string">'ORIG_REQUEST_URI'</span>: orig_request_url</span><br><span class="line">                                  &#125;,</span><br><span class="line">                                  data=req_data)</span><br><span class="line">            return_content = req.content.decode(<span class="string">'utf-8'</span>)</span><br><span class="line">            <span class="comment"># req = requests.request('REQUEST', 'http://%s:%d/' % (BURP_HOST, BURP_PORT),</span></span><br><span class="line">            <span class="comment">#                        headers=&#123;'content-type':'text/plain', 'ORIG_REQUEST_URI': orig_request_url&#125;,</span></span><br><span class="line">            <span class="comment">#                        data=json.dumps(orig_json_data))</span></span><br><span class="line">            self._script.post(&#123;<span class="string">'type'</span>:<span class="string">'input'</span>, <span class="string">'payload'</span>: return_content&#125;)</span><br><span class="line">            handled = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">elif</span> stanza[<span class="string">'from'</span>] == <span class="string">'/response'</span>:</span><br><span class="line">            req_data = stanza[<span class="string">'payload'</span>].encode(<span class="string">'utf-8'</span>)</span><br><span class="line">            req = requests.request(<span class="string">'RESPONSE'</span>, <span class="string">'http://%s:%d/'</span> % (BURP_HOST, BURP_PORT),</span><br><span class="line">                                   headers=&#123;<span class="string">'content-type'</span>: <span class="string">'text/plain'</span>&#125;,</span><br><span class="line">                                   data=req_data)</span><br><span class="line">            self._script.post(&#123;<span class="string">'type'</span>: <span class="string">'output'</span>, <span class="string">'payload'</span>: req.content.decode(<span class="string">'utf-8'</span>)&#125;)</span><br><span class="line">            handled = <span class="literal">True</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> handled:</span><br><span class="line">        self.__process_message(message, data, ui)</span><br><span class="line"></span><br><span class="line">tracer.Tracer.__process_message = tracer.Tracer._process_message</span><br><span class="line">tracer.Tracer._process_message = frida_process_message</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    tracer.main()</span><br></pre></td></tr></table></figure>
<h3 id="2-2-127-0-0-1-26080-重定位到-127-0-0-1-27080"><a href="#2-2-127-0-0-1-26080-重定位到-127-0-0-1-27080" class="headerlink" title="2.2 127.0.0.1:26080 重定位到 127.0.0.1:27080"></a>2.2 127.0.0.1:26080 重定位到 127.0.0.1:27080</h3><p><img src="https://i.loli.net/2020/03/13/s4Oja7CBWD2umLv.jpg" alt="-w674"></p>
<h3 id="2-3-回显server接受信息-返回信息"><a href="#2-3-回显server接受信息-返回信息" class="headerlink" title="2.3 回显server接受信息,返回信息"></a>2.3 回显server接受信息,返回信息</h3><ul>
<li>如果没有这个，将返回数据为 burp的代理信息给js代码，并不是burp修改后的数据。</li>
<li>相当于将数据修改后发送到127.0.0.1:27080,然后通过requests.request 返回的数据为回显server回显出来的数据。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding: utf-8</span></span><br><span class="line"><span class="keyword">import</span> platform</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> int(platform.python_version_tuple()[<span class="number">0</span>]) &lt; <span class="number">3</span>:</span><br><span class="line">    <span class="keyword">from</span> BaseHTTPServer <span class="keyword">import</span> HTTPServer, BaseHTTPRequestHandler</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">from</span> http.server <span class="keyword">import</span> HTTPServer, BaseHTTPRequestHandler</span><br><span class="line"><span class="keyword">from</span> optparse <span class="keyword">import</span> OptionParser</span><br><span class="line">ECHO_PORT = <span class="number">27080</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RequestHandler</span><span class="params">(BaseHTTPRequestHandler)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">do_REQUEST</span><span class="params">(self)</span>:</span></span><br><span class="line">        request_path = self.path</span><br><span class="line">        print(<span class="string">'Recving request connction...'</span>)</span><br><span class="line">        request_headers = self.headers</span><br><span class="line">        content_length = request_headers.getheaders(<span class="string">'content-length'</span>)</span><br><span class="line">        length = int(content_length[<span class="number">0</span>]) <span class="keyword">if</span> content_length <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        self.send_response(<span class="number">200</span>)</span><br><span class="line">        self.end_headers()</span><br><span class="line">        self.wfile.write(self.rfile.read(length))</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">do_RESPONSE</span><span class="params">(self)</span>:</span></span><br><span class="line">        request_path = self.path</span><br><span class="line">        print(<span class="string">'Recving Response connction...'</span>)</span><br><span class="line">        request_headers = self.headers</span><br><span class="line">        content_length = request_headers.getheaders(<span class="string">'content-length'</span>)</span><br><span class="line">        length = int(content_length[<span class="number">0</span>]) <span class="keyword">if</span> content_length <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        self.send_response(<span class="number">200</span>)</span><br><span class="line">        self.end_headers()</span><br><span class="line"></span><br><span class="line">        self.wfile.write(self.rfile.read(length))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'Listening on localhost: %d'</span> % ECHO_PORT)</span><br><span class="line">    server = HTTPServer((<span class="string">''</span>, ECHO_PORT), RequestHandler)</span><br><span class="line">    server.serve_forever()</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    print(<span class="string">'Staring echo server on port %d'</span> % ECHO_PORT)</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<h3 id="2-4-trace-js-测试代码-需改参数和返回值"><a href="#2-4-trace-js-测试代码-需改参数和返回值" class="headerlink" title="2.4 trace js 测试代码,需改参数和返回值"></a>2.4 trace js 测试代码,需改参数和返回值</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Called synchronously when about to call +[EncryptUtils AESEncrypt:key:].</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * @this &#123;object&#125; - Object allowing you to store state for use in onLeave.</span></span><br><span class="line"><span class="comment">   * @param &#123;function&#125; log - Call this function with a string to be presented to the user.</span></span><br><span class="line"><span class="comment">   * @param &#123;array&#125; args - Function arguments represented as an array of NativePointer objects.</span></span><br><span class="line"><span class="comment">   * For example use args[0].readUtf8String() if the first argument is a pointer to a C string encoded as UTF-8.</span></span><br><span class="line"><span class="comment">   * It is also possible to modify arguments by assigning a NativePointer object to an element of this array.</span></span><br><span class="line"><span class="comment">   * @param &#123;object&#125; state - Object allowing you to keep state across function calls.</span></span><br><span class="line"><span class="comment">   * Only one JavaScript function will execute at a time, so do not worry about race-conditions.</span></span><br><span class="line"><span class="comment">   * However, do not use this to store function arguments across onEnter/onLeave, but instead</span></span><br><span class="line"><span class="comment">   * use "this" which is an object for keeping state local to an invocation.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  onEnter: <span class="function"><span class="keyword">function</span> (<span class="params">log, args, state</span>) </span>&#123;</span><br><span class="line">    log(<span class="string">'+[EncryptUtils AESEncrypt:'</span> + args[<span class="number">2</span>] + <span class="string">' key:'</span> + args[<span class="number">3</span>] + <span class="string">']'</span>);</span><br><span class="line">    <span class="keyword">this</span>.args0=args[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">this</span>.args1=args[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">this</span>.args2=args[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">this</span>.args3=args[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> func_name_nstring = ObjC.selectorAsString(<span class="keyword">this</span>.args1);</span><br><span class="line">    send_data=<span class="built_in">JSON</span>.stringify(&#123;</span><br><span class="line">        FH_FUNC_NAME: func_name_nstring,</span><br><span class="line">        FH_ARG_COUNT: <span class="number">3</span>,</span><br><span class="line">        FH_DETAIL_OBJECT: ObjC.Object(<span class="keyword">this</span>.args0).toString(),</span><br><span class="line">        FH_DETAIL_ARG1:   ObjC.Object(<span class="keyword">this</span>.args2).toString(),</span><br><span class="line">        FH_DETAIL_ARG2:   ObjC.Object(<span class="keyword">this</span>.args3).toString(),</span><br><span class="line">        <span class="comment">// FH_DETAIL_RET: ObjC.Object(retval).toString(),</span></span><br><span class="line">    &#125;, <span class="literal">null</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    send(&#123;<span class="attr">from</span>:<span class="string">'/request'</span>, <span class="attr">payload</span>: send_data&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> op = recv(<span class="string">'input'</span>, <span class="function"><span class="keyword">function</span> <span class="title">onMessage</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">        log(<span class="string">"Waiting Input payload"</span>);</span><br><span class="line">        <span class="comment">// log(value.payload);</span></span><br><span class="line">        <span class="comment">// log("Waiting Input recv_data start");</span></span><br><span class="line">        recv_data = <span class="built_in">JSON</span>.parse(value.payload)</span><br><span class="line">        log(recv_data)</span><br><span class="line">        <span class="comment">// log("Waiting Input recv_data end");</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> NSString = ObjC.classes.NSString;</span><br><span class="line">        args[<span class="number">2</span>]  = NSString.alloc().initWithString_(recv_data[<span class="string">"FH_DETAIL_ARG1"</span>]);</span><br><span class="line">        args[<span class="number">3</span>]  = NSString.alloc().initWithString_(recv_data[<span class="string">"FH_DETAIL_ARG2"</span>]);</span><br><span class="line">    &#125;);</span><br><span class="line">    op.wait();</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Called synchronously when about to return from +[EncryptUtils AESEncrypt:key:].</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * See onEnter for details.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * @this &#123;object&#125; - Object allowing you to access state stored in onEnter.</span></span><br><span class="line"><span class="comment">   * @param &#123;function&#125; log - Call this function with a string to be presented to the user.</span></span><br><span class="line"><span class="comment">   * @param &#123;NativePointer&#125; retval - Return value represented as a NativePointer object.</span></span><br><span class="line"><span class="comment">   * @param &#123;object&#125; state - Object allowing you to keep state across function calls.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  onLeave: <span class="function"><span class="keyword">function</span> (<span class="params">log, retval, state</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(retval);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> func_name_nstring = ObjC.selectorAsString(<span class="keyword">this</span>.args1);</span><br><span class="line">    send_data=<span class="built_in">JSON</span>.stringify(&#123;</span><br><span class="line">        FH_FUNC_NAME: func_name_nstring,</span><br><span class="line">        FH_DETAIL_RET: ObjC.Object(retval).toString(),</span><br><span class="line">    &#125;, <span class="literal">null</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    send(&#123;<span class="attr">from</span>:<span class="string">'/response'</span>, <span class="attr">payload</span>: send_data&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> op = recv(<span class="string">'output'</span>, <span class="function"><span class="keyword">function</span> <span class="title">onMessage</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">        log(<span class="string">"Waiting output payload"</span>);</span><br><span class="line">        <span class="comment">// log(value.payload);</span></span><br><span class="line">        <span class="comment">// log("Waiting output recv_data start");</span></span><br><span class="line">        recv_data = <span class="built_in">JSON</span>.parse(value.payload)</span><br><span class="line">        log(recv_data)</span><br><span class="line">        <span class="comment">// log("Waiting output recv_data end");</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> NSString = ObjC.classes.NSString;</span><br><span class="line">        <span class="keyword">var</span> tmp_retval = NSString.alloc().initWithString_(recv_data[<span class="string">"FH_DETAIL_RET"</span>]);</span><br><span class="line">        retval.replace(tmp_retval);</span><br><span class="line">    &#125;);</span><br><span class="line">    op.wait();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-测试效果"><a href="#3-测试效果" class="headerlink" title="3.测试效果"></a>3.测试效果</h2><h3 id="3-1-burp接受函数参数包"><a href="#3-1-burp接受函数参数包" class="headerlink" title="3.1 burp接受函数参数包"></a>3.1 burp接受函数参数包</h3><p><img src="https://i.loli.net/2020/03/13/vC6QbUEVcH21rfY.jpg" alt="-w468"><br>可以进行修改，然后点击Forward</p>
<h3 id="3-2-burp接受函数返回包"><a href="#3-2-burp接受函数返回包" class="headerlink" title="3.2 burp接受函数返回包"></a>3.2 burp接受函数返回包</h3><p><img src="https://i.loli.net/2020/03/13/Pni6xCwveEyF9UL.jpg" alt="-w504"><br>可以进行修改，然后点击Forward</p>
<h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4.总结"></a>4.总结</h2><ul>
<li>直接测试所有二进制的函数进出返回值，用于测试工作，剩下工作就是编写合适的 js 代码,将trace的函数用于通用。当然也可以不用trace,自己写hook 框架，达到任意修改函数返回值的效果。</li>
<li>如果函数有时间校验的话，可能会出错，这时候用代码实现修改即可。</li>
</ul>
]]></content>
      <categories>
        <category>tools</category>
        <category>frida</category>
      </categories>
      <tags>
        <tag>frida</tag>
        <tag>burp</tag>
      </tags>
  </entry>
  <entry>
    <title>lldb_help</title>
    <url>/2020/02/23/lldb_about/lldb-help/</url>
    <content><![CDATA[<ul>
<li><a href="#some-lldb-tips">some lldb tips</a><ul>
<li><a href="#%e9%80%9a%e7%94%a8">通用</a><ul>
<li><a href="#%e8%ae%be%e7%bd%aelldb-%e4%bd%bf%e7%94%a8python2">设置lldb 使用python2</a></li>
<li><a href="#%e8%ae%a1%e7%ae%97%e5%81%8f%e7%a7%bbida%e5%9c%b0%e5%9d%80">计算偏移/ida地址</a></li>
<li><a href="#%e8%a7%82%e5%af%9f%e6%96%ad%e7%82%b9">观察断点</a></li>
<li><a href="#%e8%af%bb%e5%8f%96%e7%9b%ae%e6%a0%87%e5%9c%b0%e5%9d%80%e7%9a%84%e5%86%85%e5%ad%98%e6%8c%87%e4%bb%a4">读取目标地址的内存指令</a></li>
<li><a href="#dis-apc-%e5%8f%8d%e6%b1%87%e7%bc%96%e6%8c%87%e5%ae%9a%e5%9c%b0%e5%9d%80">dis-a$pc 反汇编指定地址</a></li>
<li><a href="#%e5%88%87%e6%8d%a2%e5%88%86%e6%94%af">切换分支</a></li>
<li><a href="#threadinfo%e8%be%93%e5%87%ba%e5%bd%93%e5%89%8d%e7%ba%bf%e7%a8%8b%e7%9a%84%e4%bf%a1%e6%81%af">threadinfo:输出当前线程的信息。</a></li>
<li><a href="#b-ptrace--c-xxx%e6%bb%a1%e8%b6%b3%e6%9f%90%e4%b8%aa%e6%9d%a1%e4%bb%b6%e4%b9%8b%e5%90%8e%e7%a8%8b%e5%ba%8f%e6%89%8d%e4%bc%9a%e4%b8%ad%e6%96%ad">b ptrace -c xxx:满足某个条件之后程序才会中断。</a></li>
<li><a href="#helpapropos">help/apropos</a></li>
<li><a href="#%e6%96%ad%e7%82%b9%e5%90%8e%e6%89%a7%e8%a1%8c%e5%91%bd%e4%bb%a4">断点后执行命令</a></li>
<li><a href="#%e7%ac%a6%e5%8f%b7%e6%96%ad%e7%82%b9">符号断点</a></li>
<li><a href="#%e6%9d%a1%e4%bb%b6%e6%96%ad%e7%82%b9">条件断点</a></li>
<li><a href="#xcode%e9%a2%84%e5%a4%84%e7%90%86%e5%bf%ab%e6%8d%b7%e9%94%ae">xcode预处理快捷键</a></li>
<li><a href="#pdb%e6%9d%a5%e6%8e%92%e6%9f%a5%e4%ba%86%e4%b8%80%e4%b8%aa%e8%84%9a%e6%9c%ac%e4%b8%ad%e7%9a%84%e9%97%ae%e9%a2%98">pdb来排查了一个脚本中的问题</a></li>
<li><a href="#%e5%a6%82%e4%bd%95%e5%b0%86%e6%96%ad%e7%82%b9%e8%ae%be%e7%bd%ae%e5%9c%a8%e5%8a%a8%e6%80%81%e5%ba%93%e7%9a%84%e5%85%a5%e5%8f%a3">如何将断点设置在动态库的入口</a></li>
<li><a href="#%e5%9f%ba%e6%9c%ac%e7%9a%84%e7%b1%bb">基本的类：</a></li>
</ul>
</li>
<li><a href="#android">android</a></li>
<li><a href="#ios">iOS</a><ul>
<li><a href="#%e7%a0%b8%e5%a3%b3">砸壳</a></li>
<li><a href="#%e6%9f%a5%e8%af%a2%e6%8c%89%e9%92%ae%e4%ba%8b%e4%bb%b6">查询按钮事件</a></li>
<li><a href="#chisel-%e6%89%93%e5%8d%b0%e7%bb%93%e6%9e%84">chisel 打印结构</a><ul>
<li><a href="#%e5%af%b9%e8%b1%a1%e6%9f%a5%e6%89%be">对象查找</a></li>
<li><a href="#%e5%af%b9%e8%b1%a1%e5%88%86%e6%9e%90">对象分析</a></li>
<li><a href="#%e6%96%ad%e7%82%b9">断点</a></li>
<li><a href="#%e8%a7%86%e5%9b%be%e6%9f%a5%e6%89%be">视图查找</a></li>
<li><a href="#%e8%a7%86%e5%9b%be%e5%b1%82%e7%ba%a7">视图层级</a></li>
<li><a href="#%e5%85%b6%e4%bb%96%e5%b7%a5%e5%85%b7">其他工具</a></li>
<li><a href="#%e8%a7%86%e5%9b%be%e8%b0%83%e8%af%95">视图调试</a></li>
</ul>
</li>
<li><a href="#nsobject%e7%a7%81%e6%9c%89%e6%96%b9%e6%b3%95%e5%8f%af%e4%bb%a5%e6%96%b9%e4%be%bf%e6%9f%a5%e7%9c%8b%e5%af%b9%e8%b1%a1%e7%9a%84%e5%86%85%e5%ae%b9">NSObject私有方法，可以方便查看对象的内容：</a></li>
<li><a href="#%e6%90%9c%e7%b4%a2uitextfield%e7%9a%84%e5%ae%9e%e4%be%8b%e5%af%b9%e8%b1%a1%e5%92%8ccycript%e4%b8%ad%e7%9a%84choose%e6%a0%b7%e7%9a%84">搜索UITextField的实例对象和Cycript中的choose—样的</a></li>
<li><a href="#%e8%af%bb%e5%8f%96%e5%86%85%e5%ad%98">读取内存</a></li>
<li><a href="#%e6%9f%a5%e7%9c%8b%e5%af%b9%e8%b1%a1%e5%86%85%e5%ad%98%e5%85%b3%e7%b3%bbxcode%e8%a7%82%e7%9c%8b">查看对象内存关系,xcode观看</a></li>
<li><a href="#%e6%89%a7%e8%a1%8cscript">执行script</a></li>
<li><a href="#%e5%9c%a8-snapchat%e6%a8%a1%e5%9d%97%e4%b8%ad%e6%9f%a5%e7%9c%8b%e4%b8%8elogin%e6%9c%89%e5%85%b3%e7%9a%84%e7%ac%a6%e5%8f%b7%e4%bf%a1%e6%81%af">在 Snapchat模块中查看与login有关的符号信息</a></li>
<li><a href="#%e6%9f%90%e4%b8%aa%e7%b1%bb%e7%9a%84%e6%89%80%e6%9c%89%e6%96%b9%e6%b3%95%e4%b8%8b%e6%96%ad%e7%82%b9%e5%b9%b6%e8%b7%9f%e8%b8%aa%e6%89%93%e5%8d%b0%e8%b0%83%e7%94%a8%e5%8f%82%e6%95%b0">某个类的所有方法下断点并跟踪打印调用参数</a></li>
<li><a href="#xcode-%e8%ae%be%e7%bd%ae%e7%8e%af%e5%a2%83%e5%8f%98%e9%87%8f">xcode 设置环境变量</a></li>
<li><a href="#ios-%e5%88%86%e6%9e%90%e5%b8%b8%e8%a7%81%e7%82%b9">iOS 分析常见点</a></li>
</ul>
</li>
<li><a href="#macos">macos</a><ul>
<li><a href="#%e8%b0%83%e8%af%95%e5%bc%80%e5%90%af%e9%85%8d%e7%bd%ae">调试开启配置</a><ul>
<li><a href="#wait-for-pid">wait for pid</a></li>
<li><a href="#%e7%9b%b4%e6%8e%a5%e8%b0%83%e8%af%95%e5%90%af%e5%8a%a8">直接调试启动</a></li>
<li><a href="#%e5%b0%86speech%e6%a1%86%e6%9e%b6%e5%8a%a0%e8%bd%bd%e5%88%b0deleteme%e6%b5%81%e7%a8%8b%e7%a9%ba%e9%97%b4">将Speech框架加载到DeleteMe流程空间</a></li>
<li><a href="#%e5%bc%82%e5%b8%b8">异常</a><ul>
<li><a href="#disabling-rootless">Disabling Rootless</a></li>
</ul>
</li>
<li><a href="#w%e5%b7%a5%e4%bd%9c%e7%9b%ae%e5%bd%95">-w工作目录</a></li>
<li><a href="#%e7%8e%af%e5%a2%83%e5%8f%98%e9%87%8f">环境变量</a></li>
<li><a href="#%e8%ae%be%e7%bd%ae%e6%96%b0%e7%9b%ae%e6%a0%87">设置新目标</a></li>
</ul>
</li>
<li><a href="#%e8%b0%83%e8%af%95%e5%b8%b8%e8%a7%81%e6%96%ad%e7%82%b9%e7%9b%b8%e5%85%b3">调试常见断点相关</a><ul>
<li><a href="#finding-a-class-with-a-click">Finding a class with a click</a></li>
<li><a href="#filter-breakpoints-for-important-content">Filter breakpoints for important content</a></li>
<li><a href="#%e5%9c%a8%e6%a8%a1%e5%9d%97%e4%b8%8b%e6%96%ad">在模块下断</a></li>
</ul>
</li>
<li><a href="#%e6%89%93%e5%8d%b0%e7%9b%b8%e5%85%b3">打印相关</a><ul>
<li><a href="#%e8%ae%be%e7%bd%ae%e5%90%8e%e5%88%b7%e6%96%b0">设置后刷新</a></li>
<li><a href="#%e8%be%93%e5%87%ba%e6%a8%a1%e5%9d%97%e4%b8%ad%e7%9a%84%e5%87%bd%e6%95%b0">输出模块中的函数</a></li>
</ul>
</li>
<li><a href="#%e8%b0%83%e8%af%95%e5%87%bd%e6%95%b0%e5%8d%95%e6%ad%a5%e7%9b%b8%e5%85%b3">调试函数单步相关</a><ul>
<li><a href="#%e6%ad%a5%e5%85%a5%e6%97%a0%e7%ac%a6%e5%8f%b7">步入无符号</a></li>
<li><a href="#pdb%e8%b0%83%e8%af%95">pdb调试</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<a id="more"></a>
<h1 id="some-lldb-tips"><a href="#some-lldb-tips" class="headerlink" title="some lldb tips"></a>some lldb tips</h1><h2 id="通用"><a href="#通用" class="headerlink" title="通用"></a>通用</h2><h3 id="设置lldb-使用python2"><a href="#设置lldb-使用python2" class="headerlink" title="设置lldb 使用python2"></a>设置lldb 使用python2</h3><p>defaults write com.apple.dt.lldb DefaultPythonVersion 2</p>
<h3 id="计算偏移-ida地址"><a href="#计算偏移-ida地址" class="headerlink" title="计算偏移/ida地址"></a>计算偏移/ida地址</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">p/x 0X000000010095ECCC+0X0000000000038000</span><br><span class="line">(lldb) p/x 0x0000000100e595b4-0x0000000000038000 (long) $18 = 0x0000000100e215b4</span><br><span class="line">查看某个地址所在模块的信息</span><br></pre></td></tr></table></figure>
<h3 id="观察断点"><a href="#观察断点" class="headerlink" title="观察断点"></a>观察断点</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">watchpoint set expression -w write ―- 0xl01801a48 :给某个地址设置观察断点,内存进行写操作时就会触发断点</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 获取需要监控的内存地址</span><br><span class="line">p (ptrdiff_t)ivar_getOffset((struct Ivar *)class_getInstanceVariable([MyView class], &quot;_layer&quot;))</span><br><span class="line"></span><br><span class="line">(ptrdiff_t) $0 = 8</span><br><span class="line"></span><br><span class="line">watchpoint set expression -- (int *)$myView + 8：监控_layer的地址</span><br><span class="line"></span><br><span class="line">变量监控：watchpoint set variable -w read_write</span><br><span class="line">条件监控：watchpoint modify -c &apos;(global==5)&apos;</span><br></pre></td></tr></table></figure>
<h3 id="读取目标地址的内存指令"><a href="#读取目标地址的内存指令" class="headerlink" title="读取目标地址的内存指令"></a>读取目标地址的内存指令</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">x/10xg 0xl01801a48 这里的x 表示用十六进制来显示结果。&quot;g&quot;代表giant word(8字节)大小。所以就是用十六进制显示 0x101801a48所指恐惧的10个64位的元素内容。常见的大小格式为&quot;b-byte&quot;(1字节),&quot;h-half word&quot;(2字节),&quot;w- word”(4字节),&quot;g-giantword”(8字节)。</span><br></pre></td></tr></table></figure>
<h3 id="dis-a-pc-反汇编指定地址"><a href="#dis-a-pc-反汇编指定地址" class="headerlink" title="dis-a$pc 反汇编指定地址"></a>dis-a$pc 反汇编指定地址</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">这里是pc寄存器所对应的地址。</span><br></pre></td></tr></table></figure>
<h3 id="切换分支"><a href="#切换分支" class="headerlink" title="切换分支"></a>切换分支</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">f2:切换到当前调用栈为2的位置，也就是bt中的frame #2。</span><br></pre></td></tr></table></figure>
<h3 id="threadinfo-输出当前线程的信息。"><a href="#threadinfo-输出当前线程的信息。" class="headerlink" title="threadinfo:输出当前线程的信息。"></a>threadinfo:输出当前线程的信息。</h3><h3 id="b-ptrace-c-xxx-满足某个条件之后程序才会中断。"><a href="#b-ptrace-c-xxx-满足某个条件之后程序才会中断。" class="headerlink" title="b ptrace -c xxx:满足某个条件之后程序才会中断。"></a>b ptrace -c xxx:满足某个条件之后程序才会中断。</h3><h3 id="help-apropos"><a href="#help-apropos" class="headerlink" title="help/apropos"></a>help/apropos</h3><h3 id="断点后执行命令"><a href="#断点后执行命令" class="headerlink" title="断点后执行命令"></a>断点后执行命令</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">b +[Manager performLoginWithUsernameOnEmail: password: preAuthToken: twoFAMethod: confirmReactivation:rememberDevice:fromDeepLink:onComplete:]</span><br><span class="line">Breakpoint 2: where = Snapchat&apos;+[Manager</span><br><span class="line">br com add 2</span><br><span class="line">&gt; po $x2</span><br><span class="line">&gt; po $x3</span><br><span class="line">&gt; c</span><br><span class="line">&gt; po F.viewCFG()</span><br><span class="line">&gt; DONE</span><br></pre></td></tr></table></figure>
<h3 id="符号断点"><a href="#符号断点" class="headerlink" title="符号断点"></a>符号断点</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">b isEven, br s -F isEven</span><br><span class="line">breakpoint set -f main.m -l 16：在源码文件的某一行断点</span><br><span class="line">b main.m:17。b是_regexp-break的缩写</span><br></pre></td></tr></table></figure>
<h3 id="条件断点"><a href="#条件断点" class="headerlink" title="条件断点"></a>条件断点</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">breakpoint modify -c &apos;i == 99&apos; 1</span><br><span class="line">断点时附加自定义操作：breakpoint command add 1</span><br></pre></td></tr></table></figure>
<h3 id="xcode预处理快捷键"><a href="#xcode预处理快捷键" class="headerlink" title="xcode预处理快捷键"></a>xcode预处理快捷键</h3><p>单击 Product -&gt; PerformAction -&gt;Preprocess xxxx 可以对文件进行预处理，还可以将代码转换成汇编代码。可以帮助我们理解这些宏的作用</p>
<h3 id="pdb来排查了一个脚本中的问题"><a href="#pdb来排查了一个脚本中的问题" class="headerlink" title="pdb来排查了一个脚本中的问题"></a>pdb来排查了一个脚本中的问题</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(lldb) findclass</span><br><span class="line">error: libarclite_macosx.a(arclite.o) failed to load objfile for /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/arc/libarclite_macosx.a</span><br><span class="line">error: libarclite_macosx.a(arclite.o) failed to load objfile for /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/arc/libarclite_macosx.a</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;/Users/gogleyin/lldb/findclass.py&quot;, line 40, in findclass</span><br><span class="line">    raise AssertionError(&quot;Uhoh... something went wrong, can you figure it out? :]&quot;)</span><br><span class="line">AssertionError: Uhoh... something went wrong, can you figure it out? :]</span><br><span class="line"></span><br><span class="line">(lldb) script import pdb</span><br><span class="line">(lldb) findclass</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;/Users/gogleyin/lldb/findclass.py&quot;, line 40, in findclass</span><br><span class="line">    raise AssertionError(&quot;Uhoh... something went wrong, can you figure it out? :]&quot;)</span><br><span class="line">AssertionError: Uhoh... something went wrong, can you figure it out? :]</span><br><span class="line"></span><br><span class="line">(lldb) script pdb.pm()</span><br><span class="line">&gt; /Users/gogleyin/lldb/findclass.py(40)findclass()</span><br><span class="line">-&gt; raise AssertionError(&quot;Uhoh... something went wrong, can you figure it out? :]&quot;)</span><br><span class="line"></span><br><span class="line">(Pdb) print(codeString)  # 这个东西包含了一段oc代码，用oc runtime来找出runtime的所有类</span><br><span class="line">    @import Foundation;</span><br><span class="line">    int numClasses;</span><br><span class="line">    Class * classes = NULL;</span><br><span class="line">    classes = NULL;</span><br><span class="line">    numClasses = objc_getClassList(NULL, 0);</span><br><span class="line">    NSMutableString *returnString = [NSMutableString string];</span><br><span class="line">    classes = (__unsafe_unretained Class *)malloc(sizeof(Class) * numClasses);</span><br><span class="line">    numClasses = objc_getClassList(classes, numClasses);</span><br><span class="line">    for (int i = 0; i &lt; numClasses; i++) &#123;</span><br><span class="line">      Class c = classes[i];</span><br><span class="line">      [returnString appendFormat:@&quot;%s,&quot;, class_getName(c)];</span><br><span class="line">    &#125;</span><br><span class="line">    free(classes);</span><br><span class="line">    returnString;  # 返回returnString的值给Python脚本</span><br><span class="line"></span><br><span class="line">(Pdb) l 35, 45  # 会列出35到45行代码，注意40行的 -&gt; 表示当前pdb停在的位置</span><br><span class="line"> 35         &apos;&apos;&apos;</span><br><span class="line"> 36</span><br><span class="line"> 37         res = lldb.SBCommandReturnObject()</span><br><span class="line"> 38         debugger.GetCommandInterpreter().HandleCommand(&quot;expression -lobjc -O -- &quot; + codeString, res)</span><br><span class="line"> 39         if res.GetError():</span><br><span class="line"> 40  -&gt;         raise AssertionError(&quot;Uhoh... something went wrong, can you figure it out? :]&quot;)</span><br><span class="line"> 41         elif not res.HasResult():</span><br><span class="line"> 42             raise AssertionError(&quot;There&apos;s no result. Womp womp....&quot;)</span><br><span class="line"> 43</span><br><span class="line"> 44         returnVal = res.GetOutput()</span><br><span class="line"> 45         resultArray = returnVal.split(&quot;,&quot;)</span><br><span class="line"># 嗯，似乎res.GetError()看起来更加有趣，玩一下先</span><br><span class="line"></span><br><span class="line">(Pdb) print res.GetError()</span><br><span class="line">error: &apos;objc_getClassList&apos; has unknown return type; cast the call to its declared return type</span><br><span class="line">error: &apos;objc_getClassList&apos; has unknown return type; cast the call to its declared return type</span><br><span class="line">error: &apos;class_getName&apos; has unknown return type; cast the call to its declared return type</span><br><span class="line"># 到这里可以看到，问题是codeString里面的代码让LLDB迷惑了。</span><br><span class="line"># 实际这种错误在LLDB里面是非常常见的。你需要告诉LLDB一个函数的返回类型，因为它无法知道那是啥。</span><br><span class="line"># 在这个case下， objc_getClassList 和 class_getName 都有未知的返回类型</span><br><span class="line"># Google一下便知这两个函数的签名如下：</span><br><span class="line"> int objc_getClassList(Class *buffer, int bufferCount);</span><br><span class="line">const char * class_getName(Class cls);</span><br><span class="line"># 所有我们需要做的事转换返回类型到正确的值就可以啦。如下：</span><br><span class="line"></span><br><span class="line">codeString = r&apos;&apos;&apos;</span><br><span class="line">@import Foundation;</span><br><span class="line">int numClasses;</span><br><span class="line">Class * classes = NULL;</span><br><span class="line">classes = NULL;</span><br><span class="line">numClasses = (int)objc_getClassList(NULL, 0);</span><br><span class="line">NSMutableString *returnString = [NSMutableString string];</span><br><span class="line">classes = (__unsafe_unretained Class *)malloc(sizeof(Class) *numClasses);</span><br><span class="line">numClasses = (int)objc_getClassList(classes, numClasses);</span><br><span class="line">for (int i = 0; i &lt; numClasses; i++) &#123;</span><br><span class="line">  Class c = classes[i];</span><br><span class="line">  [returnString appendFormat:@&quot;%s,&quot;, (char *)class_getName(c)];</span><br><span class="line">&#125;</span><br><span class="line">free(classes);</span><br><span class="line">returnString;</span><br><span class="line"></span><br><span class="line">--debug选项是定位JIT代码中的问题的非常好的手段,调试lldb 的好方法</span><br><span class="line">expression --debug -lobjc -O --</span><br><span class="line">可以选择使用frame variable命令打印变量</span><br></pre></td></tr></table></figure>
<h3 id="如何将断点设置在动态库的入口"><a href="#如何将断点设置在动态库的入口" class="headerlink" title="如何将断点设置在动态库的入口"></a>如何将断点设置在动态库的入口</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LLDB命令行进行调试时自 动中断在 _dyld_start 处，因为此时dyld已经加载，所以在dyld里面设置一个在所有库中加载并且在constructor 函数执行之前执行的断点，例如initializeMainExecutable</span><br><span class="line">settings set target.process.stop-on-sharedlibrary-events 1</span><br></pre></td></tr></table></figure>
<h3 id="基本的类："><a href="#基本的类：" class="headerlink" title="基本的类："></a>基本的类：</h3><ul>
<li>lldb.SBDebugger：在你的脚本中用来访问类的实例的类，非常中心，还处理LLDB命令的输入和输出</li>
<li>lldb.SBTarget：与被调试的可执行文件有关（相关调试文件，磁盘上的文件）。<br>你可以用SBDebugger的实例来获取到当前选择的SBTarget。然后 你就可以通过SBTarget访问大部分其余类。</li>
<li>lldb.SBProcess：SBTarget和SBProcess是一对多的关系：SBTarget管理者一个或多个SBProcess实例。SBProcess处理内存读写还有它自己的线程。</li>
<li>lldb.SBThread：管理对应线程的栈帧和stepping的控制逻辑</li>
<li>lldb.SBFrame：管理局部变量（debug信息有提供的）和当时的寄存器快照</li>
<li>lldb.SBModule：代表着一个可执行文件。</li>
<li>lldb.SBFunction：这代表着一个加载到内存中的函数（或者对应代码），它与SBFrame是一对一的关系。<br>实例是 lldb.debugger/lldb.target…<br><a href="https://lldb.llvm.org/python_reference/index.html" target="_blank" rel="noopener">https://lldb.llvm.org/python_reference/index.html</a><br><img src="pic/1.jpg" alt=""><br>演示了LLDB Python主要的几个类之间的相互关系<br><img src="pic/2.jpg" alt=""><br>暂停在某函数时几个类的交互</li>
</ul>
<h2 id="android"><a href="#android" class="headerlink" title="android"></a>android</h2><h2 id="iOS"><a href="#iOS" class="headerlink" title="iOS"></a>iOS</h2><h3 id="砸壳"><a href="#砸壳" class="headerlink" title="砸壳"></a>砸壳</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Cronet.framework git:(master) X otool -hf Cronet Fat headers</span><br><span class="line">fat_magic 0xcafebabe</span><br><span class="line">nfat_arch 2</span><br><span class="line">architecture 0  cputype 12 cpusubtype 9  capabilities 0x0</span><br><span class="line">	offset 16384 size 2749664 align 2A14 (16384)</span><br><span class="line">architecture 1 cputype 16777228 cpusubtype 0 capabilities 0x0</span><br><span class="line">	offset 2768896 size 3612224 align 2A14 (16384)</span><br><span class="line">Mach header</span><br><span class="line">	magic cputype cpusubtype caps filetype ncmds sizeofcmds flags</span><br><span class="line">	Oxfeedface 12 9 0x00 6 27 3328 0x00118085</span><br><span class="line">Mach header</span><br><span class="line">	magic cputype cpusubtype caps filetype ncmds sizeofcmds flags</span><br><span class="line">	0xfeedfacf 16777228 0 0x00 6 27 3816 0X00118085</span><br><span class="line"></span><br><span class="line">otool -arch arm64 -1 Cronet | grep crypt</span><br><span class="line">cryptoff 16384</span><br><span class="line">cryptsize 3309568</span><br><span class="line">cryptid 1</span><br><span class="line">(lldb) im li Cronet</span><br><span class="line">[0] 188F5BF7-B4C4-36EF-BB9A-976FA870F9D7 0x0000000105920000 /private/var/mobile/Containers/Bundle/Application/3A4C68EB-4059-47D4-ACE6-BE9C492DF205/ Snapchat.app/Frameworks/Cronet.framework/Cronet (0x0000000105920000)</span><br><span class="line">(lldb) memory read --force --outfile ~/Desktop/dumpoutput --binary count 3309568 16384+0x0000000105920000</span><br><span class="line">因为dump出来的文件都没有Mach-0文件头，所以在这里要先把dump出来的数据写回原 来加密的文件，以替换原来加密的部分</span><br><span class="line">2768896(之前获取的ARM64架构的偏移值)+16384(加密数据的偏移值)=2785280(写入的加密数据在文件中的偏移值)</span><br><span class="line">seek=n   Seek n blocks from the beginning of the output before copying.</span><br><span class="line">bs=n     Set both input and output block size to n bytes</span><br><span class="line">conv=value[,value ...]</span><br><span class="line">	notrunc  Do not truncate the output file.</span><br><span class="line">Cronet.framework git:(master) X dd seek=2785280 bs=l conv=notrunc if=/Users/monkey/Desktop/dumpoutput of=./Cronet</span><br><span class="line">3309568+0 records in</span><br><span class="line">3309568+0 records out</span><br><span class="line">3309568 bytes transferred in 4.698067 secs (704453 bytes/sec)</span><br><span class="line">Cronet.framework git:(master) X lipo Cronet -thin arm64 -output Cronet_arm64</span><br><span class="line">MachOView.app 修改Cronet_arm64 crypid 为0</span><br></pre></td></tr></table></figure>
<h3 id="查询按钮事件"><a href="#查询按钮事件" class="headerlink" title="查询按钮事件"></a>查询按钮事件</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">error: error: use of undeclared identifier &apos;UIApplication&apos;</span><br><span class="line">None</span><br><span class="line">(lldb) expression @import UIKit</span><br><span class="line">pviews</span><br><span class="line">   |    |    |    |    |    |    |    |    |    | &lt;UIButtonLabel: 0x101c730a0; frame = (7.5 12.5; 69.5 20.5); text = &apos;所有图书&apos;; opaque = NO; userInteractionEnabled = NO; layer = &lt;_UILabelLayer: 0x174295a90&gt;&gt;</span><br><span class="line">   |    |    |    |    |    |    |    |    |    |    | &lt;_UILabelContentLayer: 0x170425fa0&gt; (layer)</span><br><span class="line">   |    |    |    |    |    |    |    |    | &lt;IMTouchInsetsButton: 0x101c73f60; baseClass = UIButton; frame = (324 5.5; 35 33); opaque = NO; layer = &lt;CALayer: 0x17422d880&gt;&gt;</span><br><span class="line">   |    |    |    |    |    |    |    |    |    | &lt;UIButtonLabel: 0x101c31460; frame = (9 6.5; 35 20.5); text = &apos;选择&apos;; opaque = NO; userInteractionEnabled = NO; layer = &lt;_UILabelLayer: 0x174295360&gt;&gt;</span><br><span class="line"></span><br><span class="line">查看 “登录”按钮UIButtonLabel的响应链</span><br><span class="line">presponder 0x101c31460</span><br><span class="line">(lldb) presponder 0x101c31460</span><br><span class="line">&lt;UIButtonLabel: 0x101c31460; frame = (9 6.5; 35 20.5); text = &apos;选择&apos;; opaque = NO; userInteractionEnabled = NO; layer = &lt;_UILabelLayer: 0x174295360&gt;&gt;</span><br><span class="line">   | &lt;IMTouchInsetsButton: 0x101c73f60; baseClass = UIButton; frame = (324 5.5; 35 33); opaque = NO; layer = &lt;CALayer: 0x17422d880&gt;&gt;</span><br><span class="line">   |    | &lt;IMToolbar: 0x101c1d8b0; baseClass = UIToolbar; frame = (0 20; 375 44); opaque = NO; autoresize = W; tintColor = UIExtendedSRGBColorSpace 0 0.478431 1 1; layer = &lt;CALayer: 0x174224ec0&gt;&gt;</span><br><span class="line">查看“登录”按钮的Action事件</span><br><span class="line">(lldb) pactions 0x101c73f60</span><br><span class="line">&lt;BKLibraryViewController: 0x102817600&gt;: editButtonPressed:</span><br></pre></td></tr></table></figure>
<h3 id="chisel-打印结构"><a href="#chisel-打印结构" class="headerlink" title="chisel 打印结构"></a>chisel 打印结构</h3><p>brew install chisel –verbose</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt; NSMallocBlock : 0Xl7444b6d0&gt;</span><br><span class="line">(lldb) pblock 0xl7444b6d0</span><br><span class="line"></span><br><span class="line">(lldb) pvc</span><br><span class="line">&lt;ICSplitViewController 0x10079eab0&gt;, state: appeared, view: &lt;UILayoutContainerView 0x1009261c0&gt;</span><br><span class="line">   | &lt;UIMultiColumnViewController 0x10079f410&gt;, state: appeared, view: &lt;UIView 0x1007aee70&gt;</span><br><span class="line"></span><br><span class="line">(lldb) methods 0x10079eab0</span><br><span class="line">&lt;ICSplitViewController: 0x10079eab0&gt;:</span><br><span class="line">in ICSplitViewController:</span><br><span class="line">	Properties:</span><br><span class="line">		@property (nonatomic, getter=isDetailDimmed) BOOL detailDimmed;  (@synthesize detailDimmed = _detailDimmed;)</span><br></pre></td></tr></table></figure>
<h4 id="对象查找"><a href="#对象查找" class="headerlink" title="对象查找"></a>对象查找</h4><p>fv    用正则查找所有类的 view 实例<br>fvc    用正则查找所有类的 view controller 实例<br>findinstances    在内存中查找某个类的所有实例<br>flicker    闪烁某个 view，用于快速定位</p>
<h4 id="对象分析"><a href="#对象分析" class="headerlink" title="对象分析"></a>对象分析</h4><p>pinternals    打印对象内部的所有实例变量<br>pkp    用 -valueForKeyPath:获取对象的数据<br>pmethods    打印类的所有方法<br>poobjc    用 ObjC++ 语言执行和获取表达式的结果，expression -O -l ObjC++ —的缩写<br>pproperties    打印对象或者类的属性<br>pivar    打印对象的某个 ivar<br>wivar    给对象的某个实例变量地址设置 watchpoint，监控变化<br>pclass    打印某个对象的类继承链<br>pbcopy    打印对象并且把结果复制到粘贴板<br>pblock    打印 block 的实现函数地址和签名<br>pactions    打印 UIControl 的 target 和 action</p>
<h4 id="断点"><a href="#断点" class="headerlink" title="断点"></a>断点</h4><p>bdisable    用正则查找并关闭一组断点<br>benable    用正则查找并开启一组断点<br>binside    用相对地址设置断点，自动加上 ALSR 偏移<br>bmessage    给某个类的 method 设置断点，同时会在其父类上查找 method<br>pinvocation    打印方法调用堆栈，仅支持x86</p>
<h4 id="视图查找"><a href="#视图查找" class="headerlink" title="视图查找"></a>视图查找</h4><p>visualize    显示 UIImage, CGImageRef, UIView 或 CALayer 的图片内容，用 Mac 的预览打开，在调试绘图时非常有用<br>taplog    打印触摸到的 view，用于快速定位<br>border    给 view 加上边框，用于定位某个 view 对象<br>unborder    移除 view 或 layer 的边框<br>caflush    修改 UI 后刷新 Core Animation 界面<br>hide    隐藏 view 或 layer<br>show    显示一个 view 或者 layer，相当于执行view.hidden = NO<br>mask    给 view 添加半透明的 mask，可以用来查找被隐藏的 view<br>unmask    移除 view layer 的 mask<br>setinput    给作为 first responder 的 text field 或 text view 输入文本<br>slowanim    减慢动画速度<br>unslowanim    动画速度回复正常<br>present    Present 一个 view controller<br>dismiss    消除 present 出来的 view controller</p>
<h4 id="视图层级"><a href="#视图层级" class="headerlink" title="视图层级"></a>视图层级</h4><p>pvc    循环打印 view controller 的层级<br>pviews    循环打印 view 的层级<br>pca    打印 layer 树<br>vs    在 view 层级中搜索 view<br>ptv    打印最顶层的 table view<br>pcells    打印最顶层 table view 的所有可见的 cell<br>presponder    打印 UIResponder 响应者链</p>
<h4 id="其他工具"><a href="#其他工具" class="headerlink" title="其他工具"></a>其他工具</h4><p>sequence    执行多条命令，用;分隔<br>pjson    打印 NSDictionary 或 NSArray 的 JSON 格式<br>pcurl    用 curl 的格式显示 NSURLRequest (HTTP)<br>pdata    用字符串的形式显示 NSData<br>mwarning    模拟内存警告</p>
<h4 id="视图调试"><a href="#视图调试" class="headerlink" title="视图调试"></a>视图调试</h4><p>alamborder    给有约束错误的 view 加上边框<br>alamunborder    有约束错误的 view 加上边框<br>paltrace    打印 view 的约束信息，相当于调用_autolayoutTrace<br>panim    是否正在执行动画，相当于调用[UIView _isInAnimationBlock]</p>
<h3 id="NSObject私有方法，可以方便查看对象的内容："><a href="#NSObject私有方法，可以方便查看对象的内容：" class="headerlink" title="NSObject私有方法，可以方便查看对象的内容："></a>NSObject私有方法，可以方便查看对象的内容：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">_methodDescription：打印对象或者类的整个继承链上的方法列表，同时显示方法的地址，可以直接用于断点</span><br><span class="line">_shortMethodDescription ：打印对象或者类的方法列表，不显示父类</span><br><span class="line">_ivarDescription：打印对象或者类的所有实例变量和值</span><br></pre></td></tr></table></figure>
<h3 id="搜索UITextField的实例对象和Cycript中的choose—样的"><a href="#搜索UITextField的实例对象和Cycript中的choose—样的" class="headerlink" title="搜索UITextField的实例对象和Cycript中的choose—样的"></a>搜索UITextField的实例对象和Cycript中的choose—样的</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">search UIButton</span><br><span class="line">search UITextField</span><br><span class="line"># Find all UIViews, ignore subclasses</span><br><span class="line">find UIView  -e</span><br><span class="line"></span><br><span class="line"># Find all instances of UIViews (and subclasses) where tag == 5</span><br><span class="line">find UIView -c &quot;[obj tag] == 5&quot;</span><br></pre></td></tr></table></figure>
<h3 id="读取内存"><a href="#读取内存" class="headerlink" title="读取内存"></a>读取内存</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">memory read --size 4 --format x --count 4 0xbffff3c0</span><br><span class="line">me r -s4 -fx -c4 0xbffff3c0</span><br></pre></td></tr></table></figure>
<h3 id="查看对象内存关系-xcode观看"><a href="#查看对象内存关系-xcode观看" class="headerlink" title="查看对象内存关系,xcode观看"></a>查看对象内存关系,xcode观看</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/Applications/Xcode.app/Contents/SharedFrameworks/LLDB.framework/Versions/A/Resources/Python/lldb/macosx/heap.py</span><br><span class="line">command alias iheap command script import lldb.macosx.heap</span><br><span class="line">&quot;malloc_info&quot;, &quot;ptr_refs&quot;, &quot;cstr_refs&quot;, &quot;find_variable&quot;, and &quot;objc_refs&quot;</span><br><span class="line"></span><br><span class="line">ptr_refs</span><br><span class="line">可以在内存中找出哪些地址引用了某个指针，也就相当于查看某个变量在哪里被引用。</span><br><span class="line"></span><br><span class="line">cstr_refs</span><br><span class="line">在内存中寻找某个C String在哪里被引用。</span><br><span class="line"></span><br><span class="line">find_variable</span><br><span class="line">在当前栈帧上寻找某个局部变量在哪里被引用。</span><br><span class="line"></span><br><span class="line">objc_refs</span><br><span class="line">在内存中寻找某个类的实例。</span><br><span class="line"></span><br><span class="line">为了查看某个对象内存分配的调用堆栈，需要在程序启动的环境变量中设置 MallocSlack Logging。</span><br><span class="line">在环境变量中增加 MallocStackLogging 的值1</span><br><span class="line">单击Xcode调试工具栏上的“Debug Momery Graph”按钮</span><br><span class="line"></span><br><span class="line">malloc_info --stack-history 0x10010d680。可以快速追溯对象的创建来源，</span><br><span class="line">参考iOS逆向：在任意app上开启malloc stack追踪内存来源</span><br><span class="line">https://www.jianshu.com/p/759015369b6f</span><br><span class="line">lldb有一个内存调试工具malloc stack，开启以后就可以查看某个内存地址的malloc和free记录，追踪对象是在哪里创建的。</span><br><span class="line"></span><br><span class="line">这个工具可以打印出对象创建的堆栈，而在逆向时，也经常需要追踪某些方法的调用栈，如果可以随时打印出某个对象的创建记录，也就能直接找到其所在的类和方法，不用再花费大量的时间去打log和动态调试追踪了。</span><br></pre></td></tr></table></figure>
<h3 id="执行script"><a href="#执行script" class="headerlink" title="执行script"></a>执行script</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(lldb) e @import UIKit</span><br><span class="line">(lldb) e UIApplication *$app = [UIApplication sharedApplication];</span><br><span class="line">(lldb) e UlWindow *$keyWindow = $app.keyWindow</span><br><span class="line">(lldb) e UlViewController *$root = $keyWindow.rootViewController</span><br><span class="line">(lldb) po $root</span><br><span class="line">&lt;NavigationController: 0xl2c03d200&gt;</span><br><span class="line">(lldb) e [(SCButton *)0xl2bd4b760 setTitle:@&quot;AloneMonkey&quot; forStaterUIControlStateNormal]</span><br><span class="line">(lldb) e (void)[CATransaction flush]</span><br><span class="line">(lldb) c</span><br></pre></td></tr></table></figure>
<h3 id="在-Snapchat模块中查看与login有关的符号信息"><a href="#在-Snapchat模块中查看与login有关的符号信息" class="headerlink" title="在 Snapchat模块中查看与login有关的符号信息"></a>在 Snapchat模块中查看与login有关的符号信息</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">image lookup -rn login UserLogin</span><br><span class="line"></span><br><span class="line">(lldb) b -[UIView setTail:]</span><br><span class="line">Breakpoint 3: where = UserLogin`-[UIView(Frame) setTail:] at UIView+Frame.m:102, address = 0x0000000100b5ee34</span><br><span class="line">(lldb) il 0x0000000100b5ee34</span><br><span class="line">image lookup -a 0x0000000100b5ee34</span><br></pre></td></tr></table></figure>
<h3 id="某个类的所有方法下断点并跟踪打印调用参数"><a href="#某个类的所有方法下断点并跟踪打印调用参数" class="headerlink" title="某个类的所有方法下断点并跟踪打印调用参数"></a>某个类的所有方法下断点并跟踪打印调用参数</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">command regex bclass &apos;s/(.+)/rb \[%1 /&apos;</span><br><span class="line">rb -&gt; breakpoint set -r %1</span><br><span class="line">bclass ULLoginViewController -&gt; breakpoint set -r \[ULLoginViewController</span><br><span class="line"></span><br><span class="line">br set -r &apos;\[WAChatSessionViewController .*\]&apos;</span><br><span class="line"></span><br><span class="line">如果不在MethodTraCeCcmflg.PliSt文件里面配置需要跟踪的类，那么如下设置:</span><br><span class="line">@interface MethodTrace : NSObject</span><br><span class="line">+ (void)addClassTrace:(NSString*) className;</span><br><span class="line">+ (void)addClassTrace: (NSString *)className methodName: (NSString*) methodName;</span><br><span class="line">+ (void)addClassTrace: (NSString *)className methodList: (NSArray*) methodList;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">e [MethodTrace addClassTrace:@&quot;WAChatDataStore&quot;]</span><br><span class="line">笔者在MethodTrace的代码里面调试了—下，发现 NSLog没有被输出到Xcode的控制台，但是在Console.app里面可以看到NSLog,所以改用printf来输出。</span><br><span class="line">ENABLE_METHODTRACE</span><br></pre></td></tr></table></figure>
<h3 id="xcode-设置环境变量"><a href="#xcode-设置环境变量" class="headerlink" title="xcode 设置环境变量"></a>xcode 设置环境变量</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">打印参数和当前的环境变量, segment加载的详细信息,加载dylib,显示是否加载,各阶段的时间消耗</span><br><span class="line">xcode  DYLD_PRINT_OPTS, DYLD_PRINT_EN, DYLD_PRINT_SEGMENTS</span><br><span class="line"></span><br><span class="line">签名InsertDyUb.dylib,拷贝 InsertDylib.dylib 到Bundle Resources</span><br><span class="line">xcode  设置环境变量DYLD_INSERT_LIBRARIES @executable_path/InsertDylib.dylib</span><br><span class="line"></span><br><span class="line">xcode  设置环境变量 DYLD_PRINT_INTERPOSING 运行 App,日志如下即为hook生效</span><br><span class="line">dyld: interposing 2 tuples onto image: /var/containers/Bundle/Application/AB57C532-19F2-4022-B757-7D211296E64D/AppStart.app/InsertDylib.dylib</span><br><span class="line"></span><br><span class="line">xcode 设置 DYLD_PRINT_STATISTICS,DYLD_PRINT_STATISTICS_DETAILS 打印各阶段的时间消耗。</span><br><span class="line"></span><br><span class="line">@executable_path:表示可执行程序所在的目录，一般是xxx.app</span><br><span class="line">@loader_path:表示每一个被加载的二进制文件的目录。例如，xxxx.plugin/aaa/abc依赖xxx.plugin/bb/ccc.dylib,那么依赖的路径可以写成 @loader_path/../bbb. 这样不管xxx.plugin放在那都能找到ccc.dylib</span><br><span class="line">@rpath:这个变量是在 Xcode build里面设置， Dynamic Libray Install Name设置为(#=@path/xxx/xxx,就可以在使用的工程中设置一个或多个RunPath Search Paths 来指定搜索路径。在运行时，会将@rpath分别替换为Runpath Search Paths中指定的路径来査找动态库。</span><br></pre></td></tr></table></figure>

<h3 id="iOS-分析常见点"><a href="#iOS-分析常见点" class="headerlink" title="iOS 分析常见点"></a>iOS 分析常见点</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">handleLongPressAtPoint函数就是用于处理长按事件的函数</span><br><span class="line">第一响应者实现 canPerformAction:withSender: 来确定当前哪些操 作是被允许的、哪些操作是不被允许的。</span><br></pre></td></tr></table></figure>
<h2 id="macos"><a href="#macos" class="headerlink" title="macos"></a>macos</h2><p>查询相关 dash lldb3:<br>记录一些常用的点,基本可以用于iOS 或其他</p>
<h3 id="调试开启配置"><a href="#调试开启配置" class="headerlink" title="调试开启配置"></a>调试开启配置</h3><h4 id="wait-for-pid"><a href="#wait-for-pid" class="headerlink" title="wait for pid"></a>wait for pid</h4><p>This will tell LLDB to attach to the process named Finder whenever it next launches.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lldb -n Finder -w</span><br><span class="line">process attach --name &quot;Finder&quot; --waitfor</span><br></pre></td></tr></table></figure>
<h4 id="直接调试启动"><a href="#直接调试启动" class="headerlink" title="直接调试启动"></a>直接调试启动</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lldb -f /bin/ls</span><br><span class="line">process launch</span><br></pre></td></tr></table></figure>
<h4 id="将Speech框架加载到DeleteMe流程空间"><a href="#将Speech框架加载到DeleteMe流程空间" class="headerlink" title="将Speech框架加载到DeleteMe流程空间"></a>将Speech框架加载到DeleteMe流程空间</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(lldb) process load /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk//System/Library/Frameworks/Speech.framework/Speech</span><br></pre></td></tr></table></figure>

<h4 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h4><h5 id="Disabling-Rootless"><a href="#Disabling-Rootless" class="headerlink" title="Disabling Rootless"></a>Disabling Rootless</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Command + R,start your macOS machine.</span><br><span class="line">csrutil disable &amp;&amp; reboot</span><br></pre></td></tr></table></figure>
<h4 id="w工作目录"><a href="#w工作目录" class="headerlink" title="-w工作目录"></a>-w工作目录</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">选项在哪里启动来更改当前的工作目录。输入以下内容：</span><br><span class="line">(lldb) process launch -w /Applications</span><br></pre></td></tr></table></figure>
<h4 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h4><p>(lldb) process launch -v LSCOLORS=Af -v CLICOLOR=1  – /Applications/</p>
<h4 id="设置新目标"><a href="#设置新目标" class="headerlink" title="设置新目标"></a>设置新目标</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(lldb) target delete</span><br><span class="line">(lldb) target create /usr/bin/wc</span><br></pre></td></tr></table></figure>
<h3 id="调试常见断点相关"><a href="#调试常见断点相关" class="headerlink" title="调试常见断点相关"></a>调试常见断点相关</h3><h4 id="Finding-a-class-with-a-click"><a href="#Finding-a-class-with-a-click" class="headerlink" title="Finding a class with a click"></a>Finding a class with a click</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(lldb) b -[NSView hitTest:]</span><br><span class="line">Breakpoint 1: where = AppKit`-[NSView hitTest:], address = 0x000000010338277b</span><br><span class="line"></span><br><span class="line">breakpoint set -n  &quot;-[NSView hitTest:]&quot; -C &quot;real&quot; -G1</span><br><span class="line"></span><br><span class="line">b -[NSResponder mouseUp:]</span><br></pre></td></tr></table></figure>
<h4 id="Filter-breakpoints-for-important-content"><a href="#Filter-breakpoints-for-important-content" class="headerlink" title="Filter breakpoints for important content"></a>Filter breakpoints for important content</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">breakpoint modify -c &apos;(BOOL)[NSStringFromClass((id)[$rdi class]) containsString:@&quot;IDESourceEditorView&quot;]&apos; -G0</span><br><span class="line">最后-G0说的是修改断点，使其在执行动作后不会自动恢复执行。</span><br><span class="line"></span><br><span class="line">(lldb) breakpoint set -n &quot;-[UIViewController viewDidLoad]&quot; -C &quot;po $arg1&quot; -G1</span><br><span class="line">-G1选项告诉断点在执行命令后自动继续。</span><br></pre></td></tr></table></figure>
<h4 id="在模块下断"><a href="#在模块下断" class="headerlink" title="在模块下断"></a>在模块下断</h4><p>(lldb) rb appendSignal.*_block_invoke -s Commons</p>
<h3 id="打印相关"><a href="#打印相关" class="headerlink" title="打印相关"></a>打印相关</h3><h4 id="设置后刷新"><a href="#设置后刷新" class="headerlink" title="设置后刷新"></a>设置后刷新</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">po [$rdi setHidden:!(BOOL)[$rdi isHidden]]; [CATransaction flush]</span><br></pre></td></tr></table></figure>
<h4 id="输出模块中的函数"><a href="#输出模块中的函数" class="headerlink" title="输出模块中的函数"></a>输出模块中的函数</h4><p>(lldb) image lookup -rn _block_invoke Commons</p>
<h3 id="调试函数单步相关"><a href="#调试函数单步相关" class="headerlink" title="调试函数单步相关"></a>调试函数单步相关</h3><h4 id="步入无符号"><a href="#步入无符号" class="headerlink" title="步入无符号"></a>步入无符号</h4><p>(lldb) step -a0<br>This tells LLDB to step in regardless of whether you have the required debug symbols or not.</p>
<h4 id="pdb调试"><a href="#pdb调试" class="headerlink" title="pdb调试"></a>pdb调试</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def your_first_command(debugger, command, result, internal_dict):</span><br><span class="line">    import pdb; pdb.set_trace()</span><br><span class="line">    print (&quot;hello world&quot;)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>tools</category>
        <category>lldb</category>
      </categories>
      <tags>
        <tag>lldb</tag>
        <tag>脚本</tag>
      </tags>
  </entry>
  <entry>
    <title>如何创建docset</title>
    <url>/2020/02/22/config/%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BAdocset/</url>
    <content><![CDATA[<ul>
<li><a href="#1-docset">1. docset</a><ul>
<li><a href="#11-%e9%98%85%e8%af%bb%e6%9c%ac%e7%af%87%e6%96%87%e7%ab%a0%e9%9c%80%e6%b1%82">1.1. 阅读本篇文章需求</a></li>
<li><a href="#12-%e4%bb%80%e4%b9%88%e6%98%afdocset">1.2. 什么是docset</a></li>
<li><a href="#13-%e5%93%aa%e9%87%8c%e5%8f%af%e4%bb%a5%e4%b8%8b%e8%bd%bddocset">1.3. 哪里可以下载docset</a></li>
<li><a href="#14-%e4%b8%ba%e4%bb%80%e4%b9%88%e8%a6%81%e8%87%aa%e5%b7%b1%e7%94%9f%e6%88%90docset">1.4. 为什么要自己生成docset</a></li>
<li><a href="#15-%e5%93%aa%e9%87%8c%e8%bd%af%e4%bb%b6%e6%94%af%e6%8c%81docset">1.5. 哪里软件支持docset</a><ul>
<li><a href="#151-dash">1.5.1. dash</a></li>
<li><a href="#152-%e7%b1%bb%e4%bc%bcdash%e7%9a%84%e5%b7%a5%e5%85%b7">1.5.2. 类似dash的工具</a></li>
<li><a href="#153-%e5%ae%98%e6%96%b9%e5%b7%a5%e5%85%b7%e6%94%af%e6%8c%81%e8%87%aa%e5%ae%9a%e4%b9%89docset">1.5.3. 官方工具支持自定义docset</a><ul>
<li><a href="#1531-doc2dash">1.5.3.1. doc2dash</a></li>
<li><a href="#1532-dash-docset-builder">1.5.3.2. dash-docset-builder</a></li>
</ul>
</li>
<li><a href="#154-%e5%ae%98%e6%96%b9%e6%89%8b%e5%8a%a8%e6%96%b9%e6%b3%95%e8%87%aa%e5%ae%9a%e4%b9%89docset">1.5.4. 官方手动方法自定义docset</a></li>
<li><a href="#155-%e8%87%aa%e5%ae%9a%e4%b9%89%e7%94%9f%e6%88%90docset">1.5.5. 自定义生成docset</a><ul>
<li><a href="#1551-%e8%8e%b7%e5%8f%96htm%e5%b9%b6%e7%94%9f%e6%88%90docset">1.5.5.1. 获取htm,并生成docset</a></li>
<li><a href="#1552-%e5%88%9b%e5%bb%ba%e7%b4%a2%e5%bc%95">1.5.5.2. 创建索引</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#16-%e6%80%bb%e7%bb%93">1.6. 总结</a></li>
</ul>
</li>
</ul>
<a id="more"></a>
<h1 id="1-docset"><a href="#1-docset" class="headerlink" title="1. docset"></a>1. docset</h1><h2 id="1-1-阅读本篇文章需求"><a href="#1-1-阅读本篇文章需求" class="headerlink" title="1.1. 阅读本篇文章需求"></a>1.1. 阅读本篇文章需求</h2><p>1.知道docset是什么，后面会介绍<br>2.知道dash 如何使用，或者知道怎么使用docset</p>
<h2 id="1-2-什么是docset"><a href="#1-2-什么是docset" class="headerlink" title="1.2. 什么是docset"></a>1.2. 什么是docset</h2><p><a href="https://kapeli.com/dash_guide" target="_blank" rel="noopener">https://kapeli.com/dash_guide</a><br>Documentation sets, or docsets, consist of collections of HTML files. Dash uses these docsets to store the docs you need. This section describes the various features Dash has to help you acquire and manange docsets.<br><a href="https://fileinfo.com/extension/docset" target="_blank" rel="noopener">https://fileinfo.com/extension/docset</a><br>What is a DOCSET file?<br>Developer file created by Doxygen, a source code documentation system; contains an archive of documentation about a body of source code, which can encompass many different individual source code files and code constructs; used as the storage format for publishing documentation to developers that use the source code.</p>
<h2 id="1-3-哪里可以下载docset"><a href="#1-3-哪里可以下载docset" class="headerlink" title="1.3. 哪里可以下载docset"></a>1.3. 哪里可以下载docset</h2><p>dash.app 可以直接下<br>Docsets can be downloaded Dash’s Preferences &gt; Downloads.</p>
<h2 id="1-4-为什么要自己生成docset"><a href="#1-4-为什么要自己生成docset" class="headerlink" title="1.4. 为什么要自己生成docset"></a>1.4. 为什么要自己生成docset</h2><p>想定制一些自己查询的文档，这些文档没有别人做好的docset可以下，能找到一些html,但如果每次都查询html又觉得麻烦，所以有了自定义docset的想法。</p>
<h2 id="1-5-哪里软件支持docset"><a href="#1-5-哪里软件支持docset" class="headerlink" title="1.5. 哪里软件支持docset"></a>1.5. 哪里软件支持docset</h2><h3 id="1-5-1-dash"><a href="#1-5-1-dash" class="headerlink" title="1.5.1. dash"></a>1.5.1. dash</h3><p>作为一名程序员，最离不开的就是文档了，大多数情况下我们都是通过文档了解一个陌生的领域。想象一下，打开了一堆文档，在文档中跳来跳去，多么的不优雅！所以Bogdan Popescu一怒之下开发了dash，解放了太多在文档中跳来跳去的码农。<br>自带大量常用文档(iOS/Mac/PHP/Python/Java等)<br>支持用户自定义文档(scrapy/requests/beautifulsoup等)<br>快速搜索文档及 API<br>管理和搜索代码片段<br>无缝插入众多第三方应用(Alfred/Xcode/Terminal等)<br><img src="./pic/73436.png" alt="73436.png"></p>
<h3 id="1-5-2-类似dash的工具"><a href="#1-5-2-类似dash的工具" class="headerlink" title="1.5.2. 类似dash的工具"></a>1.5.2. 类似dash的工具</h3><p><a href="https://doc2dash.readthedocs.io/en/latest/installation.html#viewer" target="_blank" rel="noopener">https://doc2dash.readthedocs.io/en/latest/installation.html#viewer</a><br>To view the results, you will need a docset viewer, the most commonly known being Dash.app for macOS.<br>Other alternatives have been developed in cooperation with Dash.app’s developer Kapeli:<br>helm-dash for Emacs,<br>velocity for Windows,<br>and zeal for Linux, macOS, and Windows.</p>
<h3 id="1-5-3-官方工具支持自定义docset"><a href="#1-5-3-官方工具支持自定义docset" class="headerlink" title="1.5.3. 官方工具支持自定义docset"></a>1.5.3. 官方工具支持自定义docset</h3><h4 id="1-5-3-1-doc2dash"><a href="#1-5-3-1-doc2dash" class="headerlink" title="1.5.3.1. doc2dash"></a>1.5.3.1. doc2dash</h4><p>Instructions on generating docsets can be found in the Docset Generation Guide.<br>doc2dash is an MIT-licensed extensible Documentation Set generator intended to be used with the Dash.app API browser for macOS or one of its many free clones for all relevant platforms.<br>If you’ve never heard of Dash.app and its likes, you’re missing out: together with doc2dash it’s all your API documentation at your fingertips – even when you’re offline!<br>doc2dash’s documentation lives at Read the Docs, the code on GitHub. It’s tested on Python 2.7, 3.4+, and PyPy. Both Linux and macOS are tested although certain features are only available on macOS.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd docs &amp;&amp; make html</span><br><span class="line">doc2dash html</span><br></pre></td></tr></table></figure>
<p>一些项目有规范的doc文档，可以用doc2dash 来生成docset.</p>
<h4 id="1-5-3-2-dash-docset-builder"><a href="#1-5-3-2-dash-docset-builder" class="headerlink" title="1.5.3.2. dash-docset-builder"></a>1.5.3.2. dash-docset-builder</h4><p>php写的，功能还是很全，但是不太会调<br><a href="https://github.com/godbout/dash-docset-builder" target="_blank" rel="noopener">https://github.com/godbout/dash-docset-builder</a></p>
<h3 id="1-5-4-官方手动方法自定义docset"><a href="#1-5-4-官方手动方法自定义docset" class="headerlink" title="1.5.4. 官方手动方法自定义docset"></a>1.5.4. 官方手动方法自定义docset</h3><p><a href="https://kapeli.com/docsets#copyDocumentation" target="_blank" rel="noopener">https://kapeli.com/docsets#copyDocumentation</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">13.1. Create the Docset Folder#</span><br><span class="line">The docset folder structure can be created using this Terminal command:</span><br><span class="line"></span><br><span class="line">mkdir -p &lt;docset name&gt;.docset/Contents/Resources/Documents/</span><br><span class="line">You can also manually create the docset structure if you want, they&apos;re just folders.</span><br><span class="line"></span><br><span class="line">13.2. Copy the HTML Documentation#</span><br><span class="line">Copy the HTML documentation you already have to this folder:</span><br><span class="line"></span><br><span class="line">&lt;docset name&gt;.docset/Contents/Resources/Documents/</span><br><span class="line">13.3. Create the Info.plist File#</span><br><span class="line">Download and edit this sample Info.plist and place it in the &lt;docset name&gt;.docset/Contents/ folder. Editing should be straightforward, just set the values to whatever name you want for your docset.</span><br><span class="line"></span><br><span class="line">13.4. Create the SQLite Index#</span><br><span class="line">Create a SQLite database in the file &lt;docset name&gt;.docset/Contents/Resources/docSet.dsidx with the following query:</span><br><span class="line"></span><br><span class="line">CREATE TABLE searchIndex(id INTEGER PRIMARY KEY, name TEXT, type TEXT, path TEXT);</span><br><span class="line">Recommended: you can easily prevent adding duplicate entries to the index by also using this query:</span><br><span class="line"></span><br><span class="line">CREATE UNIQUE INDEX anchor ON searchIndex (name, type, path);</span><br><span class="line">13.5. Populate the SQLite Index#</span><br><span class="line">You need to create a script (or application or whatever) that will go through your HTML documentation and add appropriate rows into the SQLite database. Rows can be added using this query:</span><br><span class="line"></span><br><span class="line">INSERT OR IGNORE INTO searchIndex(name, type, path) VALUES (&apos;name&apos;, &apos;type&apos;, &apos;path&apos;);</span><br><span class="line">The values are:</span><br><span class="line"></span><br><span class="line">name is the name of the entry. For example, if you are adding a class, it would be the name of the class. This is the column that Dash searches.</span><br><span class="line">type is the type of the entry. For example, if you are adding a class, it would be &quot;Class&quot;. For a list of types that Dash recognises, see below.</span><br><span class="line">path is the relative path towards the documentation file you want Dash to display for this entry. It can contain an anchor (#). Alternatively, Dash also supports http:// URL entries.</span><br><span class="line"></span><br><span class="line">You can find a few generation script examples here.</span><br><span class="line">[https://kapeli.com/docsets#scriptExamples](https://kapeli.com/docsets#scriptExamples)</span><br></pre></td></tr></table></figure>
<h3 id="1-5-5-自定义生成docset"><a href="#1-5-5-自定义生成docset" class="headerlink" title="1.5.5. 自定义生成docset"></a>1.5.5. 自定义生成docset</h3><p>因为别的方法无法具体实现想指定的dash xxx 搜索指令，不能很方便的扩展搜索方式，自己实现可以实现任意html生成dash 的方式</p>
<h4 id="1-5-5-1-获取htm-并生成docset"><a href="#1-5-5-1-获取htm-并生成docset" class="headerlink" title="1.5.5.1. 获取htm,并生成docset"></a>1.5.5.1. 获取htm,并生成docset</h4><p>使用dash 代码片段生成得到指定网页的html,并生成docset格式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line">wget --recursive \</span><br><span class="line">  --html-extension \</span><br><span class="line">  --convert-links \</span><br><span class="line">  --domains ~_~lldb.llvm.org~_~ \</span><br><span class="line">  --restrict-file-names=windows \</span><br><span class="line">  --page-requisites \</span><br><span class="line">  --reject pdf \</span><br><span class="line">  --no-parent ~_~lldb.llvm.org~_~/~_~arm~_~.html</span><br><span class="line"></span><br><span class="line">if [ -d &quot;~_~arm~_~.docset&quot; ]; then</span><br><span class="line">    echo &quot;~_~arm~_~.docset exitst, please delete it&quot;</span><br><span class="line">    return</span><br><span class="line">fi</span><br><span class="line">contents=~_~arm~_~.docset/Contents</span><br><span class="line">res=$contents/Resources</span><br><span class="line">doc=$res/Documents</span><br><span class="line">mkdir -p $doc</span><br><span class="line">cp frida.png ~_~arm~_~.docset/icon.png</span><br><span class="line">mv ~_~arm~_~.html $doc</span><br><span class="line"></span><br><span class="line">rm $res/docSet.dsidx</span><br><span class="line"></span><br><span class="line">cat &gt; $contents/Info.plist &lt;&lt;- &quot;EOF&quot;</span><br><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE plist PUBLIC &quot;-//Apple//DTD PLIST 1.0//EN&quot; &quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;&gt;</span><br><span class="line">&lt;plist version=&quot;1.0&quot;&gt;</span><br><span class="line">&lt;dict&gt;</span><br><span class="line">  &lt;key&gt;CFBundleIdentifier&lt;/key&gt;</span><br><span class="line">  &lt;string&gt;~_~arm~_~&lt;/string&gt;</span><br><span class="line">  &lt;key&gt;CFBundleName&lt;/key&gt;</span><br><span class="line">  &lt;string&gt;~_~arm~_~&lt;/string&gt;</span><br><span class="line">  &lt;key&gt;DocSetPlatformFamily&lt;/key&gt;</span><br><span class="line">  &lt;string&gt;~_~arm~_~&lt;/string&gt;</span><br><span class="line">  &lt;key&gt;dashIndexFilePath&lt;/key&gt;</span><br><span class="line">  &lt;string&gt;~_~arm~_~.html&lt;/string&gt;</span><br><span class="line">  &lt;key&gt;isDashDocset&lt;/key&gt;</span><br><span class="line">  &lt;true/&gt;</span><br><span class="line">&lt;/dict&gt;</span><br><span class="line">&lt;/plist&gt;</span><br><span class="line">EOF</span><br><span class="line">echo &apos;done&apos;</span><br></pre></td></tr></table></figure>
<h4 id="1-5-5-2-创建索引"><a href="#1-5-5-2-创建索引" class="headerlink" title="1.5.5.2. 创建索引"></a>1.5.5.2. 创建索引</h4><p>如以下代码创建了 radare2 这个工具的html的docset<br><img src="./pic/355453.png" alt="355453.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import sqlite3</span><br><span class="line"></span><br><span class="line">from pathlib import Path</span><br><span class="line">from bs4 import BeautifulSoup</span><br><span class="line"></span><br><span class="line"># CREATE TABLE searchIndex(id INTEGER PRIMARY KEY, name TEXT, type TEXT, path TEXT);</span><br><span class="line"># CREATE UNIQUE INDEX anchor ON searchIndex (name, type, path);</span><br><span class="line"># INSERT OR IGNORE INTO searchIndex(name, type, path) VALUES (&apos;Exploit&apos;, &apos;Class&apos;, &apos;index.html&apos;);</span><br><span class="line">respath=&quot;~_~arm~_~.docset/Contents/Resources&quot;</span><br><span class="line">conn = sqlite3.connect(&apos;&#123;&#125;/docSet.dsidx&apos;.format(respath))</span><br><span class="line">conn.executescript(&apos;&apos;&apos;</span><br><span class="line">    CREATE TABLE IF NOT EXISTS searchIndex(id INTEGER PRIMARY KEY, name TEXT, type TEXT, path TEXT);</span><br><span class="line">    CREATE UNIQUE INDEX IF NOT EXISTS anchor ON searchIndex (name, type, path);&apos;&apos;&apos;)</span><br><span class="line"></span><br><span class="line">def insert(*args):</span><br><span class="line">    conn.execute(&apos;&apos;&apos;INSERT OR IGNORE INTO searchIndex(name, type, path) VALUES (?, ?, ?);&apos;&apos;&apos;, args)</span><br><span class="line"></span><br><span class="line">filename=&quot;&#123;&#125;/Documents/~_~arm~_~.html&quot;.format(respath)</span><br><span class="line">with open(filename) as fp:</span><br><span class="line">    html = fp.read()</span><br><span class="line">print(&quot;filename=&#123;&#125;&quot;.format(filename))</span><br><span class="line">soup = BeautifulSoup(html)</span><br><span class="line"></span><br><span class="line">relpath = str(Path(filename).relative_to(&quot;&#123;&#125;/Documents&quot;.format(respath)))</span><br><span class="line"></span><br><span class="line"># Rax2 1.12.1</span><br><span class="line"># Rafind2 1.12.2</span><br><span class="line"># Rarun2 1.12.3</span><br><span class="line"># Rabin2 1.12.4</span><br><span class="line"># Radiff2 1.12.5</span><br><span class="line"># Rasm2 1.12.6</span><br><span class="line"># Ragg2 1.12.7</span><br><span class="line"># Rahash2 1.12.8</span><br><span class="line"></span><br><span class="line">type = &quot;Method&quot;</span><br><span class="line"></span><br><span class="line">for subtitle in soup.select(&quot;a&quot;):</span><br><span class="line">    if not subtitle:</span><br><span class="line">        break</span><br><span class="line">    if subtitle == &quot;\n&quot;:</span><br><span class="line">        continue</span><br><span class="line">    if subtitle.text != &quot;Rax2&quot; and subtitle.text != &quot;Rafind2&quot; and subtitle.text != &quot;Rarun2&quot; \</span><br><span class="line">            and subtitle.text != &quot;Rabin2&quot; and subtitle.text != &quot;Radiff2&quot; and subtitle.text != &quot;Rasm2&quot;\</span><br><span class="line">            and subtitle.text != &quot;Ragg2&quot; and subtitle.text != &quot;Rahash2&quot;:</span><br><span class="line">        continue</span><br><span class="line"></span><br><span class="line">    name = subtitle.text</span><br><span class="line">    # path=&apos;%s#%s&apos; % (relpath, name)</span><br><span class="line">    path=&quot;&#123;&#125;&#123;&#125;&quot;.format(relpath,subtitle[&quot;href&quot;].lower())</span><br><span class="line">    print(&quot;&#123;&#125;\t\t&#123;&#125;\t\t&#123;&#125;&quot;.format(name,type,path))</span><br><span class="line">    insert(name, type, path)</span><br><span class="line"></span><br><span class="line">conn.commit()</span><br><span class="line">conn.close()</span><br></pre></td></tr></table></figure>
<h2 id="1-6-总结"><a href="#1-6-总结" class="headerlink" title="1.6. 总结"></a>1.6. 总结</h2><p>1.遇到问题多看官网，官网有解决办法，不用你老人家瞎琢磨耽误时间<br>2.看文档细心。</p>
]]></content>
      <categories>
        <category>tools</category>
        <category>dash</category>
      </categories>
      <tags>
        <tag>docset</tag>
        <tag>dash</tag>
      </tags>
  </entry>
</search>
