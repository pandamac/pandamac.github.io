<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.0.0-rc2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"pandamac.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"appID":"F8APJ8E550","apiKey":"d050e8704a1173bb5f72414e4300eed1","indexName":"pandamac","hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":3,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="[TOC]">
<meta property="og:type" content="article">
<meta property="og:title" content="总结_AFL源码学习">
<meta property="og:url" content="http://pandamac.github.io/2023/07/30/%E6%80%BB%E7%BB%93_AFL%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/index.html">
<meta property="og:site_name" content="pandamac&#39;s Note">
<meta property="og:description" content="[TOC]">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-07-22-145348.jpg">
<meta property="og:image" content="http://pandamac.github.io/%E6%80%BB%E7%BB%93_AFL%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/310c793b6254093e2ef21453329ccad2.png">
<meta property="og:image" content="http://pandamac.github.io/%E6%80%BB%E7%BB%93_AFL%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/b467dff7c08b41e961127222e7ea975d.png">
<meta property="article:published_time" content="2023-07-30T08:18:37.000Z">
<meta property="article:modified_time" content="2023-08-23T08:59:49.385Z">
<meta property="article:author" content="pandamac">
<meta property="article:tag" content="fuzzing">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-07-22-145348.jpg">

<link rel="canonical" href="http://pandamac.github.io/2023/07/30/%E6%80%BB%E7%BB%93_AFL%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>总结_AFL源码学习 | pandamac's Note</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="pandamac's Note" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">pandamac's Note</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-sitemap">

    <a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>站点地图</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://pandamac.github.io/2023/07/30/%E6%80%BB%E7%BB%93_AFL%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="pandamac">
      <meta itemprop="description" content="Android/iOS/Macos">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="pandamac's Note">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          总结_AFL源码学习
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-07-30-16:18 16:18:37" itemprop="dateCreated datePublished" datetime="2023-07-30T16:18:37+08:00">2023-07-30-16:18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-08-23-16:59 16:59:49" itemprop="dateModified" datetime="2023-08-23T16:59:49+08:00">2023-08-23-16:59</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/fuzzing/" itemprop="url" rel="index"><span itemprop="name">fuzzing</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>[TOC]</p>
<span id="more"></span>

<h1 id="总结-AFL源码学习"><a href="#总结-AFL源码学习" class="headerlink" title="总结_AFL源码学习"></a>总结_AFL源码学习</h1><h2 id="简要"><a href="#简要" class="headerlink" title="简要"></a>简要</h2><ul>
<li>本文用于分析AFL源码，之前用了xmind, 感觉太杂了，本来想用OmniGraffle,但感觉还是差不多<ul>
<li>xmind 和 OmniGraffle 适合整理思路，不适合</li>
</ul>
</li>
<li>用例子学习 [[总结_fuzzing101_例子]]</li>
</ul>
<h2 id="创建cmakelists-txt方便vscode调试"><a href="#创建cmakelists-txt方便vscode调试" class="headerlink" title="创建cmakelists.txt方便vscode调试"></a>创建cmakelists.txt方便vscode调试</h2><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.4</span>)</span><br><span class="line"><span class="keyword">project</span>(afl-fuzz)</span><br><span class="line"><span class="comment"># SET(CMAKE_C_COMPILER &quot;/usr/bin/clang&quot;)</span></span><br><span class="line"><span class="comment"># SET(CMAKE_CXX_COMPILER &quot;/usr/bin/clang++&quot;)</span></span><br><span class="line"><span class="keyword">SET</span>(CMAKE_C_COMPILER <span class="string">&quot;/usr/bin/gcc&quot;</span>)</span><br><span class="line"><span class="keyword">SET</span>(CMAKE_CXX_COMPILER <span class="string">&quot;/usr/bin/gcc++&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(CMAKE_EXPORT_COMPILE_COMMANDS <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(CMAKE_C_FLAGS <span class="string">&quot;$&#123;CMAKE_C_FLAGS&#125; -Wno-pointer-arith -funroll-loops -Wall -D_FORTIFY_SOURCE=2 -g -Wno-pointer-sign -DBIN_PATH=\\\&quot;/usr/local/bin\\\&quot;  -DAFL_PATH=\\\&quot;/usr/local/lib/afl\\\&quot; -DDOC_PATH=\\\&quot;/usr/local/share/doc/afl\\\&quot; &quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_FLAGS <span class="string">&quot;$&#123;CMAKE_C_FLAGS&#125; -Wno-pointer-arith -Wno-pointer-arith -funroll-loops -Wall -D_FORTIFY_SOURCE=2 -g -Wno-pointer-sign -fpermissive -funroll-loops -std=c++11 -w&quot;</span>)</span><br><span class="line"><span class="comment">#  -Wno-pointer-arith</span></span><br><span class="line"><span class="keyword">SET_SOURCE_FILES_PROPERTIES</span>(afl-fuzz.c PROPERTIES LANGUAGE C )</span><br><span class="line"><span class="keyword">add_executable</span>(afl-fuzz afl-fuzz.c)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(afl-fuzz <span class="variable">$&#123;CMAKE_DL_LIBS&#125;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">SET_SOURCE_FILES_PROPERTIES</span>(afl-gcc.c PROPERTIES LANGUAGE C )</span><br><span class="line"><span class="keyword">add_executable</span>(afl-gcc afl-gcc.c)</span><br><span class="line"></span><br><span class="line"><span class="keyword">target_link_libraries</span>(afl-gcc <span class="variable">$&#123;CMAKE_DL_LIBS&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">SET_SOURCE_FILES_PROPERTIES</span>(afl-as.c PROPERTIES LANGUAGE C )</span><br><span class="line"><span class="keyword">add_executable</span>(afl-as afl-as.c)</span><br><span class="line"></span><br><span class="line"><span class="keyword">target_link_libraries</span>(afl-as <span class="variable">$&#123;CMAKE_DL_LIBS&#125;</span>)</span><br><span class="line"><span class="comment"># cc -O3 -funroll-loops -Wall -D_FORTIFY_SOURCE=2 -g -Wno-pointer-sign -DAFL_PATH=\&quot;/usr/local/lib/afl\&quot; -DDOC_PATH=\&quot;/usr/local/share/doc/afl\&quot; -DBIN_PATH=\&quot;/usr/local/bin\&quot; afl-fuzz.c -o afl-fuzz -L/opt/homebrew/opt/zlib/lib</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cmake -G <span class="string">&#x27;Unix Makefiles&#x27;</span> -DCMAKE_BUILD_TYPE=Debug -B build_debug</span><br></pre></td></tr></table></figure>

<h2 id="afl-gcc-对源码插装"><a href="#afl-gcc-对源码插装" class="headerlink" title="afl-gcc-对源码插装"></a>afl-gcc-对源码插装</h2><h3 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h3><ul>
<li>[[总结_fuzzing101_例子#练习 1-Xpdf]]</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> LLVM_CONFIG=<span class="string">&quot;llvm-config-11&quot;</span></span><br><span class="line">CC=$HOME/Desktop/google_afl/afl-gcc CXX=$HOME/Desktop/google_afl/afl-g++ </span><br><span class="line"></span><br><span class="line">/home/wutang/Desktop/google_afl/afl-g++ -g -O2 -DHAVE_CONFIG_H -I.. -I. -c GHash.cc</span><br><span class="line">afl-cc <span class="number">2.57b</span> by &lt;lcamtuf@google.com&gt;</span><br><span class="line">cc_params : </span><br><span class="line">g++ -g -O2 -DHAVE_CONFIG_H -I.. -I. -c GHash.cc -B /home/wutang/Desktop/google_afl -g -O3 -funroll-loops -D__AFL_COMPILER=<span class="number">1</span> -DFUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION=<span class="number">1</span> </span><br><span class="line">over</span><br><span class="line">argv : </span><br><span class="line">/home/wutang/Desktop/google_afl/as -I .. -I . -<span class="number">-64</span> -o GHash.o /tmp/ccQVCI2H.s </span><br><span class="line">over</span><br><span class="line">afl-as <span class="number">2.57b</span> by &lt;lcamtuf@google.com&gt;</span><br><span class="line">[+] Instrumented <span class="number">435</span> <span class="built_in">locations</span> (<span class="number">64</span>-bit, non-hardened mode, ratio <span class="number">100</span>%).</span><br></pre></td></tr></table></figure>

<h3 id="main"><a href="#main" class="headerlink" title="main"></a>main</h3><ul>
<li>如果参数个数小于2（表示没有给出任何参数），则打印程序的用法信息，并退出程序</li>
<li>根据AFL_PATH环境变量，去构造afl-as路径。</li>
</ul>
<h3 id="find-as构造afl-as路径"><a href="#find-as构造afl-as路径" class="headerlink" title="find_as构造afl-as路径"></a>find_as构造afl-as路径</h3><h4 id="标记内存构造"><a href="#标记内存构造" class="headerlink" title="标记内存构造"></a>标记内存构造</h4><ul>
<li>申请内存 44 + ALLOC_OFF_HEAD(8) + 1&#x3D;53, <code>(((u32*)(_ptr))[-2])=0xFF00FF00</code>, <code>(((u32*)(_ptr))[-1]) = 44</code>, <code>(((u8*)(_ptr))[ALLOC_S(_ptr)])=0xF0</code></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">x/48xb 0x000055555555a2a0</span><br><span class="line">0x55555555a2a0: 0x00 0xff 0x00 0xff 0x2c 0x00 0x00 0x00 </span><br><span class="line"><span class="comment">#               0xFF00FF00          lenth</span></span><br><span class="line"></span><br><span class="line">0x55555555a2a8: 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00</span><br><span class="line">0x55555555a2b0: 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 </span><br><span class="line">0x55555555a2b8: 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 </span><br><span class="line">0x55555555a2c0: 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 </span><br><span class="line">0x55555555a2c8: 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00</span><br><span class="line">0x55555555a2d0: 0x00 0x00 0x00 0x00 0xf0</span><br></pre></td></tr></table></figure>

<ul>
<li>拷贝内存从 0x55555555a2a8 到 0xf0 前</li>
</ul>
<h3 id="edit-params"><a href="#edit-params" class="headerlink" title="edit_params"></a>edit_params</h3><ul>
<li>该函数用于处理传递给包装器的命令行参数，并根据参数设置各种编译器选项。</li>
<li>包装器获取参数, 构造命令行参数 cc_params</li>
<li>第一参数 遍历<code>argv[0]</code><ul>
<li>afl-clang<ul>
<li>获取环境变量 AFL_CC 作为第一参数</li>
</ul>
</li>
<li>afl-clang++<ul>
<li>获取环境变量 AFL_CXX 作为第一参数</li>
</ul>
</li>
<li>afl-g++<ul>
<li>获取环境变量 AFL_CXX 作为第一参数</li>
</ul>
</li>
<li>afl-g++</li>
<li>获取环境变量 AFL_CC 作为第一参数</li>
<li>afl-gcj<ul>
<li>获取环境变量 AFL_GCJ 作为第一参数</li>
</ul>
</li>
</ul>
</li>
<li>后续参数解析<ul>
<li><code>-fsanitize=address</code>or  <code>-fsanitize=memory</code><ul>
<li>asan_set&#x3D;1</li>
</ul>
</li>
<li><code>FORTIFY_SOURCE</code><ul>
<li>fortify_set&#x3D;1</li>
</ul>
</li>
<li>如果有环境变量 <code>AFL_HARDEN</code><ul>
<li><code>-fstack-protector-all</code></li>
<li>如果没设置了 fortify_set  设置 <code>-D_FORTIFY_SOURCE=2</code></li>
</ul>
</li>
<li>如果设置了 asan_set<ul>
<li>设置 AFL_USE_ASAN 1</li>
</ul>
</li>
<li>asan和 msan 和 AFL_HARDEN 不能同时指定</li>
<li>获取环境变量 <code>AFL_USE_ASAN</code><ul>
<li>设置 <code>-U_FORTIFY_SOURCE</code> <code>-fsanitize=address</code></li>
</ul>
</li>
<li>获取环境变量 <code>AFL_USE_MSAN</code><ul>
<li>设置 <code>-U_FORTIFY_SOURCE</code> <code>-fsanitize=memory</code></li>
</ul>
</li>
<li>如果没设置环境变量 <code>AFL_DONT_OPTIMIZE</code> 如果关闭就设置 <code>AFL_DONT_OPTIMIZE=1</code><ul>
<li>设置 <code>-g</code></li>
<li>最加上 <code>-O3</code> <code>-funroll-loops</code> <code>-D__AFL_COMPILER=1</code> <code>-DFUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION=1</code></li>
</ul>
</li>
</ul>
</li>
<li>如果设置了环境变量 <code>AFL_NO_BUILTIN</code><ul>
<li>“-fno-builtin-strcmp”, “-fno-builtin-strncmp”, “-fno-builtin-strcasecmp”, “-fno-builtin-strncasecmp”, “-fno-builtin-memcmp”, “-fno-builtin-strstr”, “-fno-builtin-strcasestr”</li>
</ul>
</li>
<li>最后参数 NULL</li>
</ul>
<h3 id="execvp来执行实际的编译器"><a href="#execvp来执行实际的编译器" class="headerlink" title="execvp来执行实际的编译器"></a>execvp来执行实际的编译器</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">/home/wutang/Desktop/google_afl/afl-g++ -g -O2 -DHAVE_CONFIG_H -I.. -I. -c /home/wutang/Desktop/fuzzing_xpdf/xpdf<span class="number">-3.02</span>/goo/GHash.cc</span><br><span class="line">-&gt;</span><br><span class="line">g++ -g -O2 -DHAVE_CONFIG_H -I.. -I. -c /home/wutang/Desktop/fuzzing_xpdf/xpdf<span class="number">-3.02</span>/goo/GHash.cc -B /home/wutang/Desktop/google_afl -g -O3 -funroll-loops -D__AFL_COMPILER=<span class="number">1</span> -DFUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION=<span class="number">1</span> -###</span><br><span class="line">-&gt;</span><br><span class="line">COLLECT_GCC_OPTIONS=<span class="string">&#x27;-g&#x27;</span> <span class="string">&#x27;-O2&#x27;</span> <span class="string">&#x27;-D&#x27;</span> <span class="string">&#x27;HAVE_CONFIG_H&#x27;</span> <span class="string">&#x27;-I&#x27;</span> <span class="string">&#x27;..&#x27;</span> <span class="string">&#x27;-I&#x27;</span> <span class="string">&#x27;.&#x27;</span> <span class="string">&#x27;-c&#x27;</span> <span class="string">&#x27;-B&#x27;</span> <span class="string">&#x27;/home/wutang/Desktop/google_afl&#x27;</span> <span class="string">&#x27;-g&#x27;</span> <span class="string">&#x27;-O3&#x27;</span> <span class="string">&#x27;-funroll-loops&#x27;</span> <span class="string">&#x27;-D&#x27;</span> <span class="string">&#x27;__AFL_COMPILER=1&#x27;</span> <span class="string">&#x27;-D&#x27;</span> <span class="string">&#x27;FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION=1&#x27;</span> <span class="string">&#x27;-shared-libgcc&#x27;</span> <span class="string">&#x27;-mtune=generic&#x27;</span> <span class="string">&#x27;-march=x86-64&#x27;</span></span><br><span class="line"></span><br><span class="line">/usr/lib/gcc/x86_64-linux-gnu/<span class="number">9</span>/cc1plus -quiet -I .. -I . -imultiarch x86_64-linux-gnu -D_GNU_SOURCE -D HAVE_CONFIG_H -D <span class="string">&quot;__AFL_COMPILER=1&quot;</span> -D <span class="string">&quot;FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION=1&quot;</span> /home/wutang/Desktop/fuzzing_xpdf/xpdf<span class="number">-3.02</span>/goo/GHash.cc -quiet -dumpbase GHash.cc <span class="string">&quot;-mtune=generic&quot;</span> <span class="string">&quot;-march=x86-64&quot;</span> -auxbase GHash -g -g -O2 -O3 -funroll-loops -fasynchronous-unwind-tables -fstack-protector-strong -Wformat -Wformat-security -fstack-clash-protection -fcf-protection -o /tmp/ccC1Zxd9.s</span><br><span class="line"></span><br><span class="line">COLLECT_GCC_OPTIONS=<span class="string">&#x27;-g&#x27;</span> <span class="string">&#x27;-O2&#x27;</span> <span class="string">&#x27;-D&#x27;</span> <span class="string">&#x27;HAVE_CONFIG_H&#x27;</span> <span class="string">&#x27;-I&#x27;</span> <span class="string">&#x27;..&#x27;</span> <span class="string">&#x27;-I&#x27;</span> <span class="string">&#x27;.&#x27;</span> <span class="string">&#x27;-c&#x27;</span> <span class="string">&#x27;-B&#x27;</span> <span class="string">&#x27;/home/wutang/Desktop/google_afl&#x27;</span> <span class="string">&#x27;-g&#x27;</span> <span class="string">&#x27;-O3&#x27;</span> <span class="string">&#x27;-funroll-loops&#x27;</span> <span class="string">&#x27;-D&#x27;</span> <span class="string">&#x27;__AFL_COMPILER=1&#x27;</span> <span class="string">&#x27;-D&#x27;</span> <span class="string">&#x27;FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION=1&#x27;</span> <span class="string">&#x27;-shared-libgcc&#x27;</span> <span class="string">&#x27;-mtune=generic&#x27;</span> <span class="string">&#x27;-march=x86-64&#x27;</span></span><br><span class="line"></span><br><span class="line">/home/wutang/Desktop/google_afl/as -I .. -I . -<span class="number">-64</span> -o GHash.o /home/wutang/Desktop/fuzzing_xpdf/xpdf<span class="number">-3.02</span>/goo/GHash.s</span><br></pre></td></tr></table></figure>

<ul>
<li>调用 [[#afl-as]]</li>
</ul>
<h2 id="afl-as"><a href="#afl-as" class="headerlink" title="afl-as"></a>afl-as</h2><h3 id="命令-1"><a href="#命令-1" class="headerlink" title="命令"></a>命令</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">/home/wutang/Desktop/google_afl/as -I .. -I . -<span class="number">-64</span> -o GHash.o /tmp/ccC1Zxd9.s</span><br></pre></td></tr></table></figure>

<h3 id="gettimeofday时间加进程pid构造随机种子"><a href="#gettimeofday时间加进程pid构造随机种子" class="headerlink" title="gettimeofday时间加进程pid构造随机种子"></a>gettimeofday时间加进程pid构造随机种子</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">gettimeofday</span>(&amp;tv, &amp;tz);</span><br><span class="line">rand_seed = tv.tv_sec ^ tv.tv_usec ^ <span class="built_in">getpid</span>();</span><br><span class="line"><span class="built_in">srandom</span>(rand_seed);</span><br></pre></td></tr></table></figure>

<h3 id="edit-params设置参数"><a href="#edit-params设置参数" class="headerlink" title="edit_params设置参数"></a>edit_params设置参数</h3><ul>
<li>函数用于处理传递给GNU as的参数，添加修改后的文件名等信息。</li>
<li>获取环境变量 <code>TMPDIR</code><ul>
<li>tmp_dir</li>
</ul>
</li>
<li>获取环境变量 <code>AFL_AS</code><ul>
<li>afl_as 后面的as目录</li>
</ul>
</li>
<li>获取环境变量 <code>TEMP</code> <code>TMP</code><ul>
<li>写入tmp_dir 否则用 <code>/tmp</code></li>
</ul>
</li>
<li>申请 <code>(8+32) *8</code> 大内存</li>
<li>第一参数 <code>argv[0]</code> as 或者设置的 afl_as</li>
<li>后续参数<ul>
<li>如果有 <code>--64</code> use_64bit&#x3D;1  默认为1</li>
<li>如果有 <code>--32</code> use_64bit&#x3D;0</li>
<li>input_file 为参数尾部，这里是 <code>/tmp/ccC1Zxd9.s</code><ul>
<li>如果是 <code>-version</code> 就退出</li>
<li>如果不为 <code>/tmp/</code> <code>/var/tmp/</code> 就会设置 pass_thru&#x3D;1 不会修改指令</li>
</ul>
</li>
<li>设置尾部参数为 <code>/tmp/pid/time(NULL)</code> <code>/tmp/.afl-124181-1690797188.s</code></li>
</ul>
</li>
</ul>
<h3 id="add-instrumentation"><a href="#add-instrumentation" class="headerlink" title="add_instrumentation"></a>add_instrumentation</h3><ul>
<li>函数用于在适当的位置插入插桩代码。</li>
</ul>
<h4 id="读取汇编文件，写入afl汇编文件"><a href="#读取汇编文件，写入afl汇编文件" class="headerlink" title="读取汇编文件，写入afl汇编文件"></a>读取汇编文件，写入afl汇编文件</h4><ul>
<li>遍历文件内容<code>/tmp/ccC1Zxd9.s</code> , 写入文件 <code>/tmp/.afl-124181-1690797188.s</code><ul>
<li>如果设置 <code>pass_thru</code> continue</li>
<li>检测文本段<ul>
<li>函数会扫描输入的汇编代码，以确定是否在正确的文本段（<code>.text</code>）内。由于插桩是针对代码段的，因此只有当程序在代码段内时才会进行插桩处理。</li>
<li>表示处于正确的文本段内，可以进行插桩</li>
<li>检查 <code>text</code>, <code>section\t.text</code>, <code>section\t__TEXT,__text</code>, <code>section __TEXT,__text</code><ul>
<li>将 <code>instr_ok</code> 设置为 1，表示处于正确的文本段内，可以进行插桩</li>
</ul>
</li>
<li>检查 <code>section\t</code>，<code>section</code>, <code>bss\n</code>, <code>data\n</code> 让他 instr_ok&#x3D;0x<ul>
<li>将 <code>instr_ok</code> 设置为 0，表示不在文本段内，不需要进行插桩。</li>
</ul>
</li>
</ul>
</li>
<li>处理不同格式的汇编代码<ul>
<li>这部分代码主要处理一些特殊格式的汇编代码，如若发现了注释中的 <code>.code32</code> 或 <code>.code64</code>，则会跳过一些代码块，因为它们通常不需要插桩</li>
</ul>
</li>
<li>处理 Intel 语法<ul>
<li>如果当前行包含 <code>.intel_syntax</code> 或 <code>.att_syntax</code> 字符串，表示当前代码是 Intel 或 AT&amp;T 语法的汇编代码。</li>
<li><code>.intel_syntax</code> 表示在处理 Intel 语法代码，会将 <code>skip_intel</code> 设置为 1，以跳过相关代码块。</li>
<li><code>.att_syntax</code> 会将 <code>skip_intel</code> 设置为 1<ul>
<li>后面自己添加的payload有 [[#64位&amp;32位汇编payload]]</li>
</ul>
</li>
</ul>
</li>
<li>处理 <code>__asm__</code> 块<ul>
<li>如果当前行是注释行（以 <code>#</code> 开头），并且包含 <code>#APP</code> 或 <code>#NO_APP</code>，表示当前处于 <code>__asm__</code> 块内部，会将 <code>skip_app</code> 设置为 1</li>
</ul>
</li>
<li>插入条件分支插桩代码<ul>
<li><code>Conditional branch instruction (jnz, etc)</code></li>
<li>如果当前行以一个制表符 <code>\t</code> 开始，表示这是一个汇编指令。如果这个指令是条件分支指令（以 <code>j</code> 开头，但不是 <code>jmp</code>），并且随机数小于插桩概率 <code>inst_ratio</code>，则会在这个指令后面插入条件分支的插桩代码</li>
</ul>
</li>
<li>插入跳转目标插桩代码<ul>
<li>如果当前行包含 <code>:</code> 字符，表示这是一个标签。函数会判断这个标签是否是跳转目标（条件分支的目标），如果是，则会在这个标签处插入插桩代码，用于收集跳转目标的覆盖信息。</li>
</ul>
</li>
<li>输出主要插桩代码：在汇编代码的末尾，会插入一段主要的插桩代码（<code>main_payload_32</code> 或 <code>main_payload_64</code>），用于处理插桩逻辑的初始化和收尾工作<ul>
<li><code>fputs(use_64bit ? main_payload_64 : main_payload_32, outf);</code> 加到末尾？</li>
<li>[[#64位&amp;32位汇编payload]]</li>
</ul>
</li>
</ul>
</li>
<li>最后输出信息 <code>[+] Instrumented 435 locations (64-bit, non-hardened mode, ratio 100%).</code></li>
</ul>
<h4 id="最重要的代码-插入逻辑"><a href="#最重要的代码-插入逻辑" class="headerlink" title="最重要的代码-插入逻辑"></a>最重要的代码-插入逻辑</h4><ul>
<li><strong>afl的插桩相当简单粗暴，就是通过汇编的前导命令来判断这是否是一个分支或者函数，然后插入instrumentation trampoline。</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">  ^func:      - <span class="function">function entry <span class="title">point</span> <span class="params">(always instrumented)</span></span></span><br><span class="line"><span class="function">      <span class="comment">// _ZN5GHash9getLengthEv:\n\0thEv, @function\n\0G\&quot;,@progbits,_ZN5GHash9getLengthEv,comdat\n</span></span></span><br><span class="line"><span class="function">      <span class="comment">// _ZN5GHashC2Ei:\n\0C2Ei, @function\n\0ZN5GHash9getLengthEv\n\0oo/GHash.h\&quot;\n\0engthEv,comdat\n&quot;...</span></span></span><br><span class="line"><span class="function">      <span class="comment">// _ZN5GHashD2Ev:\n\0D2Ev, @function\n\0\n\0Ei\n\0xpdf/xpdf-3.02/goo/GHash.cc\&quot;\n\0ngthEv,comdat\n_</span></span></span><br><span class="line"><span class="function">  ^.L0:       - GCC branch label</span></span><br><span class="line"><span class="function">      // .L9:\n\<span class="number">0</span>:\n\<span class="number">0l</span>Pvm@PLT\n\<span class="number">0</span>Ev@PLT\n\<span class="number">0</span> <span class="number">1</span> view .LVU50\n\<span class="number">0l</span>ity_v0\n\<span class="number">02</span>/goo/GHash.cc\<span class="string">&quot;\n\0ngthEv,comdat\n</span></span></span><br><span class="line"><span class="string"><span class="function">      // .L\d</span></span></span><br><span class="line"><span class="string"><span class="function">  ^.LBB0_0:   - clang branch label (but only in clang mode)</span></span></span><br><span class="line"><span class="string"><span class="function">  ^\tjnz foo  - conditional branches</span></span></span><br><span class="line"><span class="string"><span class="function">      // \tjle\t.L28\n\0, %eax\n\0tmt 0 view .LVU87\n\0_xpdf/xpdf-3.02/goo/GString.h\&quot;\n\0gthEv,comdat\n</span></span></span><br><span class="line"><span class="string"><span class="function">      // \tjxx  x不是m</span></span></span><br><span class="line"><span class="string"><span class="function"></span></span></span><br><span class="line"><span class="string"><span class="function">...but not:</span></span></span><br><span class="line"><span class="string"><span class="function"></span></span></span><br><span class="line"><span class="string"><span class="function">  ^# BB#0:    - clang comments</span></span></span><br><span class="line"><span class="string"><span class="function">  ^ # BB#0:   - ditto</span></span></span><br><span class="line"><span class="string"><span class="function">  ^.Ltmp0:    - clang non-branch labels</span></span></span><br><span class="line"><span class="string"><span class="function">  ^.LC0       - GCC non-branch labels</span></span></span><br><span class="line"><span class="string"><span class="function">  ^.LBB0_0:   - ditto (when in GCC mode)</span></span></span><br><span class="line"><span class="string"><span class="function">  ^\tjmp foo  - non-conditional jumps</span></span></span><br></pre></td></tr></table></figure>

<h4 id="32-64跳转指令"><a href="#32-64跳转指令" class="headerlink" title="32|64跳转指令"></a>32|64跳转指令</h4><ul>
<li>在合适时机插入跳转指令</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!pass_thru &amp;&amp; !skip_intel &amp;&amp; !skip_app &amp;&amp; !skip_csect &amp;&amp; instr_ok &amp;&amp;</span><br><span class="line">    instrument_next &amp;&amp; line[<span class="number">0</span>] == <span class="string">&#x27;\t&#x27;</span> &amp;&amp; <span class="built_in">isalpha</span>(line[<span class="number">1</span>])) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(outf, use_64bit ? trampoline_fmt_64 : trampoline_fmt_32,</span><br><span class="line">          <span class="built_in">R</span>(MAP_SIZE));</span><br><span class="line"></span><br><span class="line">  instrument_next = <span class="number">0</span>;</span><br><span class="line">  ins_lines++;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="trampoline-fmt-64"><a href="#trampoline-fmt-64" class="headerlink" title="trampoline_fmt_64"></a>trampoline_fmt_64</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> u8* trampoline_fmt_64 =</span><br><span class="line"></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;/* --- AFL TRAMPOLINE (64-BIT) --- */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;.align 4\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;leaq -(128+24)(%%rsp), %%rsp\n&quot;</span></span><br><span class="line">        <span class="comment">// 过 `leaq` 指令，将当前栈指针 `rsp` 向下偏移 128+24 个字节，预留出一个较大的栈帧空间，用于保存寄存器内容</span></span><br><span class="line">  <span class="string">&quot;movq %%rdx,  0(%%rsp)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;movq %%rcx,  8(%%rsp)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;movq %%rax, 16(%%rsp)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;movq $0x%08x, %%rcx\n&quot;</span></span><br><span class="line">        <span class="comment">// 将一个立即数（可能是用作函数参数的标识符）加载到 `rcx` 寄存器中。`0x%08x` 可能是一个占位符，实际的值在代码中会被替换</span></span><br><span class="line">  <span class="string">&quot;call __afl_maybe_log\n&quot;</span></span><br><span class="line">        <span class="comment">// 这是AFL的日志记录函数，用于记录被测程序的执行路径信息，以便进行代码覆盖率的统计和模糊测试的导向。</span></span><br><span class="line">  <span class="string">&quot;movq 16(%%rsp), %%rax\n&quot;</span></span><br><span class="line">  <span class="string">&quot;movq  8(%%rsp), %%rcx\n&quot;</span></span><br><span class="line">  <span class="string">&quot;movq  0(%%rsp), %%rdx\n&quot;</span></span><br><span class="line">  <span class="string">&quot;leaq (128+24)(%%rsp), %%rsp\n&quot;</span></span><br><span class="line">        <span class="comment">// 通过 `leaq` 指令，将栈指针 `rsp` 恢复到之前的位置，撤销之前的栈帧偏移。</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;/* --- END --- */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>这段代码是 American Fuzzy Lop（AFL）模糊测试工具注入到被测程序中的一部分汇编级别的插桩（Instrumentation）</li>
</ul>
<h4 id="64位-32位汇编payload"><a href="#64位-32位汇编payload" class="headerlink" title="64位&amp;32位汇编payload"></a>64位&amp;32位汇编payload</h4><ul>
<li>下面每段解释  代码+解释</li>
<li>在整个 fuzzing 过程中，父进程（afl-fuzz进程）会不断地向子进程发送命令，子进程根据这些命令执行不同的操作。这样，父进程可以控制子进程的行为，例如在发现新的输入样本时，将其发送给子进程执行，然后收集覆盖率数据。而子进程则负责实际执行目标程序，并将覆盖率数据写入共享内存，供父进程收集。这样做可以有效地分担负担并提高 fuzzing 性能。<ul>
<li><code>__afl_fork_wait_loop</code> 是一个循环，在 <code>__afl_forkserver</code> 函数中用于等待父进程（afl-fuzz进程）发来的信号并执行相应的操作</li>
</ul>
</li>
</ul>
<h5 id="afl-maybe-log"><a href="#afl-maybe-log" class="headerlink" title="__afl_maybe_log"></a>__afl_maybe_log</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> u8* main_payload_64 = </span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;/* --- AFL MAIN PAYLOAD (64-BIT) --- */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;.text\n&quot;</span></span><br><span class="line">  <span class="string">&quot;.att_syntax\n&quot;</span></span><br><span class="line">  <span class="string">&quot;.code64\n&quot;</span></span><br><span class="line">  <span class="string">&quot;.align 8\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;__afl_maybe_log:\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(__OpenBSD__)  || (defined(__FreeBSD__) &amp;&amp; (__FreeBSD__ &lt; 9))</span></span><br><span class="line">  <span class="string">&quot;  .byte 0x9f /* lahf */\n&quot;</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  <span class="string">&quot;  lahf\n&quot;</span></span><br><span class="line">          <span class="comment">//  将标志寄存器 FLAGS 的低八位保存到 AH 寄存器中</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* ^__OpenBSD__, etc */</span></span></span><br><span class="line">  <span class="string">&quot;  seto  %al\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  /* Check if SHM region is already mapped. */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq  __afl_area_ptr(%rip), %rdx\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  testq %rdx, %rdx\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  je    __afl_setup\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>__afl_maybe_log</code> 包含一些汇编代码，用于在日志中记录AFL的执行状态<ul>
<li>这是一个条件编译块，根据操作系统定义了 <code>__OpenBSD__</code> 或 <code>__FreeBSD__</code> 并且版本较低于 9，它会使用 <code>.byte</code> 汇编指令来加载 <code>0x9f</code> 到 <code>%al</code> 寄存器（加载寄存器 AH 中的标志位）。否则，直接使用 <code>lahf</code> 汇编指令。然后使用 <code>seto</code> 指令将 <code>%al</code> 寄存器中的溢出标志位设置为 1。</li>
<li><code>lahf</code> 将标志寄存器的低 8 位（FLAGS 寄存器的低 8 位）的内容加载到 <code>AH</code> 寄存器中</li>
<li>首先检查是否已经存在共享内存，如果已经存在则跳转到 <code>__afl_store</code> 以开始插桩。</li>
<li>否则进入 <code>__afl_setup</code></li>
</ul>
</li>
<li><code>__afl_area_ptr</code> 共享内存<ul>
<li>这段代码首先将 <code>__afl_area_ptr</code> 符号地址（偏移量）加载到 <code>%rdx</code> 寄存器中，然后使用 <code>testq</code> 指令检查 <code>%rdx</code> 的值是否为零。如果 <code>%rdx</code> 的值为零（也就是指针为空），则跳转到标签 <code>__afl_setup</code>，表示 SHM 区域尚未映射。</li>
<li>[[#__afl_setup_first]]</li>
</ul>
</li>
</ul>
<h5 id="afl-store"><a href="#afl-store" class="headerlink" title="__afl_store"></a>__afl_store</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">  <span class="string">&quot;__afl_store:\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  /* Calculate and store hit for the code location specified in rcx. */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> COVERAGE_ONLY</span></span><br><span class="line">  <span class="string">&quot;  xorq __afl_prev_loc(%rip), %rcx\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  xorq %rcx, __afl_prev_loc(%rip)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  shrq $1, __afl_prev_loc(%rip)\n&quot;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* ^!COVERAGE_ONLY */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> SKIP_COUNTS</span></span><br><span class="line">  <span class="string">&quot;  orb  $1, (%rdx, %rcx, 1)\n&quot;</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  <span class="string">&quot;  incb (%rdx, %rcx, 1)\n&quot;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* ^SKIP_COUNTS */</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>__afl_store</code> 主要的插桩点</li>
<li>用于计算和存储代码位置的执行路径信息。</li>
<li>这是一个条件编译块，当未定义 <code>COVERAGE_ONLY</code> 宏时，执行其中的代码。它将 <code>%rcx</code> 寄存器的值与 <code>__afl_prev_loc</code> 符号地址指向的值进行异或运算，然后将结果再次与 <code>__afl_prev_loc</code> 指向的值进行异或运算。接着，将 <code>__afl_prev_loc</code> 指向的值右移一位。</li>
<li><code>%rcx</code> 存储为原来的 <code>__afl_prev_loc(%rip)</code></li>
<li>条件编译<ul>
<li>这是另一个条件编译块，当定义了 <code>SKIP_COUNTS</code> 宏时，执行其中的代码。<ul>
<li>它将立即数 1 与地址 <code>(%rdx, %rcx, 1)</code> 处的内存进行或运算</li>
<li>否则直接在 <code>(%rdx, %rcx, 1)</code> 处加一。<ul>
<li><code>incb (%rdx, %rcx, 1)\n</code> 将位于地址 <code>%rdx + %rcx*1</code> 处的字节内容加一。</li>
</ul>
</li>
<li>这个内存地址是 <code>__afl_area_ptr</code> 指向的 SHM 区域中的某个计数器位置，用于记录覆盖情况。</li>
<li>Added SKIP_COUNTS and changed the behavior of COVERAGE_ONLY in config.h. Useful only for internal benchmarking. 用于内部benchmarking</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="afl-return"><a href="#afl-return" class="headerlink" title="__afl_return"></a>__afl_return</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">  <span class="string">&quot;__afl_return:\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  addb $127, %al\n&quot;</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(__OpenBSD__)  || (defined(__FreeBSD__) &amp;&amp; (__FreeBSD__ &lt; 9))</span></span><br><span class="line">  <span class="string">&quot;  .byte 0x9e /* sahf */\n&quot;</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  <span class="string">&quot;  sahf\n&quot;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* ^__OpenBSD__, etc */</span></span></span><br><span class="line">  <span class="string">&quot;  ret\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>__afl_return</code>  在记录完当前代码块的执行信息后，将控制权返回到调用 <code>main_payload_64</code> 函数的地方，继续执行后续的代码<ul>
<li>这段代码首先将立即数 127 加到 <code>%al</code> 寄存器中。接着，根据操作系统的不同，使用 <code>.byte</code> 汇编指令加载 <code>0x9e</code> 到 <code>sahf</code> 指令（将标志寄存器的内容从 <code>%ah</code> 寄存器中加载），或者直接使用 <code>sahf</code> 指令。最后，使用 <code>ret</code> 指令返回到调用者。</li>
</ul>
</li>
<li>这里返回到用户代码继续</li>
</ul>
<h5 id="afl-setup"><a href="#afl-setup" class="headerlink" title="__afl_setup"></a>__afl_setup</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"> <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;.align 8\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;__afl_setup:\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  /* Do not retry setup if we had previous failures. */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  cmpb $0, __afl_setup_failure(%rip)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  jne __afl_return\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  /* Check out if we have a global pointer on file. */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __APPLE__</span></span><br><span class="line">  <span class="string">&quot;  movq  __afl_global_area_ptr@GOTPCREL(%rip), %rdx\n&quot;</span></span><br><span class="line">      <span class="comment">// 将 `__afl_global_area_ptr` 的地址加载到 `rdx` 寄存器中。`__afl_global_area_ptr` 是一个指向全局共享内存区域的指针，它存储在数据段。</span></span><br><span class="line">  <span class="string">&quot;  movq  (%rdx), %rdx\n&quot;</span>  </span><br><span class="line">      <span class="comment">// 这条指令从 `rdx` 寄存器指向的内存地址中读取一个指针值，并将该指针值存储回 `rdx` 寄存器中。这样，`rdx` 寄存器将包含指向全局共享内存区域的指针。</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  <span class="string">&quot;  movq  __afl_global_area_ptr(%rip), %rdx\n&quot;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* !^__APPLE__ */</span></span></span><br><span class="line">  <span class="string">&quot;  testq %rdx, %rdx\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  je    __afl_setup_first\n&quot;</span></span><br><span class="line">      <span class="comment">// 如果 `__afl_global_area_ptr` 为 NULL，说明还没有共享内存区域，需要执行初始化操作。</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq %rdx, __afl_area_ptr(%rip)\n&quot;</span></span><br><span class="line">      <span class="comment">// 这条指令将 `rdx` 寄存器的值（即全局共享内存区域的指针）存储到 `__afl_area_ptr` 变量中。`__afl_area_ptr` 是一个全局变量，它用于存储当前函数的代码覆盖率信息。</span></span><br><span class="line">  <span class="string">&quot;  jmp  __afl_store\n&quot;</span> </span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>__afl_setup</code> 这是初始化共享内存（SHM）的部分，用于存储测试用例和覆盖率信息。<ul>
<li>将 <code>__afl_setup_failure</code> 标签的值（一个字节）与零进行比较。<code>__afl_setup_failure</code> 是用于记录初始化失败次数的变量，初始值为零。</li>
<li>读取数据段指针<code>__afl_global_area_ptr</code> ，取出一个指针到rdx<ul>
<li>如果rdx为空 跳转到 [[#__afl_setup_first]]  就执行一次</li>
</ul>
</li>
<li>尝试从环境变量中获取共享内存 ID，并调用 <code>shmat()</code> 将其映射到当前进程的地址空间。</li>
</ul>
</li>
</ul>
<h5 id="afl-setup-first"><a href="#afl-setup-first" class="headerlink" title="__afl_setup_first"></a>__afl_setup_first</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __APPLE__</span></span><br><span class="line"><span class="meta">#  <span class="keyword">define</span> CALL_L64(str)		<span class="string">&quot;call _&quot;</span> str <span class="string">&quot;\n&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#  <span class="keyword">define</span> CALL_L64(str)		<span class="string">&quot;call &quot;</span> str <span class="string">&quot;@PLT\n&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* ^__APPLE__ */</span></span></span><br><span class="line"></span><br><span class="line">  <span class="string">&quot;__afl_setup_first:\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  /* Save everything that is not yet saved and that may be touched by\n&quot;</span></span><br><span class="line">  <span class="string">&quot;     getenv() and several other libcalls we&#x27;ll be relying on. */\n&quot;</span></span><br><span class="line">          <span class="comment">// 该函数用于进行 AFL 环境的初始化。</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  leaq -352(%rsp), %rsp\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">          <span class="comment">// 在这里，将栈指针向低地址偏移的目的是为了保存一些寄存器的值，以防止在后续调用 `getenv()` 和其他 libcalls 函数时被修改。</span></span><br><span class="line">  <span class="string">&quot;  movq %rax,   0(%rsp)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq %rcx,   8(%rsp)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq %rdi,  16(%rsp)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq %rsi,  32(%rsp)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq %r8,   40(%rsp)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq %r9,   48(%rsp)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq %r10,  56(%rsp)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq %r11,  64(%rsp)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq %xmm0,  96(%rsp)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq %xmm1,  112(%rsp)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq %xmm2,  128(%rsp)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq %xmm3,  144(%rsp)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq %xmm4,  160(%rsp)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq %xmm5,  176(%rsp)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq %xmm6,  192(%rsp)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq %xmm7,  208(%rsp)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq %xmm8,  224(%rsp)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq %xmm9,  240(%rsp)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq %xmm10, 256(%rsp)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq %xmm11, 272(%rsp)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq %xmm12, 288(%rsp)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq %xmm13, 304(%rsp)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq %xmm14, 320(%rsp)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq %xmm15, 336(%rsp)\n&quot;</span></span><br><span class="line">          <span class="comment">// 这些指令用于将一些通用寄存器和 xmm 寄存器的值保存到栈上。通用寄存器用于保存整数类型数据，xmm 寄存器用于保存浮点数类型数据。</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  /* Map SHM, jumping to __afl_setup_abort if something goes wrong. */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  /* The 64-bit ABI requires 16-byte stack alignment. We&#x27;ll keep the\n&quot;</span></span><br><span class="line">  <span class="string">&quot;     original stack ptr in the callee-saved r12. */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  pushq %r12\n&quot;</span></span><br><span class="line">          <span class="comment">// 将 r12 寄存器的值压入栈中，以保存原始的栈指针地址。r12 是一个 callee-saved 寄存器，即在函数调用时，它的值需要被保持不变，由被调用函数负责保存和恢复。</span></span><br><span class="line">  <span class="string">&quot;  movq  %rsp, %r12\n&quot;</span></span><br><span class="line">          <span class="comment">// 将栈指针的值保存到 r12 寄存器中，这样 r12 中就保存了原始的栈指针地址。</span></span><br><span class="line">  <span class="string">&quot;  subq  $16, %rsp\n&quot;</span></span><br><span class="line">          <span class="comment">// 将栈指针向低地址偏移 16 字节，为后续调用 `getenv()` 函数时保存参数留出空间。</span></span><br><span class="line">  <span class="string">&quot;  andq  $0xfffffffffffffff0, %rsp\n&quot;</span></span><br><span class="line">          <span class="comment">// 对栈指针进行掩码操作，保证栈指针地址按照 16 字节对齐，因为 64 位 ABI 要求栈指针是 16 字节对齐的</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  leaq .AFL_SHM_ENV(%rip), %rdi\n&quot;</span></span><br><span class="line">          <span class="comment">// 将 `.AFL_SHM_ENV` 标签的地址保存到 `rdi` 寄存器中。`.AFL_SHM_ENV` 是一个存储字符串 `&quot;__AFL_SHM_ID&quot;` 的标签</span></span><br><span class="line">  <span class="built_in">CALL_L64</span>(<span class="string">&quot;getenv&quot;</span>)</span><br><span class="line">          <span class="comment">// 用于进行 64 位系统调用，调用 `getenv()` 函数来获取环境变量 `__AFL_SHM_ID` 的值，并将返回值保存在 `rax` 寄存器中。</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  testq %rax, %rax\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  je    __afl_setup_abort\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq  %rax, %rdi\n&quot;</span></span><br><span class="line">  <span class="built_in">CALL_L64</span>(<span class="string">&quot;atoi&quot;</span>)</span><br><span class="line">          <span class="comment">// 数将 `rdi` 中的字符串表示的共享内存 ID 转换为整数，并将结果保存在 `rax` 中。</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  xorq %rdx, %rdx   /* shmat flags    */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  xorq %rsi, %rsi   /* requested addr */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq %rax, %rdi   /* SHM ID         */\n&quot;</span></span><br><span class="line">  <span class="built_in">CALL_L64</span>(<span class="string">&quot;shmat&quot;</span>)</span><br><span class="line">          <span class="comment">// 函数将共享内存 ID 所指定的共享内存区域映射到进程的地址空间中，并将返回的共享内存区域的地址保存在 `rax` 中。</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  cmpq $-1, %rax\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  je   __afl_setup_abort\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  /* Store the address of the SHM region. */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq %rax, %rdx\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq %rax, __afl_area_ptr(%rip)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __APPLE__</span></span><br><span class="line">  <span class="string">&quot;  movq %rax, __afl_global_area_ptr(%rip)\n&quot;</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  <span class="string">&quot;  movq __afl_global_area_ptr@GOTPCREL(%rip), %rdx\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq %rax, (%rdx)\n&quot;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* ^__APPLE__ */</span></span></span><br><span class="line">  <span class="string">&quot;  movq %rax, %rdx\n&quot;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>__afl_setup_first</code><ul>
<li>调用 <code>getenv()</code> 函数来获取环境变量 <code>__AFL_SHM_ID</code> 的值, <code>__afl_area_ptr</code> 变量所对应的内存地址中，即保存共享内存区域的地址, 将共享内存区域的地址保存在 <code>__afl_global_area_ptr</code> 变量中</li>
</ul>
</li>
</ul>
<h5 id="afl-forkserver-afl-fork-wait-loop"><a href="#afl-forkserver-afl-fork-wait-loop" class="headerlink" title="__afl_forkserver&amp;__afl_fork_wait_loop"></a>__afl_forkserver&amp;__afl_fork_wait_loop</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">  <span class="string">&quot;__afl_forkserver:\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  /* Enter the fork server mode to avoid the overhead of execve() calls. We\n&quot;</span></span><br><span class="line">  <span class="string">&quot;     push rdx (area ptr) twice to keep stack alignment neat. */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  pushq %rdx\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  pushq %rdx\n&quot;</span></span><br><span class="line">          <span class="comment">// 这里将 `%rdx` 寄存器的值压入栈两次，目的是为了保持栈对齐。</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  /* Phone home and tell the parent that we&#x27;re OK. (Note that signals with\n&quot;</span></span><br><span class="line">  <span class="string">&quot;     no SA_RESTART will mess it up). If this fails, assume that the fd is\n&quot;</span></span><br><span class="line">  <span class="string">&quot;     closed because we were execve()d from an instrumented binary, or because\n&quot;</span></span><br><span class="line">  <span class="string">&quot;     the parent doesn&#x27;t want to use the fork server. */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq $4, %rdx               /* length    */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  leaq __afl_temp(%rip), %rsi /* data      */\n&quot;</span></span><br><span class="line">          <span class="comment">// 将变量 `__afl_temp` 的内存地址（偏移相对于 `rip` 寄存器的当前值）加载到寄存器 `rsi` 中</span></span><br><span class="line">          <span class="comment">// `.lcomm` 汇编伪指令用于在目标文件中分配具有局部作用域的共享内存空间</span></span><br><span class="line">  <span class="string">&quot;  movq $&quot;</span> <span class="built_in">STRINGIFY</span>((FORKSRV_FD + <span class="number">1</span>)) <span class="string">&quot;, %rdi       /* file desc */\n&quot;</span></span><br><span class="line">          <span class="comment">// #define FORKSRV_FD          198</span></span><br><span class="line">          <span class="comment">// 这里生成字符串 &quot;199&quot;  文件描述符</span></span><br><span class="line">  <span class="built_in">CALL_L64</span>(<span class="string">&quot;write&quot;</span>)</span><br><span class="line">          <span class="comment">// write 199   __afl_temp 所指向的缓冲区</span></span><br><span class="line">          <span class="comment">// 将数据从地址 `__afl_temp` 所指向的缓冲区写入到文件描述符 199 所代表的文件中，写入的数据长度是 4 字节。</span></span><br><span class="line">          <span class="comment">// 用于告知  afl-fuzz父进程当前进程已准备好，可以开始进行Fork Server模式的交互了</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  cmpq $4, %rax\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  jne  __afl_fork_resume\n&quot;</span></span><br><span class="line">          <span class="comment">// 如果失败，则表示文件描述符已关闭，可能是因为从一个带有插桩的二进制文件中执行，或者父进程不使用 fork server 模式。</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;__afl_fork_wait_loop:\n&quot;</span></span><br><span class="line">          <span class="comment">// 如果写入成功，说明父进程已收到通知，并准备与当前进程进行Fork Server模式的交互</span></span><br><span class="line">          <span class="comment">// 表示 fork server 模式的等待循环，用于等待父进程的指令并执行相应操作</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  /* Wait for parent by reading from the pipe. Abort if read fails. */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq $4, %rdx               /* length    */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  leaq __afl_temp(%rip), %rsi /* data      */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq $&quot;</span> <span class="built_in">STRINGIFY</span>(FORKSRV_FD) <span class="string">&quot;, %rdi             /* file desc */\n&quot;</span></span><br><span class="line">  <span class="built_in">CALL_L64</span>(<span class="string">&quot;read&quot;</span>)</span><br><span class="line">          <span class="comment">// read 198   从afl-fuzz 管道中读取指令</span></span><br><span class="line">  <span class="string">&quot;  cmpq $4, %rax\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  jne  __afl_die\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  /* Once woken up, create a clone of our process. This is an excellent use\n&quot;</span></span><br><span class="line">  <span class="string">&quot;     case for syscall(__NR_clone, 0, CLONE_PARENT), but glibc boneheadedly\n&quot;</span></span><br><span class="line">  <span class="string">&quot;     caches getpid() results and offers no way to update the value, breaking\n&quot;</span></span><br><span class="line">  <span class="string">&quot;     abort(), raise(), and a bunch of other things :-( */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="built_in">CALL_L64</span>(<span class="string">&quot;fork&quot;</span>)</span><br><span class="line">  <span class="string">&quot;  cmpq $0, %rax\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  jl   __afl_die\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  je   __afl_fork_resume\n&quot;</span> <span class="comment">// 表示在子进程中执行</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 父进程处理</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  /* In parent process: write PID to pipe, then wait for child. */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movl %eax, __afl_fork_pid(%rip)\n&quot;</span> <span class="comment">// 如果大于0，则表示在父进程中执行下面的代码。</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq $4, %rdx                   /* length    */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  leaq __afl_fork_pid(%rip), %rsi /* data      */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq $&quot;</span> <span class="built_in">STRINGIFY</span>((FORKSRV_FD + <span class="number">1</span>)) <span class="string">&quot;, %rdi             /* file desc */\n&quot;</span></span><br><span class="line">  <span class="built_in">CALL_L64</span>(<span class="string">&quot;write&quot;</span>)</span><br><span class="line">          <span class="comment">// write 199  子进程pid  给 afl-fuzz</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq $0, %rdx                   /* no flags  */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  leaq __afl_temp(%rip), %rsi     /* status    */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq __afl_fork_pid(%rip), %rdi /* PID       */\n&quot;</span></span><br><span class="line">  <span class="built_in">CALL_L64</span>(<span class="string">&quot;waitpid&quot;</span>)</span><br><span class="line">          <span class="comment">// 父进程 等待子进程退出</span></span><br><span class="line">  <span class="string">&quot;  cmpq $0, %rax\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  jle  __afl_die\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  /* Relay wait status to pipe, then loop back. */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq $4, %rdx               /* length    */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  leaq __afl_temp(%rip), %rsi /* data      */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq $&quot;</span> <span class="built_in">STRINGIFY</span>((FORKSRV_FD + <span class="number">1</span>)) <span class="string">&quot;, %rdi         /* file desc */\n&quot;</span></span><br><span class="line">  <span class="built_in">CALL_L64</span>(<span class="string">&quot;write&quot;</span>)</span><br><span class="line">          <span class="comment">// write 199  __afl_temp 所指向的缓冲区  通知 afl-fuzz 子进程的执行结果。</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  jmp  __afl_fork_wait_loop\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="comment">// 父进程处理 over</span></span><br></pre></td></tr></table></figure>

<ul>
<li>__afl_forkserver<ul>
<li>通过 write 199 去进程间通信</li>
<li>它会进入 Fork Server 模式，该模式的目的是为了避免重复执行 <code>execve()</code> 的开销，提高执行效率</li>
</ul>
</li>
<li>__afl_fork_wait_loop<ul>
<li>开始fork进程<ul>
<li>fork后 rax为0 表示子进程 跑到 [[#__afl_fork_resume子进程处理]]</li>
<li>fork后 rax&gt;0 表示父进程<ul>
<li>将子进程的 PID 存入 <code>__afl_fork_pid</code> 变量</li>
<li>将子进程的 PID 写入文件描述符 <code>(FORKSRV_FD + 1) = 199</code> 所对应的文件中</li>
<li>使用 <code>waitpid</code> 系统调用等待子进程退出，返回值在 <code>%rax</code> 中。如果返回值小于等于0，则跳转到 <code>__afl_die</code> 标签处终止进程。</li>
<li>然后继续循环执行 <code>__afl_fork_wait_loop</code>，等待父进程的指令</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="afl-fork-resume子进程处理"><a href="#afl-fork-resume子进程处理" class="headerlink" title="__afl_fork_resume子进程处理"></a>__afl_fork_resume子进程处理</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="string">&quot;__afl_fork_resume:\n&quot;</span></span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="string">&quot;  /* In child process: close fds, resume execution. */\n&quot;</span></span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq $&quot;</span> <span class="built_in">STRINGIFY</span>(FORKSRV_FD) <span class="string">&quot;, %rdi\n&quot;</span></span><br><span class="line"><span class="built_in">CALL_L64</span>(<span class="string">&quot;close&quot;</span>)</span><br><span class="line">        <span class="comment">// 关闭 198</span></span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq $&quot;</span> <span class="built_in">STRINGIFY</span>((FORKSRV_FD + <span class="number">1</span>)) <span class="string">&quot;, %rdi\n&quot;</span></span><br><span class="line"><span class="built_in">CALL_L64</span>(<span class="string">&quot;close&quot;</span>)</span><br><span class="line">        <span class="comment">// 关闭 199</span></span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="string">&quot;  popq %rdx\n&quot;</span></span><br><span class="line"><span class="string">&quot;  popq %rdx\n&quot;</span></span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq %r12, %rsp\n&quot;</span></span><br><span class="line"><span class="string">&quot;  popq %r12\n&quot;</span></span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq  0(%rsp), %rax\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq  8(%rsp), %rcx\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq 16(%rsp), %rdi\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq 32(%rsp), %rsi\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq 40(%rsp), %r8\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq 48(%rsp), %r9\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq 56(%rsp), %r10\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq 64(%rsp), %r11\n&quot;</span></span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq  96(%rsp), %xmm0\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq 112(%rsp), %xmm1\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq 128(%rsp), %xmm2\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq 144(%rsp), %xmm3\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq 160(%rsp), %xmm4\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq 176(%rsp), %xmm5\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq 192(%rsp), %xmm6\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq 208(%rsp), %xmm7\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq 224(%rsp), %xmm8\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq 240(%rsp), %xmm9\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq 256(%rsp), %xmm10\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq 272(%rsp), %xmm11\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq 288(%rsp), %xmm12\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq 304(%rsp), %xmm13\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq 320(%rsp), %xmm14\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq 336(%rsp), %xmm15\n&quot;</span></span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="string">&quot;  leaq 352(%rsp), %rsp\n&quot;</span></span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="string">&quot;  jmp  __afl_store\n&quot;</span></span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>__afl_fork_resume<ul>
<li>表示在子进程中执行。在子进程中，关闭文件描述符 <code>FORKSRV_FD</code> 和 <code>(FORKSRV_FD + 1)</code>，然后进行一系列寄存器的恢复操作，最后跳转到 <code>__afl_store</code> 标签处，继续进行 fuzzing 过程。<ul>
<li>[[#__afl_store]] 代码覆盖记录</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="afl-die退出"><a href="#afl-die退出" class="headerlink" title="__afl_die退出"></a>__afl_die退出</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;__afl_die:\n&quot;</span></span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="string">&quot;  xorq %rax, %rax\n&quot;</span></span><br><span class="line"><span class="built_in">CALL_L64</span>(<span class="string">&quot;_exit&quot;</span>)</span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br></pre></td></tr></table></figure>

<h5 id="afl-setup-abort配置失败"><a href="#afl-setup-abort配置失败" class="headerlink" title="__afl_setup_abort配置失败"></a>__afl_setup_abort配置失败</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;__afl_setup_abort:\n&quot;</span></span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="string">&quot;  /* Record setup failure so that we don&#x27;t keep calling\n&quot;</span></span><br><span class="line"><span class="string">&quot;     shmget() / shmat() over and over again. */\n&quot;</span></span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="string">&quot;  incb __afl_setup_failure(%rip)\n&quot;</span></span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq %r12, %rsp\n&quot;</span></span><br><span class="line"><span class="string">&quot;  popq %r12\n&quot;</span></span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq  0(%rsp), %rax\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq  8(%rsp), %rcx\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq 16(%rsp), %rdi\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq 32(%rsp), %rsi\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq 40(%rsp), %r8\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq 48(%rsp), %r9\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq 56(%rsp), %r10\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq 64(%rsp), %r11\n&quot;</span></span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq  96(%rsp), %xmm0\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq 112(%rsp), %xmm1\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq 128(%rsp), %xmm2\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq 144(%rsp), %xmm3\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq 160(%rsp), %xmm4\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq 176(%rsp), %xmm5\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq 192(%rsp), %xmm6\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq 208(%rsp), %xmm7\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq 224(%rsp), %xmm8\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq 240(%rsp), %xmm9\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq 256(%rsp), %xmm10\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq 272(%rsp), %xmm11\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq 288(%rsp), %xmm12\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq 304(%rsp), %xmm13\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq 320(%rsp), %xmm14\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq 336(%rsp), %xmm15\n&quot;</span></span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="string">&quot;  leaq 352(%rsp), %rsp\n&quot;</span></span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="string">&quot;  jmp __afl_return\n&quot;</span></span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="string">&quot;.AFL_VARS:\n&quot;</span></span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br></pre></td></tr></table></figure>

<h5 id="变量申请"><a href="#变量申请" class="headerlink" title="变量申请"></a>变量申请</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __APPLE__</span></span><br><span class="line"></span><br><span class="line">  <span class="string">&quot;  .comm   __afl_area_ptr, 8\n&quot;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> COVERAGE_ONLY</span></span><br><span class="line">  <span class="string">&quot;  .comm   __afl_prev_loc, 8\n&quot;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* !COVERAGE_ONLY */</span></span></span><br><span class="line">  <span class="string">&quot;  .comm   __afl_fork_pid, 4\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  .comm   __afl_temp, 4\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  .comm   __afl_setup_failure, 1\n&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"></span><br><span class="line">  <span class="string">&quot;  .lcomm   __afl_area_ptr, 8\n&quot;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> COVERAGE_ONLY</span></span><br><span class="line">  <span class="string">&quot;  .lcomm   __afl_prev_loc, 8\n&quot;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* !COVERAGE_ONLY */</span></span></span><br><span class="line">  <span class="string">&quot;  .lcomm   __afl_fork_pid, 4\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  .lcomm   __afl_temp, 4\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  .lcomm   __afl_setup_failure, 1\n&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* ^__APPLE__ */</span></span></span><br><span class="line"></span><br><span class="line">  <span class="string">&quot;  .comm    __afl_global_area_ptr, 8, 8\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;.AFL_SHM_ENV:\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  .asciz \&quot;&quot;</span> SHM_ENV_VAR <span class="string">&quot;\&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;/* --- END --- */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span>;</span><br></pre></td></tr></table></figure>

<h3 id="main-1"><a href="#main-1" class="headerlink" title="main"></a>main</h3><ul>
<li>函数是程序的主入口，它读取环境变量和命令行参数，然后执行相应的操作，包括调用上述函数来进行插桩处理。</li>
<li>获取环境变量 <code>__AFL_CLANG_MODE</code><ul>
<li>clang_mode</li>
</ul>
</li>
<li>获取环境变量 <code>AFL_QUIET</code> 设置 be_quiet 不打印信息</li>
<li>[[#gettimeofday时间加进程pid构造随机种子]]</li>
<li>[[#edit_params设置参数]]</li>
<li>获取环境变量 <code>AFL_INST_RATIO</code><ul>
<li>inst_ratio_str 可以设置指令比例 比如 AFL_INST_RATIO&#x3D;30 设置 inst_ratio</li>
</ul>
</li>
<li>获取环境变量 <code>__AFL_AS_LOOPCHECK</code><ul>
<li>之后设置他 <code>AS_LOOP_ENV_VAR 1</code></li>
<li>这段代码是为了防止在执行 <code>as</code>（GNU as汇编器）时发生无限循环，以提高程序的稳定性和安全性。</li>
</ul>
</li>
<li>如果设置 <code>AFL_USE_ASAN</code> <code>AFL_USE_MSAN</code><ul>
<li><code>sanitizer = 1;   inst_ratio /= 3;  指令随机变1/3</code></li>
</ul>
</li>
<li>[[#add_instrumentation]]<ul>
<li>插入汇编指令</li>
</ul>
</li>
<li>子进程执行 <code>as -I .. -I . --64 -o /tmp/GHash.o /tmp/.afl-125229-1690800161.s </code></li>
<li>父进程等待子进程执行完毕 <code>if (waitpid(pid, &amp;status, 0) &lt;= 0) PFATAL(&quot;waitpid() failed&quot;);</code></li>
<li>设置环境变量 <code>AFL_KEEP_ASSEMBLY</code> 保存这个 <code>/tmp/.afl-133075-1690873059.s</code><ul>
<li>否则 <code>unlink</code> 删除文件系统中的文件 <code>/tmp/.afl-133075-1690873059.s</code></li>
</ul>
</li>
</ul>
<h2 id="afl-fast-clang"><a href="#afl-fast-clang" class="headerlink" title="afl-fast-clang"></a>afl-fast-clang</h2><ul>
<li>因为AFL对于上述通过<code>afl-gcc</code>来插桩这种做法已经属于不建议，并提供了更好的工具afl-clang-fast，通过llvm pass来插桩。</li>
</ul>
<h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><ul>
<li>[[总结_llvm_clang命令_学习_llvm编译]]</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># use llvm16  error</span></span><br><span class="line"><span class="built_in">export</span> LLVM_CONFIG=<span class="string">&quot;/home/wutang/Desktop/llvm-project-16.0.0.src/install_release/bin/llvm-config&quot;</span></span><br><span class="line"><span class="built_in">export</span> CC=/home/wutang/Desktop/llvm-project-16.0.0.src/install_release/bin/clang-16 CXX=/home/wutang/Desktop/llvm-project-16.0.0.src/install_release/bin/clang-16++</span><br><span class="line"><span class="comment"># /home/wutang/Desktop/llvm-project-16.0.0.src/install_release/bin/llvm-config --ldflags</span></span><br><span class="line"><span class="comment"># /home/wutang/Desktop/llvm-project-16.0.0.src/build/lib</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># /home/wutang/Desktop/llvm-project-16.0.0.src/build/bin/llvm-config --cxxflags</span></span><br><span class="line"><span class="built_in">cd</span> /home/wutang/Desktop/google_afl/llvm_mode</span><br><span class="line">make  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># use llvm11</span></span><br><span class="line"><span class="built_in">export</span> LLVM_CONFIG=<span class="string">&quot;llvm-config-11&quot;</span></span><br><span class="line"><span class="built_in">export</span> CC=clang-11 CXX=clang++-11</span><br><span class="line"><span class="comment"># apt install clang-11</span></span><br><span class="line"><span class="comment"># sudo ln -s /usr/bin/clang-11 /usr/bin/clang</span></span><br><span class="line"><span class="comment"># sudo ln -s /usr/bin/clang /usr/bin/clang++</span></span><br><span class="line"><span class="built_in">cd</span> /home/wutang/Desktop/google_afl/llvm_mode</span><br><span class="line">make all  <span class="comment"># AFL_TRACE_PC=1 不指定就用so插装</span></span><br><span class="line"></span><br><span class="line">clang++-11 `llvm-config-11 --cxxflags` -Wl,-znodelete -fno-rtti -fpic -funroll-loops  -Wall -D_FORTIFY_SOURCE=2 -g -Wno-pointer-sign -DVERSION=\&quot;2.57b\&quot; -Wno-variadic-macros -shared afl-llvm-pass.so.cc -o ../afl-llvm-pass.so `llvm-config-11 --ldflags`</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果启用 AFL_TRACE_PC 就不使用so插装了</span></span><br><span class="line">-DUSE_TRACE_PC=1 </span><br><span class="line"></span><br><span class="line">clang -O3 -funroll-loops -Wall -D_FORTIFY_SOURCE=2 -g -Wno-pointer-sign -DAFL_PATH=\&quot;/usr/local/lib/afl\&quot; -DBIN_PATH=\&quot;/usr/local/bin\&quot; -DVERSION=\&quot;2.57b\&quot;  afl-clang-fast.c -o ../afl-clang-fast </span><br><span class="line"><span class="built_in">ln</span> -sf afl-clang-fast ../afl-clang-fast++</span><br><span class="line"></span><br><span class="line">clang++ `llvm-config-11 --cxxflags` -Wl,-znodelete -fno-rtti -fpic -O3 -funroll-loops -Wall -D_FORTIFY_SOURCE=2 -g -Wno-pointer-sign -DVERSION=\&quot;2.57b\&quot; -Wno-variadic-macros -shared afl-llvm-pass.so.cc -o ../afl-llvm-pass.so `llvm-config-11 --ldflags`</span><br><span class="line"></span><br><span class="line">clang -O3 -funroll-loops -Wall -D_FORTIFY_SOURCE=2 -g -Wno-pointer-sign -DAFL_PATH=\&quot;/usr/local/lib/afl\&quot; -DBIN_PATH=\&quot;/usr/local/bin\&quot; -DVERSION=\&quot;2.57b\&quot;  -fPIC -c afl-llvm-rt.o.c -o ../afl-llvm-rt.o</span><br><span class="line"></span><br><span class="line">[*] Testing the CC wrapper and instrumentation output...</span><br><span class="line"><span class="built_in">unset</span> AFL_USE_ASAN AFL_USE_MSAN AFL_INST_RATIO; AFL_QUIET=1 AFL_PATH=. AFL_CC=clang ../afl-clang-fast -O3 -funroll-loops -Wall -D_FORTIFY_SOURCE=2 -g -Wno-pointer-sign -DAFL_PATH=\&quot;/usr/local/lib/afl\&quot; -DBIN_PATH=\&quot;/usr/local/bin\&quot; -DVERSION=\&quot;2.57b\&quot;  ../test-instr.c -o test-instr </span><br><span class="line">argv :</span><br><span class="line">../afl-clang-fast -O3 -funroll-loops -Wall -D_FORTIFY_SOURCE=2 -g -Wno-pointer-sign -DAFL_PATH=<span class="string">&quot;/usr/local/lib/afl&quot;</span> -DBIN_PATH=<span class="string">&quot;/usr/local/bin&quot;</span> -DVERSION=<span class="string">&quot;2.57b&quot;</span> ../test-instr.c -o test-instr </span><br><span class="line"></span><br><span class="line">cc_params:</span><br><span class="line">clang -Xclang -load -Xclang ../afl-llvm-pass.so -Qunused-arguments -O3 -funroll-loops -Wall -D_FORTIFY_SOURCE=2 -g -Wno-pointer-sign -DAFL_PATH=<span class="string">&quot;/usr/local/lib/afl&quot;</span> -DBIN_PATH=<span class="string">&quot;/usr/local/bin&quot;</span> -DVERSION=<span class="string">&quot;2.57b&quot;</span> ../test-instr.c -o test-instr -g -O3 -funroll-loops -D__AFL_HAVE_MANUAL_CONTROL=1 -D__AFL_COMPILER=1 -DFUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION=1 -D__AFL_LOOP(_A)=(&#123; static volatile char *_B __attribute__((used));  _B = (char*)<span class="string">&quot;##SIG_AFL_PERSISTENT##&quot;</span>; __attribute__((visibility(&quot;default&quot;))) int _L(unsigned int) __asm__(<span class="string">&quot;__afl_persistent_loop&quot;</span>); _L(_A); &#125;) -D__AFL_INIT()=<span class="keyword">do</span> &#123; static volatile char *_A __attribute__((used));  _A = (char*)<span class="string">&quot;##SIG_AFL_DEFER_FORKSRV##&quot;</span>; __attribute__((visibility(&quot;default&quot;))) void _I(void) __asm__(<span class="string">&quot;__afl_manual_init&quot;</span>); _I(); &#125; <span class="keyword">while</span> (0) ../afl-llvm-rt.o </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[+] afl llvm pass runOnModule tragger</span><br><span class="line">afl-llvm-pass 2.57b by &lt;lszekeres@google.com&gt;</span><br><span class="line">[+] Instrumented 6 locations (non-hardened mode, ratio 100%).</span><br><span class="line">[+] afl llvm pass runOnModule over</span><br><span class="line"></span><br><span class="line">../afl-showmap -m none -q -o .test-instr0 ./test-instr &lt; /dev/null</span><br><span class="line"><span class="built_in">echo</span> 1 | ../afl-showmap -m none -q -o .test-instr1 ./test-instr</span><br><span class="line">[+] All right, the instrumentation seems to be working!</span><br><span class="line">[+] All <span class="keyword">done</span>! You can now use <span class="string">&#x27;../afl-clang-fast&#x27;</span> to compile programs.</span><br></pre></td></tr></table></figure>

<h3 id="测试命令"><a href="#测试命令" class="headerlink" title="测试命令"></a>测试命令</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">cd /home/wutang/Desktop/google_afl</span><br><span class="line">unset AFL_USE_ASAN AFL_USE_MSAN AFL_INST_RATIO; </span><br><span class="line"><span class="keyword">export</span> AFL_PATH=. AFL_CC=clang </span><br><span class="line"># AFL_QUIET=<span class="number">1</span> </span><br><span class="line">build_debug/afl-clang-fast -O3 -funroll-loops -Wall -D_FORTIFY_SOURCE=<span class="number">2</span> -g -Wno-pointer-sign -DAFL_PATH=\<span class="string">&quot;/usr/local/lib/afl\&quot; -DBIN_PATH=\&quot;/usr/local/bin\&quot; -DVERSION=\&quot;2.57b\&quot; test-instr.c -o test-instr </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">-&gt;</span></span><br><span class="line"><span class="string">build_debug/afl-clang-fast -O3 -funroll-loops -Wall -D_FORTIFY_SOURCE=2 -g -Wno-pointer-sign -DAFL_PATH=&quot;</span>/usr/local/lib/afl<span class="string">&quot; -DBIN_PATH=&quot;</span>/usr/local/bin<span class="string">&quot; -DVERSION=&quot;</span><span class="number">2.57b</span><span class="string">&quot; test-instr.c -o test-instr </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">clang -Xclang -load -Xclang ./afl-llvm-pass.so -Qunused-arguments -O3 -funroll-loops -Wall -D_FORTIFY_SOURCE=2 -g -Wno-pointer-sign -DAFL_PATH=&quot;</span>/usr/local/lib/afl<span class="string">&quot; -DBIN_PATH=&quot;</span>/usr/local/bin<span class="string">&quot; -DVERSION=&quot;</span><span class="number">2.57b</span><span class="string">&quot; test-instr.c -o test-instr -g -O3 -funroll-loops -D__AFL_HAVE_MANUAL_CONTROL=1 -D__AFL_COMPILER=1 -DFUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION=1 -D__AFL_LOOP(_A)=(&#123; static volatile char *_B __attribute__((used));  _B = (char*)&quot;</span>##SIG_AFL_PERSISTENT##<span class="string">&quot;; __attribute__((visibility(&quot;</span><span class="keyword">default</span><span class="string">&quot;))) int _L(unsigned int) __asm__(&quot;</span>__afl_persistent_loop<span class="string">&quot;); _L(_A); &#125;) -D__AFL_INIT()=do &#123; static volatile char *_A __attribute__((used));  _A = (char*)&quot;</span>##SIG_AFL_DEFER_FORKSRV##<span class="string">&quot;; __attribute__((visibility(&quot;</span><span class="keyword">default</span><span class="string">&quot;))) void _I(void) __asm__(&quot;</span>__afl_manual_init<span class="string">&quot;); _I(); &#125; while (0) ./afl-llvm-rt.o </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">-&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">clang -Xclang -load -Xclang /home/wutang/Desktop/google_afl/afl-llvm-pass.so -Qunused-arguments -O3 -funroll-loops -Wall -D_FORTIFY_SOURCE=2 -g -Wno-pointer-sign -DAFL_PATH=\&quot;/usr/local/lib/afl\&quot; -DBIN_PATH=\&quot;/usr/local/bin\&quot; -DVERSION=\&quot;2.57b\&quot; test-instr.c -o test-instr -g -O3 -funroll-loops -D__AFL_HAVE_MANUAL_CONTROL=1 -D__AFL_COMPILER=1 -DFUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION=1 -D&quot;</span>__AFL_LOOP\(_A\)<span class="string">&quot;=&quot;</span>\(\&#123; <span class="type">static</span> <span class="keyword">volatile</span> <span class="type">char</span> *_B __attribute__\(\(used\)\);  _B = \(<span class="type">char</span>*\)\<span class="string">&quot;##SIG_AFL_PERSISTENT##\&quot;; __attribute__\(\(visibility\(\&quot;default\&quot;\)\)\) int _L\(unsigned int\) __asm__\(\&quot;__afl_persistent_loop\&quot;\); _L\(_A\); \&#125;\)&quot;</span> -D<span class="string">&quot;__AFL_INIT\(\)&quot;</span>=<span class="string">&quot;do \&#123; static volatile char *_A __attribute__\(\(used\)\);  _A = \(char*\)\&quot;##SIG_AFL_DEFER_FORKSRV##\&quot;; __attribute__\(\(visibility\(\&quot;default\&quot;\)\)\) void _I\(void\) __asm__\(\&quot;__afl_manual_init\&quot;\); _I\(\); \&#125; while \(0\)&quot;</span> /home/wutang/Desktop/google_afl/afl-llvm-rt.o</span><br></pre></td></tr></table></figure>

<h3 id="find-obj"><a href="#find-obj" class="headerlink" title="find_obj"></a>find_obj</h3><ul>
<li>该函数用于查找 AFL 的运行时库文件<code>afl-llvm-rt.o</code> 路径。它首先尝试从环境变量 <code>AFL_PATH</code> 中获取路径，然后尝试从可执行文件的路径中获取路径，最后尝试使用默认路径 <code>AFL_PATH</code> 来查找运行时库文件。</li>
<li>获取环境变量 <code>AFL_PATH</code> 寻找<code>afl-llvm-rt.o</code>文件存储路径到 obj_path</li>
<li>若没有<code>AFL_PATH</code> 找 <code>argv[0]</code> 寻找<code>afl-llvm-rt.o</code>文件存储路径到 obj_path</li>
</ul>
<h3 id="edit-params-1"><a href="#edit-params-1" class="headerlink" title="edit_params"></a>edit_params</h3><ul>
<li>该函数用于编辑编译器参数，将必要的参数添加到 <code>cc_params</code> 数组中。它会根据参数、环境变量和其他设置来添加编译器参数，如 ASAN（AddressSanitizer）和 MSAN（MemorySanitizer）的参数、优化参数、路径等。</li>
<li><code>argv[0]</code> 判断<ul>
<li>如果是<code>afl-clang-fast++</code>  获取环境变量 <code>AFL_CXX</code></li>
<li>否则获取环境变量 <code>AFL_CC</code></li>
</ul>
</li>
<li>如果编译时设置了 <code>USE_TRACE_PC</code>  两种方式<ul>
<li>USE_TRACE_PC 添加参数 <code>-fsanitize-coverage=trace-pc-guard</code><ul>
<li>此时非android 指定 <code>-mllvm -sanitizer-coverage-block-threshold=0</code><ul>
<li>LLVM replaced “-sanitizer-coverage-block-threshold” with “<code>--sanitizer-coverage-level</code>“ in certain commit (probably in LLVM 5.0) and make it default to 0.</li>
</ul>
</li>
</ul>
</li>
<li>非USE_TRACE_PC  否则使用 添加llvm 加载pass参数的方式<ul>
<li><code>-Xclang -load -Xclang /home/wutang/Desktop/google_afl/afl-llvm-pass.so</code></li>
</ul>
</li>
</ul>
</li>
<li>接着过滤参数<ul>
<li>设置bit_mode&#x3D;32 如果遇到参数如下<ul>
<li><code>-m32</code></li>
<li><code>armv7a-linux-androideabi</code></li>
</ul>
</li>
<li>设置 bit_mode &#x3D; 64 如果遇到参数如下<ul>
<li><code>-m64</code></li>
</ul>
</li>
<li>设置 x_set&#x3D;1 如果遇到参数如下<ul>
<li><code>-x</code>  后续设置 <code>-x none</code></li>
</ul>
</li>
<li><code>-fsanitize=address</code>or  <code>-fsanitize=memory</code><ul>
<li>设置 asan_set &#x3D; 1</li>
</ul>
</li>
<li><code>FORTIFY_SOURCE</code><ul>
<li>设置 fortify_set &#x3D; 1</li>
</ul>
</li>
<li>continue 如果遇到参数如下<ul>
<li><code>-Wl,-z,defs</code></li>
<li>或者 <code>-Wl,--no-undefined</code></li>
</ul>
</li>
</ul>
</li>
<li>获取环境变量 <code>AFL_HARDEN</code><ul>
<li><code>-fstack-protector-all</code></li>
<li>如果没设置了 fortify_set  设置 <code>-D_FORTIFY_SOURCE=2</code></li>
</ul>
</li>
<li>asan和 msan 和 AFL_HARDEN 不能同时指定<ul>
<li>获取环境变量 <code>AFL_USE_ASAN</code><ul>
<li>设置 <code>-U_FORTIFY_SOURCE</code> <code>-fsanitize=address</code></li>
</ul>
</li>
<li>获取环境变量 <code>AFL_USE_MSAN</code><ul>
<li>设置 <code>-U_FORTIFY_SOURCE</code> <code>-fsanitize=memory</code></li>
</ul>
</li>
</ul>
</li>
<li>如果没设置环境变量 <code>AFL_DONT_OPTIMIZE</code><ul>
<li>设置 <code>-g</code>  <code>-O3</code> <code>-funroll-loops</code></li>
</ul>
</li>
<li>如果设置了环境变量 <code>AFL_NO_BUILTIN</code><ul>
<li>“-fno-builtin-strcmp”, “-fno-builtin-strncmp”, “-fno-builtin-strcasecmp”, “-fno-builtin-strncasecmp”, “-fno-builtin-memcmp” 比afl-gcc少了两个</li>
</ul>
</li>
<li>设置参数 <code>-D__AFL_HAVE_MANUAL_CONTROL=1 -D__AFL_COMPILER=1 -DFUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION=1</code></li>
<li>通过宏添加代码</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">-<span class="built_in">D__AFL_LOOP</span>(_A)=(&#123; <span class="type">static</span> <span class="keyword">volatile</span> <span class="type">char</span> *_B __attribute__((used));  _B = (<span class="type">char</span>*)<span class="string">&quot;##SIG_AFL_PERSISTENT##&quot;</span>; __attribute__((<span class="built_in">visibility</span>(<span class="string">&quot;default&quot;</span>))) <span class="type">int</span> _L(<span class="type">unsigned</span> <span class="type">int</span>) __asm__(<span class="string">&quot;__afl_persistent_loop&quot;</span>); _L(_A); &#125;) -<span class="built_in">D__AFL_INIT</span>()=<span class="keyword">do</span> &#123; <span class="type">static</span> <span class="keyword">volatile</span> <span class="type">char</span> *_A __attribute__((used));  _A = (<span class="type">char</span>*)<span class="string">&quot;##SIG_AFL_DEFER_FORKSRV##&quot;</span>; __attribute__((<span class="built_in">visibility</span>(<span class="string">&quot;default&quot;</span>))) <span class="type">void</span> _I(<span class="type">void</span>) __asm__(<span class="string">&quot;__afl_manual_init&quot;</span>); _I(); &#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">-&gt;</span><br><span class="line">__AFL_LOOP(_A)=(&#123; \</span><br><span class="line">  <span class="type">static</span> <span class="keyword">volatile</span> <span class="type">char</span> *_B __attribute__((used)); \</span><br><span class="line">  _B = (<span class="type">char</span>*)<span class="string">&quot;##SIG_AFL_PERSISTENT##&quot;</span>; \</span><br><span class="line">  __attribute__((<span class="built_in">visibility</span>(<span class="string">&quot;default&quot;</span>))) <span class="type">int</span> _L(<span class="type">unsigned</span> <span class="type">int</span>) \</span><br><span class="line">  __asm__(<span class="string">&quot;__afl_persistent_loop&quot;</span>);  <span class="comment">// 这里是调用afl-llvm-rt.o.c的代码</span></span><br><span class="line">  _L(_A); </span><br><span class="line">&#125;) </span><br><span class="line">__AFL_INIT()=<span class="keyword">do</span> &#123; \</span><br><span class="line">  <span class="type">static</span> <span class="keyword">volatile</span> <span class="type">char</span> *_A __attribute__((used));  \</span><br><span class="line">  _A = (<span class="type">char</span>*)<span class="string">&quot;##SIG_AFL_DEFER_FORKSRV##&quot;</span>; \</span><br><span class="line">  __attribute__((<span class="built_in">visibility</span>(<span class="string">&quot;default&quot;</span>))) <span class="type">void</span> _I(<span class="type">void</span>) \</span><br><span class="line">    __asm__(<span class="string">&quot;__afl_manual_init&quot;</span>);  <span class="comment">// 这里是调用afl-llvm-rt.o.c的代码</span></span><br><span class="line">  _I(); </span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>判断-m32 -m64 架构添加对应架构<code>afl-llvm-rt-XX.o</code><ul>
<li>添加代码到目标下,这里是 <code>/home/wutang/Desktop/google_afl/afl-llvm-rt.o</code></li>
</ul>
</li>
<li>最后添加NULL</li>
</ul>
<h3 id="非USE-TRACE-PC方式-使用llvmpass"><a href="#非USE-TRACE-PC方式-使用llvmpass" class="headerlink" title="非USE_TRACE_PC方式-使用llvmpass"></a>非USE_TRACE_PC方式-使用llvmpass</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">cd /home/wutang/Desktop/google_afl</span><br><span class="line">clang -Xclang -load -Xclang /home/wutang/Desktop/google_afl/afl-llvm-pass.so -Qunused-arguments -O3 -funroll-loops -Wall -D_FORTIFY_SOURCE=<span class="number">2</span> -g -Wno-pointer-sign -DAFL_PATH=\<span class="string">&quot;/usr/local/lib/afl\&quot; -DBIN_PATH=\&quot;/usr/local/bin\&quot; -DVERSION=\&quot;2.57b\&quot; test-instr.c -o test-instr -g -O3 -funroll-loops -D__AFL_HAVE_MANUAL_CONTROL=1 -D__AFL_COMPILER=1 -DFUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION=1 -D&quot;</span>__AFL_LOOP\(_A\)<span class="string">&quot;=&quot;</span>\(\&#123; <span class="type">static</span> <span class="keyword">volatile</span> <span class="type">char</span> *_B __attribute__\(\(used\)\);  _B = \(<span class="type">char</span>*\)\<span class="string">&quot;##SIG_AFL_PERSISTENT##\&quot;; __attribute__\(\(visibility\(\&quot;default\&quot;\)\)\) int _L\(unsigned int\) __asm__\(\&quot;__afl_persistent_loop\&quot;\); _L\(_A\); \&#125;\)&quot;</span> -D<span class="string">&quot;__AFL_INIT\(\)&quot;</span>=<span class="string">&quot;do \&#123; static volatile char *_A __attribute__\(\(used\)\);  _A = \(char*\)\&quot;##SIG_AFL_DEFER_FORKSRV##\&quot;; __attribute__\(\(visibility\(\&quot;default\&quot;\)\)\) void _I\(void\) __asm__\(\&quot;__afl_manual_init\&quot;\); _I\(\); \&#125; while \(0\)&quot;</span> /home/wutang/Desktop/google_afl/afl-llvm-rt.o</span><br><span class="line"></span><br><span class="line">gdb-pwndbg /usr/bin/clang</span><br></pre></td></tr></table></figure>

<ul>
<li>afl-llvm-pass.so<ul>
<li><code>AFLCoverage::runOnModule</code></li>
<li>获取环境变量 <code>AFL_INST_RATIO</code><ul>
<li>作为 inst_ratio</li>
</ul>
</li>
<li>创建全局变量 <code>__afl_area_ptr</code> AFLMapPtr  <code>__afl_prev_loc</code>AFLPrevLoc<ul>
<li>分别用于指向 AFL 的共享内存区域和上一个位置。</li>
</ul>
</li>
<li>2的16次方&#x3D;65536 取随机数<ul>
<li><code>unsigned int cur_loc = AFL_R(MAP_SIZE);</code></li>
</ul>
</li>
<li>将之前加载的值 <code>PrevLoc</code> 进行零扩展，转换为一个更大的整数类型。这里使用 <code>getInt32Ty()</code> 是为了将之前加载的值转换为 32 位整数类型。</li>
<li>遍历函数和基本块，为每个基本块插入 AFL 插桩代码。通过计算随机数和插桩比例，确定是否要在当前基本块插入插桩代码。插桩代码会更新覆盖地图（bitmap）。</li>
<li>输出插桩结果，显示已插桩的基本块数量和插桩模式等信息</li>
</ul>
</li>
<li>总的来说就是通过遍历每个基本块，向其中插入实现了如下伪代码功能的instruction ir来进行插桩。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">cur_location = &lt;COMPILE_TIME_RANDOM&gt;;   </span><br><span class="line">shared_mem[cur_location ^ prev_location]++;   </span><br><span class="line">prev_location = cur_location &gt;&gt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">cur_location = &lt;COMPILE_TIME_RANDOM&gt;</span><br><span class="line">__afl_area_ptr[cur_location ^ __afl_prev_loc]++</span><br><span class="line">__afl_prev_loc = cur_location &gt;&gt; <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<h4 id="test-instr-c插桩前后IR对比"><a href="#test-instr-c插桩前后IR对比" class="headerlink" title="test-instr.c插桩前后IR对比"></a>test-instr.c插桩前后IR对比</h4><ul>
<li>将pass加入clang passmanager 即可调试pass</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> </span>&#123;</span><br><span class="line">  <span class="type">char</span> buf[<span class="number">8</span>];</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">read</span>(<span class="number">0</span>, buf, <span class="number">8</span>) &lt; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hum?\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (buf[<span class="number">0</span>] == <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Looks like a zero to me!\n&quot;</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;A non-zero value? How quaint!\n&quot;</span>);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>插桩前的ir</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">; ModuleID = <span class="string">&#x27;nopt_test-instr.ll&#x27;</span>  </span><br><span class="line">source_filename = <span class="string">&quot;test-instr.c&quot;</span>  </span><br><span class="line">target datalayout = <span class="string">&quot;e-m:o-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128&quot;</span>  </span><br><span class="line">target triple = <span class="string">&quot;x86_64-apple-macosx10.15.0&quot;</span>  </span><br><span class="line">  </span><br><span class="line">@.str = <span class="keyword">private</span> unnamed_addr constant [<span class="number">6</span> x i8] c<span class="string">&quot;Hum?\0A\00&quot;</span>, align <span class="number">1</span>  </span><br><span class="line">@.str<span class="number">.1</span> = <span class="keyword">private</span> unnamed_addr constant [<span class="number">26</span> x i8] c<span class="string">&quot;Looks like a zero to me!\0A\00&quot;</span>, align <span class="number">1</span>  </span><br><span class="line">@.str<span class="number">.2</span> = <span class="keyword">private</span> unnamed_addr constant [<span class="number">31</span> x i8] c<span class="string">&quot;A non-zero value? How quaint!\0A\00&quot;</span>, align <span class="number">1</span>  </span><br><span class="line">  </span><br><span class="line">; Function Attrs: noinline nounwind ssp uwtable  </span><br><span class="line">define i32 @<span class="built_in">main</span>(i32 %<span class="number">0</span>, i8** %<span class="number">1</span>) #<span class="number">0</span> &#123;  </span><br><span class="line">  %<span class="number">3</span> = alloca [<span class="number">8</span> x i8], align <span class="number">1</span>  </span><br><span class="line">  %<span class="number">4</span> = getelementptr inbounds [<span class="number">8</span> x i8], [<span class="number">8</span> x i8]* %<span class="number">3</span>, i64 <span class="number">0</span>, i64 <span class="number">0</span>  </span><br><span class="line">  %<span class="number">5</span> = call i64 @<span class="string">&quot;\01_read&quot;</span>(i32 <span class="number">0</span>, i8* %<span class="number">4</span>, i64 <span class="number">8</span>)  </span><br><span class="line">  %<span class="number">6</span> = icmp slt i64 %<span class="number">5</span>, <span class="number">1</span>  </span><br><span class="line">  br i1 %<span class="number">6</span>, label %<span class="number">7</span>, label %<span class="number">9</span>  </span><br><span class="line">  </span><br><span class="line"><span class="number">7</span>:                                                ; preds = %<span class="number">2</span>  </span><br><span class="line">  %<span class="number">8</span> = call <span class="built_in">i32</span> (i8*, ...) @<span class="built_in">printf</span>(i8* getelementptr <span class="built_in">inbounds</span> ([<span class="number">6</span> x i8], [<span class="number">6</span> x i8]* @.str, i64 <span class="number">0</span>, i64 <span class="number">0</span>))  </span><br><span class="line">  call <span class="type">void</span> @<span class="built_in">exit</span>(i32 <span class="number">1</span>) #<span class="number">3</span>  </span><br><span class="line">  unreachable  </span><br><span class="line">  </span><br><span class="line"><span class="number">9</span>:                                                ; preds = %<span class="number">2</span>  </span><br><span class="line">  %<span class="number">10</span> = getelementptr inbounds [<span class="number">8</span> x i8], [<span class="number">8</span> x i8]* %<span class="number">3</span>, i64 <span class="number">0</span>, i64 <span class="number">0</span>  </span><br><span class="line">  %<span class="number">11</span> = load i8, i8* %<span class="number">10</span>, align <span class="number">1</span>  </span><br><span class="line">  %<span class="number">12</span> = sext i8 %<span class="number">11</span> to i32  </span><br><span class="line">  %<span class="number">13</span> = icmp eq i32 %<span class="number">12</span>, <span class="number">48</span>  </span><br><span class="line">  br i1 %<span class="number">13</span>, label %<span class="number">14</span>, label %<span class="number">16</span>  </span><br><span class="line">  </span><br><span class="line"><span class="number">14</span>:                                               ; preds = %<span class="number">9</span>  </span><br><span class="line">  %<span class="number">15</span> = call <span class="built_in">i32</span> (i8*, ...) @<span class="built_in">printf</span>(i8* getelementptr <span class="built_in">inbounds</span> ([<span class="number">26</span> x i8], [<span class="number">26</span> x i8]* @.str<span class="number">.1</span>, i64 <span class="number">0</span>, i64 <span class="number">0</span>))  </span><br><span class="line">  br label %<span class="number">18</span>  </span><br><span class="line">  </span><br><span class="line"><span class="number">16</span>:                                               ; preds = %<span class="number">9</span>  </span><br><span class="line">  %<span class="number">17</span> = call <span class="built_in">i32</span> (i8*, ...) @<span class="built_in">printf</span>(i8* getelementptr <span class="built_in">inbounds</span> ([<span class="number">31</span> x i8], [<span class="number">31</span> x i8]* @.str<span class="number">.2</span>, i64 <span class="number">0</span>, i64 <span class="number">0</span>))  </span><br><span class="line">  br label %<span class="number">18</span>  </span><br><span class="line">  </span><br><span class="line"><span class="number">18</span>:                                               ; preds = %<span class="number">16</span>, %<span class="number">14</span>  </span><br><span class="line">  call <span class="type">void</span> @<span class="built_in">exit</span>(i32 <span class="number">0</span>) #<span class="number">3</span>  </span><br><span class="line">  unreachable  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">declare i64 @<span class="string">&quot;\01_read&quot;</span>(i32, i8*, i64) #<span class="number">1</span>  </span><br><span class="line">  </span><br><span class="line">declare i32 @<span class="built_in">printf</span>(i8*, ...) #<span class="number">1</span>  </span><br><span class="line">  </span><br><span class="line">; Function Attrs: noreturn  </span><br><span class="line">declare <span class="type">void</span> @<span class="built_in">exit</span>(i32) #<span class="number">2</span>  </span><br><span class="line">  </span><br><span class="line">attributes #<span class="number">0</span> = &#123; noinline nounwind ssp uwtable <span class="string">&quot;correctly-rounded-divide-sqrt-fp-math&quot;</span>=<span class="string">&quot;false&quot;</span> <span class="string">&quot;disable-tail-calls&quot;</span>=<span class="string">&quot;false&quot;</span> <span class="string">&quot;frame-pointer&quot;</span>=<span class="string">&quot;all&quot;</span> <span class="string">&quot;less-precise-fpmad&quot;</span>=<span class="string">&quot;false&quot;</span> <span class="string">&quot;min-legal-vector-width&quot;</span>=<span class="string">&quot;0&quot;</span> <span class="string">&quot;no-infs-fp-math&quot;</span>=<span class="string">&quot;false&quot;</span> <span class="string">&quot;no-jump-tables&quot;</span>=<span class="string">&quot;false&quot;</span> <span class="string">&quot;no-nans-fp-math&quot;</span>=<span class="string">&quot;false&quot;</span> <span class="string">&quot;no-signed-zeros-fp-math&quot;</span>=<span class="string">&quot;false&quot;</span> <span class="string">&quot;no-trapping-math&quot;</span>=<span class="string">&quot;false&quot;</span> <span class="string">&quot;stack-protector-buffer-size&quot;</span>=<span class="string">&quot;8&quot;</span> <span class="string">&quot;target-cpu&quot;</span>=<span class="string">&quot;penryn&quot;</span> <span class="string">&quot;target-features&quot;</span>=<span class="string">&quot;+cx16,+cx8,+fxsr,+mmx,+sahf,+sse,+sse2,+sse3,+sse4.1,+ssse3,+x87&quot;</span> <span class="string">&quot;unsafe-fp-math&quot;</span>=<span class="string">&quot;false&quot;</span> <span class="string">&quot;use-soft-float&quot;</span>=<span class="string">&quot;false&quot;</span> &#125;  </span><br><span class="line">attributes #<span class="number">1</span> = &#123; <span class="string">&quot;correctly-rounded-divide-sqrt-fp-math&quot;</span>=<span class="string">&quot;false&quot;</span> <span class="string">&quot;disable-tail-calls&quot;</span>=<span class="string">&quot;false&quot;</span> <span class="string">&quot;frame-pointer&quot;</span>=<span class="string">&quot;all&quot;</span> <span class="string">&quot;less-precise-fpmad&quot;</span>=<span class="string">&quot;false&quot;</span> <span class="string">&quot;no-infs-fp-math&quot;</span>=<span class="string">&quot;false&quot;</span> <span class="string">&quot;no-nans-fp-math&quot;</span>=<span class="string">&quot;false&quot;</span> <span class="string">&quot;no-signed-zeros-fp-math&quot;</span>=<span class="string">&quot;false&quot;</span> <span class="string">&quot;no-trapping-math&quot;</span>=<span class="string">&quot;false&quot;</span> <span class="string">&quot;stack-protector-buffer-size&quot;</span>=<span class="string">&quot;8&quot;</span> <span class="string">&quot;target-cpu&quot;</span>=<span class="string">&quot;penryn&quot;</span> <span class="string">&quot;target-features&quot;</span>=<span class="string">&quot;+cx16,+cx8,+fxsr,+mmx,+sahf,+sse,+sse2,+sse3,+sse4.1,+ssse3,+x87&quot;</span> <span class="string">&quot;unsafe-fp-math&quot;</span>=<span class="string">&quot;false&quot;</span> <span class="string">&quot;use-soft-float&quot;</span>=<span class="string">&quot;false&quot;</span> &#125;  </span><br><span class="line">attributes #<span class="number">2</span> = &#123; noreturn <span class="string">&quot;correctly-rounded-divide-sqrt-fp-math&quot;</span>=<span class="string">&quot;false&quot;</span> <span class="string">&quot;disable-tail-calls&quot;</span>=<span class="string">&quot;false&quot;</span> <span class="string">&quot;frame-pointer&quot;</span>=<span class="string">&quot;all&quot;</span> <span class="string">&quot;less-precise-fpmad&quot;</span>=<span class="string">&quot;false&quot;</span> <span class="string">&quot;no-infs-fp-math&quot;</span>=<span class="string">&quot;false&quot;</span> <span class="string">&quot;no-nans-fp-math&quot;</span>=<span class="string">&quot;false&quot;</span> <span class="string">&quot;no-signed-zeros-fp-math&quot;</span>=<span class="string">&quot;false&quot;</span> <span class="string">&quot;no-trapping-math&quot;</span>=<span class="string">&quot;false&quot;</span> <span class="string">&quot;stack-protector-buffer-size&quot;</span>=<span class="string">&quot;8&quot;</span> <span class="string">&quot;target-cpu&quot;</span>=<span class="string">&quot;penryn&quot;</span> <span class="string">&quot;target-features&quot;</span>=<span class="string">&quot;+cx16,+cx8,+fxsr,+mmx,+sahf,+sse,+sse2,+sse3,+sse4.1,+ssse3,+x87&quot;</span> <span class="string">&quot;unsafe-fp-math&quot;</span>=<span class="string">&quot;false&quot;</span> <span class="string">&quot;use-soft-float&quot;</span>=<span class="string">&quot;false&quot;</span> &#125;  </span><br><span class="line">attributes #<span class="number">3</span> = &#123; noreturn &#125;  </span><br><span class="line">  </span><br><span class="line">!llvm.<span class="keyword">module</span>.flags = !&#123;!<span class="number">0</span>, !<span class="number">1</span>&#125;  </span><br><span class="line">!llvm.ident = !&#123;!<span class="number">2</span>&#125;  </span><br><span class="line">  </span><br><span class="line">!<span class="number">0</span> = !&#123;i32 <span class="number">1</span>, !<span class="string">&quot;wchar_size&quot;</span>, i32 <span class="number">4</span>&#125;  </span><br><span class="line">!<span class="number">1</span> = !&#123;i32 <span class="number">7</span>, !<span class="string">&quot;PIC Level&quot;</span>, i32 <span class="number">2</span>&#125;  </span><br><span class="line">!<span class="number">2</span> = !&#123;!<span class="string">&quot;clang version 10.0.0 &quot;</span>&#125;  </span><br></pre></td></tr></table></figure>

<ul>
<li>插桩后的ir</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">; ModuleID = <span class="string">&#x27;m2r_nopt_test-instr.ll&#x27;</span>\</span><br><span class="line">source_filename = <span class="string">&quot;test-instr.c&quot;</span>\</span><br><span class="line">target datalayout = <span class="string">&quot;e-m:o-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128&quot;</span>\</span><br><span class="line">target triple = <span class="string">&quot;x86_64-apple-macosx10.15.0&quot;</span></span><br><span class="line"></span><br><span class="line">@.str = <span class="keyword">private</span> unnamed_addr constant [<span class="number">6</span> x i8] c<span class="string">&quot;Hum?\0A\00&quot;</span>, align <span class="number">1</span>\</span><br><span class="line">@.str<span class="number">.1</span> = <span class="keyword">private</span> unnamed_addr constant [<span class="number">26</span> x i8] c<span class="string">&quot;Looks like a zero to me!\0A\00&quot;</span>, align <span class="number">1</span>\</span><br><span class="line">@.str<span class="number">.2</span> = <span class="keyword">private</span> unnamed_addr constant [<span class="number">31</span> x i8] c<span class="string">&quot;A non-zero value? How quaint!\0A\00&quot;</span>, align <span class="number">1</span>\</span><br><span class="line">@__afl_area_ptr = external global i8*\</span><br><span class="line">@__afl_prev_loc = external <span class="keyword">thread_local</span> global i32</span><br><span class="line"></span><br><span class="line">; Function Attrs: noinline nounwind ssp uwtable\</span><br><span class="line">define i32 @<span class="built_in">main</span>(i32 %<span class="number">0</span>, i8** %<span class="number">1</span>) #<span class="number">0</span> &#123;\</span><br><span class="line">%<span class="number">3</span> = load i32, i32* @__afl_prev_loc, !nosanitize !<span class="number">3</span>\</span><br><span class="line">%<span class="number">4</span> = load i8*, i8** @__afl_area_ptr, !nosanitize !<span class="number">3</span>\</span><br><span class="line">%<span class="number">5</span> = <span class="keyword">xor</span> i32 %<span class="number">3</span>, <span class="number">17767</span>\</span><br><span class="line">%<span class="number">6</span> = getelementptr i8, i8* %<span class="number">4</span>, i32 %<span class="number">5</span>\</span><br><span class="line">%<span class="number">7</span> = load i8, i8* %<span class="number">6</span>, !nosanitize !<span class="number">3</span>\</span><br><span class="line">%<span class="number">8</span> = add i8 %<span class="number">7</span>, <span class="number">1</span>\</span><br><span class="line">store i8 %<span class="number">8</span>, i8* %<span class="number">6</span>, !nosanitize !<span class="number">3</span>\</span><br><span class="line">store i32 <span class="number">8883</span>, i32* @__afl_prev_loc, !nosanitize !<span class="number">3</span>\</span><br><span class="line">%<span class="number">9</span> = alloca [<span class="number">8</span> x i8], align <span class="number">1</span>\</span><br><span class="line">%<span class="number">10</span> = getelementptr inbounds [<span class="number">8</span> x i8], [<span class="number">8</span> x i8]* %<span class="number">9</span>, i64 <span class="number">0</span>, i64 <span class="number">0</span>\</span><br><span class="line">%<span class="number">11</span> = call i64 @<span class="string">&quot;\01_read&quot;</span>(i32 <span class="number">0</span>, i8* %<span class="number">10</span>, i64 <span class="number">8</span>)\</span><br><span class="line">%<span class="number">12</span> = icmp slt i64 %<span class="number">11</span>, <span class="number">1</span>\</span><br><span class="line">br i1 %<span class="number">12</span>, label %<span class="number">13</span>, label %<span class="number">21</span></span><br><span class="line"></span><br><span class="line"><span class="number">13</span>:                                               ; preds = %<span class="number">2</span>\</span><br><span class="line">%<span class="number">14</span> = load i32, i32* @__afl_prev_loc, !nosanitize !<span class="number">3</span>\</span><br><span class="line">%<span class="number">15</span> = load i8*, i8** @__afl_area_ptr, !nosanitize !<span class="number">3</span>\</span><br><span class="line">%<span class="number">16</span> = <span class="keyword">xor</span> i32 %<span class="number">14</span>, <span class="number">9158</span>\</span><br><span class="line">%<span class="number">17</span> = getelementptr i8, i8* %<span class="number">15</span>, i32 %<span class="number">16</span>\</span><br><span class="line">%<span class="number">18</span> = load i8, i8* %<span class="number">17</span>, !nosanitize !<span class="number">3</span>\</span><br><span class="line">%<span class="number">19</span> = add i8 %<span class="number">18</span>, <span class="number">1</span>\</span><br><span class="line">store i8 %<span class="number">19</span>, i8* %<span class="number">17</span>, !nosanitize !<span class="number">3</span>\</span><br><span class="line">store i32 <span class="number">4579</span>, i32* @__afl_prev_loc, !nosanitize !<span class="number">3</span>\</span><br><span class="line">%<span class="number">20</span> = call <span class="built_in">i32</span> (i8*, ...) @<span class="built_in">printf</span>(i8* getelementptr <span class="built_in">inbounds</span> ([<span class="number">6</span> x i8], [<span class="number">6</span> x i8]* @.str, i64 <span class="number">0</span>, i64 <span class="number">0</span>))\</span><br><span class="line">call <span class="type">void</span> @<span class="built_in">exit</span>(i32 <span class="number">1</span>) #<span class="number">3</span>\</span><br><span class="line">unreachable</span><br><span class="line"></span><br><span class="line"><span class="number">21</span>:                                               ; preds = %<span class="number">2</span>\</span><br><span class="line">%<span class="number">22</span> = load i32, i32* @__afl_prev_loc, !nosanitize !<span class="number">3</span>\</span><br><span class="line">%<span class="number">23</span> = load i8*, i8** @__afl_area_ptr, !nosanitize !<span class="number">3</span>\</span><br><span class="line">%<span class="number">24</span> = <span class="keyword">xor</span> i32 %<span class="number">22</span>, <span class="number">39017</span>\</span><br><span class="line">%<span class="number">25</span> = getelementptr i8, i8* %<span class="number">23</span>, i32 %<span class="number">24</span>\</span><br><span class="line">%<span class="number">26</span> = load i8, i8* %<span class="number">25</span>, !nosanitize !<span class="number">3</span>\</span><br><span class="line">%<span class="number">27</span> = add i8 %<span class="number">26</span>, <span class="number">1</span>\</span><br><span class="line">store i8 %<span class="number">27</span>, i8* %<span class="number">25</span>, !nosanitize !<span class="number">3</span>\</span><br><span class="line">store i32 <span class="number">19508</span>, i32* @__afl_prev_loc, !nosanitize !<span class="number">3</span>\</span><br><span class="line">%<span class="number">28</span> = getelementptr inbounds [<span class="number">8</span> x i8], [<span class="number">8</span> x i8]* %<span class="number">9</span>, i64 <span class="number">0</span>, i64 <span class="number">0</span>\</span><br><span class="line">%<span class="number">29</span> = load i8, i8* %<span class="number">28</span>, align <span class="number">1</span>\</span><br><span class="line">%<span class="number">30</span> = sext i8 %<span class="number">29</span> to i32\</span><br><span class="line">%<span class="number">31</span> = icmp eq i32 %<span class="number">30</span>, <span class="number">48</span>\</span><br><span class="line">br i1 %<span class="number">31</span>, label %<span class="number">32</span>, label %<span class="number">40</span></span><br><span class="line"></span><br><span class="line"><span class="number">32</span>:                                               ; preds = %<span class="number">21</span>\</span><br><span class="line">%<span class="number">33</span> = load i32, i32* @__afl_prev_loc, !nosanitize !<span class="number">3</span>\</span><br><span class="line">%<span class="number">34</span> = load i8*, i8** @__afl_area_ptr, !nosanitize !<span class="number">3</span>\</span><br><span class="line">%<span class="number">35</span> = <span class="keyword">xor</span> i32 %<span class="number">33</span>, <span class="number">18547</span>\</span><br><span class="line">%<span class="number">36</span> = getelementptr i8, i8* %<span class="number">34</span>, i32 %<span class="number">35</span>\</span><br><span class="line">%<span class="number">37</span> = load i8, i8* %<span class="number">36</span>, !nosanitize !<span class="number">3</span>\</span><br><span class="line">%<span class="number">38</span> = add i8 %<span class="number">37</span>, <span class="number">1</span>\</span><br><span class="line">store i8 %<span class="number">38</span>, i8* %<span class="number">36</span>, !nosanitize !<span class="number">3</span>\</span><br><span class="line">store i32 <span class="number">9273</span>, i32* @__afl_prev_loc, !nosanitize !<span class="number">3</span>\</span><br><span class="line">%<span class="number">39</span> = call <span class="built_in">i32</span> (i8*, ...) @<span class="built_in">printf</span>(i8* getelementptr <span class="built_in">inbounds</span> ([<span class="number">26</span> x i8], [<span class="number">26</span> x i8]* @.str<span class="number">.1</span>, i64 <span class="number">0</span>, i64 <span class="number">0</span>))\</span><br><span class="line">br label %<span class="number">48</span></span><br><span class="line"></span><br><span class="line"><span class="number">40</span>:                                               ; preds = %<span class="number">21</span>\</span><br><span class="line">%<span class="number">41</span> = load i32, i32* @__afl_prev_loc, !nosanitize !<span class="number">3</span>\</span><br><span class="line">%<span class="number">42</span> = load i8*, i8** @__afl_area_ptr, !nosanitize !<span class="number">3</span>\</span><br><span class="line">%<span class="number">43</span> = <span class="keyword">xor</span> i32 %<span class="number">41</span>, <span class="number">56401</span>\</span><br><span class="line">%<span class="number">44</span> = getelementptr i8, i8* %<span class="number">42</span>, i32 %<span class="number">43</span>\</span><br><span class="line">%<span class="number">45</span> = load i8, i8* %<span class="number">44</span>, !nosanitize !<span class="number">3</span>\</span><br><span class="line">%<span class="number">46</span> = add i8 %<span class="number">45</span>, <span class="number">1</span>\</span><br><span class="line">store i8 %<span class="number">46</span>, i8* %<span class="number">44</span>, !nosanitize !<span class="number">3</span>\</span><br><span class="line">store i32 <span class="number">28200</span>, i32* @__afl_prev_loc, !nosanitize !<span class="number">3</span>\</span><br><span class="line">%<span class="number">47</span> = call <span class="built_in">i32</span> (i8*, ...) @<span class="built_in">printf</span>(i8* getelementptr <span class="built_in">inbounds</span> ([<span class="number">31</span> x i8], [<span class="number">31</span> x i8]* @.str<span class="number">.2</span>, i64 <span class="number">0</span>, i64 <span class="number">0</span>))\</span><br><span class="line">br label %<span class="number">48</span></span><br><span class="line"></span><br><span class="line"><span class="number">48</span>:                                               ; preds = %<span class="number">40</span>, %<span class="number">32</span>\</span><br><span class="line">%<span class="number">49</span> = load i32, i32* @__afl_prev_loc, !nosanitize !<span class="number">3</span>\</span><br><span class="line">%<span class="number">50</span> = load i8*, i8** @__afl_area_ptr, !nosanitize !<span class="number">3</span>\</span><br><span class="line">%<span class="number">51</span> = <span class="keyword">xor</span> i32 %<span class="number">49</span>, <span class="number">23807</span>\</span><br><span class="line">%<span class="number">52</span> = getelementptr i8, i8* %<span class="number">50</span>, i32 %<span class="number">51</span>\</span><br><span class="line">%<span class="number">53</span> = load i8, i8* %<span class="number">52</span>, !nosanitize !<span class="number">3</span>\</span><br><span class="line">%<span class="number">54</span> = add i8 %<span class="number">53</span>, <span class="number">1</span>\</span><br><span class="line">store i8 %<span class="number">54</span>, i8* %<span class="number">52</span>, !nosanitize !<span class="number">3</span>\</span><br><span class="line">store i32 <span class="number">11903</span>, i32* @__afl_prev_loc, !nosanitize !<span class="number">3</span>\</span><br><span class="line">call <span class="type">void</span> @<span class="built_in">exit</span>(i32 <span class="number">0</span>) #<span class="number">3</span>\</span><br><span class="line">unreachable\</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">declare i64 @<span class="string">&quot;\01_read&quot;</span>(i32, i8*, i64) #<span class="number">1</span></span><br><span class="line"></span><br><span class="line">declare i32 @<span class="built_in">printf</span>(i8*, ...) #<span class="number">1</span></span><br><span class="line"></span><br><span class="line">; Function Attrs: noreturn\</span><br><span class="line">declare <span class="type">void</span> @<span class="built_in">exit</span>(i32) #<span class="number">2</span></span><br><span class="line"><span class="number">310</span>c793b6254093e2ef21453329ccad2</span><br><span class="line">attributes #<span class="number">0</span> = &#123; noinline nounwind ssp uwtable <span class="string">&quot;correctly-rounded-divide-sqrt-fp-math&quot;</span>=<span class="string">&quot;false&quot;</span> <span class="string">&quot;disable-tail-calls&quot;</span>=<span class="string">&quot;false&quot;</span> <span class="string">&quot;frame-pointer&quot;</span>=<span class="string">&quot;all&quot;</span> <span class="string">&quot;less-precise-fpmad&quot;</span>=<span class="string">&quot;false&quot;</span> <span class="string">&quot;min-legal-vector-width&quot;</span>=<span class="string">&quot;0&quot;</span> <span class="string">&quot;no-infs-fp-math&quot;</span>=<span class="string">&quot;false&quot;</span> <span class="string">&quot;no-jump-tables&quot;</span>=<span class="string">&quot;false&quot;</span> <span class="string">&quot;no-nans-fp-math&quot;</span>=<span class="string">&quot;false&quot;</span> <span class="string">&quot;no-signed-zeros-fp-math&quot;</span>=<span class="string">&quot;false&quot;</span> <span class="string">&quot;no-trapping-math&quot;</span>=<span class="string">&quot;false&quot;</span> <span class="string">&quot;stack-protector-buffer-size&quot;</span>=<span class="string">&quot;8&quot;</span> <span class="string">&quot;target-cpu&quot;</span>=<span class="string">&quot;penryn&quot;</span> <span class="string">&quot;target-features&quot;</span>=<span class="string">&quot;+cx16,+cx8,+fxsr,+mmx,+sahf,+sse,+sse2,+sse3,+sse4.1,+ssse3,+x87&quot;</span> <span class="string">&quot;unsafe-fp-math&quot;</span>=<span class="string">&quot;false&quot;</span> <span class="string">&quot;use-soft-float&quot;</span>=<span class="string">&quot;false&quot;</span> &#125;\</span><br><span class="line">attributes #<span class="number">1</span> = &#123; <span class="string">&quot;correctly-rounded-divide-sqrt-fp-math&quot;</span>=<span class="string">&quot;false&quot;</span> <span class="string">&quot;disable-tail-calls&quot;</span>=<span class="string">&quot;false&quot;</span> <span class="string">&quot;frame-pointer&quot;</span>=<span class="string">&quot;all&quot;</span> <span class="string">&quot;less-precise-fpmad&quot;</span>=<span class="string">&quot;false&quot;</span> <span class="string">&quot;no-infs-fp-math&quot;</span>=<span class="string">&quot;false&quot;</span> <span class="string">&quot;no-nans-fp-math&quot;</span>=<span class="string">&quot;false&quot;</span> <span class="string">&quot;no-signed-zeros-fp-math&quot;</span>=<span class="string">&quot;false&quot;</span> <span class="string">&quot;no-trapping-math&quot;</span>=<span class="string">&quot;false&quot;</span> <span class="string">&quot;stack-protector-buffer-size&quot;</span>=<span class="string">&quot;8&quot;</span> <span class="string">&quot;target-cpu&quot;</span>=<span class="string">&quot;penryn&quot;</span> <span class="string">&quot;target-features&quot;</span>=<span class="string">&quot;+cx16,+cx8,+fxsr,+mmx,+sahf,+sse,+sse2,+sse3,+sse4.1,+ssse3,+x87&quot;</span> <span class="string">&quot;unsafe-fp-math&quot;</span>=<span class="string">&quot;false&quot;</span> <span class="string">&quot;use-soft-float&quot;</span>=<span class="string">&quot;false&quot;</span> &#125;\</span><br><span class="line">attributes #<span class="number">2</span> = &#123; noreturn <span class="string">&quot;correctly-rounded-divide-sqrt-fp-math&quot;</span>=<span class="string">&quot;false&quot;</span> <span class="string">&quot;disable-tail-calls&quot;</span>=<span class="string">&quot;false&quot;</span> <span class="string">&quot;frame-pointer&quot;</span>=<span class="string">&quot;all&quot;</span> <span class="string">&quot;less-precise-fpmad&quot;</span>=<span class="string">&quot;false&quot;</span> <span class="string">&quot;no-infs-fp-math&quot;</span>=<span class="string">&quot;false&quot;</span> <span class="string">&quot;no-nans-fp-math&quot;</span>=<span class="string">&quot;false&quot;</span> <span class="string">&quot;no-signed-zeros-fp-math&quot;</span>=<span class="string">&quot;false&quot;</span> <span class="string">&quot;no-trapping-math&quot;</span>=<span class="string">&quot;false&quot;</span> <span class="string">&quot;stack-protector-buffer-size&quot;</span>=<span class="string">&quot;8&quot;</span> <span class="string">&quot;target-cpu&quot;</span>=<span class="string">&quot;penryn&quot;</span> <span class="string">&quot;target-features&quot;</span>=<span class="string">&quot;+cx16,+cx8,+fxsr,+mmx,+sahf,+sse,+sse2,+sse3,+sse4.1,+ssse3,+x87&quot;</span> <span class="string">&quot;unsafe-fp-math&quot;</span>=<span class="string">&quot;false&quot;</span> <span class="string">&quot;use-soft-float&quot;</span>=<span class="string">&quot;false&quot;</span> &#125;\</span><br><span class="line">attributes #<span class="number">3</span> = &#123; noreturn &#125;</span><br><span class="line"></span><br><span class="line">!llvm.<span class="keyword">module</span>.flags = !&#123;!<span class="number">0</span>, !<span class="number">1</span>&#125;\</span><br><span class="line">!llvm.ident = !&#123;!<span class="number">2</span>&#125;</span><br><span class="line"></span><br><span class="line">!<span class="number">0</span> = !&#123;i32 <span class="number">1</span>, !<span class="string">&quot;wchar_size&quot;</span>, i32 <span class="number">4</span>&#125;\</span><br><span class="line">!<span class="number">1</span> = !&#123;i32 <span class="number">7</span>, !<span class="string">&quot;PIC Level&quot;</span>, i32 <span class="number">2</span>&#125;\</span><br><span class="line">!<span class="number">2</span> = !&#123;!<span class="string">&quot;clang version 10.0.0 &quot;</span>&#125;\</span><br><span class="line">!<span class="number">3</span> = !&#123;&#125;</span><br></pre></td></tr></table></figure>

<h4 id="内部变量-afl-prev-loc-afl-area-ptr"><a href="#内部变量-afl-prev-loc-afl-area-ptr" class="headerlink" title="内部变量 __afl_prev_loc&amp;__afl_area_ptr"></a>内部变量 <code>__afl_prev_loc&amp;__afl_area_ptr</code></h4><ul>
<li>参考 [[#afl-llvm-rt]] 实现</li>
</ul>
<h2 id="afl-llvm-rt"><a href="#afl-llvm-rt" class="headerlink" title="afl-llvm-rt"></a>afl-llvm-rt</h2><ul>
<li>AFL LLVM_Mode中存在着三个特殊的功能。这三个功能的源码位于afl-llvm-rt.o.c中。</li>
<li>被 [[#afl-fast-clang]] 依赖编译<ul>
<li><a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=S_OeRTePeXg&list=PL0qj8UdnOw30ZGMcM6DwvM1J2tttyy_D6">(1) Tutorial1 Introduction to LLVM - YouTube</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/UofT-EcoSystem/CSCD70/tree/2023S/Tutorial01-Introduction_to_LLVM">CSCD70&#x2F;Tutorial01-Introduction_to_LLVM at 2023S · UofT-EcoSystem&#x2F;CSCD70</a></li>
</ul>
</li>
</ul>
<h3 id="解释内部变量"><a href="#解释内部变量" class="headerlink" title="解释内部变量"></a>解释内部变量</h3><h4 id="afl-prev-loc"><a href="#afl-prev-loc" class="headerlink" title="__afl_prev_loc"></a>__afl_prev_loc</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">__thread u32 __afl_prev_loc;</span><br></pre></td></tr></table></figure>

<ul>
<li>在永久模式下设置 <code>__afl_prev_loc=0</code></li>
</ul>
<h4 id="afl-area-initial"><a href="#afl-area-initial" class="headerlink" title="__afl_area_initial"></a>__afl_area_initial</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">u8  __afl_area_initial[MAP_SIZE];</span><br><span class="line">u8* __afl_area_ptr = __afl_area_initial;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>__afl_map_shm()</code> 会设置 <code>__afl_area_ptr</code></li>
<li>永久模式也会设置</li>
</ul>
<h3 id="deferred-instrumentation"><a href="#deferred-instrumentation" class="headerlink" title="deferred instrumentation"></a>deferred instrumentation</h3><h4 id="延迟初始化配置-代码"><a href="#延迟初始化配置-代码" class="headerlink" title="延迟初始化配置+代码"></a>延迟初始化配置+代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">afl-fuzz模式</span><br><span class="line">deferred_mode,             <span class="comment">/* Deferred forkserver mode?        */</span></span><br></pre></td></tr></table></figure>

<ul>
<li>AFL会尝试通过仅执行一次目标二进制文件来优化性能。它会暂停控制流，然后复制该“主”进程以持续提供fuzzer的目标。该功能在某些情况下可以减少操作系统、链接与libc内部执行程序的成本。</li>
<li><strong>选好位置后，将下述代码添加到该位置上，之后使用afl-clang-fast重新编译代码即可</strong></li>
<li><strong>主动添加代码</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __AFL_HAVE_MANUAL_CONTROL  </span></span><br><span class="line">  __AFL_INIT();  </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h4 id="afl-manual-init"><a href="#afl-manual-init" class="headerlink" title="__afl_manual_init"></a>__afl_manual_init</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __AFL_HAVE_MANUAL_CONTROL  </span></span><br><span class="line">  __AFL_INIT();  </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">-&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __AFL_HAVE_MANUAL_CONTROL  </span></span><br><span class="line">  <span class="keyword">do</span> &#123; </span><br><span class="line">    <span class="type">static</span> <span class="keyword">volatile</span> <span class="type">char</span> *_A __attribute__((used));  </span><br><span class="line">    <span class="comment">// 定义了一个静态的 `volatile` 变量 `_A`，并使用 `__attribute__((used))` 修饰，这个修饰可以防止编译器优化掉未使用的变量</span></span><br><span class="line">    _A = (<span class="type">char</span>*)<span class="string">&quot;##SIG_AFL_DEFER_FORKSRV##&quot;</span>; </span><br><span class="line">    <span class="comment">// 将 `_A` 指向字符串 `&quot;##SIG_AFL_DEFER_FORKSRV##&quot;` 的首地址。</span></span><br><span class="line">    <span class="comment">// 实际上，这个字符串的内容对这段代码的逻辑没有直接影响，只是用来占用一些空间</span></span><br><span class="line">    __attribute__((<span class="built_in">visibility</span>(<span class="string">&quot;default&quot;</span>))) <span class="type">void</span> _I(<span class="type">void</span>) </span><br><span class="line">      __asm__(<span class="string">&quot;__afl_manual_init&quot;</span>); </span><br><span class="line">    <span class="comment">// 定义了一个带有 `visibility(&quot;default&quot;)` 属性的函数 `_I`，这个函数是 `__afl_manual_init` 函数的别名。</span></span><br><span class="line">    <span class="comment">// 使用了汇编宏指令 `__asm__` 来创建一个函数的别名。</span></span><br><span class="line">    _I(); </span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> </span></span><br></pre></td></tr></table></figure>

<ul>
<li>所以，整个宏定义的目的是在满足条件 <code>__AFL_HAVE_MANUAL_CONTROL</code> 时，调用 <code>_I</code> 函数，实际上就是调用 <code>__afl_manual_init</code> 函数。</li>
<li><code>__AFL_INIT()</code>内部调用<code>__afl_manual_init</code>函数。该函数的源代码如下</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// google_afl/llvm_mode/afl-llvm-rt.o.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* This one can be called from user code when deferred forkserver mode</span></span><br><span class="line"><span class="comment">    is enabled. */</span></span><br><span class="line"><span class="type">void</span> __afl_manual_init(<span class="type">void</span>) &#123;  </span><br><span class="line">  <span class="type">static</span> u8 init_done;  </span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (!init_done) &#123;  </span><br><span class="line">    __afl_map_shm();  </span><br><span class="line">    __afl_start_forkserver();  </span><br><span class="line">    init_done = <span class="number">1</span>;  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<ul>
<li><code>__afl_manual_init</code> 用于在启用了延迟 fork 服务器模式（deferred forkserver mode）时进行初始化操作</li>
<li>如果还没有被初始化，就初始化共享内存，然后开始执行forkserver，然后设置init_done为1。</li>
</ul>
<h4 id="afl-map-shm"><a href="#afl-map-shm" class="headerlink" title="__afl_map_shm"></a>__afl_map_shm</h4><ul>
<li>简单的通过读取环境变量<code>SHM_ENV_VAR</code>来获取共享内存，然后将地址赋值给<code>__afl_area_ptr</code>。否则，默认的<code>__afl_area_ptr</code>指向的是一个数组。</li>
</ul>
<h4 id="afl-start-forkserver"><a href="#afl-start-forkserver" class="headerlink" title="__afl_start_forkserver"></a>__afl_start_forkserver</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> __afl_start_forkserver(<span class="type">void</span>) &#123;</span><br><span class="line">  <span class="type">static</span> u8 tmp[<span class="number">4</span>];</span><br><span class="line">  s32 child_pid;</span><br><span class="line"></span><br><span class="line">  u8 child_stopped = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Phone home and tell the parent that we&#x27;re OK. If parent isn&#x27;t there,</span></span><br><span class="line"><span class="comment">     assume we&#x27;re not running in forkserver mode and just execute program. */</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">write</span>(FORKSRV_FD + <span class="number">1</span>, tmp, <span class="number">4</span>) != <span class="number">4</span>) <span class="comment">// 告知AFL fuzz已经准备好了。</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;   <span class="comment">// 进入fuzz loop循环</span></span><br><span class="line">    u32 was_killed;</span><br><span class="line">    <span class="type">int</span> status;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Wait for parent by reading from the pipe. Abort if read fails. */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">read</span>(FORKSRV_FD, &amp;was_killed, <span class="number">4</span>) != <span class="number">4</span>)</span><br><span class="line">      _exit(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 读取4个字节，如果当前管道中没有内容，就会堵塞在这里，如果读到了，就代表AFL命令我们fork server去执行一次fuzz</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If we stopped the child in persistent mode, but there was a race</span></span><br><span class="line"><span class="comment">       condition and afl-fuzz already issued SIGKILL, write off the old</span></span><br><span class="line"><span class="comment">       process. */</span></span><br><span class="line">    <span class="comment">// 这段代码的目的是确保子进程在被杀死之前有机会重新启动，以避免竞态条件。如果子进程在被杀死之前处于停止状态，父进程会将其杀死并重新启动。如果子进程在被杀死之前未被停止，那么这段代码不会执行。</span></span><br><span class="line">    <span class="comment">// 这是为了解决可能的竞态条件，以确保子进程在被杀死前有机会重新启动</span></span><br><span class="line">    <span class="keyword">if</span> (child_stopped &amp;&amp; was_killed) &#123; </span><br><span class="line">      child_stopped = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">waitpid</span>(child_pid, &amp;status, <span class="number">0</span>) &lt; <span class="number">0</span>) </span><br><span class="line">      <span class="comment">// 使用 `waitpid` 函数等待子进程的状态，以确保子进程的资源得到释放</span></span><br><span class="line">        _exit(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!child_stopped) &#123; <span class="comment">// child_stopped 为0 接fork出一个子进程去进行fuzz</span></span><br><span class="line">      <span class="comment">/* Once woken up, create a clone of our process. */</span></span><br><span class="line">      child_pid = fork(); </span><br><span class="line">      <span class="keyword">if</span> (child_pid &lt; <span class="number">0</span>)</span><br><span class="line">        _exit(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* In child process: close fds, resume execution. */</span></span><br><span class="line">      <span class="keyword">if</span> (!child_pid) &#123;</span><br><span class="line">        <span class="built_in">close</span>(FORKSRV_FD);</span><br><span class="line">        <span class="built_in">close</span>(FORKSRV_FD + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span>; <span class="comment">// 从这里开始执行用户的测试二进制程序。</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">/* Special handling for persistent mode: if the child is alive but</span></span><br><span class="line"><span class="comment">         currently stopped, simply restart it with SIGCONT. */</span></span><br><span class="line">      <span class="built_in">kill</span>(child_pid, SIGCONT); </span><br><span class="line">      <span class="comment">// 这里是执行到 WIFSTOPPED(status) 之后设置了 child_stopped=1 说明子进程已经被暂停</span></span><br><span class="line">      <span class="comment">// 在这种情况下，通过调用 `kill(child_pid, SIGCONT)` 来向子进程发送 `SIGCONT` 信号，从而重新启动子进程的执行。</span></span><br><span class="line">      child_stopped = <span class="number">0</span>;</span><br><span class="line">      <span class="comment">// 子进程重新启动后，`child_stopped` 被设置为 0，表示子进程已经恢复执行。</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* In parent process: write PID to pipe, then wait for child. */</span></span><br><span class="line">    <span class="comment">// 写入子进程的pid，然后等待子进程结束</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">write</span>(FORKSRV_FD + <span class="number">1</span>, &amp;child_pid, <span class="number">4</span>) != <span class="number">4</span>)</span><br><span class="line">      _exit(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注意这里对于persistent mode，我们会设置waitpid的第三个参数为WUNTRACED，代表若子进程进入暂停状态，则马上返回。</span></span><br><span class="line">    <span class="comment">//    waitpid的第三个参数=UNTRACED -&gt;  如果一个子进程处于停止状态（例如，收到了 `SIGSTOP` 或 `SIGTSTP` 信号），那么 `waitpid()` 将会返回该子进程的信息。</span></span><br><span class="line">    <span class="comment">//    在子进程被暂停时返回，而不是等待子进程终止。这就是子进程进入暂停状态的关键</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 非persistent mode </span></span><br><span class="line">    <span class="comment">//    waitpid的第三个参数=0        -&gt;  如果一个子进程处于停止状态，`waitpid()` 将不会因为这个原因而立即返回。相反，它会等待其他事件，例如子进程终止，然后返回终止的子进程的信息。</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">waitpid</span>(child_pid, &amp;status, is_persistent ? WUNTRACED : <span class="number">0</span>) &lt; <span class="number">0</span>) <span class="comment">// 获取信息</span></span><br><span class="line">      _exit(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* In persistent mode, the child stops itself with SIGSTOP to indicate</span></span><br><span class="line"><span class="comment">       a successful run. In this case, we want to wake it up without forking</span></span><br><span class="line"><span class="comment">       again. */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">WIFSTOPPED</span>(status))</span><br><span class="line">    <span class="comment">// 用于检查 `waitpid()` 或 `wait()` 函数返回的状态值（通常在 `status` 变量中），以确定子进程是否处于停止状态。</span></span><br><span class="line">    <span class="comment">// 如果子进程没有被暂停，即不是因为收到了 `SIGSTOP` 或 `SIGTSTP` 信号而停止，那么 `WIFSTOPPED(status)` 将返回 0（假）</span></span><br><span class="line">    <span class="comment">// 因为在persistent mode里子进程会通过SIGSTOP信号来暂停自己，并以此指示运行成功，所以在这种情况下，我们需要再进行一次fuzz，就只需要和上面一样，通过SIGCONT信号来唤醒子进程继续执行即可，不需要再进行一次fuzz</span></span><br><span class="line">      child_stopped = <span class="number">1</span>; <span class="comment">// 说明子进程已经被暂停</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* Relay wait status to pipe, then loop back. */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">write</span>(FORKSRV_FD + <span class="number">1</span>, &amp;status, <span class="number">4</span>) != <span class="number">4</span>)</span><br><span class="line">      _exit(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="可能失灵初始化"><a href="#可能失灵初始化" class="headerlink" title="可能失灵初始化"></a>可能失灵初始化</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"> In particular, the program will probably malfunction <span class="keyword">if</span> you select</span><br><span class="line">a location after:</span><br><span class="line">  - The creation of any vital threads <span class="keyword">or</span> child processes - since the forkserver</span><br><span class="line">    can<span class="number">&#x27;</span>t clone them easily.</span><br><span class="line">  - <span class="function">The initialization of timers via <span class="title">setitimer</span><span class="params">()</span> <span class="keyword">or</span> equivalent calls.</span></span><br><span class="line"><span class="function">  - The creation of temporary files, network sockets, offset-sensitive file</span></span><br><span class="line"><span class="function">    descriptors, <span class="keyword">and</span> similar shared-state resources - but only provided that</span></span><br><span class="line"><span class="function">    their state meaningfully influences the behavior of the program later on.</span></span><br><span class="line"><span class="function">  - Any access to the fuzzed input, including reading the metadata about its</span></span><br><span class="line"><span class="function">    size.</span></span><br></pre></td></tr></table></figure>

<h3 id="persistent-mode"><a href="#persistent-mode" class="headerlink" title="persistent mode"></a>persistent mode</h3><ul>
<li>上面我们其实已经介绍过persistent mode的一些特点了，那就是它并不是通过fork出子进程去进行fuzz的，而是认为当前我们正在fuzz的API是无状态的，当API重置后，一个长期活跃的进程就可以被重复使用，这样可以消除重复执行fork函数以及OS相关所需要的开销。</li>
<li>比llvm ‘s libfuzzer 弱，但比fork强</li>
</ul>
<h4 id="持久模式配置"><a href="#持久模式配置" class="headerlink" title="持久模式配置"></a>持久模式配置</h4><ul>
<li>afl-clang-fast编译<ul>
<li>循环次数不能设置过大，因为较小的循环次数可以将内存泄漏和类似故障的影响降到最低。所以循环次数设置成1000是个不错的选择。</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">while</span> (__AFL_LOOP(<span class="number">1000</span>)) &#123;</span><br><span class="line">    <span class="comment">/* Read input data. */</span></span><br><span class="line">    <span class="comment">/* Call library code to be fuzzed. */</span></span><br><span class="line">    <span class="comment">/* Reset state. */</span></span><br><span class="line">  &#125;</span><br><span class="line">-&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (&#123; \</span><br><span class="line">  <span class="type">static</span> <span class="keyword">volatile</span> <span class="type">char</span> *_B __attribute__((used)); </span><br><span class="line">  _B = (<span class="type">char</span>*)<span class="string">&quot;##SIG_AFL_PERSISTENT##&quot;</span>; </span><br><span class="line">  <span class="comment">// // 实际上，这个字符串的内容对这段代码的逻辑没有直接影响，只是用来占用一些空间</span></span><br><span class="line">  __attribute__((<span class="built_in">visibility</span>(<span class="string">&quot;default&quot;</span>))) <span class="type">int</span> _L(<span class="type">unsigned</span> <span class="type">int</span>)  __asm__(<span class="string">&quot;__afl_persistent_loop&quot;</span>); </span><br><span class="line">  _L(<span class="number">1000</span>); </span><br><span class="line">&#125;) </span><br><span class="line">&#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line">-&gt;</span><br><span class="line"><span class="keyword">while</span>(__afl_persistent_loop(<span class="number">1000</span>))&#123;</span><br><span class="line">    <span class="comment">/* Read input data. */</span></span><br><span class="line">    <span class="comment">/* Call library code to be fuzzed. */</span></span><br><span class="line">    <span class="comment">/* Reset state. */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="afl-auto-init"><a href="#afl-auto-init" class="headerlink" title="__afl_auto_init"></a>__afl_auto_init</h4><ul>
<li>默认持久模式下</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> USE_TRACE_PC</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CONST_PRIO 5</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CONST_PRIO 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* ^USE_TRACE_PC */</span></span></span><br><span class="line"><span class="comment">/* Proper initialization routine. */</span></span><br><span class="line">__attribute__((<span class="built_in">constructor</span>(CONST_PRIO))) <span class="type">void</span> __afl_auto_init(<span class="type">void</span>) &#123;</span><br><span class="line">  is_persistent = !!<span class="built_in">getenv</span>(PERSIST_ENV_VAR);</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">getenv</span>(DEFER_ENV_VAR)) </span><br><span class="line">  <span class="comment">// 因为deferred instrumentation会自己选择合适的时机，手动init，不需要用这个函数来init，所以这个函数只在没有手动init的时候会自动init。</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  __afl_manual_init();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>一开始就调用 [[#__afl_manual_init]]</li>
</ul>
<h4 id="afl-persistent-loop"><a href="#afl-persistent-loop" class="headerlink" title="__afl_persistent_loop"></a>__afl_persistent_loop</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* A simplified persistent mode handler, used as explained in README.llvm. */</span></span><br><span class="line"><span class="type">int</span> __afl_persistent_loop(<span class="type">unsigned</span> <span class="type">int</span> max_cnt) &#123;</span><br><span class="line">  <span class="type">static</span> u8 first_pass = <span class="number">1</span>;</span><br><span class="line">  <span class="type">static</span> u32 cycle_cnt;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (first_pass) &#123;</span><br><span class="line">    <span class="comment">/* Make sure that every iteration of __AFL_LOOP() starts with a clean slate.</span></span><br><span class="line"><span class="comment">       On subsequent calls, the parent will take care of that, but on the first</span></span><br><span class="line"><span class="comment">       iteration, it&#x27;s our job to erase any trace of whatever happened</span></span><br><span class="line"><span class="comment">       before the loop. */</span></span><br><span class="line">       <span class="comment">// 我们需要抹掉之前发生的任何痕迹。</span></span><br><span class="line">    <span class="keyword">if</span> (is_persistent) &#123;</span><br><span class="line">      <span class="built_in">memset</span>(__afl_area_ptr, <span class="number">0</span>, MAP_SIZE);</span><br><span class="line">      __afl_area_ptr[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">      __afl_prev_loc = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cycle_cnt = max_cnt;</span><br><span class="line">    first_pass = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (is_persistent) &#123;  <span class="comment">// </span></span><br><span class="line">    <span class="keyword">if</span> (--cycle_cnt) &#123; <span class="comment">//  如果剩余迭代次数不为零</span></span><br><span class="line">      <span class="built_in">raise</span>(SIGSTOP);  <span class="comment">// 暂停当前进程，等待父进程唤醒   这里配合 [[#__afl_start_forkserver]]</span></span><br><span class="line">      __afl_area_ptr[<span class="number">0</span>] = <span class="number">1</span>;  <span class="comment">// 将第一个字节设置为 1</span></span><br><span class="line">      __afl_prev_loc = <span class="number">0</span>;     <span class="comment">// 将前一个位置重置为 0</span></span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">/* When exiting __AFL_LOOP(), make sure that the subsequent code that</span></span><br><span class="line"><span class="comment">         follows the loop is not traced. We do that by pivoting back to the</span></span><br><span class="line"><span class="comment">         dummy output region. */</span></span><br><span class="line">      __afl_area_ptr = __afl_area_initial; <span class="comment">// 将 __afl_area_ptr 指针回退到初始位置</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 返回 0，表示迭代结束</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (__AFL_LOOP(<span class="number">1000</span>)) &#123;</span><br><span class="line">    <span class="built_in">fuzzAPI</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>过程<ul>
<li>首先在main函数之前读取共享内容，然后以当前进程为fork server，去和AFL fuzz通信。</li>
<li>当AFL fuzz通知进行一次fuzz，由于此时child_stopped为0，则fork server先fork出一个子进程。</li>
<li>这个子进程会很快执行到<code>__AFL_LOOP</code>包围的代码，因为是第一次执行loop，所以会先清空<code>__afl_area_ptr</code>和设置<code>__afl_prev_loc</code>为0，并向共享内存的第一个元素写一个值，然后设置循环次数1000，随后返回1，此时<code>while(__AFL_LOOP)</code>满足条件，于是执行一次fuzzAPI。</li>
<li>然后因为是while循环，会再次进入<code>__AFL_LOOP</code>里，此时将循环次数减一，变成999，然后发出信号<code>SIGSTOP</code>来让当前进程暂停，因为我们设置了<code>WUNTRACED</code>，所以<code>waitpid</code>函数就会返回，fork server将继续执行。</li>
<li>fork server在收到<code>SIGSTOP</code>信号后就知道fuzzAPI已经被成功执行结束了，就设置child_stopped为1，并告知AFL fuzz</li>
<li>然后当AFL fuzz通知再进行一次fuzz的时候，fork server将不再需要去fork出一个新的子进程去进行fuzz，只需要恢复之前的子进程继续执行，并设置<code>child_stopped</code>为0</li>
<li>因为我们是<strong>相当于重新执行一次程序</strong>，所以将<code>__afl_prev_loc</code>设置为0，并向共享内存的第一个元素写一个值，随后直接返回1，此时<code>while(__AFL_LOOP)</code>满足条件，于是执行一次fuzzAPI，然后因为是while循环，会再次进入<code>__AFL_LOOP</code>里，再次减少一次循环次数变成998，并发出信号暂停。</li>
<li>上述过程重复执行，直到第1000次执行时，先恢复执行，然后返回1，然后执行一次fuzzAPI，然后因为是while循环，会再次进入<code>__AFL_LOOP</code>里，再次减少一次循环次数变成0，此时循环次数cnt已经被减到0，就不会再发出信号暂停子进程，而是设置<code>__afl_area_ptr</code>指向一个无关数组<code>__afl_area_initial</code>，随后将子进程执行到结束。</li>
<li><strong>这是因为程序依然会向后执行并触发到instrument，这会向<code>__afl_area_ptr</code>里写值，但是此时我们其实并没有执行<code>fuzzAPI</code>，我们并不想向共享内存里写值，于是将其指向一个无关数组，随意写值。同理，在deferred instrumentation模式里，在执行<code>__afl_manual_init</code>之前，也是向无关数组里写值，因为我们将fork点手动设置，就代表在这个fork点之前的path我们并不关心。</strong></li>
<li>重新整理一下上面的逻辑<ul>
<li>loop第一次执行的时候，会初始化，然后返回1，执行一次fuzzAPI，然后cnt会减到999，然后抛出信号暂停子进程。</li>
<li>loop第二次执行的时候，恢复执行，清空一些值，然后返回1，执行一次fuzzAPI，然后cnt会减到998，然后抛出信号暂停子进程。</li>
<li>loop第1000次执行的时候，恢复执行，清空一些值，然后返回1，执行一次fuzzAPI，然后cnt会减到0，然后就设置指向无关数组，返回0，while循环结束，程序也将执行结束。</li>
</ul>
</li>
</ul>
</li>
<li>此时fork server将不再收到SIGSTOP信号，于是child_stopped仍为0。</li>
<li>所以当AFL fuzz通知fork server再进行一次fuzz的时候，由于此时child_stopped为0，则fork server会先fork出一个子进程，然后后续过程和之前一样了</li>
</ul>
<h3 id="trace-pc-guard-mode-测试"><a href="#trace-pc-guard-mode-测试" class="headerlink" title="trace-pc-guard mode-测试"></a>trace-pc-guard mode-测试</h3><ul>
<li><a target="_blank" rel="noopener" href="https://clang.llvm.org/docs/SanitizerCoverage.html#tracing-pcs-with-guards">SanitizerCoverage — Clang 18.0.0git documentation</a></li>
</ul>
<h4 id="使用trace-pc"><a href="#使用trace-pc" class="headerlink" title="使用trace-pc"></a>使用trace-pc</h4><ul>
<li>要使用这个功能，需要先通过<code>AFL_TRACE_PC=1</code>来定义<code>DUSE_TRACE_PC</code>宏，从而在执行afl-clang-fast的时候传入<code>-fsanitize-coverage=trace-pc-guard</code>参数，来开启这个功能，和之前我们的插桩不同，<strong>开启了这个功能之后，我们不再是仅仅只对每个基本块插桩，而是对每条edge都进行了插桩</strong>。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> LLVM_CONFIG=<span class="string">&quot;llvm-config-11&quot;</span></span><br><span class="line"><span class="built_in">export</span> CC=clang-11 CXX=clang++-11</span><br><span class="line"><span class="built_in">cd</span> /home/wutang/Desktop/google_afl/ </span><br><span class="line">AFL_TRACE_PC=1 make clean all   <span class="comment"># 编译下面需要的</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> /home/wutang/Desktop/google_afl/llvm_mode</span><br><span class="line">AFL_TRACE_PC=1 make clean all  <span class="comment"># 不会用 afl-llvm-pass.so </span></span><br><span class="line">    </span><br><span class="line">nm test-instr |grep __sanitizer_cov_trace_pc_guard</span><br><span class="line">0000000000424110 T __sanitizer_cov_trace_pc_guard</span><br><span class="line">0000000000424140 T __sanitizer_cov_trace_pc_guard_init</span><br><span class="line"></span><br><span class="line"><span class="comment">#include &lt;assert.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;stdlib.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;string.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;unistd.h&gt;</span></span><br><span class="line">int main(int argc, char **argv) &#123;</span><br><span class="line">  char buf[8];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">read</span>(0, buf, 8) &lt; 1) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hum?\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(1);</span><br><span class="line">  &#125;</span><br><span class="line">  // input **ABCD** 通过</span><br><span class="line">  <span class="keyword">if</span> (buf[2] == <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;check A\n&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (buf[3] == <span class="string">&#x27;B&#x27;</span>) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;check B\n&quot;</span>);</span><br><span class="line">      <span class="keyword">if</span> (buf[4] == <span class="string">&#x27;3&#x27;</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;check C\n&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (buf[5] == <span class="string">&#x27;4&#x27;</span>) &#123;</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">&quot;check D\n&quot;</span>);</span><br><span class="line">          <span class="keyword">if</span> (strlen(buf) == 8 ) &#123;</span><br><span class="line">              assert(0);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="built_in">printf</span>(<span class="string">&quot;nothing\n&quot;</span>);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;A non-zero value? How quaint!\n&quot;</span>);</span><br><span class="line">  <span class="built_in">exit</span>(0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[+] All <span class="built_in">set</span> and ready to build.</span><br><span class="line">clang -funroll-loops  -Wall -D_FORTIFY_SOURCE=2 -g -Wno-pointer-sign -DAFL_PATH=\&quot;/usr/local/lib/afl\&quot; -DBIN_PATH=\&quot;/usr/local/bin\&quot; -DVERSION=\&quot;2.57b\&quot;  -DUSE_TRACE_PC=1 -fPIC -c afl-llvm-rt.o.c -o ../afl-llvm-rt.o</span><br><span class="line">[*] Building 32-bit variant of the runtime (-m32)... failed (that<span class="string">&#x27;s fine)</span></span><br><span class="line"><span class="string">[*] Building 64-bit variant of the runtime (-m64)... success!</span></span><br><span class="line"><span class="string">[*] Testing the CC wrapper and instrumentation output...</span></span><br><span class="line"><span class="string">unset AFL_USE_ASAN AFL_USE_MSAN AFL_INST_RATIO; AFL_PATH=. AFL_CC=clang ../afl-clang-fast -funroll-loops  -Wall -D_FORTIFY_SOURCE=2 -g -Wno-pointer-sign -DAFL_PATH=\&quot;/usr/local/lib/afl\&quot; -DBIN_PATH=\&quot;/usr/local/bin\&quot; -DVERSION=\&quot;2.57b\&quot;  -DUSE_TRACE_PC=1 ../test-instr.c -o test-instr </span></span><br><span class="line"><span class="string">-&gt;</span></span><br><span class="line"><span class="string">clang -fsanitize-coverage=trace-pc-guard -Qunused-arguments -funroll-loops -Wall -D_FORTIFY_SOURCE=2 -g -Wno-pointer-sign -DAFL_PATH=&quot;/usr/local/lib/afl&quot; -DBIN_PATH=&quot;/usr/local/bin&quot; -DVERSION=&quot;2.57b&quot; -DUSE_TRACE_PC=1 ../test-instr.c -o test-instr -g -O3 -funroll-loops -D__AFL_HAVE_MANUAL_CONTROL=1 -D__AFL_COMPILER=1 -DFUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION=1 -D__AFL_LOOP(_A)=(&#123; static volatile char *_B __attribute__((used));  _B = (char*)&quot;##SIG_AFL_PERSISTENT##&quot;; __attribute__((visibility(&quot;default&quot;))) int _L(unsigned int) __asm__(&quot;__afl_persistent_loop&quot;); _L(_A); &#125;) -D__AFL_INIT()=do &#123; static volatile char *_A __attribute__((used));  _A = (char*)&quot;##SIG_AFL_DEFER_FORKSRV##&quot;; __attribute__((visibility(&quot;default&quot;))) void _I(void) __asm__(&quot;__afl_manual_init&quot;); _I(); &#125; while (0) ../afl-llvm-rt.o </span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ifdef AFL_TRACE_PC  </span><br><span class="line">  CFLAGS    += -DUSE_TRACE_PC=<span class="number">1</span>  </span><br><span class="line">endif</span><br><span class="line"></span><br><span class="line">使用 `-flto` 选项，你可以在编译和链接阶段都启用链接时优化。要使用这个选项，需要注意以下几点：</span><br><span class="line"><span class="number">1.</span>  所有涉及的源文件和目标文件都必须启用 `-flto`。</span><br><span class="line"><span class="number">2.</span>  需要使用支持 LTO 的版本的 GCC 或 Clang。</span><br><span class="line"><span class="number">3.</span>  链接阶段可能会增加一些额外的时间和内存消耗，因为编译器需要处理更多的信息。</span><br><span class="line">总之，`-flto` 是一种用于进行全局优化的编译器选项，可以提高生成的可执行文件的性能和效率。</span><br></pre></td></tr></table></figure>

<ul>
<li>跟 <code>AFL_INST_RATIO</code> 不兼容</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> USE_TRACE_PC</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CONST_PRIO 5</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CONST_PRIO 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* ^USE_TRACE_PC */</span></span></span><br><span class="line"></span><br><span class="line">确保在 `<span class="string">&#x27;trace-pc-guard&#x27;</span>` 模式下，运行时初始化会在 forkserver 初始化之后发生。因为较高的优先级值会在较低优先级的初始化之后执行。这可以避免在初始化过程中出现问题，从而确保所需的顺序。</span><br></pre></td></tr></table></figure>

<h4 id="fsanitize-coverage-trace-pc-guard"><a href="#fsanitize-coverage-trace-pc-guard" class="headerlink" title="-fsanitize-coverage&#x3D;trace-pc-guard"></a>-fsanitize-coverage&#x3D;trace-pc-guard</h4><h5 id="官网介绍"><a href="#官网介绍" class="headerlink" title="官网介绍"></a>官网介绍</h5><ul>
<li>With <code>-fsanitize-coverage=trace-pc-guard</code> the compiler will insert the following code on <strong>every edge</strong>:</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">__sanitizer_cov_trace_pc_guard(&amp;guard_variable)</span><br></pre></td></tr></table></figure>

<ul>
<li>Every edge will have its own guard_variable (uint32_t).</li>
<li>The compiler will also insert calls to a module constructor:</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// The guards are [start, stop).</span></span><br><span class="line"><span class="comment">// This function will be called at least once per DSO and may be called</span></span><br><span class="line"><span class="comment">// more than once with the same values of start/stop.</span></span><br><span class="line">__sanitizer_cov_trace_pc_guard_init(<span class="type">uint32_t</span> *start, <span class="type">uint32_t</span> *stop);</span><br></pre></td></tr></table></figure>

<ul>
<li>With an additional <code>...=trace-pc,indirect-calls</code> flag <code>__sanitizer_cov_trace_pc_indirect(void *callee)</code> will be inserted on every indirect call.</li>
</ul>
<h5 id="afl实现方法"><a href="#afl实现方法" class="headerlink" title="afl实现方法"></a>afl实现方法</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Init callback. Populates instrumentation IDs. Note that we&#x27;re using</span></span><br><span class="line"><span class="comment">   ID of 0 as a special value to indicate non-instrumented bits. That may</span></span><br><span class="line"><span class="comment">   still touch the bitmap, but in a fairly harmless way. */</span></span><br><span class="line"><span class="type">void</span> __sanitizer_cov_trace_pc_guard_init(<span class="type">uint32_t</span> *start, <span class="type">uint32_t</span> *stop) &#123;</span><br><span class="line">  u32 inst_ratio = <span class="number">100</span>;</span><br><span class="line">  u8 *x;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (start == stop || *start)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  x = <span class="built_in">getenv</span>(<span class="string">&quot;AFL_INST_RATIO&quot;</span>); <span class="comment">// 没有使用 `afl-clang-fast` 进行编译时可以用</span></span><br><span class="line">  <span class="keyword">if</span> (x)</span><br><span class="line">    inst_ratio = <span class="built_in">atoi</span>(x);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!inst_ratio || inst_ratio &gt; <span class="number">100</span>) &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;[-] ERROR: Invalid AFL_INST_RATIO (must be 1-100).\n&quot;</span>);</span><br><span class="line">    <span class="built_in">abort</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Make sure that the first element in the range is always set - we use that</span></span><br><span class="line"><span class="comment">     to avoid duplicate calls (which can happen as an artifact of the underlying</span></span><br><span class="line"><span class="comment">     implementation in LLVM). */</span></span><br><span class="line">  *(start++) = <span class="built_in">R</span>(MAP_SIZE - <span class="number">1</span>) + <span class="number">1</span>;  </span><br><span class="line">  <span class="comment">// 第一个元素总是被设置为非零值。这是为了避免基于 LLVM 实现的底层机制中可能出现的重复调用</span></span><br><span class="line">  <span class="comment">// `R` 可能是一个随机数生成函数，它用于生成一个在 `[0, MAP_SIZE - 1]` 范围内的随机数，然后 `+ 1` 是为了确保不为零</span></span><br><span class="line">  <span class="keyword">while</span> (start &lt; stop) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">R</span>(<span class="number">100</span>) &lt; inst_ratio)</span><br><span class="line">      *start = <span class="built_in">R</span>(MAP_SIZE - <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">      <span class="comment">// 为当前基本块设置一个随机的非零值，否则将其设置为零。 [0, MAP_SIZE - 1]` 范围内的随机数，然后 `+ 1` </span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      *start = <span class="number">0</span>;</span><br><span class="line">    start++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>这个函数在程序初始化时被调用，用于初始化代码覆盖率的相关信息。它会根据一些配置和环境变量来设置代码覆盖率的初始化情况。具体来说：<ul>
<li><code>start</code> 和 <code>stop</code> 参数表示一个范围，用于初始化代码覆盖率数据的位图。这个范围通常涵盖了可执行程序的所有基本块（basic block）。</li>
<li>首先，它会尝试从环境变量中获取 <code>AFL_INST_RATIO</code>，表示代码覆盖率的比率，默认为 100。如果设置了这个值，则按照比率确定哪些基本块需要被标记为被执行。</li>
<li>如果比率设置无效（不在 1-100 范围内），就会输出错误信息并中止程序。</li>
<li>接着，它会确保范围内的第一个元素被设置，以避免重复调用。然后，它会根据比率随机选择基本块进行标记，从而在执行过程中收集代码覆盖率信息。</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* The following stuff deals with supporting -fsanitize-coverage=trace-pc-guard.</span></span><br><span class="line"><span class="comment">   It remains non-operational in the traditional, plugin-backed LLVM mode.</span></span><br><span class="line"><span class="comment">   For more info about &#x27;trace-pc-guard&#x27;, see README.llvm.</span></span><br><span class="line"><span class="comment">   The first function (__sanitizer_cov_trace_pc_guard) is called back on every</span></span><br><span class="line"><span class="comment">   edge (as opposed to every basic block). */</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> __sanitizer_cov_trace_pc_guard(<span class="type">uint32_t</span> *guard) &#123;</span><br><span class="line">  __afl_area_ptr[*guard]++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>这个函数是一个回调函数，会在程序执行过程中的每个边界（edge）触发时被调用。<strong>边界指的是基本块（basic block）之间的跳转点</strong>。它的作用是将被执行的边界的计数器递增，从而收集代码覆盖率信息。<code>guard</code> 参数表示一个边界的标识符，会用来索引代码覆盖率数据的位图，将对应的位设置为被访问。</li>
<li>如果我们的edge足够多，而<code>MAP_SIZE</code>不够大，就有可能重复，而这个加一是因为我们会把0当成一个特殊的值，其代表对这个edge不进行插桩。</li>
</ul>
<h2 id="afl-fuzz"><a href="#afl-fuzz" class="headerlink" title="afl-fuzz"></a>afl-fuzz</h2><h3 id="调试配置"><a href="#调试配置" class="headerlink" title="调试配置"></a>调试配置</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">echo <span class="string">&quot;&quot;</span>&gt;/home/wutang/Desktop/fuzz_test/fuzz_input/<span class="number">1</span></span><br><span class="line">echo core &gt;/proc/sys/kernel/core_pattern</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调试</span></span><br><span class="line">afl-fuzz -x /home/wutang/Desktop/fuzz_test/mydict.txt@<span class="number">3</span> -t <span class="number">3600000</span> -M fuzzer1:<span class="number">1</span>/<span class="number">2</span> -i /home/wutang/Desktop/fuzz_test/fuzz_input -o /home/wutang/Desktop/fuzz_test/fuzz_output -- /home/wutang/Desktop/google_afl/llvm_mode/test-instr </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// @@ 指定就传入文件路径 </span></span><br><span class="line"><span class="comment">// 如果无@@ 就标准输入重定向 out_fd 后续就用这个文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">///////////////////////////////////</span></span><br><span class="line">主fuzzer可以多个 可以进行确定性fuzz  ，跟Slave 是一致的 也会skip_deterministic=<span class="number">1</span></span><br><span class="line">-M fuzzer1:<span class="number">1</span>/<span class="number">2</span>   </span><br><span class="line">master_id=<span class="number">1</span></span><br><span class="line">master_max=<span class="number">2</span></span><br><span class="line"></span><br><span class="line">判断是否跳过deteministic fuzzing</span><br><span class="line"><span class="comment">/* Skip deterministic fuzzing if exec path checksum puts this out of scope for this master instance. */</span></span><br><span class="line"><span class="built_in">p</span> (queue_cur-&gt;exec_cksum % <span class="number">5</span>) != <span class="number">5</span> - <span class="number">1</span>)</span><br><span class="line"><span class="built_in">p</span> (<span class="number">3331718982</span> % <span class="number">5</span> != 指定数 <span class="number">-1</span>)</span><br><span class="line">-M fuzzer1:<span class="number">1</span>/<span class="number">5</span>   skip_deterministic=<span class="number">1</span></span><br><span class="line">-M fuzzer1:<span class="number">2</span>/<span class="number">5</span>   skip_deterministic=<span class="number">1</span></span><br><span class="line">-M fuzzer1:<span class="number">3</span>/<span class="number">5</span>   skip_deterministic=<span class="number">0</span></span><br><span class="line">-M fuzzer1:<span class="number">4</span>/<span class="number">5</span>   skip_deterministic=<span class="number">1</span></span><br><span class="line">-M fuzzer1:<span class="number">4</span>/<span class="number">5</span>   skip_deterministic=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">-S Slave1  skip_deterministic=<span class="number">1</span> 直接进行HAVOC</span><br><span class="line"></span><br><span class="line"><span class="comment">/////////////////////////////////// 总结下来就可以用 多主fuzzer 或者用主fuzzer+从fuzzer</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 必须是 llvm_mode下的test-instr</span><br><span class="line">nm test-instr |grep __sanitizer_cov_trace_pc_guard</span><br><span class="line"><span class="number">0000000000424110</span> T __sanitizer_cov_trace_pc_guard</span><br><span class="line"><span class="number">0000000000424140</span> T __sanitizer_cov_trace_pc_guard_init</span><br></pre></td></tr></table></figure>

<h4 id="字典编写规则"><a href="#字典编写规则" class="headerlink" title="字典编写规则"></a>字典编写规则</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 字典文件</span></span><br><span class="line">vim  /home/wutang/Desktop/fuzz_test/mydict.txt</span><br><span class="line"><span class="number">12345678</span> <span class="string">&quot;12345678&quot;</span></span><br><span class="line">key <span class="string">&quot;12345678&quot;</span></span><br><span class="line">ABCD=<span class="string">&quot;ABCD&quot;</span></span><br><span class="line">@<span class="number">2</span> <span class="string">&quot;123&quot;</span></span><br><span class="line">key <span class="string">&quot;\x01ABC&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> 字典可以用# 略过</span><br><span class="line"><span class="number">2.</span> key 只是解释，没什么用？</span><br><span class="line"><span class="number">3.</span> 左右两边字符空格略过</span><br><span class="line"><span class="number">4.</span> 后面的字符必须带引号 Malformed name=\<span class="string">&quot;value\&quot; pair in line</span></span><br><span class="line"><span class="string">5. 略过 _ 数字字符</span></span><br><span class="line"><span class="string">6. 空格 或者 = 分割</span></span><br><span class="line"><span class="string">7. 最大token 128</span></span><br><span class="line"><span class="string">8. dict@3 表示字典按 dict_level 为3 来解析</span></span><br><span class="line"><span class="string">9. 它处理了输入字符串中的转义序列，如 `\\` 和 `\xNN`，将其转换为相应的字符值</span></span><br><span class="line"><span class="string">10. `-x/home/wutang/Desktop/fuzz_test/mydict.txt@3` 表示要提取字典级别（level），并将 `@` 之后的数字解析为字典级别 `dict_level`。 好像没什么用</span></span><br></pre></td></tr></table></figure>

<h3 id="初始配置"><a href="#初始配置" class="headerlink" title="初始配置"></a>初始配置</h3><h4 id="所有流程"><a href="#所有流程" class="headerlink" title="所有流程"></a>所有流程</h4><ul>
<li>获取<code>AFL_BENCH_JUST_ONE</code><ul>
<li>设置 exit_1</li>
</ul>
</li>
<li>时间作为随机种子</li>
<li>解析参数<ul>
<li><code>-i</code> 设置 输入为 in_dir<ul>
<li>如果in_dir 是 <code>-</code>  设置 <code>in_place_resume</code>&#x3D;1</li>
<li>If you wish to start a new session, remove or rename the directory manually, or specify a different output location for this job. To resume the old session, put ‘-‘ as the input directory in the command line (<strong>-i -</strong>) and try again.</li>
</ul>
</li>
<li><code>-o</code> 设置 输出为 out_dir</li>
<li><code>-M</code> 用于存储同步标识符. <code>master sync ID </code><ul>
<li>可能存在 <code>123:456</code><ul>
<li>设置 master_id master_max</li>
</ul>
</li>
<li>用于存储同步标识符, 设置 sync_id</li>
<li><code>force_deterministic=1</code> 表示后续的 fuzzing 进程将被强制设置为确定性模式，这是为了确保同步的正确性。</li>
<li>与 <code>-S</code>不能同时指定</li>
</ul>
</li>
<li><code>-S</code> 用于存储同步标识符 <code>Slave fuzzer</code><ul>
<li>用于存储同步标识符, 设置 sync_id</li>
<li>[[#fix_up_sync]] 相关</li>
<li><code>skip_deterministic=1</code> 不进行确定性fuzz 直接到[[#RANDOM HAVOC阶段]]</li>
<li>设置 <code>use_splicing=1</code> Recombine input files 重组输入</li>
</ul>
</li>
<li><code>-n</code> dumb mode模式<ul>
<li><code>Dumb&quot; fork server</code> fork server 不会执行目标程序的初始化代码，而是直接执行测试用例。这样可以快速启动 fork server，但可能会导致目标程序在没有正确初始化的情况下运行，因此可能会遗漏一些重要的程序行为。</li>
<li>这是因为在某些情况下，启动目标程序的初始化代码可能会干扰到 fuzzing 进程的运行，导致无法正常 fuzzing。<ul>
<li>例如，<code>某些目标程序的初始化可能会导致程序崩溃或无法正常退出，从而影响到 fuzzing 的效果</code>。在这种情况下，使用 “dumb” fork server 可以绕过这些问题，快速执行测试用例。</li>
<li>但需要注意，使用 “dumb” fork server 模式<code>可能会忽略一些初始化和环境设置，导致无法模拟真实的运行环境</code>。</li>
</ul>
</li>
</ul>
</li>
<li><code>-d</code><ul>
<li>设置确定模式 <code>skip_deterministic=1</code> 直接去[[#RANDOM HAVOC阶段]]</li>
<li>设置 <code>use_splicing=1</code> Recombine input files 重组输入</li>
</ul>
</li>
<li><code>-x</code>设置字典 extras_dir 还要键值对？</li>
<li><code>-f</code> 可设置目标文件 或者用 <code>@@</code> 指定预料</li>
<li><code>-t</code> 设置exec_tmout</li>
<li><code>-C</code> 设置 <code>FAULT_CRASH</code> 非一般的crash方式？</li>
</ul>
</li>
<li>[[#setup_signal_handlers]]</li>
<li>[[#check_asan_opts]]</li>
<li>[[#fix_up_sync]]</li>
<li><code>AFL_NO_FORKSRV</code>设置 no_forkserver</li>
<li><code>AFL_NO_CPU_RED</code>设置 no_cpu_meter_red<ul>
<li>将禁用 CPU 利用率的自动调整</li>
</ul>
</li>
<li><code>AFL_NO_ARITH</code>设置 no_arith<ul>
<li>将禁用算术变异策略  [[#ARITHMETIC INC&#x2F;DEC阶段]]</li>
</ul>
</li>
<li><code>AFL_SHUFFLE_QUEUE</code>设置 shuffle_queue<ul>
<li>将启用测试用例队列的随机洗牌</li>
</ul>
</li>
<li><code>AFL_FAST_CAL</code>设置 fast_cal<ul>
<li>这里涉及 [[#u8 calibrate_case(char **argv, struct queue_entry *q, u8 *use_mem, u32 handicap, u8 from_queue)]]</li>
<li>默认是3次stage_max</li>
</ul>
</li>
<li><code>AFL_HANG_TMOUT</code>设置 hang_tmout<ul>
<li>将设置程序运行的超时时间，以防止程序进入无限循环或挂起</li>
</ul>
</li>
<li><code>AFL_PRELOAD</code><ul>
<li>将设置 <code>LD_PRELOAD</code> 和 <code>DYLD_INSERT_LIBRARIES</code> 环境变量，用于加载指定的共享库。</li>
</ul>
</li>
<li>[[#save_cmdline]] 到 orig_cmdline</li>
<li>[[#fix_up_banner]] 更新程序的 banner 信息，use_banner 文件路径</li>
<li>[[#check_if_tty]]  检查是否在tty终端上面运行。</li>
<li>[[#get_core_count]] 计数logical CPU cores，多少cpu cores&#x2F;正在使用多少</li>
<li>[[#bind_to_free_cpu]] 找到未被绑定到特定CPU核心的空闲CPU核心，然后将程序绑定到其中一个空闲核心上，以优化性能</li>
<li>[[#check_crash_handling]] 其主要目的是检查系统的崩溃处理设置，以确保在程序运行过程中产生的崩溃不会被外部崩溃报告工具处理，从而影响程序运行和崩溃处理的准确性。</li>
<li>[[#check_cpu_governor]]  检查系统的 CPU 调频策略（CPU Scaling Governor）是否对 Fuzzing 运行有不良影响</li>
<li>[[#setup_post]] 加载后处理器（post-processor）库，并检测后处理器是否成功加载和正常运行，任意语言包括go编译的so</li>
<li>[[#setup_shm]] 主要功能是配置共享内存和初始化 <code>virgin_bits</code> 数组。这些操作在程序启动时进行, 映射内存到本地</li>
<li>[[#init_count_class16]] 定义了一个处理执行计数的函数和两个查找表<code>count_class_lookup8 count_class_lookup16</code>，用于对执行计数进行分类。<ul>
<li>给trace_bits 用的</li>
</ul>
</li>
<li>[[#setup_dirs_fds]] 各种需要的路径创建</li>
<li>[[#read_testcases]] 从输入文件夹中读取所有文件，然后将它们排队进行测试。<ul>
<li>[[#add_to_queue(u8 *fname, u32 len, u8 passed_det)]] 将新的测试用例添加到队列中，以供后续进行测试。</li>
</ul>
</li>
<li>[[#load_auto]]  load自动生成的提取出来的词典token<ul>
<li>[[#maybe_add_auto(u8 *mem, u32 len)]] 是向自动生成的字典中添加新的条目（字典项）</li>
</ul>
</li>
<li>[[#pivot_inputs]] 函数负责将输入测试用例文件重新命名、链接（或拷贝）到输出目录中，并在需要的情况下更新文件名以及关联的信息。这有助于模糊测试过程的组织和恢复</li>
<li>[[#load_extras]]  这段代码负责加载额外的字典文件（extra dictionary）并对其进行排序，使其按照字典条目的大小进行排列</li>
<li>[[#find_timeout]] 寻找之前会话中的超时设置，并将其应用于当前会话</li>
<li>[[#detect_file_args]] 这个函数其实就是识别参数里面有没有<code>@@</code>，如果有就替换为<code>out_dir/.cur_input</code>，如果没有就返回</li>
<li>[[#setup_stdio_file]] 如果out_file为NULL ， 如果没有使用-f  &amp;&amp; 或者没有指定 <code>@@</code>，删除<code>out_dir/.cur_input</code></li>
<li>[[#check_binary]] 它检查二进制文件是否存在、是否为可执行文件、是否为 ELF 或 Mach-O 格式，是否包含 AFL 仪表插装标记，以及其他相关特征。</li>
<li>get_cur_time 记录时间</li>
<li>[[#perform_dry_run]] 尝试去fuzz程序，计算是否符合要求等<ul>
<li>calibrate_case<ul>
<li>init_forkserver</li>
<li>write_to_testcase</li>
<li>run_target</li>
<li>count_bytes</li>
<li>hash32</li>
<li>[[#has_new_bits(u8 *virgin_map)]]</li>
<li>update_bitmap_score</li>
</ul>
</li>
<li>check_map_coverage</li>
</ul>
</li>
<li>[[#cull_queue]] 该函数的目标是在模糊测试期间调整队列，以便更多地探索未被完全探索的路径</li>
<li>[[#show_init_stats]] 这段代码用于在处理输入目录后显示初始化统计信息和一些警告</li>
<li>[[#find_start_position]] resume模式下有意义，其目的是在恢复模式下寻找一个合适的队列起始位置</li>
<li>[[#void write_stats_file(double bitmap_cvg, double stability, double eps)]] 数负责将各项统计信息写入名为 <code>fuzzer_stats</code> 的文件中，这些信息用于监控 fuzzer 的性能和状态。这可以帮助用户了解 fuzzer 的执行情况、性能和资源使用情况</li>
<li>[[#save_auto]]目的是将用于自动筛选的额外测试用例保存到磁盘中。</li>
<li>sleep 4秒</li>
<li>进入循环-fuzzing [[#fuzz-主要流程]]</li>
</ul>
<h4 id="setup-signal-handlers"><a href="#setup-signal-handlers" class="headerlink" title="setup_signal_handlers"></a>setup_signal_handlers</h4><ul>
<li>函数负责配置各种信号的信号处理程序，这些信号可能在 AFL fuzzer 运行过程中出现。信号处理程序是在进程接收到特定信号时执行的函数。通过设置适当的信号处理程序，程序可以处理中断、超时和其他可能影响其执行的情况</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Handle stop signal (Ctrl-C, etc). */</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">handle_stop_sig</span><span class="params">(<span class="type">int</span> sig)</span> </span>&#123;</span><br><span class="line">  stop_soon = <span class="number">1</span>; </span><br><span class="line">  <span class="keyword">if</span> (child_pid &gt; <span class="number">0</span>) <span class="built_in">kill</span>(child_pid, SIGKILL);</span><br><span class="line">  <span class="keyword">if</span> (forksrv_pid &gt; <span class="number">0</span>) <span class="built_in">kill</span>(forksrv_pid, SIGKILL);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Handle timeout (SIGALRM). */</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">handle_timeout</span><span class="params">(<span class="type">int</span> sig)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (child_pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    child_timed_out = <span class="number">1</span>; </span><br><span class="line">    <span class="built_in">kill</span>(child_pid, SIGKILL);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (child_pid == <span class="number">-1</span> &amp;&amp; forksrv_pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    child_timed_out = <span class="number">1</span>; </span><br><span class="line">    <span class="built_in">kill</span>(forksrv_pid, SIGKILL);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Handle screen resize (SIGWINCH). */</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">handle_resize</span><span class="params">(<span class="type">int</span> sig)</span> </span>&#123;</span><br><span class="line">  clear_screen = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Handle skip request (SIGUSR1). */</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">handle_skipreq</span><span class="params">(<span class="type">int</span> sig)</span> </span>&#123;</span><br><span class="line">  skip_requested = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Set up signal handlers. More complicated that needs to be, because libc on</span></span><br><span class="line"><span class="comment">   Solaris doesn&#x27;t resume interrupted reads(), sets SA_RESETHAND when you call</span></span><br><span class="line"><span class="comment">   siginterrupt(), and does other unnecessary things. */</span></span><br></pre></td></tr></table></figure>

<ul>
<li>这里handle_timeout往后看 [[#init_forkserver设置子进程超时]]</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">EXP_ST <span class="type">void</span> <span class="title">setup_signal_handlers</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">sigaction</span> sa;</span><br><span class="line">  <span class="comment">// 函数开始时，创建一个名为 `sa` 的 `struct sigaction`，其中包含有关每个信号所需行为的信息。 官方的</span></span><br><span class="line">  sa.sa_handler   = <span class="literal">NULL</span>;</span><br><span class="line">  sa.sa_flags     = SA_RESTART; </span><br><span class="line">  <span class="comment">// /* Restart syscall on signal return.  */ </span></span><br><span class="line">  sa.sa_sigaction = <span class="literal">NULL</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">sigemptyset</span>(&amp;sa.sa_mask); <span class="comment">// /* Clear all signals from SET.  */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Various ways of saying &quot;stop&quot;. */</span></span><br><span class="line"></span><br><span class="line">  sa.sa_handler = handle_stop_sig; </span><br><span class="line">  <span class="comment">// `handle_stop_sig` 函数负责处理这些信号。它启动停止模糊测试程序的过程。</span></span><br><span class="line">  <span class="built_in">sigaction</span>(SIGHUP, &amp;sa, <span class="literal">NULL</span>); </span><br><span class="line">  <span class="comment">// 当终端或会话连接中断时，操作系统会发送 `SIGHUP` 信号给与其相关联的进程。</span></span><br><span class="line">  <span class="built_in">sigaction</span>(SIGINT, &amp;sa, <span class="literal">NULL</span>);</span><br><span class="line">  <span class="comment">// 当用户在终端按下 Ctrl + C 时，操作系统会发送 `SIGINT` 信号给前台进程。</span></span><br><span class="line">  <span class="built_in">sigaction</span>(SIGTERM, &amp;sa, <span class="literal">NULL</span>);</span><br><span class="line">  <span class="comment">// 当操作系统需要终止进程时，会发送 `SIGTERM` 信号。</span></span><br><span class="line">  <span class="comment">// 对 `SIGHUP`、`SIGINT` 和 `SIGTERM` 调用 `sigaction`，将 `&amp;sa` 作为接收到这些信号时要执行的操作。</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* Exec timeout notifications. */</span></span><br><span class="line">  sa.sa_handler = handle_timeout;</span><br><span class="line">  <span class="built_in">sigaction</span>(SIGALRM, &amp;sa, <span class="literal">NULL</span>);</span><br><span class="line">  <span class="comment">// 在模糊测试中，`SIGALRM` 信号通常用于实现执行超时，以确保程序不会无限期地运行下去。如果程序在规定的时间内未完成执行，操作系统会发送 `SIGALRM` 信号。</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Window resize */</span></span><br><span class="line">  sa.sa_handler = handle_resize;</span><br><span class="line">  <span class="built_in">sigaction</span>(SIGWINCH, &amp;sa, <span class="literal">NULL</span>);</span><br><span class="line">  <span class="comment">// 当终端窗口大小调整时，操作系统会发送 `SIGWINCH` 信号给相关进程。</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* SIGUSR1: skip entry */</span></span><br><span class="line">  sa.sa_handler = handle_skipreq;</span><br><span class="line">  <span class="built_in">sigaction</span>(SIGUSR1, &amp;sa, <span class="literal">NULL</span>);</span><br><span class="line">  <span class="comment">// 用户自定义的信号 `SIGUSR1` 信号通常被用来触发特定的操作。在源码中，它被用来跳过当前测试用例的执行。</span></span><br><span class="line">  <span class="comment">// ``c_signal</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* Things we don&#x27;t care about. */</span></span><br><span class="line">  sa.sa_handler = SIG_IGN; <span class="comment">// 表示忽略该信号</span></span><br><span class="line">  <span class="built_in">sigaction</span>(SIGTSTP, &amp;sa, <span class="literal">NULL</span>);</span><br><span class="line">  <span class="comment">// 通常由用户按下 `Ctrl-Z` 组合键来发送。它会使进程进入停止（暂停）状态，进入后台，并暂停运行。进程在这个状态下可以通过 `fg` 命令恢复运行到前台。</span></span><br><span class="line">  <span class="built_in">sigaction</span>(SIGPIPE, &amp;sa, <span class="literal">NULL</span>);</span><br><span class="line">  <span class="comment">// 这是一个在进程尝试写入一个已关闭的写端管道时产生的信号。如果进程忽略这个信号，继续写入已关闭的管道会触发一个 `EPIPE` 错误，而不会中断程序</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="check-asan-opts"><a href="#check-asan-opts" class="headerlink" title="check_asan_opts"></a>check_asan_opts</h4><ul>
<li>这个函数的目的是确保在使用 ASan 和 MSan 运行 AFL-Fuzz 时，相应的运行选项被正确地设置，以便在检测内存错误时能够正常运行。</li>
<li>读取环境变量ASAN_OPTIONS和MSAN_OPTIONS，做一些检查</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Check ASAN options. */</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">check_asan_opts</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">  u8* x = <span class="built_in">getenv</span>(<span class="string">&quot;ASAN_OPTIONS&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (x) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strstr</span>(x, <span class="string">&quot;abort_on_error=1&quot;</span>))</span><br><span class="line">      <span class="built_in">FATAL</span>(<span class="string">&quot;Custom ASAN_OPTIONS set without abort_on_error=1 - please fix!&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strstr</span>(x, <span class="string">&quot;symbolize=0&quot;</span>))</span><br><span class="line">      <span class="built_in">FATAL</span>(<span class="string">&quot;Custom ASAN_OPTIONS set without symbolize=0 - please fix!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  x = <span class="built_in">getenv</span>(<span class="string">&quot;MSAN_OPTIONS&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (x) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strstr</span>(x, <span class="string">&quot;exit_code=&quot;</span> <span class="built_in">STRINGIFY</span>(MSAN_ERROR)))</span><br><span class="line">      <span class="built_in">FATAL</span>(<span class="string">&quot;Custom MSAN_OPTIONS set without exit_code=&quot;</span></span><br><span class="line">            <span class="built_in">STRINGIFY</span>(MSAN_ERROR) <span class="string">&quot; - please fix!&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strstr</span>(x, <span class="string">&quot;symbolize=0&quot;</span>))</span><br><span class="line">      <span class="built_in">FATAL</span>(<span class="string">&quot;Custom MSAN_OPTIONS set without symbolize=0 - please fix!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h4 id="fix-up-sync"><a href="#fix-up-sync" class="headerlink" title="fix_up_sync"></a>fix_up_sync</h4><ul>
<li><code>-S</code>指定了sync_id</li>
<li><code>-M</code> 指定了sync_id<ul>
<li>设置<code>sync_dir</code>的值为 -o的那个 <code>out_dir</code><ul>
<li><code>/home/wutang/Desktop/fuzz_test/fuzz_output</code></li>
</ul>
</li>
<li>设置<code>out_dir</code>的值为   -o的那个<code>out_dir/sync_id</code><ul>
<li><code>/home/wutang/Desktop/fuzz_test/fuzz_output/fuzzer1</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="save-cmdline"><a href="#save-cmdline" class="headerlink" title="save_cmdline"></a>save_cmdline</h4><ul>
<li>拷贝字符串 orig_cmdline</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">uint8_t</span> *orig_cmdline;  <span class="comment">/* Original command line            *</span></span><br><span class="line"><span class="comment">          </span></span><br><span class="line"><span class="comment">save_cmdline(argc, argv);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">/* Make a copy of the current command line. */</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">save_cmdline</span><span class="params">(<span class="type">uint32_t</span> argc, <span class="type">char</span>** argv)</span> </span>&#123;</span><br><span class="line">  u32 len = <span class="number">1</span>, i;</span><br><span class="line">  <span class="type">uint8_t</span>* buf;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; argc; i++)</span><br><span class="line">    len += <span class="built_in">strlen</span>(argv[i]) + <span class="number">1</span>;</span><br><span class="line">  </span><br><span class="line">  buf = orig_cmdline = <span class="built_in">malloc</span>(len); <span class="comment">// ck_alloc</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; argc; i++) &#123;</span><br><span class="line">    u32 l = <span class="built_in">strlen</span>(argv[i]);</span><br><span class="line">    <span class="built_in">memcpy</span>(buf, argv[i], l);</span><br><span class="line">    buf += l;</span><br><span class="line">    <span class="keyword">if</span> (i != argc - <span class="number">1</span>) *(buf++) = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  *buf = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="fix-up-banner"><a href="#fix-up-banner" class="headerlink" title="fix_up_banner"></a>fix_up_banner</h4><ul>
<li>它的主要作用是在启动 AFL-Fuzz 时更新程序的 banner 信息，即程序运行时在终端上显示的版本信息和标题。它接受一个参数，即目标文件的路径，然后根据该文件的内容更新 banner 信息</li>
</ul>
<h4 id="check-if-tty"><a href="#check-if-tty" class="headerlink" title="check_if_tty"></a>check_if_tty</h4><ul>
<li>检查是否在tty终端上面运行。</li>
<li>启动 AFL-Fuzz 时更新程序的 banner 信息，即程序运行时在终端上显示的版本信息和标题</li>
<li>读取环境变量<code>AFL_NO_UI</code>的值，如果为真，则设置not_on_tty为1，并返回</li>
<li><code>ioctl(1, TIOCGWINSZ, &amp;ws)</code>通过ioctl来读取window size，如果报错为ENOTTY，则代表当前不在一个tty终端运行，设置not_on_tty</li>
</ul>
<h4 id="get-core-count"><a href="#get-core-count" class="headerlink" title="get_core_count"></a>get_core_count</h4><ul>
<li>计数logical CPU cores， 多少cpu cores&#x2F;正在使用多少<ul>
<li>&#96;&#96;c_linux_cpu</li>
</ul>
</li>
</ul>
<h4 id="bind-to-free-cpu"><a href="#bind-to-free-cpu" class="headerlink" title="bind_to_free_cpu"></a>bind_to_free_cpu</h4><ul>
<li>找到未被绑定到特定CPU核心的空闲CPU核心，然后将程序绑定到其中一个空闲核心上，以优化性能<ul>
<li>函数会尝试打开 <code>/proc</code> 目录，然后遍历其中的所有进程。目的是扫描所有进程的 <code>/proc/&lt;pid&gt;/status</code> 文件，检查进程是否绑定到特定的 CPU 核心。这样的检查通过读取进程的 <code>Cpus_allowed_list</code> 字段来实现</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">遍历进程</span><br><span class="line">cat /proc/<span class="number">8</span>/status</span><br><span class="line"></span><br><span class="line">读取 Cpus_allowed_list:	<span class="number">1</span> 有VmSize  那么cpu被占用</span><br><span class="line">否则空闲，读取他</span><br><span class="line"></span><br><span class="line">``c_linux_cpu_bind</span><br></pre></td></tr></table></figure>

<h4 id="check-crash-handling"><a href="#check-crash-handling" class="headerlink" title="check_crash_handling"></a>check_crash_handling</h4><ul>
<li>其主要目的是检查系统的崩溃处理设置，以确保在程序运行过程中产生的崩溃不会被外部崩溃报告工具处理，从而影响程序运行和崩溃处理的准确性。<ul>
<li>首先，代码在 Apple 系统中使用命令 <code>launchctl list</code> 检查是否启用了外部的崩溃报告工具（<code>.ReportCrash</code>）。如果启用了，说明系统将崩溃信息发送到外部报告工具，而不是直接让 fuzzer 通过标准的 <code>waitpid()</code> API 获取崩溃信息。在这种情况下，函数会输出警告信息，提示用户需要禁用该功能。</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">SL=/System/Library; PL=com.apple.ReportCrash</span><br><span class="line">launchctl unload -w $&#123;SL&#125;/LaunchAgents/$&#123;PL&#125;.plist</span><br><span class="line">sudo launchctl unload -w $&#123;SL&#125;/LaunchDaemons/$&#123;PL&#125;.Root.plist</span><br></pre></td></tr></table></figure>

<ul>
<li>如果不是 Apple 系统，则在 Linux 系统中，代码会读取 <code>/proc/sys/kernel/core_pattern</code> 文件，检查其中的核心转储模式设置。如果核心转储模式以 <code>|</code> 符号开头，说明系统将核心转储信息通过管道传递给了外部工具。这也会导致崩溃信息的延迟传递，从而影响 fuzzer 对崩溃的处理。在这种情况下，函数会输出警告信息，提示用户需要修改核心转储模式<ul>
<li>设置 <code>echo core &gt;/proc/sys/kernel/core_pattern</code></li>
</ul>
</li>
</ul>
<h4 id="check-cpu-governor"><a href="#check-cpu-governor" class="headerlink" title="check_cpu_governor"></a>check_cpu_governor</h4><ul>
<li>检查系统的 CPU 调频策略（CPU Scaling Governor）是否对 Fuzzing 运行有不良影响。Fuzzing 运行通常需要稳定的 CPU 运行频率以保证稳定的性能，而某些 CPU 调频策略可能会导致性能下降，从而影响 Fuzzing 运行的准确性和效率。</li>
<li>检查<code>AFL_SKIP_CPUFREQ</code> 不检查</li>
<li>首先，代码尝试打开文件 <code>/sys/devices/system/cpu/cpu0/cpufreq/scaling_governor</code>，读取系统当前的 CPU 调频策略。如果无法打开该文件，说明系统可能不支持 CPU 调频策略设置，或者文件路径不正确，那么函数直接返回。</li>
</ul>
<h4 id="setup-post"><a href="#setup-post" class="headerlink" title="setup_post"></a>setup_post</h4><ul>
<li>加载后处理器（post-processor）库，并检测后处理器是否成功加载和正常运行，任意语言包括go编译的so。在 Fuzzing 运行结束后，后处理器可以用于对 Fuzzing 的结果进行进一步的处理、分析或报告。<ul>
<li>Allows AFL_POST_LIBRARY postprocessors to be written in arbitrary languages that don’t have C &#x2F; .so bindings. Includes examples in Go.</li>
</ul>
</li>
<li>设置宏 <code>AFL_POST_LIBRARY=xxx.so</code><ul>
<li>里面包含 <code>afl_postprocess</code>  调用 <code>post_handler(&quot;hello&quot;, &amp;tlen);</code><ul>
<li>[[#u8 common_fuzz_stuff(char **argv, u8 *out_buf, u32 len)]]</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="setup-shm"><a href="#setup-shm" class="headerlink" title="setup_shm"></a>setup_shm</h4><ul>
<li>主要功能是配置共享内存和初始化 <code>virgin_bits</code> 数组。这些操作在程序启动时进行, 映射内存到本地<ul>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/52php/p/5861372.html">Linux进程间通信（六）：共享内存 shmget()、shmat()、shmdt()、shmctl() - 52php - 博客园</a></li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Get rid of shared memory (atexit handler). */</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">remove_shm</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">shmctl</span>(shm_id, IPC_RMID, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 该函数会在程序退出时被调用，用于删除之前创建的共享内存段</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Configure shared memory and virgin_bits. This is called at startup. */</span></span><br><span class="line"><span class="function">EXP_ST <span class="type">void</span> <span class="title">setup_shm</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">  u8* shm_str;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!in_bitmap) <span class="built_in">memset</span>(virgin_bits, <span class="number">255</span>, MAP_SIZE);</span><br><span class="line">  <span class="built_in">memset</span>(virgin_tmout, <span class="number">255</span>, MAP_SIZE);</span><br><span class="line">  <span class="built_in">memset</span>(virgin_crash, <span class="number">255</span>, MAP_SIZE);</span><br><span class="line">  <span class="comment">// `virgin_tmout` 和 `virgin_crash` 数组也被初始化为 255。这两个数组分别用于跟踪超时和崩溃的情况。</span></span><br><span class="line"></span><br><span class="line">  shm_id = <span class="built_in">shmget</span>(IPC_PRIVATE, MAP_SIZE, IPC_CREAT | IPC_EXCL | <span class="number">0600</span>);</span><br><span class="line">  <span class="comment">// 1) `IPC_PRIVATE` 标志创建一个新的共享内存段</span></span><br><span class="line">  <span class="comment">// -   `IPC_CREAT`: 这个标志位表示如果共享内存段不存在，就创建一个新的。如果已经存在具有相同 `key` 的共享内存段，则返回该共享内存段的标识符。</span></span><br><span class="line">  <span class="comment">// -   `IPC_EXCL`: 这个标志位与 `IPC_CREAT` 一起使用时，表示只在共享内存段不存在的情况下创建。如果已经存在具有相同 `key` 的共享内存段，则 `shmget` 调用会失败。</span></span><br><span class="line">  <span class="comment">// -   `0600`: 这是一个八进制数，用于设置共享内存段的权限。在这个例子中，权限被设置为用户可读可写，没有执行权限</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (shm_id &lt; <span class="number">0</span>) <span class="built_in">PFATAL</span>(<span class="string">&quot;shmget() failed&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// /* Register a function to be called when `exit&#x27; is called.  */</span></span><br><span class="line">  <span class="built_in">atexit</span>(remove_shm);</span><br><span class="line">  </span><br><span class="line">  shm_str = <span class="built_in">alloc_printf</span>(<span class="string">&quot;%d&quot;</span>, shm_id);</span><br><span class="line">  <span class="comment">/* If somebody is asking us to fuzz instrumented binaries in dumb mode,</span></span><br><span class="line"><span class="comment">     we don&#x27;t want them to detect instrumentation, since we won&#x27;t be sending</span></span><br><span class="line"><span class="comment">     fork server commands. This should be replaced with better auto-detection</span></span><br><span class="line"><span class="comment">     later on, perhaps? */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!dumb_mode) <span class="built_in">setenv</span>(SHM_ENV_VAR, shm_str, <span class="number">1</span>);</span><br><span class="line">  <span class="comment">// 如果不是在 &quot;dumb mode&quot; 下运行（即非简化模式），则通过 `setenv` 函数将共享内存 ID 字符串存储到环境变量 `SHM_ENV_VAR` 中。这是为了在 fork server 模式下通知其他进程使用的共享内存。</span></span><br><span class="line">  <span class="built_in">ck_free</span>(shm_str);</span><br><span class="line">  trace_bits = <span class="built_in">shmat</span>(shm_id, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="comment">// 第一次创建完共享内存时，它还不能被任何进程访问，所以通过shmat来启动对该共享内存的访问，并把共享内存连接到当前进程的地址空间。</span></span><br><span class="line">  <span class="comment">// 调用 `shmat` 函数将共享内存段附加到当前进程的地址空间。如果附加失败，返回值为 `(void *)-1`，则会调用 `PFATAL` 函数终止程序运行。</span></span><br><span class="line">  <span class="comment">// 2) 通常为空，表示让系统来选择共享内存的地址</span></span><br><span class="line">  <span class="comment">// 3) shm_flg是一组标志位，通常为0</span></span><br><span class="line">  <span class="keyword">if</span> (trace_bits == (<span class="type">void</span> *)<span class="number">-1</span>) <span class="built_in">PFATAL</span>(<span class="string">&quot;shmat() failed&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="init-count-class16"><a href="#init-count-class16" class="headerlink" title="init_count_class16"></a>init_count_class16</h4><ul>
<li>定义了一个处理执行计数的函数和两个查找表，用于对执行计数进行分类。</li>
<li>这些查找表的主要目的是在进行后续的执行计数处理时，能够将执行计数转换为更具有统计意义的分类值，从而减少内存占用和计算成本。这在大规模的测试用例集中，对于执行计数的统计分析非常有用。</li>
<li>count_class_lookup8<ul>
<li>对于0，映射到分类值0。</li>
<li>对于1，映射到分类值1。</li>
<li>对于2，映射到分类值2。</li>
<li>对于3，映射到分类值4。</li>
<li>对于4到7，映射到分类值8。</li>
<li>对于8到15，映射到分类值16。</li>
<li>对于16到31，映射到分类值32。</li>
<li>对于32到127，映射到分类值64。</li>
<li>对于128到255，映射到分类值128。</li>
</ul>
</li>
<li>count_class_lookup16<ul>
<li>这是一个长度为65536的数组，用于将两个字节（16位）的执行计数组合成一个更粗粒度的分类值。它通过对每个字节在 count_class_lookup8 查找表中的分类值进行位运算来实现。</li>
</ul>
</li>
<li>这其实是因为<code>trace_bits</code>是用一个字节来记录是否到达这个路径，和这个路径被命中了多少次的，而这个次数在0-255之间，但比如一个循环，它循环5次和循环6次可能是完全一样的效果，为了避免被当成不同的路径，或者说尽可能减少因为命中次数导致的</li>
</ul>
<h4 id="setup-dirs-fds"><a href="#setup-dirs-fds" class="headerlink" title="setup_dirs_fds"></a>setup_dirs_fds</h4><ul>
<li>各种需要的路径创建</li>
</ul>
<h5 id="maybe-delete-out-dir"><a href="#maybe-delete-out-dir" class="headerlink" title="maybe_delete_out_dir"></a>maybe_delete_out_dir</h5><ul>
<li>这段代码主要用于管理和清理输出目录，以确保能够正常开始一个新的会话或者继续之前的会话。</li>
<li>读取<code>/home/wutang/Desktop/fuzz_test/fuzz_output/fuzzer1/fuzzer_stats</code></li>
<li>首先，代码检查输出目录是否被其他实例的 afl-fuzz 进程使用。如果目录被锁定，会给出相应的错误信息并终</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> * out_dir;</span><br><span class="line"></span><br><span class="line">  out_dir_fd = <span class="built_in">open</span>(out_dir, O_RDONLY);</span><br><span class="line">  <span class="keyword">if</span> (out_dir_fd &lt; <span class="number">0</span>) <span class="built_in">PFATAL</span>(<span class="string">&quot;Unable to open &#x27;%s&#x27;&quot;</span>, out_dir);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __sun <span class="comment">// 用于排除掉特定操作系统（例如 SunOS）的代码部分</span></span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">flock</span>(out_dir_fd, LOCK_EX | LOCK_NB) &amp;&amp; errno == EWOULDBLOCK) &#123;</span><br><span class="line">    <span class="comment">// LOCK_EX 独占锁</span></span><br><span class="line">    <span class="comment">// LOCK_NB 非阻塞模式</span></span><br><span class="line">    <span class="comment">// 如果目录已被其他进程锁定且设置了非阻塞模式，那么此次加锁会失败，并且 `errno` 的值会被设置为 `EWOULDBLOCK`</span></span><br><span class="line">    <span class="built_in">SAYF</span>(<span class="string">&quot;\n&quot;</span> cLRD <span class="string">&quot;[-] &quot;</span> cRST</span><br><span class="line">         <span class="string">&quot;Looks like the job output directory is being actively used by another\n&quot;</span></span><br><span class="line">         <span class="string">&quot;    instance of afl-fuzz. You will need to choose a different %s\n&quot;</span></span><br><span class="line">         <span class="string">&quot;    or stop the other process first.\n&quot;</span>,</span><br><span class="line">         sync_id ? <span class="string">&quot;fuzzer ID&quot;</span> : <span class="string">&quot;output location&quot;</span>);</span><br><span class="line">    <span class="built_in">FATAL</span>(<span class="string">&quot;Directory &#x27;%s&#x27; is in use&quot;</span>, out_dir);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* !__sun */</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>如果没设置<code>-i -</code>， <code>in_place_resume=0</code> &amp;&amp; 已经跑了 <code>last_update - start_time &gt; OUTPUT_GRACE * 60</code> 25分钟了<ul>
<li>退出不能继续跑</li>
</ul>
</li>
<li>如果设置 <code>-i -</code> ,<code>in_place_resume=1</code>输出  <code>Output directory exists, will attempt session resume.</code></li>
</ul>
<h5 id="函数主程序"><a href="#函数主程序" class="headerlink" title="函数主程序"></a>函数主程序</h5><ul>
<li>准备输出文件夹和fd<ul>
<li>如果<code>sync_id</code>存在，且创建<code>sync_dir</code>文件夹，设置权限为<code>0700</code>（读写执行）</li>
<li><code>/home/wutang/Desktop/fuzz_test/fuzz_output</code></li>
<li>如果报错，且errno不是EEXIST，则抛出异常。</li>
<li>创建<code>out_dir</code>，设置权限为0700（读写执行） <code>/home/wutang/Desktop/fuzz_test/fuzz_output/fuzzer1</code></li>
<li>创建失败<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- 如果报错，且errno不是EEXIST，则抛出异常。</span><br><span class="line">- 是EEXIST 执行函数 [[#maybe_delete_out_dir]]</span><br></pre></td></tr></table></figure></li>
<li>如果创建成功<ul>
<li>如果设置 <code>-i -</code>, <code>in_place_resume=1</code> ， 就抛出异常 <strong>Resume attempted but old output directory not found</strong></li>
<li><code>out_dir_fd = open(out_dir, O_RDONLY)</code> 以只读模式打开这个文件，并返回文件句柄<code>out_dir_fd</code></li>
<li>如果没有定义宏<code>__sun</code></li>
<li>如果打开out_dir失败，或者为out_dir通过flock建立互斥锁定失败，就抛出异常<code>Unable to flock() output directory.</code></li>
</ul>
</li>
<li>建立queue文件夹 <code>/home/wutang/Desktop/fuzz_test/fuzz_output/fuzzer1/queue</code></li>
<li>创建<code>out_dir/queue</code>文件夹，设置权限为0700</li>
<li>创建<code>out_dir/queue/.state/</code>,设置权限为0700,该文件夹主要<strong>保存用于session resume和related tasks的queue metadata</strong></li>
<li>创建<code>out_dir/queue/.state/deterministic_done/</code>,设置权限为0700,该文件夹<strong>标记过去经历过deterministic fuzzing的queue entries</strong>。</li>
<li>创建<code>out_dir/queue/.state/auto_extras/</code>,设置权限为0700,<strong>Directory with the auto-selected dictionary entries.</strong></li>
<li>创建<code>out_dir/queue/.state/redundant_edges/</code>,设置权限为0700,<strong>保存当前被认为是多余的路径集合</strong></li>
<li>创建<code>out_dir/queue/.state/variable_behavior/</code>,设置权限为0700,<strong>The set of paths showing variable behavior.</strong></li>
<li>如果<code>sync_id</code>存在<ul>
<li>创建<code>out_dir/.synced/</code>,设置权限为0700, <strong>同步文件夹，用于跟踪cooperating fuzzers.</strong></li>
</ul>
</li>
<li>建立crashes文件夹<ul>
<li>创建<code>out_dir/crashes</code>文件夹，设置权限为0700,用于记录crashes</li>
</ul>
</li>
<li>建立hangs文件夹<ul>
<li>创建<code>out_dir/hangs</code>文件夹，设置权限为0700,用于记录hangs</li>
</ul>
</li>
<li>通常有用的文件描述符<ul>
<li><code>dev_null_fd = open(&quot;/dev/null&quot;, O_RDWR);</code>以读写模式打开<code>/dev/null</code></li>
<li><code>dev_urandom_fd = open(&quot;/dev/urandom&quot;, O_RDONLY);</code>,以只读模式打开<code>/dev/urandom</code></li>
</ul>
</li>
<li>建立Gnuplot输出文件夹<ul>
<li><code>fd = open(tmp, O_WRONLY | O_CREAT | O_EXCL, 0600);</code></li>
<li>以只写方式打开<code>out_dir/plot_data</code>文件，如果文件不存在，就创建，并获取句柄</li>
<li><code>plot_file = fdopen(fd, &quot;w&quot;);</code>根据句柄得到FILE* plot_file<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- 使用 `fdopen()` 函数将文件描述符 `fd` 关联到一个文件流，以便后续进行文件操作。参数 &quot;w&quot; 表示以写入模式打开文件流。</span><br></pre></td></tr></table></figure></li>
<li>向其中写入<code># unix_time, cycles_done, cur_path, paths_total, pending_total, pending_favs, map_size, unique_crashes, unique_hangs, max_depth, execs_per_sec\n</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="read-testcases"><a href="#read-testcases" class="headerlink" title="read_testcases"></a>read_testcases</h4><ul>
<li>从输入文件夹中读取所有文件，然后将它们排队进行测试。<ul>
<li>尝试访问<code>in_dir/queue</code>文件夹，如果存在就重新设置<code>in_dir</code>为<code>in_dir/queue</code><ul>
<li>Auto-detect non-in-place resumption attempts.</li>
</ul>
</li>
<li><code>scandir</code>扫描in_dir，并将结果保存在<code>struct dirent **nl</code>里<ul>
<li>不使用readdir,因为测试用例的顺序将随机地有些变化,并且将难以控制。</li>
</ul>
</li>
<li>如果设置宏<code>AFL_SHUFFLE_QUEUE</code>, <code>shuffle_queue</code>的值为真，且nl_cnt大于1<ul>
<li>则<code>shuffle_ptrs((void **) nl, nl_cnt)</code>，字面意思上就是重排nl里的指针的位置。<strong>随机化</strong></li>
</ul>
</li>
<li>遍历<code>nl,nl[i]-&gt;d_name</code>的值为input文件夹下的文件名字符串<ul>
<li><code>u8 *fn = alloc_printf(&quot;%s/%s&quot;, in_dir, nl[i]-&gt;d_name);</code></li>
<li><code>u8 *dfn = alloc_printf(&quot;%s/.state/deterministic_done/%s&quot;, in_dir, nl[i]-&gt;d_name);</code></li>
<li>通过<code>lstat(fn, &amp;st) &amp;&amp; !S_ISREG(st.st_mode)</code>, 文件属性过滤掉<code>.</code>和<code>..</code>这样的regular文件，并检查文件大小，如果文件大小大于MAX_FILE，默认是<code>1024*1024</code>字节，即<strong>1M</strong></li>
<li><code>find . -type f -size +1M</code></li>
<li>通过access检查<code>in_dir/.state/deterministic_done/nl[i]-&gt;d_name</code>是否存在，这应该是为了用在resume恢复扫描使用</li>
<li>如果存在就设置<code>passed_det</code>为1</li>
<li>这个检查是用来判断是否这个entry已完成<code>deterministic fuzzing</code>。在恢复异常终止的扫描时，我们不想重复<code>deterministic fuzzing</code>，因为这将毫无意义，而且可能非常耗时</li>
<li><code>add_to_queue(fn, st.st_size, passed_det);</code></li>
<li>[[#add_to_queue(u8 *fname, u32 len, u8 passed_det)]]</li>
<li>如果<code>queued_paths</code>为0，则代表输入文件夹为0，抛出异常</li>
<li>设置 <code>last_path_time</code> 为0</li>
<li><code>queued_at_start</code>的值设置为queued_paths<ul>
<li>Total number of initial inputs</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="add-to-queue-u8-fname-u32-len-u8-passed-det"><a href="#add-to-queue-u8-fname-u32-len-u8-passed-det" class="headerlink" title="add_to_queue(u8 *fname, u32 len, u8 passed_det)"></a>add_to_queue(u8 *fname, u32 len, u8 passed_det)</h4><ul>
<li>将新的测试用例添加到队列中，以供后续进行测试。<ul>
<li>形成一个链表 <code>queue_top</code></li>
<li>会添加测试用例 然后 <code>queued_paths++</code></li>
</ul>
</li>
<li><code>queue_entry</code>是一个链表数据结构</li>
<li>先通过calloc动态分配一个<code>queue_entry</code>结构体，并 <strong>初始化其fname为文件名fn，len为文件大小，depth为cur_depth + 1, passed_det为传递进来的 passed_det</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">q-&gt;fname = fname;  </span><br><span class="line">q-&gt;len = len;  </span><br><span class="line">q-&gt;depth = cur_depth + <span class="number">1</span>;  </span><br><span class="line">q-&gt;passed_det = passed_det;  </span><br></pre></td></tr></table></figure>

<ul>
<li>如果<code>q-&gt;depth &gt; max_depth</code>，则设置<code>max_depth为q-&gt;depth</code></li>
<li>如果queue_top不为空，则设置<code>queue_top-&gt;next为q，queue_top = q;</code>，否则<code>q_prev100 = queue = queue_top = q;</code></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> <span class="title class_">queue_entry</span> *queue, <span class="comment">/* Fuzzing queue (linked list)*/</span>  </span><br><span class="line">*queue_top, <span class="comment">/* Top of the list            */</span>  </span><br><span class="line">*q_prev100; <span class="comment">/* Previous 100 marker        */</span>  </span><br></pre></td></tr></table></figure>

<ul>
<li>queue计数器 queued_paths 和待fuzz的样例计数器 <code>pending_not_fuzzed</code> 加一</li>
<li>cycles_wo_finds 设置为0<ul>
<li><code>Cycles without any new paths</code></li>
</ul>
</li>
<li>如果<code>queued_paths % 100</code>得到0，则设置<code>q_prev100-&gt;next_100 = q; q_prev100 = q;</code></li>
<li>设置 <code>last_path_time</code> 为当前时间。</li>
</ul>
<h4 id="load-auto"><a href="#load-auto" class="headerlink" title="load_auto"></a>load_auto</h4><ul>
<li>load自动生成的提取出来的词典token<ul>
<li>遍历循环从i等于0到 <code>USE_AUTO_EXTRAS</code>，默认<code>50</code></li>
<li>以只读模式尝试打开文件名为<code>alloc_printf(&quot;%s/.state/auto_extras/auto_%06u&quot;, in_dir, i)</code>的文件<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- `/home/wutang/Desktop/fuzz_test/fuzz_input/.state/auto_extras/auto_000000`</span><br></pre></td></tr></table></figure></li>
<li>如果打开失败，则结束</li>
<li>如果打开成功，则从fd读取最多<code>MAX_AUTO_EXTRA+1=32+1</code>个字节到tmp数组里，这是单个auto extra文件的最大大小，读取出的长度保存到len里。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-   `3&lt;= len &lt;= 32` 会 `maybe_add_auto(tmp,  );`   [[#maybe_add_auto(u8 *mem, u32 len)]]</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h4 id="maybe-add-auto-u8-mem-u32-len"><a href="#maybe-add-auto-u8-mem-u32-len" class="headerlink" title="maybe_add_auto(u8 *mem, u32 len)"></a>maybe_add_auto(u8 *mem, u32 len)</h4><ul>
<li>如果用户设置了 <code>MAX_AUTO_EXTRAS</code> 或者 <code>USE_AUTO_EXTRAS</code> 为0，则直接返回。</li>
<li><strong>如果不允许自动生成字典项，则直接返回</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Allow users to specify that they don&#x27;t want auto dictionaries. */</span></span><br><span class="line"><span class="keyword">if</span> (!MAX_AUTO_EXTRAS || !USE_AUTO_EXTRAS) <span class="keyword">return</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>跳过连续相同的字节</strong><ul>
<li>循环遍历i从1到len，将<code>tmp[0]</code>和<code>tmp[i]</code>异或，如果相同，则结束循环。</li>
<li>如果结束时<code>i=0</code>，即<code>tmp[0]</code>和<code>tmp[1]</code>就相同，就直接返回。这里我推断tmp应该是从小到大排序的字节流。</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Skip runs of identical bytes. */</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; len; i++)</span><br><span class="line">  <span class="keyword">if</span> (mem[<span class="number">0</span>] ^ mem[i]) <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>根据长度，检查字节序列是否与内置的有趣值相匹配，如果匹配则跳过</strong><ul>
<li>如果len的长度为2，就和interesting_16数组里的元素比较，如果和其中某一个相同，就直接return</li>
<li>如果len的长度为4，就和interesting_32数组里的元素比较，如果和其中某一个相同，就直接return</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (i == len) <span class="keyword">return</span>;</span><br><span class="line"><span class="comment">/* Reject builtin interesting values. */</span></span><br><span class="line"><span class="keyword">if</span> (len == <span class="number">2</span>) &#123;</span><br><span class="line">  i = <span class="built_in">sizeof</span>(interesting_16) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (i--) </span><br><span class="line">    <span class="keyword">if</span> (*((u16*)mem) == interesting_16[i] ||</span><br><span class="line">        *((u16*)mem) == <span class="built_in">SWAP16</span>(interesting_16[i])) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (len == <span class="number">4</span>) &#123;</span><br><span class="line">  i = <span class="built_in">sizeof</span>(interesting_32) &gt;&gt; <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">while</span> (i--) </span><br><span class="line">    <span class="keyword">if</span> (*((u32*)mem) == interesting_32[i] ||</span><br><span class="line">        *((u32*)mem) == <span class="built_in">SWAP32</span>(interesting_32[i])) <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>检查待添加的自动生成字典项是否与已经存在的字典项相匹配，以避免重复添加相同的字典项</strong></li>
<li>这段代码通过优化策略，避免了对所有已存在的字典项进行不必要的比较，而是通过比较待添加字典项的长度来减少实际比较的次数，提高了性能。这样可以有效地防止将相同的字典项重复添加到字典中</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Reject anything that matches existing extras. Do a case-insensitive</span></span><br><span class="line"><span class="comment">   match. We optimize by exploiting the fact that extras[] are sorted</span></span><br><span class="line"><span class="comment">   by size. */</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; extras_cnt; i++)</span><br><span class="line">  <span class="keyword">if</span> (extras[i].len &gt;= len) <span class="keyword">break</span>;</span><br><span class="line">  <span class="comment">// 找到第一个长度大于等于待添加字典项长度的索引 `i`。这是为了减少匹配的次数，因为已存在的字典项是按照长度排好序的。</span></span><br><span class="line"><span class="keyword">for</span> (; i &lt; extras_cnt &amp;&amp; extras[i].len == len; i++)</span><br><span class="line">  <span class="comment">// 然后，在找到的这个位置之后的一段连续长度相等的字典项中，继续循环遍历。这是因为 `extras[]` 是按长度从小到大排列的，所以这段连续长度相等的字典项必然是在相等长度的部分中。</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">memcmp_nocase</span>(extras[i].data, mem, len)) <span class="keyword">return</span>;</span><br><span class="line">  <span class="comment">// 实现了不区分大小写的比较  如果发现有匹配的已存在字典项，则直接返回，不再添加重复的字典项</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>标记自动生成字典项已更改</strong></li>
<li><code>auto_changed = 1;</code>：标记自动生成的字典项已经发生更改。</li>
<li>遍历<code>a_extras</code>数组，比较<code>memcmp_nocase(a_extras[i].data, mem, len)</code>, 如果相同，就将其<code>hit_cnt</code>值加一，这是代表在语料中被use的次数,然后跳转到<code>sort_a_extras</code></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">extra_data</span> &#123;  </span><br><span class="line">u8 *data;                           <span class="comment">/* Dictionary token data    */</span>  </span><br><span class="line">u32 len;                            <span class="comment">/* Dictionary token length  */</span>  </span><br><span class="line">u32 hit_cnt;                        <span class="comment">/* Use count in the corpus  */</span> </span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> <span class="title class_">extra_data</span>* a_extras;   <span class="comment">/* Automatically selected extras    */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Last but not least, check a_extras[] for matches. There are no</span></span><br><span class="line"><span class="comment">     guarantees of a particular sort order. */</span></span><br><span class="line">  auto_changed = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; a_extras_cnt; i++) &#123;</span><br><span class="line">  <span class="comment">// 通过循环遍历已存在的自动生成字典项数组 `a_extras[]`，检查是否有与待添加的字典项内容相匹配的项</span></span><br><span class="line">    <span class="keyword">if</span> (a_extras[i].len == len &amp;&amp; !<span class="built_in">memcmp_nocase</span>(a_extras[i].data, mem, len)) &#123;</span><br><span class="line">      a_extras[i].hit_cnt++;</span><br><span class="line">      <span class="comment">// 增加已存在字典项的命中计数，表示这个字典项被使用的次数增加了。</span></span><br><span class="line">      <span class="keyword">goto</span> sort_a_extras; <span class="comment">// 该标签用于在后续的排序操作中对自动生成字典项数组 `a_extras[]` 进行排序</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>将新的自动生成的字典项添加到 <code>a_extras[]</code> 数组中，管理这个数组的容量</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* At this point, looks like we&#x27;re dealing with a new entry. So, let&#x27;s</span></span><br><span class="line"><span class="comment">   append it if we have room. Otherwise, let&#x27;s randomly evict some other</span></span><br><span class="line"><span class="comment">   entry from the bottom half of the list. */</span></span><br><span class="line"><span class="keyword">if</span> (a_extras_cnt &lt; MAX_AUTO_EXTRAS) &#123;</span><br><span class="line"><span class="comment">// 首先，检查已存在的自动生成字典项的数量是否还未达到最大容量 `MAX_AUTO_EXTRAS`</span></span><br><span class="line">  a_extras = <span class="built_in">ck_realloc_block</span>(a_extras, (a_extras_cnt + <span class="number">1</span>) * <span class="built_in">sizeof</span>(<span class="keyword">struct</span> extra_data));</span><br><span class="line">  a_extras[a_extras_cnt].data = <span class="built_in">ck_memdup</span>(mem, len);</span><br><span class="line">  a_extras[a_extras_cnt].len  = len;</span><br><span class="line">  a_extras_cnt++;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果数组已经达到最大容量</span></span><br><span class="line">  i = MAX_AUTO_EXTRAS / <span class="number">2</span> + <span class="built_in">UR</span>((MAX_AUTO_EXTRAS + <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">  <span class="comment">// 随机选择数组的底部一半中的一个项进行替换</span></span><br><span class="line">  <span class="built_in">ck_free</span>(a_extras[i].data);</span><br><span class="line">  a_extras[i].data    = <span class="built_in">ck_memdup</span>(mem, len); <span class="comment">// 将新的字典项内容复制到被替换的位置中。</span></span><br><span class="line">  a_extras[i].len     = len;</span><br><span class="line">  a_extras[i].hit_cnt = <span class="number">0</span>; <span class="comment">// 将命中计数重置为 0，因为这是一个新的项。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>标签<code>sort_a_extras</code> 对 <code>a_extras[]</code> 数组中的自动生成字典项进行排序</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">compare_extras_use_d</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* p1, <span class="type">const</span> <span class="type">void</span>* p2)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">extra_data</span> *e1 = (<span class="keyword">struct</span> extra_data*)p1,</span><br><span class="line">                    *e2 = (<span class="keyword">struct</span> extra_data*)p2;</span><br><span class="line">  <span class="keyword">return</span> e2-&gt;hit_cnt - e1-&gt;hit_cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* First, sort all auto extras by use count, descending order. */</span></span><br><span class="line">  <span class="built_in">qsort</span>(a_extras, a_extras_cnt, <span class="built_in">sizeof</span>(<span class="keyword">struct</span> extra_data),</span><br><span class="line">        compare_extras_use_d);</span><br><span class="line">  <span class="comment">// 使用 C 语言标准库中的 `qsort()` 函数对 `a_extras[]` 数组中的自动生成字典项按照使用计数（`hit_cnt`）进行降序排序</span></span><br><span class="line">  <span class="comment">// a_extras：待排序数组的首元素地址。</span></span><br><span class="line">  <span class="comment">// a_extras_cnt：数组中元素的数量。</span></span><br><span class="line">  <span class="comment">// sizeof(struct extra_data)：每个元素的大小，用于计算排序时每次移动的字节数。</span></span><br><span class="line">  <span class="comment">// compare_extras_use_d：用于比较两个元素大小关系的比较函数，这里使用的是按照使用计数降序排列。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">compare_extras_len</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* p1, <span class="type">const</span> <span class="type">void</span>* p2)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">extra_data</span> *e1 = (<span class="keyword">struct</span> extra_data*)p1,</span><br><span class="line">                    *e2 = (<span class="keyword">struct</span> extra_data*)p2;</span><br><span class="line">  <span class="keyword">return</span> e1-&gt;len - e2-&gt;len;</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">/* Then, sort the top USE_AUTO_EXTRAS entries by size. */</span></span><br><span class="line">  <span class="built_in">qsort</span>(a_extras, <span class="built_in">MIN</span>(USE_AUTO_EXTRAS, a_extras_cnt),</span><br><span class="line">        <span class="built_in">sizeof</span>(<span class="keyword">struct</span> extra_data), compare_extras_len);</span><br><span class="line">    <span class="comment">// 这次是按照字典项长度进行排序，但只对数组中前 `USE_AUTO_EXTRAS=50` 个元素进行排序</span></span><br><span class="line">    <span class="comment">// 这是因为在之前的排序中，数组已经按照使用计数进行了排序，现在只需要对其中最重要的一部分元素按照长度排序即可。</span></span><br></pre></td></tr></table></figure>

<h4 id="pivot-inputs"><a href="#pivot-inputs" class="headerlink" title="pivot_inputs"></a>pivot_inputs</h4><ul>
<li>函数负责将输入测试用例文件重新命名、链接（或拷贝）到输出目录中，并在需要的情况下更新文件名以及关联的信息。这有助于模糊测试过程的组织和恢复</li>
<li>逻辑上说这个函数就是为<code>inputdir</code>里的<code>testcase</code>，在<code>output dir</code>里创建<code>hard link</code><ul>
<li>初始化<code>id=0</code></li>
<li>依次遍历queue里的queue_entry<ul>
<li><code>u8  *nfn, *rsl = strrchr(q-&gt;fname, &#39;/&#39;);</code></li>
<li><code>q-&gt;fname   /home/wutang/Desktop/fuzz_test/fuzz_input/1</code></li>
<li><code>if (!rsl) rsl = q-&gt;fname; else rsl++;</code><ul>
<li>rsl 变成 <code>1</code></li>
</ul>
</li>
<li>将rsl的前三个字节和<code>id:</code>进行比较<ul>
<li>如果相等，则设置<code>resuming_fuzz</code>为1,然后做一些恢复操作，不叙述。<ul>
<li>赋值 orig_id  为  <code>id:123</code>的123</li>
<li>…</li>
</ul>
</li>
<li>如果不相等<ul>
<li>在rsl里寻找<code>,orig:</code>子串，如果找到了，将use_name指向该子串的冒号后的名字；如果没找到，就另<code>use_name = rsl</code></li>
<li><code>nfn = alloc_printf(&quot;%s/queue/id:%06u,orig:%s&quot;, out_dir, id, use_name);</code></li>
<li><code>nfn   /home/wutang/Desktop/fuzz_test/fuzz_output/fuzzer1/queue/id:000000,orig:1</code></li>
</ul>
</li>
</ul>
</li>
<li>尝试创建从<code>q-&gt;fname</code> 到 <code>nfn</code> 的硬链接   <code>link_or_copy(q-&gt;fname, nfn);</code><ul>
<li>可能性执行链接（link）或者拷贝（copy）操作，将一个文件从一个路径复制到另一个路径</li>
<li>&#96;&#96;c_link_copy</li>
</ul>
</li>
<li>修改q的 <code>fname</code> 指向这个硬链接 <code>nfn</code></li>
<li>如果q的<code>passed_det</code>为1，则<code>mark_as_det_done(q)</code>,这主要是对应上面的 <code>resuming_fuzz</code>的情况。<ul>
<li>mark_as_det_done简单的说就是打开<code>out_dir/queue/.state/deterministic_done/use_name</code>这个文件，如果不存在就创建这个文件，然后设置q的passed_det为1。</li>
<li>这里的<code>use_name就是orig:后面的字符串</code></li>
</ul>
</li>
</ul>
</li>
<li>如果设置了<code>-i -</code> 也就是 <code>in_place_resume</code> 为1，则 <code>nuke_resume_dir()</code><ul>
<li><code>nuke_resume_dir()</code><ul>
<li>删除<code>out_dir/_resume/.state/deterministic_done</code>文件夹下所有<code>id:</code>前缀的文件</li>
<li>删除<code>out_dir/_resume/.state/auto_extras</code>文件夹下所有<code>auto_</code>前缀的文件</li>
<li>删除<code>out_dir/_resume/.state/redundant_edges</code>文件夹下所有<code>id:</code>前缀的文件</li>
<li>删除<code>out_dir/_resume/.state/variable_behavior</code>文件夹下所有<code>id:</code>前缀的文件</li>
<li>删除文件夹<code>out_dir/_resume/.state</code></li>
<li>删除<code>out_dir/_resume</code>文件夹下所有<code>id:</code>前缀的文件</li>
<li>如果全部删除成功就正常返回，如果有某一个删除失败就抛出异常。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="load-extras"><a href="#load-extras" class="headerlink" title="load_extras"></a>load_extras</h4><ul>
<li>这段代码负责加载额外的字典文件（extra dictionary）并对其进行排序，使其按照字典条目的大小进行排列</li>
<li>如果定义了extras_dir，则从extras_dir读取extras到extras数组里，并按size排序。<ul>
<li><code>-x @123</code> 表示要提取字典级别（level），并将 <code>@</code> 之后的数字解析为字典级别 <code>dict_level</code>。</li>
<li>打开目录 <code>dir</code>，使用 <code>opendir</code> 函数。<ul>
<li>如果打开目录失败，首先检查错误类型。<ul>
<li>如果错误是 <code>ENOTDIR</code>，则表示 <code>dir</code> 不是一个目录，可能是一个文件路径，因此尝试以文件方式加载字典文件，跳转到 <code>load_extras_file</code> 进行处理。<ul>
<li><code>goto check_and_sort;</code>之后退出循环</li>
</ul>
</li>
<li>如果不是 <code>ENOTDIR</code> 错误，而是其他错误，使用 <code>PFATAL</code> 报错，指示无法打开目录</li>
</ul>
</li>
<li>如果 <code>x</code> 存在（之前解析了字典级别），则报错，因为当前版本不支持目录级别的字典文件。</li>
<li>如果打开目录成功<ul>
<li>遍历目录文件<ul>
<li>过滤 <code>.</code> or <code>..</code></li>
<li>大小大雨 MAX_DICT_FILE 128  ，用 <code>FATAL</code> 报错，指示该额外字典文件过大。</li>
</ul>
</li>
<li>跟踪最小和最大字典文件大小，以便在之后显示有关额外字典文件的信息</li>
<li>为 <code>extras</code> 数组分配更多的内存以容纳新的字典文件。<ul>
<li>分配足够的内存来存储字典文件的内容，并将大小设置为文件大小。</li>
</ul>
</li>
<li>增加 <code>extras_cnt</code> 计数器，表示已加载的额外字典文件数量</li>
</ul>
</li>
<li><code>check_and_sort</code><ul>
<li>使用 <code>qsort</code> 对 <code>extras</code> 数组中的字典文件进行按照大小排序。</li>
<li>如果最大字典条目大小超过 32，使用 <code>WARNF</code> 发出警告，建议考虑裁剪字典条目。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="find-timeout"><a href="#find-timeout" class="headerlink" title="find_timeout"></a>find_timeout</h4><ul>
<li>这段代码的作用是用于寻找之前会话中的超时设置，并将其应用于当前会话。主要用于在恢复会话时，不希望超时设置重复地自动进行缩放，以防止由于随机因素而导致超时设置不断增大</li>
<li>如果 <code>timeout_given</code> 没有被设置，则进入find_timeout<ul>
<li>这个想法是，在不指定 <code>-t</code> 的情况下 <code>resuming sessions</code> 时，我们不希望一遍又一遍地自动调整超时时间，以防止超时值因随机波动而增长</li>
<li>如果 <code>resuming_fuzz</code> 为0，则直接 return ,不需要恢复</li>
<li>如果 <code>in_place_resume</code> 为1，则<code>fn = alloc_printf(&quot;%s/fuzzer_stats&quot;, out_dir);</code>，否则<code>fn = alloc_printf(&quot;%s/../fuzzer_stats&quot;, in_dir);</code></li>
<li>以只读方式打开fd，读取内容到<code>tmp[4096]</code>里，并在里面搜索 <code>exec_timeout :</code> ，如果搜索不到就直接返回，如果搜索到了，就读取这个timeout的数值，如果大于4就设置为exec_tmout的值。<ul>
<li><code>EXP_ST u32 exec_tmout = EXEC_TIMEOUT; /* Configurable exec timeout (ms) */</code></li>
</ul>
</li>
<li><code>timeout_given = 3;</code><ul>
<li><code>timeout_given, /* Specific timeout given? */</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="detect-file-args"><a href="#detect-file-args" class="headerlink" title="detect_file_args"></a>detect_file_args</h4><ul>
<li>这个函数其实就是识别参数里面有没有<code>@@</code>，如果有就替换为<code>out_dir/.cur_input</code>，如果没有就返回<ul>
<li>替换为 <code>/home/wutang/Desktop/fuzz_test/fuzz_output/fuzzer1/.cur_input</code></li>
</ul>
</li>
</ul>
<h4 id="setup-stdio-file"><a href="#setup-stdio-file" class="headerlink" title="setup_stdio_file"></a>setup_stdio_file</h4><ul>
<li>如果out_file为NULL ， 如果没有使用-f  &amp;&amp; 或者没有指定 <code>@@</code>，就删除原本的<code>out_dir/.cur_input</code>，创建一个新的<code>out_dir/.cur_input</code>，保存其文件描述符在out_fd中</li>
</ul>
<h4 id="check-binary"><a href="#check-binary" class="headerlink" title="check_binary"></a>check_binary</h4><ul>
<li>这段代码用于验证目标二进制文件的合法性和是否进行了适当的 AFL 仪表插装（instrumentation）。具体来说，它检查二进制文件是否存在、是否为可执行文件、是否为 ELF 或 Mach-O 格式，是否包含 AFL 仪表插装标记，以及其他相关特征。<ul>
<li><code>/home/wutang/Desktop/google_afl/llvm_mode/test-instr</code></li>
<li>可以指定 <code>AFL_SKIP_BIN_CHECK</code> 跳过check</li>
<li>…</li>
</ul>
</li>
<li>check指定路径处要执行的程序是否存在，且它不能是一个shell script</li>
</ul>
<h4 id="perform-dry-run"><a href="#perform-dry-run" class="headerlink" title="perform_dry_run"></a>perform_dry_run</h4><h5 id="输入参数"><a href="#输入参数" class="headerlink" title="输入参数"></a>输入参数</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">/home/wutang/Desktop/google_afl/llvm_mode/test-instr /home/wutang/Desktop/fuzz_test/fuzz_output/fuzzer1/.cur_input</span><br></pre></td></tr></table></figure>

<h5 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h5><ul>
<li>确认目标应用程序是否按预期工作。干扰运行是在初始的输入测试用例上进行的，用于验证应用程序在不进行实际变异的情况下是否会崩溃、超时或产生其他异常行为。</li>
<li>执行所有的测试用例，以检查是否按预期工作<ul>
<li>读取环境变量 <code>AFL_SKIP_CRASHES</code> 到<code>skip_crashes</code>，设置cal_failures为0</li>
<li>遍历queue<ul>
<li>打开q-&gt;fname，并读取到分配的内存use_mem里</li>
<li><code>/home/wutang/Desktop/fuzz_test/fuzz_output/fuzzer1/queue/id:000000,orig:1</code></li>
<li><code>res = calibrate_case(argv, q, use_mem, 0, 1);</code><ul>
<li>校准测试用例 [[#u8 calibrate_case(char **argv, struct queue_entry *q, u8 *use_mem, u32 handicap, u8 from_queue)]] 返回res</li>
</ul>
</li>
<li>如果<code>stop_soon</code>被置为1，就直接return</li>
<li>如果res的结果为<code>crash_mode</code>或者<code>FAULT_NOBITS</code><ul>
<li>打印<code>SAYF(&quot;len = %u, map size = %u, exec speed = %llu us\n&quot;, q-&gt;len, q-&gt;bitmap_size, q-&gt;exec_us);</code></li>
<li>比如 <code>len = 4, map size = 2, exec speed = 3237980 us</code></li>
</ul>
</li>
<li>依据res的结果查看是哪种错误并进行判断。一共有以下几种错误类型<ul>
<li>FAULT_NONE<ul>
<li>如果q是头结点，即第一个测试用例，则<code>check_map_coverage</code>，用以评估map coverage [[#void check_map_coverage(void)]] 测试覆盖率低直接告警<ul>
<li>检查覆盖率地图（coverage map）的覆盖情况。覆盖率地图是记录在模糊测试中哪些代码路径被执行过的数据结构</li>
<li>计数trace_bits发现的路径数，如果小于100，就直接返回</li>
<li>在trace_bits的数组后半段，如果有值就直接返回。</li>
<li>抛出警告<code>WARNF(&quot;Recompile binary with newer version of afl to improve coverage!&quot;)</code></li>
</ul>
</li>
<li>设置<code>-C</code> 也就是设置crash_mode为<code>FAULT_CRASH</code>则抛出异常，<code>FATAL(&quot;Test case &#39;%s&#39; does *NOT* crash&quot;, fn);</code>，该文件不崩溃</li>
</ul>
</li>
<li>FAULT_TMOUT<ul>
<li>如果指定了-t参数，<code>-t 360000+</code>则timeout_given值为2<ul>
<li>抛出警告<code>WARNF(&quot;Test case results in a timeout (skipping)&quot;);</code>，并设置q的cal_failed为CAL_CHANCES，cal_failures计数器加一。</li>
</ul>
</li>
</ul>
</li>
<li>FAULT_CRASH<ul>
<li>设置<code>-Q</code> 会设置 <code>mem_limit</code>, 判断是否指定<code>mem_limit</code>，给出不同的内存的建议</li>
<li>但不管指定了还是没有，都会抛出异常<code>FATAL(&quot;Test case &#39;%s&#39; results in a crash&quot;, fn);</code></li>
</ul>
</li>
<li>FAULT_ERROR<ul>
<li>抛出异常<code>Unable to execute target application</code></li>
</ul>
</li>
<li>FAULT_NOINST<ul>
<li>这个样例运行没有出现任何路径信息，抛出异常<code>No instrumentation detected</code></li>
</ul>
</li>
<li>FAULT_NOBITS<ul>
<li>如果这个样例有出现路径信息，但是没有任何新路径，抛出警告<code>WARNF(&quot;No new instrumentation output, test case may be useless.&quot;)</code>，认为这是无用路径。useless_at_start计数器加一</li>
</ul>
</li>
</ul>
</li>
<li>如果这个样例q的var_behavior为真，则代表它多次运行，同样的输入条件下，却出现不同的覆盖信息。<ul>
<li>抛出警告<code>WARNF(&quot;Instrumentation output varies across runs.&quot;);</code>，代表这个样例的路径输出可变</li>
</ul>
</li>
<li>然后读取下一个queue，继续测试，直到结束。</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> &#123;  </span><br><span class="line"><span class="comment">/* 00 */</span> FAULT_NONE,  </span><br><span class="line"><span class="comment">/* 01 */</span> FAULT_TMOUT,  </span><br><span class="line"><span class="comment">/* 02 */</span> FAULT_CRASH,  </span><br><span class="line"><span class="comment">/* 03 */</span> FAULT_ERROR,  </span><br><span class="line"><span class="comment">/* 04 */</span> FAULT_NOINST,  </span><br><span class="line"><span class="comment">/* 05 */</span> FAULT_NOBITS </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="u8-calibrate-case-char-argv-struct-queue-entry-q-u8-use-mem-u32-handicap-u8-from-queue"><a href="#u8-calibrate-case-char-argv-struct-queue-entry-q-u8-use-mem-u32-handicap-u8-from-queue" class="headerlink" title="u8 calibrate_case(char **argv, struct queue_entry *q, u8 *use_mem, u32 handicap, u8 from_queue)"></a>u8 calibrate_case(char **argv, struct queue_entry *q, u8 *use_mem, u32 handicap, u8 from_queue)</h4><ul>
<li>对一个新的测试用例进行校准（calibration）。校准是为了验证测试用例的执行结果，确认应用程序的行为，同时检测出变量行为等情况。</li>
<li>这个函数评估input文件夹下的case，来发现这些testcase的行为是否异常；以及在发现新的路径时，用以评估这个新发现的testcase的行为是否是可变（这里的可变是指多次执行这个case，发现的路径不同）等等<ul>
<li>创建<code>first_trace[MAP_SIZE]</code></li>
<li>如果<code>q-&gt;exec_cksum</code>为0，代表这是这个case第一次运行，即来自input文件夹下，所以将first_run置为1。</li>
<li>保存原有的stage_cur、stage_max、stage_name</li>
<li>设置use_tmout为exec_tmout,如果from_queue是0或者resuming_fuzz被置为1，即代表不来自于queue中或者在resuming sessions的时候，则use_tmout的值被设置的更大。</li>
<li><code>q-&gt;cal_failed++</code></li>
<li>设置stage_name为”calibration”,以及根据是否fast_cal为1，来设置stage_max的值为3还是CAL_CYCLES(默认为8)，含义是每个新测试用例（以及显示出可变行为的测试用例）的校准周期数，也就是说这个stage要执行几次的意思。</li>
<li>如果当前不是以dumb mode运行，且no_forkserver（禁用forkserver）为0，且forksrv_pid为0，则<ul>
<li><code>init_forkserver(argv)</code>启动fork server  [[#init_forkserver]]</li>
</ul>
</li>
<li>如果<strong>这个queue不是来自input文件夹，而是评估新case</strong>，则此时<code>q-&gt;exec_cksum</code>不为空，拷贝trace_bits到first_trace里，然后计算<code>has_new_bits</code>的值，赋值给new_bits。<ul>
<li>[[#has_new_bits(u8 *virgin_map)]]</li>
</ul>
</li>
<li>开始执行<code>calibration stage</code>，共执行stage_max循环<ul>
<li>如果<strong>这个queue不是来自input文件夹，而是评估新case</strong>，且第一轮calibration stage执行结束时，刷新一次展示界面<code>show_stats</code>，用来展示这次执行的结果，此后不再展示。</li>
<li><code>write_to_testcase(use_mem, q-&gt;len)</code><ul>
<li>将从<code>q-&gt;fname</code>中读取的内容写入到<code>.cur_input</code>中</li>
<li>[[#void write_to_testcase(void *mem, u32 len)]]</li>
</ul>
</li>
<li><code>u8 run_target(argv, use_tmout)</code>,通过Fork-server 开始fork出子进程进进行fuzz, <strong>对trace_bits进行赋值</strong>，运行目标应用程序并监控是否超时，返回运行结果的状态信息<ul>
<li>[[#u8 run_target(char **argv, u32 timeout)]]  返回res</li>
</ul>
</li>
<li>如果这是<code>calibration stage</code>第一次运行，且不在<code>dumb_mode</code>，且共享内存里没有任何路径（即没有任何byte被置位），设置fault为<code>FAULT_NOINST</code>,然后<code>goto abort_calibration</code><ul>
<li>计算共享内存里有多少字节被置位了,通过count_bytes函数。 计算在位图中设置为1的字节数量的函数, 验证 0x4000 字节的数据<ul>
<li>[[#u32 count_bytes(u8 *mem)]]</li>
</ul>
</li>
</ul>
</li>
<li>计算<code>hash32(trace_bits, MAP_SIZE, HASH_CONST)</code>的结果，其值为一个32位uint值，保存到cksum中.计算长度为2的16次方hash<ul>
<li>[[#inline u32 hash32(const void* key, u32 len, u32 seed)]]</li>
</ul>
</li>
<li>如果<code>q-&gt;exec_cksum</code>不等于cksum，即代表<strong>这是第一次运行，或者在相同的参数下，每次执行，cksum却不同，是一个路径可变的queue</strong><ul>
<li><code>hnb = has_new_bits(virgin_bits)</code>  [[#char has_new_bits(u8 *virgin_map)]] 目的是检查当前执行路径是否带来了新的信息（新的位）。它会更新”virgin_map”以反映新发现的位，并返回不同的值来表示发现的情况</li>
<li>如果hnb大于new_bits，设置new_bits的值为hnb</li>
<li>如果<code>q-&gt;exec_cksum</code>不等于0，即代表这是判断是否是可变queue<ul>
<li>i从0到MAP_SIZE遍历，如果 <code>first_trace[i]</code> 不等于 <code>trace_bits[i]</code> ，<strong>代表发现了可变queue</strong>，且var_bytes为空，则将该字节设置为1，并将stage_max设置为<code>CAL_CYCLES_LONG</code>，即需要执行40次。</li>
<li>将var_detected设置为1</li>
</ul>
</li>
<li>否则，即<code>q-&gt;exec_cksum</code>等于0，即代表这是第一次执行这个queue<ul>
<li>设置<code>q-&gt;exec_cksum</code>的值为之前计算出来的本次执行的cksum</li>
<li>拷贝trace_bits到first_trace中。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>保存所有轮次总的执行时间，加到 <code>total_cal_us</code> 里，总的执行轮次，加到 <code>total_cal_cycles</code> 里</li>
<li>计算出一些统计信息，包括<ul>
<li>计算出单次执行时间的平均值保存到<code>q-&gt;exec_us</code>里</li>
<li>将最后一次执行所覆盖到的路径数保存到<code>q-&gt;bitmap_size</code>里</li>
<li><code>q-&gt;handicap = handicap;</code></li>
<li><code>q-&gt;cal_failed = 0;</code></li>
<li>total_bitmap_size里加上这个queue所覆盖到的路径数</li>
<li>total_bitmap_entries++</li>
<li>[[#update_bitmap_score(struct queue_entry *q)]] 更新路径的评分，以便确定哪些路径是更有利于模糊测试的</li>
<li>如果fault为<code>FAULT_NONE</code>，且该queue是第一次执行，且不属于<code>dumb_mode</code>，而且<code>new_bits</code>为0，<strong>代表在这个样例所有轮次的执行里，都没有发现任何新路径和出现异常</strong>，设置fault为<code>FAULT_NOBITS</code></li>
</ul>
</li>
<li>如果new_bits为2，且<code>q-&gt;has_new_cov</code>为0，设置其值为1，并将queued_with_cov加一，<strong>代表有一个queue发现了新路径</strong>。</li>
<li>如果这个queue是可变路径，即<code>var_detected</code>为1，则计算<code>var_bytes</code>里被置位的tuple个数，保存到<code>var_byte_count</code>里，代表这些tuple具有可变的行为。<ul>
<li>将这个queue标记为一个variable<ul>
<li><code>mark_as_variable(struct queue_entry *q)</code><ul>
<li>创建符号链接<code>out_dir/queue/.state/variable_behavior/fname</code></li>
<li>设置queue的var_behavior为1</li>
</ul>
</li>
<li>计数variable behavior的计数器<code>queued_variable</code>的值加一</li>
</ul>
</li>
</ul>
</li>
<li>恢复之前的stage值</li>
<li>如果不是第一次运行这个queue，展示<code>show_stats</code></li>
<li>返回fault的值</li>
</ul>
</li>
</ul>
<h4 id="init-forkserver"><a href="#init-forkserver" class="headerlink" title="init_forkserver"></a>init_forkserver</h4><ul>
<li>建立管道<code>st_pipe</code>传递状态和<code>ctl_pipe</code> 传递命令，在父子进程之间，是通过管道进行通信<ul>
<li>在继续往下读之前需要仔细阅读这篇文章</li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/58489873">Linux 的进程间通信：管道</a><ul>
<li><a target="_blank" rel="noopener" href="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-07-22-145348.jpg"><img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-07-22-145348.jpg"></a></li>
<li>我们也可以理解为，管道本质上就是一个文件，前面的进程以写方式打开文件，后面的进程以读方式打开。这样前面写完后面读，于是就实现了通信。</li>
<li>&#96;&#96;linux_mkfifo_mknod_pipe</li>
</ul>
</li>
</ul>
</li>
<li>fork出一个子进程，fork函数执行完毕后，如果创建新进程成功，则出现两个进程，一个是子进程，一个是父进程。在子进程中，fork函数返回0，在父进程中，fork返回新创建子进程的进程ID。我们可以通过fork返回的值来判断当前进程是子进程还是父进程。<ul>
<li><code>forksrv_pid = fork()</code></li>
</ul>
</li>
<li>子进程和父进程都会向下执行，我们通过pid来使它们执行不同的代码<code>if(!forksrv_pid)</code><ul>
<li>以下都是子进程要执行的代码<ul>
<li>在继续向下读之前，需要仔细阅读这篇文章<ul>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/GODYCA/archive/2013/01/05/2846197.html">进程间通信管道进阶篇：linux下dup&#x2F;dup2函数的用法</a></li>
<li>&#96;&#96;linux_dup_dup2</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="init-forkserver父进程行为"><a href="#init-forkserver父进程行为" class="headerlink" title="init_forkserver父进程行为"></a>init_forkserver父进程行为</h5><ul>
<li>以下都是父进程要执行的代码<ul>
<li>关闭不需要的endpoints</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 关闭不是需要的endpoints</span></span><br><span class="line"><span class="built_in">close</span>(ctl_pipe[<span class="number">0</span>]);</span><br><span class="line"><span class="built_in">close</span>(st_pipe[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">fsrv_ctl_fd = ctl_pipe[<span class="number">1</span>]; <span class="comment">//父进程只能发送(&quot;写出&quot;)命令\</span></span><br><span class="line"><span class="comment">fsrv_st_fd = st_pipe[0];   //父进程只能读取状态</span></span><br></pre></td></tr></table></figure>

<ul>
<li>init_forkserver设置子进程超时</li>
<li>之前设置了 timeout方法  [[#setup_signal_handlers]]</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Wait for the fork server to come up, but don&#x27;t wait too long. */</span></span><br><span class="line">it.it_value.tv_sec = ((exec_tmout * FORK_WAIT_MULT) / <span class="number">1000</span>);</span><br><span class="line">it.it_value.tv_usec = ((exec_tmout * FORK_WAIT_MULT) % <span class="number">1000</span>) * <span class="number">1000</span>;</span><br><span class="line"><span class="built_in">setitimer</span>(ITIMER_REAL, &amp;it, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">rlen = <span class="built_in">read</span>(fsrv_st_fd, &amp;status, <span class="number">4</span>);</span><br><span class="line">it.it_value.tv_sec = <span class="number">0</span>;</span><br><span class="line">it.it_value.tv_usec = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">setitimer</span>(ITIMER_REAL, &amp;it, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>等待fork server启动，但是不能等太久。（所以在调试时要注意这个…） 设置-t<ul>
<li>从管道里读取4个字节到status里，如果读取成功，则代表fork server成功启动，就结束这个函数并返回。</li>
<li>如果超时，就抛出异常。</li>
</ul>
</li>
<li></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ACTF</span>(<span class="string">&quot;read pipe block&quot;</span>);</span><br><span class="line">rlen = <span class="built_in">read</span>(fsrv_st_fd, &amp;status, <span class="number">4</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>这里阻塞进入子进程 [[#init_forkserver子进程行为]]</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">it.it_value.tv_sec = <span class="number">0</span>;</span><br><span class="line">it.it_value.tv_usec = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">setitimer</span>(ITIMER_REAL, &amp;it, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* If we have a four-byte &quot;hello&quot; message from the server, we&#x27;re all set.</span></span><br><span class="line"><span class="comment">   Otherwise, try to figure out what went wrong. */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (rlen == <span class="number">4</span>) &#123;</span><br><span class="line">  <span class="built_in">OKF</span>(<span class="string">&quot;All right - fork server is up.&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>之后关闭timer 然后读取到4字节退出返回父进程</li>
</ul>
<h5 id="init-forkserver子进程行为"><a href="#init-forkserver子进程行为" class="headerlink" title="init_forkserver子进程行为"></a>init_forkserver子进程行为</h5><ul>
<li>进入 <code>if(!forksrv_pid)</code><ul>
<li>在 fork 服务器初始化时执行的，其主要目的是设置子进程的执行环境，然后使用 <code>execv</code> 调用目标二进制文件</li>
<li>设置文件描述符限制</li>
<li>做重定向<ul>
<li><code>dev_null_fd = open(&quot;/dev/null&quot;, O_RDWR);</code> 之前</li>
<li><code>dup2(dev_null_fd, 1);</code> 标准输出（文件描述符 1）</li>
<li><code>dup2(dev_null_fd, 2);</code> 标准错误（文件描述符 2）</li>
<li>如果指定了 <code>out_file</code>   <code>dup2(dev_null_fd, 0);</code> 将标准输入重定向到 <code>/dev/null</code><ul>
<li>否则 <code>dup2(out_fd, 0);</code> <code>标准输入重定向到文件</code></li>
</ul>
</li>
<li><strong>子进程只能读取命令</strong>   <code>dup2(ctl_pipe[0], FORKSRV_FD)</code></li>
<li><strong>子进程只能发送(“写出”)状态</strong> <code>dup2(st_pipe[1], FORKSRV_FD + 1) &lt; 0)</code></li>
</ul>
</li>
<li>关闭子进程里的一些文件描述符</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">struct</span> <span class="title class_">rlimit</span> r;</span><br><span class="line">    <span class="comment">/* Umpf. On OpenBSD, the default fd limit for root users is set to</span></span><br><span class="line"><span class="comment">       soft 128. Let&#x27;s try to fix that... */</span></span><br><span class="line">    <span class="comment">// 获取当前进程的文件描述符限制。`RLIMIT_NOFILE` 表示文件描述符数量的限制。</span></span><br><span class="line">    <span class="comment">// r.rlim_cur 表示当前进程的软限制，即允许的最大文件描述符数量。</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">getrlimit</span>(RLIMIT_NOFILE, &amp;r) &amp;&amp; r.rlim_cur &lt; FORKSRV_FD + <span class="number">2</span>) &#123;</span><br><span class="line">      r.rlim_cur = FORKSRV_FD + <span class="number">2</span>;</span><br><span class="line">      <span class="built_in">setrlimit</span>(RLIMIT_NOFILE, &amp;r); <span class="comment">/* Ignore errors */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mem_limit) &#123; <span class="comment">// 默认50</span></span><br><span class="line">      r.rlim_max = r.rlim_cur = ((<span class="type">rlim_t</span>)mem_limit) &lt;&lt; <span class="number">20</span>; <span class="comment">// 50 ^20 = 52428800</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> RLIMIT_AS</span></span><br><span class="line">      <span class="built_in">setrlimit</span>(RLIMIT_AS, &amp;r); <span class="comment">/* Ignore errors */</span></span><br><span class="line">      <span class="comment">// 来设置进程的地址空间限制，即最大可用虚拟内存空间的限制。</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"></span><br><span class="line">      <span class="comment">/* This takes care of OpenBSD, which doesn&#x27;t have RLIMIT_AS, but</span></span><br><span class="line"><span class="comment">         according to reliable sources, RLIMIT_DATA covers anonymous</span></span><br><span class="line"><span class="comment">         maps - so we should be getting good protection against OOM bugs. */</span></span><br><span class="line"></span><br><span class="line">      <span class="built_in">setrlimit</span>(RLIMIT_DATA, &amp;r); <span class="comment">/* Ignore errors */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* ^RLIMIT_AS */</span></span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* Dumping cores is slow and can lead to anomalies if SIGKILL is delivered</span></span><br><span class="line"><span class="comment">       before the dump is complete. */</span></span><br><span class="line">    <span class="comment">// 设置进程的 core dump（核心转储）限制，即当程序发生崩溃或异常情况时，是否生成核心转储文件。核心转储文件通常用于帮助开发人员诊断程序崩溃的原因</span></span><br><span class="line">    r.rlim_max = r.rlim_cur = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">setrlimit</span>(RLIMIT_CORE, &amp;r); <span class="comment">/* Ignore errors */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* Isolate the process and configure standard descriptors. If out_file is</span></span><br><span class="line"><span class="comment">       specified, stdin is /dev/null; otherwise, out_fd is cloned instead. */</span></span><br><span class="line">       <span class="comment">/*</span></span><br><span class="line"><span class="comment">1.  如果调用进程不是一个会话首领（leader），则创建一个新的会话。这意味着调用进程将成为这个新会话的首领。</span></span><br><span class="line"><span class="comment">2.  调用进程将成为新会话的首进程（session leader），新会话中的所有进程都将与控制终端分离。</span></span><br><span class="line"><span class="comment">3.  调用进程不再有控制终端，这是因为新会话中的进程不再与之前的会话或进程组关联。</span></span><br><span class="line"><span class="comment">4. 这个函数通常在后台进程启动时使用，以确保后台进程与终端的完全分离，不会受到终端关闭或其他终端相关操作的影响。</span></span><br><span class="line"><span class="comment">       需要注意的是，`setsid()` 只能由非会话首领进程调用。如果调用进程已经是会话首领，则调用 `setsid()` 会失败。通常情况下，需要在 `fork()` 之后，但在 `exec()` 之前调用 `setsid()`，以确保在新进程中创建新的会话。</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">    <span class="built_in">setsid</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dup2</span>(dev_null_fd, <span class="number">1</span>); <span class="comment">// 之前 dev_null_fd = open(&quot;/dev/null&quot;, O_RDWR);</span></span><br><span class="line">    <span class="built_in">dup2</span>(dev_null_fd, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span> (out_file) &#123;</span><br><span class="line">      <span class="built_in">dup2</span>(dev_null_fd, <span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">dup2</span>(out_fd, <span class="number">0</span>);</span><br><span class="line">      <span class="built_in">close</span>(out_fd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Set up control and status pipes, close the unneeded original fds. */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">dup2</span>(ctl_pipe[<span class="number">0</span>], FORKSRV_FD) &lt; <span class="number">0</span>) <span class="built_in">PFATAL</span>(<span class="string">&quot;dup2() failed&quot;</span>);    <span class="comment">// 子进程只能读取命令</span></span><br><span class="line">    <span class="comment">// 将 `ctl_pipe[0]` 的文件描述符复制到 `FORKSRV_FD` 的位置，`FORKSRV_FD` 通常是一个预定义的值。这实际上是为子进程设置了一个与父进程通信的管道，子进程可以通过这个文件描述符从管道读取数据</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">dup2</span>(st_pipe[<span class="number">1</span>],  FORKSRV_FD + <span class="number">1</span>) &lt; <span class="number">0</span>) <span class="built_in">PFATAL</span>(<span class="string">&quot;dup2() failed&quot;</span>);<span class="comment">// 子进程只能发送(写出)状态</span></span><br><span class="line">    <span class="comment">// 将 `st_pipe[1]` 的文件描述符复制到 `FORKSRV_FD + 1` 的位置，也就是为子进程设置了一个与父进程通信的管道，子进程可以通过这个文件描述符向管道写入数据。</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 关闭子进程里的一些文件描述符</span></span><br><span class="line">    <span class="comment">// 关闭所有的管道是为了确保子进程在不再需要这些管道时不会产生资源泄漏。关闭管道并不会影响之前创建的重定向，因为这些重定向是通过 `dup2` 函数实现的，而不是通过打开文件来实现的</span></span><br><span class="line">    <span class="comment">// 首先使用 dup2 函数将管道的文件描述符复制到特定的位置（比如 FORKSRV_FD 和 FORKSRV_FD + 1），这样子进程就能够通过这些文件描述符进行与父进程的通信。</span></span><br><span class="line">    <span class="built_in">close</span>(ctl_pipe[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">close</span>(ctl_pipe[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">close</span>(st_pipe[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">close</span>(st_pipe[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(out_dir_fd);  <span class="comment">// 用于输出目录的文件描述符，</span></span><br><span class="line">    <span class="built_in">close</span>(dev_null_fd); <span class="comment">// 用于 `/dev/null` 文件的文件描述符，它被用来关闭子进程中的标准输出和标准错误输出</span></span><br><span class="line">    <span class="built_in">close</span>(dev_urandom_fd); <span class="comment">// 这是之前用于随机数生成的 `/dev/urandom` 文件的文件描述符。在子进程中，随机数生成可能不再需要，所以可以关闭这个文件描述符</span></span><br><span class="line">    <span class="built_in">close</span>(<span class="built_in">fileno</span>(plot_file)); <span class="comment">// 这是之前用于绘制图表的文件描述符。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* This should improve performance a bit, since it stops the linker from</span></span><br><span class="line"><span class="comment">       doing extra work post-fork(). */</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">getenv</span>(<span class="string">&quot;LD_BIND_LAZY&quot;</span>)) <span class="built_in">setenv</span>(<span class="string">&quot;LD_BIND_NOW&quot;</span>, <span class="string">&quot;1&quot;</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// int setenv(const char *name, const char *value, int overwrite);</span></span><br><span class="line">    <span class="comment">// 读取环境变量LD_BIND_LAZY，如果没有设置，则设置环境变量LD_BIND_NOW为1</span></span><br><span class="line">    <span class="comment">// 这段代码的作用是尝试提高性能，通过设置环境变量 `LD_BIND_NOW` 来告诉链接器在 fork 子进程之后不要进行额外的工作。</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">-   在 Unix-like 操作系统中，当一个程序运行时，它需要加载所需的库和符号，这些操作需要进行符号解析和动态链接。链接器通常会延迟加载这些库，即在实际需要时再加载，这被称为 &quot;lazy binding&quot;。这样做可以在启动时减少加载时间，但在程序执行过程中可能会引入一些额外的开销。</span></span><br><span class="line"><span class="comment">-   在这段代码中，它首先检查环境变量 `LD_BIND_LAZY` 是否已设置。如果没有设置，意味着程序没有显式地要求启用 &quot;lazy binding&quot;。</span></span><br><span class="line"><span class="comment">-   然后，它调用 `setenv` 函数，将环境变量 `LD_BIND_NOW` 设置为 `&quot;1&quot;`，即告诉链接器在加载程序时立即进行符号解析和链接，而不是延迟加载。这种设置可以减少子进程 fork 后链接器所需的额外工作，从而可能提高程序执行的性能。</span></span><br><span class="line"><span class="comment">总之，这段代码是为了尝试在 fork 子进程后通过禁用 &quot;lazy binding&quot; 来提高性能。不过，这个设置的效果可能因操作系统和程序的不同而有所不同。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">/* Set sane defaults for ASAN if nothing else specified. */</span></span><br><span class="line">    <span class="comment">// 一种内存错误检测工具</span></span><br><span class="line">    <span class="built_in">setenv</span>(<span class="string">&quot;ASAN_OPTIONS&quot;</span>, <span class="string">&quot;abort_on_error=1:&quot;</span> </span><br><span class="line">    <span class="comment">// `abort_on_error=1`：当检测到内存错误时，立即中止程序的执行。</span></span><br><span class="line">                           <span class="string">&quot;detect_leaks=0:&quot;</span></span><br><span class="line">    <span class="comment">// `detect_leaks=0`：禁用内存泄漏检测。</span></span><br><span class="line">                           <span class="string">&quot;symbolize=0:&quot;</span></span><br><span class="line">    <span class="comment">// symbolize=0：禁用符号化，即不在报告中显示函数名、行号等信息。</span></span><br><span class="line">                           <span class="string">&quot;allocator_may_return_null=1&quot;</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// allocator_may_return_null=1：分配器在无法分配内存时返回 NULL，而不是触发错误。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* MSAN is tricky, because it doesn&#x27;t support abort_on_error=1 at this</span></span><br><span class="line"><span class="comment">       point. So, we do this in a very hacky way. */</span></span><br><span class="line">    <span class="comment">// 一种用于检测未初始化内存访问的工具 </span></span><br><span class="line">    <span class="comment">// 由于它在代码执行期间模拟了对未初始化内存的读取，因此与其他工具相比稍显复杂</span></span><br><span class="line">    <span class="built_in">setenv</span>(<span class="string">&quot;MSAN_OPTIONS&quot;</span>, <span class="string">&quot;exit_code=&quot;</span> <span class="built_in">STRINGIFY</span>(MSAN_ERROR) <span class="string">&quot;:&quot;</span></span><br><span class="line">                           <span class="string">&quot;symbolize=0:&quot;</span></span><br><span class="line">                           <span class="string">&quot;abort_on_error=1:&quot;</span> </span><br><span class="line">    <span class="comment">// 在此时并不受支持，因此使用了一种“hacky”的方式来实现类似的效果。</span></span><br><span class="line">                           <span class="string">&quot;allocator_may_return_null=1:&quot;</span></span><br><span class="line">                           <span class="string">&quot;msan_track_origins=0&quot;</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">execv</span>(target_path, argv);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Use a distinctive bitmap signature to tell the parent about execv()</span></span><br><span class="line"><span class="comment">       falling through. */</span></span><br><span class="line">   <span class="comment">// 为了告知父进程 `execv` 执行失败，这段代码通过修改内存中的 `trace_bits`（位图数组）的内容来传递信息。具体来说，它将特定的标识值 `EXEC_FAIL_SIG` 赋值给 `trace_bits` 数组的前四个字节，然后调用 `exit(0)` 终止当前进程的执行。</span></span><br><span class="line">    *(u32*)trace_bits = EXEC_FAIL_SIG; <span class="comment">// 0xfee1dead </span></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li><code>execv(target_path, argv)</code>带参数执行target,这个函数除非出错不然不会返回。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- `/home/wutang/Desktop/google_afl/llvm_mode/test-instr /home/wutang/Desktop/fuzz_test/fuzz_output/fuzzer1/.cur_input`</span><br><span class="line">-   execv会替换掉原有的进程空间为target_path代表的程序，所以相当于后续就是去执行target_path，这个程序结束的话，子进程就结束。</span><br><span class="line">-   **而在这里非常特殊，第一个target会进入`__afl_maybe_log`里的`__afl_fork_wait_loop`，并充当fork server，在整个Fuzz的过程中，它都不会结束，每次要Fuzz一次target，都会从这个fork server fork出来一个子进程去fuzz。**</span><br></pre></td></tr></table></figure>

<ul>
<li>使用一个独特的<code>bitmaps EXEC_FAIL_SIG(0xfee1dead)</code>写入<code>trace_bits</code>，来告诉父进程执行失败，并结束子进程。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- 后续有检测 `if (*(u32*)trace_bits == EXEC_FAIL_SIG)`</span><br></pre></td></tr></table></figure>

<h5 id="execv子进程继续执行插入的代码"><a href="#execv子进程继续执行插入的代码" class="headerlink" title="execv子进程继续执行插入的代码"></a>execv子进程继续执行插入的代码</h5><ul>
<li>这里使用trace-pc模式 [[#trace-pc-guard mode-测试]]</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">/home/wutang/Desktop/google_afl/llvm_mode/test-instr /home/wutang/Desktop/fuzz_test/fuzz_output/fuzzer1/.cur_input</span><br></pre></td></tr></table></figure>

<h4 id="void-write-to-testcase-void-mem-u32-len"><a href="#void-write-to-testcase-void-mem-u32-len" class="headerlink" title="void write_to_testcase(void *mem, u32 len)"></a>void write_to_testcase(void *mem, u32 len)</h4><ul>
<li>将从<code>mem</code>中读取<code>len</code>个字节，写入到<code>.cur_input</code>中</li>
<li>如果没指定<code>@@</code> 也就是<code>out_fd=null</code>就继续写入 out_fd<ul>
<li>[[#setup_stdio_file]] 里设置的out_fd</li>
</ul>
</li>
</ul>
<h4 id="u8-run-target-char-argv-u32-timeout"><a href="#u8-run-target-char-argv-u32-timeout" class="headerlink" title="u8 run_target(char **argv, u32 timeout)"></a>u8 run_target(char **argv, u32 timeout)</h4><ul>
<li>通过Fork-server 开始fork出子进程进进行fuzz, <strong>对trace_bits进行赋值</strong>，运行目标应用程序并监控是否超时，返回运行结果的状态信息<ul>
<li>先清空<code>trace_bits[MAP_SIZE]</code>，将其全置为0，也就是清空共享内存。</li>
<li>如果<code>dumb_mode</code>等于1，且<code>no_forkserver</code>，则</li>
<li>直接fork出一个子进程，然后让子进程execv去执行target，如果execv执行失败，则向<code>trace_bits</code>写入<code>EXEC_FAIL_SIG</code> 类似上面的操作</li>
<li>否则与子进程通信</li>
<li>向<code>fsrv_ctl_fd</code> 写入<code>prev_timed_out</code>的值，命令<code>Fork server</code>开始fork出一个子进程进行fuzz，然后从状态管道读取<code>fork server</code>返回的fork出的子进程的ID到<code>child_pid</code></li>
<li>超时任务</li>
<li>无论实际执行的是上面两种的哪一种，在执行target期间，都设置计数器为<code>timeout</code>，如果超时，就杀死正在执行的子进程，并设置 <code>child_timed_out</code>为1;</li>
<li><code>setitimer(ITIMER_REAL, &amp;it, NULL);</code></li>
<li>等待target执行结束，如果是dumb_mode ，target执行结束的状态码将直接保存到status中，如果不是dumb_mode，则从状态管道中读取target执行结束的状态码。<ul>
<li><code>read(fsrv_st_fd, &amp;status, 4)</code> 获取状态码 256</li>
<li><code>if (!WIFSTOPPED(status)) child_pid = 0;</code> 设置child_pid&#x3D;0</li>
</ul>
</li>
<li>计算target执行时间<code>exec_ms</code>，并将<code>total_execs</code>这个执行次数计数器加一。</li>
<li><code>classify_counts((u64 *) trace_bits)</code> [[#classify_counts(u64 *mem)]] 用于将跟踪计数转换为分类信息的函数，目的是优化稀疏位图的处理。 <strong>对trace_bits进行赋值。</strong><ul>
<li>具体地，target是将每个分支的执行次数用1个byte来储存，而fuzzer则进一步把这个执行次数归入到buckets中，举个例子，如果某分支执行了1次，那么落入第2个bucket，其计数 byte 仍为1；如果某分支执行了4次，那么落入第5个bucket，其计数byte将变为8，等等。</li>
<li>这样处理之后，对分支执行次数就会有一个简单的归类。例如，如果对某个测试用例处理时，分支A执行了32次；对另外一个测试用例，分支A执行了33次，那么AFL就会认为这两次的代码覆盖是相同的。当然，这样的简单分类肯定不能区分所有的情况，不过在某种程度上，处理了一些因为循环次数的微小区别，而误判为不同执行结果的情况.</li>
</ul>
</li>
<li>设置 <code>prev_timed_out</code> 的值为 <code>child_timed_out</code></li>
<li>接着依据status的值，向调用者返回结果。</li>
<li><code>WIFSIGNALED(status)</code>若为异常结束子进程返回的状态，则为真<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-   `WTERMSIG(status)`取得子进程因信号而中止的信号代码</span><br><span class="line">  -   如果child_timed_out为1，且状态码为`SIGKILL`，则返回`FAULT_TMOUT`</span><br><span class="line">  -   否则返回`FAULT_CRASH`</span><br></pre></td></tr></table></figure></li>
<li>如果是<code>dumb_mode</code>，且 <code>trace_bits</code>为<code>EXEC_FAIL_SIG</code>，就返回<code>FAULT_ERROR</code></li>
<li>设置执行时间 <code>slowest_exec_ms</code><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- 如果`timeout`小于等于`exec_tmout`，且`slowest_exec_ms`小于`exec_ms`，设置`slowest_exec_ms`等于`exec_ms`</span><br></pre></td></tr></table></figure></li>
<li>返回<code>FAULT_NONE</code></li>
</ul>
</li>
</ul>
<h4 id="classify-counts-u64-mem"><a href="#classify-counts-u64-mem" class="headerlink" title="classify_counts(u64 *mem)"></a>classify_counts(u64 *mem)</h4><ul>
<li>用于将跟踪计数转换为分类信息的函数，目的是优化稀疏位图的处理。</li>
<li>8个字节一组去循环读入，直到遍历完整个mem</li>
<li>每次取两个字节<code>u16 *mem16 = (u16 *) mem</code></li>
<li>i从0到3，计算<code>mem16[i]</code>的值，在<code>count_class_lookup16[mem16[i]]</code>里找到对应的取值，并赋值给<code>mem16[i]</code></li>
</ul>
<h4 id="u32-count-bytes-u8-mem"><a href="#u32-count-bytes-u8-mem" class="headerlink" title="u32 count_bytes(u8 *mem)"></a>u32 count_bytes(u8 *mem)</h4><ul>
<li>计算在位图中设置为1的字节数量的函数, 验证 0x4000 字节的数据</li>
<li>[[CSAPP_深入理解计算机系统#掩码]]</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这个宏定义 FF(_b) 是用来生成一个指定位数的字节掩码的，具体解释如下：</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FF(_b)  (0xff &lt;&lt; ((_b) &lt;&lt; 3))</span></span><br><span class="line"><span class="comment">// 这里的 `(_b) &lt;&lt; 3` 相当于将 `_b` 乘以 8，是因为每个字节有 8 位</span></span><br><span class="line"><span class="comment">// 用于生成一个 8 位字节的掩码，该掩码在指定位置 `_b` 上的位为1，其他位置的位为0</span></span><br><span class="line">如果 _b 的值为 <span class="number">0</span>，那么 _b &lt;&lt; <span class="number">3</span> 就是 <span class="number">0</span>，掩码就是 <span class="number">0xff</span>，即所有位都是 <span class="number">1</span>的字节。</span><br><span class="line">如果 _b 的值为 <span class="number">1</span>，那么 _b &lt;&lt; <span class="number">3</span> 就是 <span class="number">8</span>，掩码就是 <span class="number">0xff00</span>，表示在第二个字节位置上的掩码。</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Count the number of bytes set in the bitmap. Called fairly sporadically,</span></span><br><span class="line"><span class="comment">   mostly to update the status screen or calibrate and examine confirmed</span></span><br><span class="line"><span class="comment">   new paths. */</span></span><br><span class="line"><span class="function"><span class="type">static</span> u32 <span class="title">count_bytes</span><span class="params">(u8* mem)</span> </span>&#123;</span><br><span class="line">  u32* ptr = (u32*)mem;</span><br><span class="line">  u32  i   = (MAP_SIZE &gt;&gt; <span class="number">2</span>);</span><br><span class="line">  u32  ret = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (i--) &#123;</span><br><span class="line">    u32 v = *(ptr++);</span><br><span class="line">    <span class="keyword">if</span> (!v) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">if</span> (v &amp; <span class="built_in">FF</span>(<span class="number">0</span>)) ret++;</span><br><span class="line">    <span class="keyword">if</span> (v &amp; <span class="built_in">FF</span>(<span class="number">1</span>)) ret++;</span><br><span class="line">    <span class="keyword">if</span> (v &amp; <span class="built_in">FF</span>(<span class="number">2</span>)) ret++;</span><br><span class="line">    <span class="keyword">if</span> (v &amp; <span class="built_in">FF</span>(<span class="number">3</span>)) ret++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="inline-u32-hash32-const-void-key-u32-len-u32-seed"><a href="#inline-u32-hash32-const-void-key-u32-len-u32-seed" class="headerlink" title="inline u32 hash32(const void* key, u32 len, u32 seed)"></a>inline u32 hash32(const void* key, u32 len, u32 seed)</h4><ul>
<li>计算哈希值的函数 <code>hash32</code>，用于计算32位哈希值。计算长度为2的16次方hash</li>
</ul>
<h4 id="char-has-new-bits-u8-virgin-map"><a href="#char-has-new-bits-u8-virgin-map" class="headerlink" title="char has_new_bits(u8 *virgin_map)"></a>char has_new_bits(u8 *virgin_map)</h4><ul>
<li>这段代码的主要目的是检查当前执行路径是否带来了新的信息（新的位）。它会更新”virgin_map”以反映新发现的位，并返回不同的值来表示发现的情况<ul>
<li>如果只有特定元组的命中计数发生变化，则返回1。</li>
<li>如果发现了新的元组，则返回2。</li>
<li>如果没有发现新的位，则返回0。</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Check if the current execution path brings anything new to the table.</span></span><br><span class="line"><span class="comment">   Update virgin bits to reflect the finds. Returns 1 if the only change is</span></span><br><span class="line"><span class="comment">   the hit-count for a particular tuple; 2 if there are new tuples seen. </span></span><br><span class="line"><span class="comment">   Updates the map, so subsequent calls will always return 0.</span></span><br><span class="line"><span class="comment">   This function is called after every exec() on a fairly large buffer, so</span></span><br><span class="line"><span class="comment">   it needs to be fast. We do this in 32-bit and 64-bit flavors. */</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">inline</span> u8 <span class="title">has_new_bits</span><span class="params">(u8* virgin_map)</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> WORD_SIZE_64</span></span><br><span class="line">  u64* current = (u64*)trace_bits;</span><br><span class="line">  u64* virgin  = (u64*)virgin_map;</span><br><span class="line">  u32  i = (MAP_SIZE &gt;&gt; <span class="number">3</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  u32* current = (u32*)trace_bits;</span><br><span class="line">  u32* virgin  = (u32*)virgin_map;</span><br><span class="line">  u32  i = (MAP_SIZE &gt;&gt; <span class="number">2</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* ^WORD_SIZE_64 */</span></span></span><br><span class="line">  u8   ret = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (i--) &#123;</span><br><span class="line">    <span class="comment">/* Optimize for (*current &amp; *virgin) == 0 - i.e., no bits in current bitmap</span></span><br><span class="line"><span class="comment">       that have not been already cleared from the virgin map - since this will</span></span><br><span class="line"><span class="comment">       almost always be the case. */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">unlikely</span>(*current) &amp;&amp; <span class="built_in">unlikely</span>(*current &amp; *virgin)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">likely</span>(ret &lt; <span class="number">2</span>)) &#123;</span><br><span class="line">        u8* cur = (u8*)current;</span><br><span class="line">        u8* vir = (u8*)virgin;</span><br><span class="line">        <span class="comment">/* Looks like we have not found any new bytes yet; see if any non-zero</span></span><br><span class="line"><span class="comment">           bytes in current[] are pristine in virgin[]. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> WORD_SIZE_64</span></span><br><span class="line">        <span class="comment">// 如果只有特定元组的命中计数发生变化，则返回1。</span></span><br><span class="line">        <span class="comment">// 当前bitmap中的某些位在&quot;virgin_map&quot;中仍然是&quot;1&quot;，表示有新的位被发现。这时，代码会遍历当前bitmap，更新&quot;virgin_map&quot;，并根据情况设置返回值ret为1或2。</span></span><br><span class="line">        <span class="keyword">if</span> ((cur[<span class="number">0</span>] &amp;&amp; vir[<span class="number">0</span>] == <span class="number">0xff</span>) || (cur[<span class="number">1</span>] &amp;&amp; vir[<span class="number">1</span>] == <span class="number">0xff</span>) ||</span><br><span class="line">            (cur[<span class="number">2</span>] &amp;&amp; vir[<span class="number">2</span>] == <span class="number">0xff</span>) || (cur[<span class="number">3</span>] &amp;&amp; vir[<span class="number">3</span>] == <span class="number">0xff</span>) ||</span><br><span class="line">            (cur[<span class="number">4</span>] &amp;&amp; vir[<span class="number">4</span>] == <span class="number">0xff</span>) || (cur[<span class="number">5</span>] &amp;&amp; vir[<span class="number">5</span>] == <span class="number">0xff</span>) ||</span><br><span class="line">            (cur[<span class="number">6</span>] &amp;&amp; vir[<span class="number">6</span>] == <span class="number">0xff</span>) || (cur[<span class="number">7</span>] &amp;&amp; vir[<span class="number">7</span>] == <span class="number">0xff</span>)) ret = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">else</span> ret = <span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">        <span class="keyword">if</span> ((cur[<span class="number">0</span>] &amp;&amp; vir[<span class="number">0</span>] == <span class="number">0xff</span>) || (cur[<span class="number">1</span>] &amp;&amp; vir[<span class="number">1</span>] == <span class="number">0xff</span>) ||</span><br><span class="line">            (cur[<span class="number">2</span>] &amp;&amp; vir[<span class="number">2</span>] == <span class="number">0xff</span>) || (cur[<span class="number">3</span>] &amp;&amp; vir[<span class="number">3</span>] == <span class="number">0xff</span>)) ret = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">else</span> ret = <span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* ^WORD_SIZE_64 */</span></span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 这个操作通常用于更新位图（bitmaps）。在上下文中，`virgin` 和 `current` 可能表示某些执行路径中的状态信息，通过将新的执行路径状态与之前的状态进行位与操作，可以确定是否有新的位被设置为 1，从而判断是否有新的路径被探索</span></span><br><span class="line">      *virgin &amp;= ~*current;</span><br><span class="line">    &#125;</span><br><span class="line">    current++;</span><br><span class="line">    virgin++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果发现了新位并且更新的是全局的&quot;virgin_bits&quot;，则设置&quot;bitmap_changed&quot;标志为1</span></span><br><span class="line">  <span class="keyword">if</span> (ret &amp;&amp; virgin_map == virgin_bits) bitmap_changed = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 当前bitmap中的位在&quot;virgin_map&quot;中已经全部被清除，表示没有新的位被发现。在这种情况下，代码不执行遍历，直接返回ret为0。</span></span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>检查有没有新路径或者某个路径的执行次数有所不同。</li>
<li>初始化current和virgin为trace_bits和virgin_map的u64首元素地址，设置ret的值为0</li>
<li>8个字节一组，每次从trace_bits，也就是共享内存里取出8个字节</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-   如果current不为0，且`current &amp; virgin`不为0，即代表current发现了新路径或者某条路径的执行次数和之前有所不同</span><br><span class="line">  -   如果ret当前小于2</span><br><span class="line">    -   取current的首字节地址为cur，virgin的首字节地址为vir</span><br><span class="line">    -   i的范围是0-7，比较`cur[i] &amp;&amp; vir[i] == 0xff`，如果有一个为真，则设置ret为2</span><br><span class="line">      -   这代表发现了之前没有出现过的tuple</span><br><span class="line">      -   **注意==的优先级比&amp;&amp;要高，所以先判断vir[i]是否是0xff，即之前从未被覆盖到，然后再和cur[i]进行逻辑与**</span><br><span class="line">    -   否则设置ret为1</span><br><span class="line">        -   这代表仅仅只是改变了某个tuple的hit-count</span><br><span class="line">  -   `*virgin &amp;= ~*current`</span><br><span class="line">-   current和virgin移动到下一组8个字节，直到MAPSIZE全被遍历完。</span><br></pre></td></tr></table></figure>

<ul>
<li>如果传入给has_new_bits的参数<code>virgin_map</code>是<code>virgin_bits</code>,且ret不为0，就设置<strong>bitmap_changed为1</strong><ul>
<li>virgin_bits保存还没有被Fuzz覆盖到的byte，其初始值每位全被置位1,然后每次按字节置位。</li>
</ul>
</li>
<li>返回ret的值</li>
<li>这里可以优化</li>
</ul>
<h4 id="update-bitmap-score-struct-queue-entry-q"><a href="#update-bitmap-score-struct-queue-entry-q" class="headerlink" title="update_bitmap_score(struct queue_entry *q)"></a>update_bitmap_score(struct queue_entry *q)</h4><ul>
<li>这段代码用于更新路径的评分，以便确定哪些路径是更有利于模糊测试的。在进行模糊测试时，通常希望尽可能选择一些路径，这些路径可以触发目标程序的不同位，从而更好地发现漏洞。为此，这段代码维护了一个 <code>top_rated</code> 数组，用于存储每个字节的顶级路径（评分最高的路径）<ul>
<li>每当我们发现一个新的路径，都会调用这个函数来判断其是不是更加地<code>favorable</code>，这个favorable的意思是说是否包含最小的路径集合来遍历到所有bitmap中的位，我们专注于这些集合而忽略其他的。<ul>
<li>首先计算出这个case的 <code>fav_factor</code>，计算方法是<code>q-&gt;exec_us * q-&gt;len</code>即<strong>执行时间和样例大小的乘积</strong>，以这两个指标来衡量权重。</li>
<li>遍历<code>trace_bits</code>数组，如果该字节的值不为0，则代表这是已经被覆盖到的path</li>
<li>然后检查对应于这个path的<code>top_rated</code>是否存在<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-   `static struct queue_entry *top_rated[MAP_SIZE]; /* Top entries for bitmap bytes */`</span><br></pre></td></tr></table></figure></li>
<li>如果存在，就比较<code>fav_factor &gt; top_rated[i]-&gt;exec_us * top_rated[i]-&gt;len</code>，即比较执行<strong>时间和样例大小的乘积，哪个更小</strong>。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-   如果`top_rated[i]`的更小，则代表`top_rated[i]`的更优，不做任何处理continue，继续遍历下一个path。</span><br><span class="line">-   如果q更小，就将`top_rated[i]`原先对应的queue entry的tc_ref字段减一，并将其trace_mini字段置为空。</span><br><span class="line">  -   `u8 *trace_mini; /* Trace bytes, if kept */`</span><br><span class="line">  -   `u32 tc_ref; /* Trace bytes ref count */`</span><br></pre></td></tr></table></figure></li>
<li>然后设置<code>top_rated[i]</code>为<code>q</code>，即当前case，然后将其tc_ref的值加一</li>
<li>如果<code>q-&gt;trace_mini</code>为空，则将trace_bits经过<code>minimize_bits</code>压缩，然后存到trace_mini字段里 [[#void minimize_bits(u8 *dst, u8 *src)]] <strong>BitMap数据压缩 trace_bits</strong></li>
<li>设置 <code>score_changed</code> 为1</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="void-minimize-bits-u8-dst-u8-src"><a href="#void-minimize-bits-u8-dst-u8-src" class="headerlink" title="void minimize_bits(u8 *dst, u8 *src)"></a>void minimize_bits(u8 *dst, u8 *src)</h4><ul>
<li>将trace_bits压缩为较小的位图。 BitMap数据压缩 trace_bits</li>
<li>简单的理解就是把原本是包括了是否覆盖到和覆盖了多少次的byte，<strong>压缩成是否覆盖到的bit。</strong></li>
<li>在看这个函数和下一个函数cull_queue之前，建议把<a target="_blank" rel="noopener" href="https://blog.csdn.net/lxlmycsdnfree/article/details/78926359">经典算法系列之(一) - BitMap [数据的压缩存储]</a>读完。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Index</span>(N)代表N的索引号，<span class="built_in">Position</span>(N)代表N的所在的位置号</span><br><span class="line"><span class="built_in">Index</span>(N) = N/<span class="number">8</span> = N &gt;&gt; <span class="number">3</span>;</span><br><span class="line"><span class="built_in">Position</span>(N) = N%<span class="number">8</span> = N &amp; <span class="number">0x07</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">add</span>(<span class="type">int</span> num)</span><br><span class="line"></span><br><span class="line">package com.chs.alg.bitmap;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BitMap</span> &#123;</span><br><span class="line">    <span class="comment">//保存数据的</span></span><br><span class="line">    <span class="keyword">private</span> byte[] bits;</span><br><span class="line">    <span class="comment">//能够存储多少数据</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> capacity;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BitMap</span><span class="params">(<span class="type">int</span> capacity)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//1bit能存储8个数据，那么capacity数据需要多少个bit呢，capacity/8+1,右移3位相当于除以8</span></span><br><span class="line">        bits = <span class="keyword">new</span> byte[(capacity &gt;&gt;<span class="number">3</span> )+<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> num)</span></span>&#123;               <span class="comment">// 0x111</span></span><br><span class="line">        <span class="comment">// num/8得到byte[]的index</span></span><br><span class="line">        <span class="type">int</span> arrayIndex = num &gt;&gt; <span class="number">3</span>;          <span class="comment">// 0x22</span></span><br><span class="line">        <span class="comment">// num%8得到在byte[index]的位置</span></span><br><span class="line">        <span class="type">int</span> position = num &amp; <span class="number">0x07</span>;          <span class="comment">// 0x1</span></span><br><span class="line">        <span class="comment">// 将1左移position后，那个位置自然就是1，然后和以前的数据做|，这样那个位置就替换成1了。</span></span><br><span class="line">        bits[arrayIndex] |= <span class="number">1</span> &lt;&lt; position;  <span class="comment">// bits[0x22] |= 1 &lt;&lt; 1;   bits[0x22] |= 2</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 还原  (0x22&lt;&lt;3) + (2&gt;&gt;1) = 0x111</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> boolean <span class="title">contain</span><span class="params">(<span class="type">int</span> num)</span></span>&#123;</span><br><span class="line">        <span class="comment">// num/8得到byte[]的index</span></span><br><span class="line">        <span class="type">int</span> arrayIndex = num &gt;&gt; <span class="number">3</span>; </span><br><span class="line">        <span class="comment">// num%8得到在byte[index]的位置</span></span><br><span class="line">        <span class="type">int</span> position = num &amp; <span class="number">0x07</span>; </span><br><span class="line">        <span class="comment">// 将1左移position后，那个位置自然就是1，然后和以前的数据做&amp;，判断是否为0即可</span></span><br><span class="line">        <span class="keyword">return</span> (bits[arrayIndex] &amp; (<span class="number">1</span> &lt;&lt; position)) !=<span class="number">0</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="type">void</span> <span class="title">clear</span><span class="params">(<span class="type">int</span> num)</span></span>&#123;</span><br><span class="line">        <span class="comment">// num/8得到byte[]的index</span></span><br><span class="line">        <span class="type">int</span> arrayIndex = num &gt;&gt; <span class="number">3</span>; </span><br><span class="line">        <span class="comment">// num%8得到在byte[index]的位置</span></span><br><span class="line">        <span class="type">int</span> position = num &amp; <span class="number">0x07</span>; </span><br><span class="line">        <span class="comment">// 将1左移position后，那个位置自然就是1，然后对取反，再与当前值做&amp;，即可清除当前的位置了.</span></span><br><span class="line">        bits[arrayIndex] &amp;= ~(<span class="number">1</span> &lt;&lt; position); </span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="type">static</span> <span class="type">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BitMap bitmap = <span class="keyword">new</span> <span class="built_in">BitMap</span>(<span class="number">100</span>);</span><br><span class="line">        bitmap.<span class="built_in">add</span>(<span class="number">7</span>);</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">&quot;插入7成功&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        boolean isexsit = bitmap.<span class="built_in">contain</span>(<span class="number">7</span>);</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">&quot;7是否存在:&quot;</span>+isexsit);</span><br><span class="line">        </span><br><span class="line">        bitmap.<span class="built_in">clear</span>(<span class="number">7</span>);</span><br><span class="line">        isexsit = bitmap.<span class="built_in">contain</span>(<span class="number">7</span>);</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">&quot;7是否存在:&quot;</span>+isexsit);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">       <span class="keyword">if</span> (!q-&gt;trace_mini) &#123;</span><br><span class="line">         q-&gt;trace_mini = <span class="built_in">ck_alloc</span>(MAP_SIZE &gt;&gt; <span class="number">3</span>);</span><br><span class="line">         <span class="built_in">minimize_bits</span>(q-&gt;trace_mini, trace_bits);</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">minimize_bits</span><span class="params">(u8 *dst, u8 *src)</span> </span>&#123;  </span><br><span class="line">    u32 i = <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">while</span> (i &lt; MAP_SIZE) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (*(src++)) dst[i &gt;&gt; <span class="number">3</span>] |= <span class="number">1</span> &lt;&lt; (i &amp; <span class="number">7</span>);  </span><br><span class="line">        i++;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="void-check-map-coverage-void"><a href="#void-check-map-coverage-void" class="headerlink" title="void check_map_coverage(void)"></a>void check_map_coverage(void)</h4><ul>
<li>此函数主要用于在模糊测试开始时检查覆盖率地图的覆盖情况。它采用两个步骤：</li>
</ul>
<ol>
<li>如果覆盖的字节数小于100，就认为覆盖不足，直接返回。这是一个简单的阈值，<strong>如果模糊测试的初始覆盖率太低，可能意味着测试效果不佳</strong>。</li>
<li>遍历从 <code>1 &lt;&lt; (MAP_SIZE_POW2 - 1)</code> 到 <code>MAP_SIZE</code> 范围内的字节。如果在这个范围内的任何一个字节的 <code>trace_bits</code> 不为零，表示至少有一个路径经过了这个位置，覆盖率已经存在。如果没有，那么发出警告，建议重新编译二进制文件以改善覆盖率。</li>
</ol>
<ul>
<li>总之，这段代码用于判断模糊测试初始时覆盖率地图的情况，以便根据情况提出警告或建议。</li>
</ul>
<h4 id="cull-queue"><a href="#cull-queue" class="headerlink" title="cull_queue"></a>cull_queue</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* The second part of the mechanism discussed above is a routine that</span></span><br><span class="line"><span class="comment">   goes over top_rated[] entries, and then sequentially grabs winners for</span></span><br><span class="line"><span class="comment">   previously-unseen bytes (temp_v) and marks them as favored, at least</span></span><br><span class="line"><span class="comment">   until the next run. The favored entries are given more air time during</span></span><br><span class="line"><span class="comment">   all fuzzing steps. */</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">cull_queue</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">queue_entry</span>* q;</span><br><span class="line">  <span class="type">static</span> u8 temp_v[MAP_SIZE &gt;&gt; <span class="number">3</span>];</span><br><span class="line">  u32 i;</span><br><span class="line">  <span class="keyword">if</span> (dumb_mode || !score_changed) <span class="keyword">return</span>;</span><br><span class="line">  score_changed = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">memset</span>(temp_v, <span class="number">255</span>, MAP_SIZE &gt;&gt; <span class="number">3</span>);</span><br><span class="line">  queued_favored  = <span class="number">0</span>;</span><br><span class="line">  pending_favored = <span class="number">0</span>;</span><br><span class="line">  q = queue;</span><br><span class="line">  <span class="keyword">while</span> (q) &#123;</span><br><span class="line">    q-&gt;favored = <span class="number">0</span>;</span><br><span class="line">    q = q-&gt;next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* Let&#x27;s see if anything in the bitmap isn&#x27;t captured in temp_v.</span></span><br><span class="line"><span class="comment">     If yes, and if it has a top_rated[] contender, let&#x27;s use it. */</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAP_SIZE; i++)</span><br><span class="line">    <span class="keyword">if</span> (top_rated[i] &amp;&amp; (temp_v[i &gt;&gt; <span class="number">3</span>] &amp; (<span class="number">1</span> &lt;&lt; (i &amp; <span class="number">7</span>)))) &#123;</span><br><span class="line">      u32 j = MAP_SIZE &gt;&gt; <span class="number">3</span>;</span><br><span class="line">      <span class="comment">/* Remove all bits belonging to the current entry from temp_v. */</span></span><br><span class="line">      <span class="keyword">while</span> (j--) </span><br><span class="line">        <span class="keyword">if</span> (top_rated[i]-&gt;trace_mini[j])</span><br><span class="line">          temp_v[j] &amp;= ~top_rated[i]-&gt;trace_mini[j];</span><br><span class="line">      <span class="comment">// 比如这里算 j=8084  i=45299   top_rated[i]-&gt;trace_mini[j]=@  0x40</span></span><br><span class="line">      <span class="comment">// ~top_rated[i]-&gt;trace_mini[j]= -65  = hex(0xff-0x40) = 0xbf</span></span><br><span class="line">      top_rated[i]-&gt;favored = <span class="number">1</span>;</span><br><span class="line">      queued_favored++;</span><br><span class="line">      <span class="keyword">if</span> (!top_rated[i]-&gt;was_fuzzed) pending_favored++;</span><br><span class="line">    &#125;</span><br><span class="line">  q = queue;</span><br><span class="line">  <span class="keyword">while</span> (q) &#123;</span><br><span class="line">    <span class="built_in">mark_as_redundant</span>(q, !q-&gt;favored);</span><br><span class="line">    q = q-&gt;next;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>该函数的目标是在模糊测试期间调整队列，以便更多地探索未被完全探索的路径。这在实际的模糊测试中非常有用，因为它<strong>可以帮助集中资源在最有希望的路径上，提高测试的效率</strong>。函数的具体步骤包括：</li>
<li>精简队列<ul>
<li>如果score_changed为0，即top_rated没有变化，或者 dumb_mode ,就直接返回</li>
<li>设置score_changed的值为0</li>
<li>创建u8 temp_v数组，大小为<code>MAP_SIZE/8</code>，并将其初始值设置为0xff，其每位如果为1就代表还没有被覆盖到，如果为0就代表以及被覆盖到了。</li>
<li>设置queued_favored为0，<code>pending_favored</code>为0</li>
<li>开始遍历queue队列，设置其favored的值都为0</li>
<li>将i从0到MAP_SIZE迭代，这个迭代其实就是筛选出一组queue entry，它们就能够覆盖到所有现在已经覆盖到的路径，而且这个case集合里的case要更小更快，这并不是最优算法，只能算是贪婪算法。<ul>
<li>这又是个不好懂的位运算，<code>temp_v[i &gt;&gt; 3] &amp; (1 &lt;&lt; (i &amp; 7))</code>与上面的差不多，中间的或运算改成了与，是为了检查该位是不是0，即判断该path对应的bit有没有被置位。</li>
</ul>
</li>
</ul>
</li>
<li></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAP_SIZE; i++)  </span><br><span class="line">    <span class="keyword">if</span> (top_rated[i] &amp;&amp; (temp_v[i &gt;&gt; <span class="number">3</span>] &amp; (<span class="number">1</span> &lt;&lt; (i &amp; <span class="number">7</span>)))) &#123;  </span><br><span class="line">...  </span><br></pre></td></tr></table></figure>

<ul>
<li>如果<code>top_rated[i]</code>有值，且该path在temp_v里被置位<ul>
<li>就从temp_v中清除掉所有<code>top_rated[i]</code>覆盖到的path，将对应的bit置为0</li>
<li>设置<code>top_rated[i]-&gt;favored</code>为1，queued_favored计数器加一</li>
<li>如果<code>top_rated[i]</code>的was_fuzzed字段是0，代表其还没有fuzz过，则将pending_favored计数器加一</li>
</ul>
</li>
<li>遍历queue队列</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-   `mark_as_redundant(q, !q-&gt;favored)`</span><br><span class="line">    - `/home/wutang/Desktop/fuzz_test/fuzz_output/fuzzer1/queue/.state/redundant_edges/xxx`</span><br><span class="line">  -   也就是说，如果不是favored的case，就被标记成`redundant_edges`</span><br><span class="line">  - [[#mark_as_redundant(struct queue_entry *q, u8 state)]]</span><br></pre></td></tr></table></figure>

<h4 id="mark-as-redundant-struct-queue-entry-q-u8-state"><a href="#mark-as-redundant-struct-queue-entry-q-u8-state" class="headerlink" title="mark_as_redundant(struct queue_entry *q, u8 state)"></a>mark_as_redundant(struct queue_entry *q, u8 state)</h4><ul>
<li>该函数用于标记&#x2F;取消标记队列中的项目为冗余（仅涉及边缘）。主要步骤包括：<ol>
<li>如果新状态与项目之前的状态相同，则直接返回，没有任何操作。</li>
<li>更新项目的冗余状态。</li>
<li>从项目的文件名中获取最后一个 ‘&#x2F;‘ 后的部分，这部分将用于构建冗余文件的路径。</li>
<li>如果新状态为 1，表示要将项目标记为冗余，则进行下面的操作：<ul>
<li>创建一个新文件，并设置文件权限为 0600。</li>
<li><code>/home/wutang/Desktop/fuzz_test/fuzz_output/fuzzer1/queue/.state/redundant_edges/xxx</code></li>
</ul>
</li>
<li>如果新状态为 0，表示要取消项目的冗余标记，则进行下面的操作：<ul>
<li>删除之前创建的冗余文件。</li>
</ul>
</li>
<li>释放为构建文件路径而分配的内存。</li>
</ol>
</li>
</ul>
<h4 id="show-init-stats"><a href="#show-init-stats" class="headerlink" title="show_init_stats"></a>show_init_stats</h4><ul>
<li>在处理输入目录的末尾显示统计信息，以及一堆警告,以及几个硬编码的常量。<ul>
<li>这段代码用于在处理输入目录后显示初始化统计信息和一些警告</li>
</ul>
</li>
</ul>
<h4 id="find-start-position"><a href="#find-start-position" class="headerlink" title="find_start_position"></a>find_start_position</h4><ul>
<li>resume模式下有意义，其目的是在恢复模式下寻找一个合适的队列起始位置。这个功能只有在进行恢复且能找到原始的 <code>fuzzer_stats</code> 文件时才有意义。</li>
<li>resume时,请尝试查找要从其开始的队列位置,这仅在resume时以及当我们可以找到原始的fuzzer_stats时才有意义.<ul>
<li>如果不是<code>resuming_fuzz</code>，就直接返回</li>
<li>如果是<code>in_place_resume</code>,就打开<code>out_dir/fuzzer_stats</code>文件，否则打开<code>in_dir/../fuzzer_stats</code>文件</li>
<li>读这个文件的内容到<code>tmp[4096]</code>中，找到<code>cur_path</code>，并设置为ret的值，如果大于<code>queued_paths</code>就设置ret为0，返回ret</li>
</ul>
</li>
</ul>
<h4 id="void-write-stats-file-double-bitmap-cvg-double-stability-double-eps"><a href="#void-write-stats-file-double-bitmap-cvg-double-stability-double-eps" class="headerlink" title="void write_stats_file(double bitmap_cvg, double stability, double eps)"></a>void write_stats_file(double bitmap_cvg, double stability, double eps)</h4><ul>
<li><p>更新用于无人值守监控的统计文件</p>
</li>
<li><p>函数负责将各项统计信息写入名为 <code>fuzzer_stats</code> 的文件中，这些信息用于监控 fuzzer 的性能和状态。这可以帮助用户了解 fuzzer 的执行情况、性能和资源使用情况。</p>
<ul>
<li><code>/home/wutang/Desktop/fuzz_test/fuzz_output/fuzzer1/fuzzer_stats</code></li>
</ul>
</li>
<li><p>fuzzer_stats</p>
<ul>
<li>创建文件<code>out_dir/fuzzer_stats</code></li>
<li>写入统计信息</li>
<li>start_time<ul>
<li>fuzz运行的开始时间，start_time &#x2F; 1000</li>
</ul>
</li>
<li>last_update<ul>
<li>当前时间</li>
</ul>
</li>
<li>fuzzer_pid<ul>
<li>获取当前pid</li>
</ul>
</li>
<li>cycles_done<ul>
<li><code>queue_cycle</code>在<code>queue_cur</code>为空，即执行到当前队列尾的时候才增加1，所以这代表queue队列被完全变异一次的次数。</li>
</ul>
</li>
<li>execs_done<ul>
<li>total_execs，target的总的执行次数，每次<code>run_target</code>的时候会增加1</li>
</ul>
</li>
<li>execs_per_sec<ul>
<li>每秒执行的次数</li>
</ul>
</li>
<li>paths_total<ul>
<li>queued_paths在每次<code>add_to_queue</code>的时候会增加1，代表queue里的样例总数</li>
</ul>
</li>
<li>paths_favored<ul>
<li>queued_favored，有价值的路径总数</li>
</ul>
</li>
<li>paths_found<ul>
<li>queued_discovered在每次<code>common_fuzz_stuff</code>去执行一次fuzz时，发现新的interesting case的时候会增加1，代表在fuzz运行期间发现的新queue entry。</li>
</ul>
</li>
<li>paths_imported<ul>
<li>queued_imported是master-slave模式下，如果sync过来的case是interesting的，就增加1</li>
</ul>
</li>
<li>max_depth<ul>
<li>最大路径深度</li>
</ul>
</li>
<li>cur_path<ul>
<li>current_entry一般情况下代表的是正在执行的queue entry的整数ID,queue首节点的ID是0</li>
</ul>
</li>
<li>pending_favs<ul>
<li>pending_favored 等待fuzz的favored paths数</li>
</ul>
</li>
<li>pending_total<ul>
<li>pending_not_fuzzed 在queue中等待fuzz的case数</li>
</ul>
</li>
<li>variable_paths<ul>
<li>queued_variable在<code>calibrate_case</code>去评估一个新的test case的时候，如果发现这个case的路径是可变的，则将这个计数器加一，代表发现了一个可变case</li>
</ul>
</li>
<li>stability</li>
<li>bitmap_cvg</li>
<li>unique_crashes<ul>
<li>unique_crashes这是在<code>save_if_interesting</code>时，如果fault是FAULT_CRASH，就将unique_crashes计数器加一</li>
</ul>
</li>
<li>unique_hangs<ul>
<li>unique_hangs这是在<code>save_if_interesting</code>时，如果fault是FAULT_TMOUT，且exec_tmout小于hang_tmout，就以hang_tmout为超时时间再执行一次，如果还超时，就让hang计数器加一。</li>
</ul>
</li>
<li>last_path<ul>
<li>在<code>add_to_queue</code>里将一个新case加入queue时，就设置一次last_path_time为当前时间，<code>last_path_time / 1000</code></li>
</ul>
</li>
<li>last_crash<ul>
<li>同上，在unique_crashes加一的时候，last_crash也更新时间，<code>last_crash_time / 1000</code></li>
</ul>
</li>
<li>last_hang<ul>
<li>同上，在unique_hangs加一的时候，last_hang也更新时间，<code>last_hang_time / 1000</code></li>
</ul>
</li>
<li>execs_since_crash<ul>
<li>total_execs - last_crash_execs,这里last_crash_execs是在上一次crash的时候的总计执行了多少次</li>
</ul>
</li>
<li>exec_tmout<ul>
<li>配置好的超时时间，有三种可能的配置方式，见上文</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="save-auto"><a href="#save-auto" class="headerlink" title="save_auto"></a>save_auto</h4><ul>
<li>目的是将用于自动筛选的额外测试用例保存到磁盘中。</li>
<li>保存自动生成的extras<ul>
<li>如果auto_changed为0，则直接返回</li>
<li>如果不为0，就设置为0，然后创建名为<code>alloc_printf(&quot;%s/queue/.state/auto_extras/auto_%06u&quot;, out_dir, i);</code>的文件，并写入a_extras的内容。</li>
</ul>
</li>
</ul>
<h3 id="Fuzz执行"><a href="#Fuzz执行" class="headerlink" title="Fuzz执行"></a>Fuzz执行</h3><h4 id="fuzz-主要流程"><a href="#fuzz-主要流程" class="headerlink" title="fuzz-主要流程"></a>fuzz-主要流程</h4><ul>
<li>进入while循环<ul>
<li>[[#cull_queue]] 该函数的目标是在模糊测试期间调整队列，以便更多地探索未被完全探索的路径</li>
<li>[[#show_stats]] 在终端上显示有关Fuzzer状态和统计信息的用户界面</li>
<li>如果在一轮执行之后的queue里的case数，和执行之前一样，代表在完整的一轮执行里都没有发现任何一个新的case<ul>
<li>如果<code>use_splicing为1</code>，就设置cycles_wo_finds计数器加1</li>
<li>否则，设置<code>use_splicing为1</code>，代表我们接下来要通过splice重组queue里的case。</li>
</ul>
</li>
<li>设置-M -S &amp;&amp; 宏<code>AFL_IMPORT_FIRST</code> 去从其他fuzzer中导入test cases <code>sync_fuzzers</code> [[#sync_fuzzers(char **argv)]]<ul>
<li>这段代码用于从其他模糊测试器中获取有趣的测试案例并执行</li>
<li><code>/home/wutang/Desktop/fuzz_test/fuzz_output/</code></li>
<li>感觉没必要</li>
</ul>
</li>
<li><code>skipped_fuzz = fuzz_one(use_argv);</code> [[#fuzz_one]]</li>
</ul>
</li>
</ul>
<h4 id="show-stats"><a href="#show-stats" class="headerlink" title="show_stats"></a>show_stats</h4><ul>
<li>该函数用于在终端上显示有关Fuzzer状态和统计信息的用户界面。这个界面是一个详细的终端输出，显示有关Fuzzer执行进度、发现路径数量、执行速度、覆盖率等的信息。<ol>
<li>获取当前时间，并检查是否已经足够时间过去以进行下一次界面更新，如果没有则返回。</li>
<li><code>cur_ms - last_ms &lt; 1000 / UI_TARGET_HZ(5)</code></li>
<li>检查是否已经运行了超过10分钟，如果是则将变量 <code>run_over10m</code> 设置为1</li>
<li>计算平滑的执行速度统计信息。如果是第一次调用该函数，直接计算执行速度。否则，计算当前的执行速度并进行平滑处理，以避免突然的速度变化。</li>
<li>更新时间和执行次数的记录，用于下一次函数调用时计算速度。</li>
<li><code>last_ms</code> <code>last_execs</code></li>
<li>根据平均执行速度计算多久需要调用一次 <code>stats_update</code> 函数以更新状态。</li>
<li>计算位图统计信息，包括非255字节的数量、比特位密度等。</li>
<li><code>t_bytes = count_non_255_bytes(virgin_bits)</code>  这段代码用于计算在位图（bitmap）中设置为非 255（0xFF）的字节数。它主要用于状态屏幕，大约每秒钟调用几次</li>
<li>每隔一分钟，更新模糊器的状态、保存自动 tokens 和写入位图。</li>
<li><code>write_stats_file(t_byte_ratio, stab_ratio, avg_exec)</code></li>
<li><code>save_auto()</code></li>
<li><code>write_bitmap();</code><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. `/home/wutang/Desktop/fuzz_test/fuzz_output/fuzzer1/fuzz_bitmap`</span><br></pre></td></tr></table></figure></li>
<li>每隔一段时间，更新绘图数据。</li>
<li><code>maybe_update_plot_file(t_byte_ratio, avg_exec);</code> 更新 <code>/home/wutang/Desktop/fuzz_test/fuzz_output/fuzzer1/plot_data</code></li>
<li>根据条件设置 <code>stop_soon</code> 变量，用于控制 Fuzzer 的退出。</li>
<li>如果终端不可用，直接返回。</li>
<li>计算位图的比特位统计信息。 <code>count_bits(virgin_bits)</code></li>
<li>计算给定位图中设置的位数（即置为1的位数），主要用于状态屏幕，每秒钟多次调用，不必要求非常高的速度</li>
<li>清除屏幕并显示 Fuzzer 的横幅信息，其中包括 Fuzzer 的名称、版本号等。</li>
<li>绘制统计信息表格，包括运行时间、路径数量、独特崩溃数量等。</li>
<li>绘制运行阶段进展信息，包括当前阶段、运行的执行次数等。</li>
<li>绘制策略和路径几何信息，包括位翻转、字节翻转、算术操作等。</li>
<li>显示CPU利用率信息，根据实际情况使用不同颜色显示。</li>
</ol>
</li>
</ul>
<h4 id="fuzz-one"><a href="#fuzz-one" class="headerlink" title="fuzz_one"></a>fuzz_one</h4><ul>
<li>all<ul>
<li>设置ret_val&#x3D;1</li>
<li>如果<code>pending_favored</code>不为0，则对于queue_cur被fuzz过或者不是favored的，有99%的几率直接返回1。</li>
<li>如果<code>pending_favored</code>为0且queued_paths(即queue里的case总数)大于10<ul>
<li>如果queue_cycle大于1且queue_cur没有被fuzz过，则有75%的概率直接返回1</li>
<li>如果queue_cur被fuzz过，否则有95%的概率直接返回1</li>
</ul>
</li>
<li>设置len为<code>queue_cur-&gt;len</code></li>
<li>打开该case对应的文件，并通过mmap映射到内存里，地址赋值给<code>in_buf</code>和<code>orig_in</code></li>
<li>打开预料 <code>/home/wutang/Desktop/fuzz_test/fuzz_output/fuzzer1/queue/id:000000,orig:1</code></li>
<li>分配len大小的内存，并初始化为全0，然后将地址赋值给out_buf</li>
<li>[[#CALIBRATION阶段]]</li>
<li>[[#TRIMMING阶段]]</li>
<li>[[#PERFORMANCE SCORE阶段]]</li>
<li>[[#SIMPLE BITFLIP (+dictionary construction)阶段]]</li>
<li>[[#ARITHMETIC INC&#x2F;DEC阶段]]</li>
<li>[[#INTERESTING VALUES阶段]]</li>
<li>[[#RANDOM HAVOC阶段]]</li>
<li>[[#SPLICING阶段]]</li>
<li>设置ret_val的值为0</li>
<li>如果queue_cur通过了评估，且was_fuzzed字段是0</li>
<li>就设置<code>queue_cur-&gt;was_fuzzed</code>为1，然后pending_not_fuzzed计数器减一</li>
<li>如果queue_cur是favored, pending_favored计数器减一。</li>
<li>return ret_val</li>
</ul>
</li>
</ul>
<h4 id="各个阶段"><a href="#各个阶段" class="headerlink" title="各个阶段"></a>各个阶段</h4><h5 id="CALIBRATION阶段"><a href="#CALIBRATION阶段" class="headerlink" title="CALIBRATION阶段"></a>CALIBRATION阶段</h5><p>假如当前项有校准错误，并且校准错误次数小于3次，那么就用 <code>calibrate_case</code> 再次校准。</p>
<h5 id="TRIMMING阶段"><a href="#TRIMMING阶段" class="headerlink" title="TRIMMING阶段"></a>TRIMMING阶段</h5><ul>
<li>如果该case没有trim过，<code>queue_cur-&gt;trim_done</code> 为0<ul>
<li>调用函数<code>trim_case(argv, queue_cur, in_buf)</code>进行trim(修剪) [[#trim_case(char **argv, struct queue_entry *q, u8 *in_buf)]]   in_buf 就是预料信息</li>
<li>设置queue_cur的trim_done为1</li>
<li>重新读取一次<code>queue_cur-&gt;len</code>到len中</li>
</ul>
</li>
<li>将in_buf拷贝len个字节到out_buf中</li>
</ul>
<h5 id="PERFORMANCE-SCORE阶段"><a href="#PERFORMANCE-SCORE阶段" class="headerlink" title="PERFORMANCE SCORE阶段"></a>PERFORMANCE SCORE阶段</h5><ul>
<li>perf_score &#x3D; <code>calculate_score(queue_cur)</code> [[#u32 calculate_score(struct queue_entry *q)]]</li>
<li>如果 <code>skip_deterministic</code> 为1，或者<code>queue_cur-&gt;was_fuzzed</code>被fuzz过，或者<code>queue_cur-&gt;passed_d</code>et为1，则跳转去havoc_stage阶段</li>
<li>设置doing_det为1</li>
</ul>
<h5 id="SIMPLE-BITFLIP-dictionary-construction-阶段"><a href="#SIMPLE-BITFLIP-dictionary-construction-阶段" class="headerlink" title="SIMPLE BITFLIP (+dictionary construction)阶段"></a>SIMPLE BITFLIP (+dictionary construction)阶段</h5><ul>
<li><code>bitflip 1/1</code>翻转 <code>需要注意 不会在  -d mode or -S 生成字典</code></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> FLIP_BIT(_ar, _b) do &#123; \</span></span><br><span class="line"><span class="meta">    u8* _arf = (u8*)(_ar); \</span></span><br><span class="line"><span class="meta">    u32 _bf = (_b); \</span></span><br><span class="line"><span class="meta">    _arf[(_bf) &gt;&gt; 3] ^= (128 &gt;&gt; ((_bf) &amp; 7)); \</span></span><br><span class="line"><span class="meta">  &#125; while (0)</span></span><br><span class="line"></span><br><span class="line">  stage_max   = len &lt;&lt; <span class="number">3</span>;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">for</span> (stage_cur = <span class="number">0</span>; stage_cur &lt; stage_max; stage_cur++) &#123;</span><br><span class="line">    stage_cur_byte = stage_cur &gt;&gt; <span class="number">3</span>;</span><br><span class="line">    <span class="built_in">FLIP_BIT</span>(out_buf, stage_cur);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">common_fuzz_stuff</span>(argv, out_buf, len)) <span class="keyword">goto</span> abandon_entry;</span><br><span class="line">    <span class="built_in">FLIP_BIT</span>(out_buf, stage_cur);</span><br></pre></td></tr></table></figure>

<ul>
<li>流程<ul>
<li>设置stage_name为<code>bitflip 1/1</code>, ar的取值是out_buf,而_bf的取值在<code>[0: len &lt;&lt; 3)</code>    也就是测试<strong>长度*8</strong> 次</li>
<li>所以用<code>_bf &amp; 7</code>能够得到<code>0,1,2...7 0,1,2...7</code>这样的取值一共len组 (每组8个)</li>
<li>然后 index  -&gt;   <code>(_bf) &gt;&gt; 3</code>又将<code>[0: len&lt;&lt;3)</code>映射回了<code>[0: len)</code>，对应到buf里的每个byte</li>
<li>然后 value  -&gt; <code>(128 &gt;&gt; ((_bf) &amp; 7))</code> 对应 <code>128,64,32,16,8,4,2,1</code></li>
<li>遍历out_buf 中字符 ， 与上面进行 异或<ul>
<li><code>out_buf[0] ^= 128</code></li>
<li><code>out_buf[0] ^= 64</code></li>
<li><code>out_buf[0] ^= 32</code></li>
<li><code>out_buf[0] ^= 16</code></li>
<li><code>out_buf[0] ^= 8</code></li>
<li><code>out_buf[0] ^= 4</code></li>
<li><code>out_buf[0] ^= 2</code></li>
<li><code>out_buf[0] ^= 1</code></li>
<li><code>out_buf[1] ^= 128</code></li>
<li>…</li>
</ul>
</li>
<li><code>common_fuzz_stuff(argv, out_buf, len)</code> [[#u8 common_fuzz_stuff(char **argv, u8 *out_buf, u32 len)]]</li>
<li>所以在从<code>0-len*8</code>的遍历过程中会通过xor运算，依次将每个位翻转，然后执行一次<code>common_fuzz_stuff</code>，然后再翻转回来。</li>
<li>在进行bitflip 1&#x2F;1变异时，对于每个byte的最低位(least significant bit)翻转还进行了额外的处理<ul>
<li>如果连续多个bytes的最低位被翻转后，程序的执行路径都未变化，而且与原始执行路径不一致，那么就把这一段连续的bytes判断是一条token。<br>比如对于SQL的<code>SELECT *</code>，如果<code>SELECT</code>被破坏，则肯定和正确的路径不一致，而被破坏之后的路径却肯定是一样的，比如<code>AELECT</code>和<code>SBLECT</code>，显然都是无意义的，而只有不破坏token，才有可能出现和原始执行路径一样的结果，所以AFL在这里就是在猜解关键字token。</li>
<li>token<strong>默认最小是3，最大是32</strong>,每次发现新token时，通过<code>maybe_add_auto</code>添加到<code>a_extras</code>数组里。 [[#maybe_add_auto(u8 *mem, u32 len)]]</li>
</ul>
</li>
<li><code>stage_finds[STAGE_FLIP1]</code>的值加上在整个FLIP_BIT中新发现的路径和Crash总和</li>
<li><code>stage_cycles[STAGE_FLIP1]</code>的值加上在整个FLIP_BIT中执行的target次数<code>stage_max</code></li>
<li><img src="/%E6%80%BB%E7%BB%93_AFL%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/310c793b6254093e2ef21453329ccad2.png"></li>
</ul>
</li>
<li><code>bitflip 2/1</code> <strong>翻转2次</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">stage_max = (len &lt;&lt; <span class="number">3</span>) - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (stage_cur = <span class="number">0</span>; stage_cur &lt; stage_max; stage_cur++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">FLIP_BIT</span>(out_buf, stage_cur);</span><br><span class="line">    <span class="built_in">FLIP_BIT</span>(out_buf, stage_cur + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">common_fuzz_stuff</span>(argv, out_buf, len)) <span class="keyword">goto</span> abandon_entry;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FLIP_BIT</span>(out_buf, stage_cur);</span><br><span class="line">    <span class="built_in">FLIP_BIT</span>(out_buf, stage_cur + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>流程<ul>
<li>设置stage_name为<code>bitflip 2/1</code>,原理和之前一样，只是这次是<strong>连续翻转</strong></li>
<li><code>out_buf[0] = 0x31^128^64</code></li>
<li><code>out_buf[0] = 0x31^64^32</code></li>
<li>…</li>
<li>然后保存结果到<code>stage_finds[STAGE_FLIP2]和stage_cycles[STAGE_FLIP2]</code>里。</li>
</ul>
</li>
<li>同理，设置stage_name为<code>bitflip 4/1</code>，<strong>翻转连续4次并记录。</strong></li>
<li>流程<ul>
<li><code>out_buf[0] = 0x31^128^64^32^16 = 0xC1</code></li>
<li><code>out_buf[0] = 0x31^64^32^16^8   = 0x49</code></li>
<li><code>out_buf[0] = 0x31^32^16^8^4    = 0xD</code></li>
<li><code>out_buf[0] = 0x31^16^8^4^2     = 0x2F</code></li>
<li><code>out_buf[0] = 0x31^8^4^2^1      = 0x3E</code></li>
<li><code>out_buf[0] = 0x31^4^2^1        = 0x36   out_buf[1] = 0x32^128         = 0xB2</code></li>
<li><code>out_buf[0] = 0x31^2^1          = 0x32   out_buf[1] = 0x32^128^64      = 0xF2</code></li>
<li><code>out_buf[0] = 0x31^1            = 0x30   out_buf[1] = 0x32^128^64^32   = 0xD2</code></li>
<li>…</li>
</ul>
</li>
<li><code>生成effector map</code><ul>
<li>在进行bitflip 8&#x2F;8变异时，AFL还生成了一个非常重要的信息：effector map。这个effector map几乎贯穿了整个deterministic fuzzing的始终。</li>
<li>具体地，在对每个byte进行翻转时，如果其造成执行路径与原始路径不一致，就将该byte在effector map中标记为1，即“有效”的，否则标记为0，即“无效”的。</li>
<li>这样做的逻辑是：如果一个byte完全翻转，都无法带来执行路径的变化，那么这个byte很有可能是属于”data”，而非”metadata”（例如size, flag等），对整个fuzzing的意义不大。所以，在随后的一些变异中，<code>会参考effector map，跳过那些“无效”的byte，从而节省了执行资源</code>。</li>
<li>由此，通过极小的开销（没有增加额外的执行次数），AFL又一次对文件格式进行了<code>启发式的判断</code>。看到这里，不得不叹服于AFL实现上的精妙。</li>
<li>不过，<code>在某些情况下并不会检测有效字符</code>。</li>
<li>第一种情况就是<code>dumb mode</code>或者<code>从fuzzer</code>，此时文件所有的字符都有可能被变异。</li>
<li>第二、第三种情况与文件本身有关：</li>
</ul>
</li>
<li><code>bitflip 8/8变异</code><ul>
<li>设置stage_name为<code>bitflip 8/8</code>，以字节为单位，直接通过和<code>0xff</code>亦或运算去翻转整个字节的位，然后执行一次，并记录。</li>
</ul>
</li>
<li><code>bitflip 16/8变异</code><ul>
<li>设置stage_name为<code>bitflip 16/8</code>，设置<code>stage_max</code>为<code>len - 1</code>，以字为单位和<code>0xffff</code>进行亦或运算，<code>去翻转相邻的两个字节(即一个字的)的位</code>。</li>
<li><code>out_buf[0] = 0x3231 ^ 0xffff = 0xCDCE</code></li>
<li><code>out_buf[0] = 0x3332 ^ 0xffff = 0xCCCD</code></li>
<li>…</li>
<li>这里要注意在翻转之前会先检查eff_map里对应于这两个字节的标志是否为0，如果为0，则这两个字节是无效的数据，stage_max减一，然后开始变异下一个字。</li>
<li>common_fuzz_stuff执行变异后的结果，然后还原。</li>
</ul>
</li>
<li><code>如果预料len&lt;4 就跳出bitflip goto skip_bitflip</code></li>
<li><code>bitflip 32/8变异</code><ul>
<li><code>out_buf[0] = 0xA333231 ^ 0xFFFFFFFF = 0xF5CCCDCE</code></li>
<li>同理，设置stage_name为<code>bitflip 32/8</code>，然后设置<code>stage_max</code>为<code>len - 3</code>，以双字为单位，直接通过和<code>0xffffffff</code>亦或运算去相邻四个字节的位，然后执行一次，并记录。<ul>
<li>在每次翻转之前会检查eff_map里对应于这四个字节的标志是否为0，如果是0，则这两个字节是无效的数据，stage_max减一，然后开始变异下一组双字。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="ARITHMETIC-INC-DEC阶段"><a href="#ARITHMETIC-INC-DEC阶段" class="headerlink" title="ARITHMETIC INC&#x2F;DEC阶段"></a>ARITHMETIC INC&#x2F;DEC阶段</h5><ul>
<li>判断是否指定 <code>AFL_NO_ARITH</code> 略过</li>
<li>流程<ul>
<li>在bitflip变异全部进行完成后，便进入下一个阶段：arithmetic。与bitflip类似的是，arithmetic根据目标大小的不同，也分为了多个子阶段：</li>
<li>算法运算有个<code>could_be_bitflip</code>   确定给定的 <code>xor_val</code> 是否可能是由位翻转引起的变化。<ul>
<li>举例<code>arith 8/8</code><ul>
<li>取第一位</li>
<li>检查 <code>orig ^ (orig + j) = 0x31 ^ 0x32 = 0x3</code>  跳过<ul>
<li>用于检查特定的变化（通过 <code>xor_val = old ^ new</code> 表示）是否可能是由 <code>afl-fuzz</code> 尝试的确定性位翻转引起的。这在后续的一些确定性模糊测试操作中用于避免重复。如果 <code>xor_val</code> 为零，还会返回 1，这意味着旧值和尝试的新值是相同的，执行将是浪费时间。</li>
</ul>
</li>
<li>检查   <code>orig ^ (orig - j) = 0x31 - 0x30 = 0x1</code>  跳过</li>
<li>取第二位</li>
<li>检查 <code>orig ^ (orig + j) = 0x31 ^ 0x33 = 0x2</code>     <code>0x2 &gt;&gt;=1 = 0x1</code> 跳过</li>
<li>检查 <code>orig ^ (orig - j) = 0x31 ^ 0x2F = 0x1E</code>    <code>0x1e &gt;&gt;=1 = 0xF</code>跳过</li>
<li>取三位</li>
<li>检查 <code>orig ^ (orig + j) = 0x31 ^ 0x34 = 0x5</code>通过<ul>
<li>然后使用 <code>out_buf[0]  = 0x34</code>这个值  去 <code>common_fuzz_stuff</code></li>
</ul>
</li>
<li>继续检查 <code>orig ^ (orig - j) = 0x31 ^ 0x2E = 0x1F</code>通过<ul>
<li>然后使用 <code>out_buf[0]  = 0x2E</code>这个值  去 <code>common_fuzz_stuff</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><code>下面要分大小端测试</code></li>
<li><code>arith 8/8</code>，每次对8个bit进行加减运算，按照每8个bit的步长从头开始，即对文件的每个byte进行整数加减变异</li>
<li><code>arith 16/8</code>，每次对16个bit进行加减运算，按照每8个bit的步长从头开始，即对文件的每个word进行整数加减变异</li>
<li><code>arith 32/8</code>，每次对32个bit进行加减运算，按照每8个bit的步长从头开始，即对文件的每个dword进行整数加减变异</li>
<li>加减变异的上限，在<code>config.h</code>中的宏<code>ARITH_MAX</code>定义，默认为35。所以，<code>对目标整数会进行+1, +2, …, +35, -1, -2, …, -35的变异</code>。特别地，<code>由于整数存在大端序和小端序两种表示方式，AFL会贴心地对这两种整数表示方式都进行变异</code>。</li>
<li>此外，AFL还会智能地跳过某些arithmetic变异。</li>
<li>第一种情况就是前面提到的<code>effector map</code>：如果一个整数的所有bytes都被判断为“无效”，那么就跳过对整数的变异。</li>
<li>第二种情况是之前bitflip已经生成过的变异：如果加&#x2F;减某个数后，其效果与之前的某种bitflip相同，那么这次变异肯定在上一个阶段已经执行过了，此次便不会再执行。</li>
</ul>
</li>
<li><img src="/%E6%80%BB%E7%BB%93_AFL%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/b467dff7c08b41e961127222e7ea975d.png"></li>
</ul>
<h5 id="INTERESTING-VALUES阶段"><a href="#INTERESTING-VALUES阶段" class="headerlink" title="INTERESTING VALUES阶段"></a>INTERESTING VALUES阶段</h5><ul>
<li>流程<ul>
<li>下一个阶段是interest，具体可分为：</li>
<li>interest 8&#x2F;8，每次对8个bit进替换，按照每8个bit的步长从头开始，即对文件的每个byte进行替换</li>
<li>interest 16&#x2F;8，每次对16个bit进替换，按照每8个bit的步长从头开始，即对文件的每个word进行替换</li>
<li>interest 32&#x2F;8，每次对32个bit进替换，按照每8个bit的步长从头开始，即对文件的每个dword进行替换</li>
<li>而用于替换的”interesting values”，是AFL预设的一些比较特殊的数,这些数的定义在config.h文件中</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> s8  interesting_8[]  = &#123; INTERESTING_8 &#125;;  </span><br><span class="line"><span class="type">static</span> s16 interesting_16[] = &#123; INTERESTING_8, INTERESTING_16 &#125;;  </span><br><span class="line"><span class="type">static</span> s32 interesting_32[] = &#123; INTERESTING_8, INTERESTING_16, INTERESTING_32 &#125;;  </span><br></pre></td></tr></table></figure>

<ul>
<li>与之前类似，effector map仍然会用于判断是否需要变异；此外，如果某个interesting value，是可以通过bitflip或者arithmetic变异达到，那么这样的重复性变异也是会跳过的。 Skip if the value could be a product of bitflips or arithmetics.</li>
<li><code>out_buf[0] = interesting_8[0] = -128;</code></li>
<li>…</li>
<li><code>*(u16*)(out_buf + 0)  = interesting_16[0] = -128;  = 0xffff-128+1 = 0xff80</code></li>
<li>…</li>
<li><code>*(u32*)(out_buf + 0)  = interesting_32[0] = -128;  = 0xffffffff-128+1 = 0xFFFFFF80</code><ul>
<li><code>0x005320c8: 0x80 0xff 0xff 0xff 0xf0 0x00 0x00 0x00</code></li>
</ul>
</li>
</ul>
<h5 id="DICTIONARY-STUFF阶段"><a href="#DICTIONARY-STUFF阶段" class="headerlink" title="DICTIONARY STUFF阶段"></a>DICTIONARY STUFF阶段</h5><ul>
<li>[[#字典编写规则]]</li>
<li>流程<ul>
<li><code>extras_cnt=0</code> 跳过<ul>
<li>改变他 用 <code>load_extras_file</code> 自己指定的字典</li>
</ul>
</li>
<li>遍历字典<ul>
<li>如果发现跟预料一致跳过</li>
<li>如果发现超过200跳过？</li>
<li>进入到这个阶段，就接近deterministic fuzzing的尾声了。具体有以下子阶段：</li>
<li><code>user extras(over)</code> 从头开始,将用户提供的tokens依次替换到原文件中,stage_max为<code>extras_cnt * len</code></li>
<li><code>ABCD</code></li>
<li><code>user extras(insert)</code> 从头开始,将用户提供的tokens依次插入到原文件中,stage_max为<code>extras_cnt * len</code></li>
<li><code>123123</code></li>
<li><code>auto extras(over)</code> 从头开始,将<code>自动检测的tokens</code>依次替换到原文件中,stage_max为<code>MIN(a_extras_cnt, USE_AUTO_EXTRAS) * len</code><ul>
<li>这里是自己检测得到的 a_extras_cnt个 token</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="RANDOM-HAVOC阶段"><a href="#RANDOM-HAVOC阶段" class="headerlink" title="RANDOM HAVOC阶段"></a>RANDOM HAVOC阶段</h5><ul>
<li>设置确定性检测，创建文件 <code>mark_as_det_done</code><ul>
<li><code>/home/wutang/Desktop/fuzz_test/fuzz_output/fuzzer1/queue/.state/deterministic_done/id:000000,orig:1</code></li>
</ul>
</li>
<li>流程<ul>
<li>对于非dumb mode的主fuzzer来说，完成了上述<code>deterministic fuzzing</code>后，便进入了充满随机性的这一阶段；<strong>对于dumb mode或者从fuzzer来说，则是直接从这一阶段开始</strong>。</li>
<li>havoc，顾名思义，是充满了各种随机生成的变异，是对<strong>原文件的“大破坏</strong>”。具体来说，havoc包含了对原文件的多轮变异，每一轮都是将多种方式组合（stacked）而成：</li>
<li>随机选取某个bit进行翻转</li>
<li><code>FLIP_BIT(out_buf, UR(temp_len &lt;&lt; 3));</code></li>
<li>随机选取某个byte，将其设置为随机的interesting value</li>
<li><code>out_buf[UR(temp_len)] = interesting_8[UR(sizeof(interesting_8))];</code></li>
<li>随机选取某个word，并随机选取大、小端序，将其设置为随机的interesting value</li>
<li><code>*(u16*)(out_buf + UR(temp_len - 1)) = interesting_16[UR(sizeof(interesting_16) &gt;&gt; 1)];</code></li>
<li>随机选取某个dword，并随机选取大、小端序，将其设置为随机的interesting value</li>
<li><code>*(u32*)(out_buf + UR(temp_len - 3)) = interesting_32[UR(sizeof(interesting_32) &gt;&gt; 2)];</code></li>
<li>随机选取某个byte，对其减去一个随机数</li>
<li><code>out_buf[UR(temp_len)] -= 1 + UR(ARITH_MAX);</code></li>
<li>随机选取某个byte，对其加上一个随机数</li>
<li><code>out_buf[UR(temp_len)] += 1 + UR(ARITH_MAX);</code></li>
<li>随机选取某个word，并随机选取大、小端序，对其减去一个随机数</li>
<li><code>*(u16*)(out_buf + pos) = SWAP16(SWAP16(*(u16*)(out_buf + pos)) - num);</code></li>
<li>随机选取某个word，并随机选取大、小端序，对其加上一个随机数</li>
<li><code>*(u16*)(out_buf + pos) = SWAP16(SWAP16(*(u16*)(out_buf + pos)) + num);</code></li>
<li>随机选取某个dword，并随机选取大、小端序，对其减去一个随机数</li>
<li>随机选取某个dword，并随机选取大、小端序，对其加上一个随机数</li>
<li>随机选取某个byte，将其设置为随机数</li>
<li><code>out_buf[UR(temp_len)] ^= 1 + UR(255);</code></li>
<li>随机删除一段bytes</li>
<li><code>Clone bytes (75%) or insert a block of constant bytes (25%).</code></li>
<li>随机选取一个位置 75% 的概率是克隆（复制）一段数据，25% 的概率是插入一段常量数据</li>
<li><code>clone_len  = choose_block_len(temp_len);</code> 在一定的范围内选择合适的块长度，以便在块操作中产生不同大小的修改</li>
<li><code>clone_from = UR(temp_len - clone_len + 1);</code> 一个更简单的随机数生成函数，用于从 0 到 <code>limit - 1</code> 之间选择一个随机数。它的主要目的是在需要产生随机数的地方使用。</li>
<li><code>new_buf = ck_alloc_nozero(temp_len + clone_len);</code><ul>
<li>创建8+clone_len(随机长度) 长度 新buf&#x3D;new_buf</li>
</ul>
</li>
<li><code>memcpy(new_buf + clone_to, out_buf + clone_from, clone_len);</code><ul>
<li>out_buf + clone_from(随机数)  拷贝长度为clone_len(随机长度)  到  new_buf+clone_to(随机数)</li>
</ul>
</li>
<li><code>Overwrite bytes with a randomly selected chunk (75%) or fixed bytes (25%). </code></li>
<li>15 随机选取一个位置，用随机选取的token（用户提供的或自动生成的）替换</li>
<li>16 随机选取一个位置，用随机选取的token（用户提供的或自动生成的）插入</li>
<li>怎么样，看完上面这么多的“随机”，有没有觉得晕？还没完，AFL会生成一个随机数，作为变异组合的数量，并根据这个数量，每次从上面那些方式中随机选取一个（可以参考高中数学的有放回摸球），依次作用到文件上。如此这般丧心病狂的变异，原文件就大概率面目全非了，而这么多的随机性，也就成了fuzzing过程中的不可控因素，即所谓的“看天吃饭”了。</li>
</ul>
</li>
</ul>
<h5 id="SPLICING阶段"><a href="#SPLICING阶段" class="headerlink" title="SPLICING阶段"></a>SPLICING阶段</h5><ul>
<li><code>use_splicing</code> 在之前一整轮没有发现就会被设置,<code>retry_splicing</code>循环。 重新尝试 splicing 15次后退出循环</li>
<li>随机读取一个预料 到 new_buf</li>
<li>对比in_buf 旧预料 和 随机预料 new_buf不同的第一和最后的offset<ul>
<li><code>locate_diffs(in_buf, new_buf, MIN(len, target-&gt;len), &amp;f_diff, &amp;l_diff);</code></li>
<li>比如 预料<code>123</code> 躲避 <code>2222</code> 得到 <code>f_diff=0 l_diff=3</code></li>
<li>随机得到分割offset <code>split_at = f_diff + UR(l_diff - f_diff);</code></li>
<li>然后拷贝 in_buf的长度为 split_at 到 new_buf  <code>memcpy(new_buf, in_buf, split_at);</code></li>
</ul>
</li>
<li>跳转到 [[#RANDOM HAVOC阶段]]</li>
</ul>
<h4 id="sync-fuzzers-char-argv"><a href="#sync-fuzzers-char-argv" class="headerlink" title="sync_fuzzers(char **argv)"></a>sync_fuzzers(char **argv)</h4><h4 id="trim-case-char-argv-struct-queue-entry-q-u8-in-buf"><a href="#trim-case-char-argv-struct-queue-entry-q-u8-in-buf" class="headerlink" title="trim_case(char **argv, struct queue_entry *q, u8 *in_buf)"></a>trim_case(char **argv, struct queue_entry *q, u8 *in_buf)</h4><ul>
<li>用于在进行确定性检查deterministic checks时修剪测试用例，以便节省时间和资源</li>
</ul>
<h4 id="u32-calculate-score-struct-queue-entry-q"><a href="#u32-calculate-score-struct-queue-entry-q" class="headerlink" title="u32 calculate_score(struct queue_entry *q)"></a>u32 calculate_score(struct queue_entry *q)</h4><ul>
<li>用于计算测试用例（case）的可取得分（desirability score），以便在执行混沌模糊测试（havoc fuzzing）时调整模糊测试的长度。</li>
</ul>
<h4 id="u8-common-fuzz-stuff-char-argv-u8-out-buf-u32-len"><a href="#u8-common-fuzz-stuff-char-argv-u8-out-buf-u32-len" class="headerlink" title="u8 common_fuzz_stuff(char **argv, u8 *out_buf, u32 len)"></a>u8 common_fuzz_stuff(char **argv, u8 *out_buf, u32 len)</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Write a modified test case, run program, process results. Handle</span></span><br><span class="line"><span class="comment">   error conditions, returning 1 if it&#x27;s time to bail out. This is</span></span><br><span class="line"><span class="comment">   a helper function for fuzz_one(). */</span></span><br><span class="line"><span class="function">EXP_ST u8 <span class="title">common_fuzz_stuff</span><span class="params">(<span class="type">char</span>** argv, u8* out_buf, u32 len)</span> </span>&#123;</span><br><span class="line">  u8 fault;</span><br><span class="line">  <span class="keyword">if</span> (post_handler) &#123;</span><br><span class="line">    out_buf = <span class="built_in">post_handler</span>(out_buf, &amp;len); </span><br><span class="line">    <span class="comment">// so中的后处理逻辑提供扩展</span></span><br><span class="line">    <span class="keyword">if</span> (!out_buf || !len) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">write_to_testcase</span>(out_buf, len);</span><br><span class="line">  fault = <span class="built_in">run_target</span>(argv, exec_tmout);</span><br><span class="line">  <span class="comment">// 调用 `run_target` 函数来执行目标程序，`argv` 是目标程序的命令行参数，`exec_tmout` 是执行的超时时间。将执行结果保存在 `fault` 变量中</span></span><br><span class="line">  <span class="keyword">if</span> (stop_soon) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (fault == FAULT_TMOUT) &#123;</span><br><span class="line">    <span class="keyword">if</span> (subseq_tmouts++ &gt; TMOUT_LIMIT) &#123;</span><br><span class="line">      cur_skipped_paths++;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> subseq_tmouts = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">/* Users can hit us with SIGUSR1 to request the current input</span></span><br><span class="line"><span class="comment">     to be abandoned. */</span></span><br><span class="line">  <span class="keyword">if</span> (skip_requested) &#123;</span><br><span class="line">     skip_requested = <span class="number">0</span>;</span><br><span class="line">     cur_skipped_paths++;</span><br><span class="line">     <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* This handles FAULT_ERROR for us: */</span></span><br><span class="line">  queued_discovered += <span class="built_in">save_if_interesting</span>(argv, out_buf, len, fault);</span><br><span class="line">  <span class="keyword">if</span> (!(stage_cur % stats_update_freq) || stage_cur + <span class="number">1</span> == stage_max)</span><br><span class="line">    <span class="built_in">show_stats</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>[[#show_stats]]</li>
<li>简单的说就是写入文件并执行，然后处理结果，如果出现错误，就返回1.<ul>
<li>如果定义了<code>post_handler</code>,就通过<code>out_buf = post_handler(out_buf, &amp;len)</code>处理一下out_buf，如果out_buf或者len有一个为0，则直接返回0<ul>
<li><strong>这里其实很有价值，尤其是如果需要对变异完的queue，做一层wrapper再写入的时候。</strong></li>
</ul>
</li>
<li><code>write_to_testcase(out_buf, len)</code></li>
<li>[[#void write_to_testcase(void *mem, u32 len)]]</li>
<li><code>fault = run_target(argv, exec_tmout)</code></li>
<li>[[#u8 run_target(char **argv, u32 timeout)]]</li>
<li>如果fault是FAULT_TMOUT<ul>
<li>如果<code>subseq_tmouts++ &gt; TMOUT_LIMIT</code>（默认250），就将cur_skipped_paths加一，直接返回1</li>
<li>subseq_tmout是连续超时数</li>
</ul>
</li>
<li>否则设置subseq_tmouts为0</li>
<li>如果skip_requested为1<ul>
<li>设置skip_requested为0，然后将cur_skipped_paths加一，直接返回1</li>
</ul>
</li>
<li><code>queued_discovered += save_if_interesting(argv, out_buf, len, fault)</code>，即如果发现了新的路径才会加一。</li>
<li>[[#u8 save_if_interesting(char **argv, void *mem, u32 len, u8 fault)]] 会把什么阶段的样例记录下来</li>
<li>如果stage_cur除以stats_update_freq余数是0，或者其加一等于stage_max，就更新展示界面<code>show_stats</code></li>
<li>返回0</li>
</ul>
</li>
</ul>
<h4 id="u8-save-if-interesting-char-argv-void-mem-u32-len-u8-fault"><a href="#u8-save-if-interesting-char-argv-void-mem-u32-len-u8-fault" class="headerlink" title="u8 save_if_interesting(char **argv, void *mem, u32 len, u8 fault)"></a>u8 save_if_interesting(char **argv, void *mem, u32 len, u8 fault)</h4><ul>
<li>判断目标程序的执行结果是否有趣，如果有趣则保存或排队。<ul>
<li>[[#char has_new_bits(u8 *virgin_map)]] 没发现新路径就return</li>
</ul>
</li>
<li><code>/home/wutang/Desktop/fuzz_test/fuzz_output/fuzzer1/queue/id:000003,src:000000,op:flip2,pos:2,+cov</code><ul>
<li>会把什么阶段的样例记录下来</li>
<li>将其添加到队列里<ul>
<li>[[#add_to_queue(u8 *fname, u32 len, u8 passed_det)]]</li>
</ul>
</li>
<li>计算hash 保存hash到其exec_cksum<ul>
<li>[[#inline u32 hash32(const void* key, u32 len, u32 seed)]]</li>
</ul>
</li>
<li>评估这个queue<ul>
<li>[[#u8 calibrate_case(char **argv, struct queue_entry *q, u8 *use_mem, u32 handicap, u8 from_queue)]]</li>
</ul>
</li>
<li>设置keeping值为1</li>
<li>根据fault结果进入不同的分支<ul>
<li>FAULT_TMOUT<ul>
<li>设置total_tmouts计数器加一</li>
<li>如果unique_hangs的个数超过能保存的最大数量<code>KEEP_UNIQUE_HANG</code>，就直接返回keeping的值</li>
<li>如果不是dumb mode，就<code>simplify_trace((u64 *) trace_bits)</code>进行规整。</li>
<li>[[#simplify_trace(u64 *mem)]]  这段代码的目的是对位图中的活动位进行简化，以减少位图的复杂性，提高执行效率</li>
<li>如果没有发现新的超时路径，就直接返回keeping</li>
<li>否则，代表发现了新的超时路径，unique_tmouts计数器加一</li>
<li>如果hang_tmout大于exec_tmout，则以hang_tmout为timeout，重新执行一次runt_target<ul>
<li>如果结果为<code>FAULT_CRASH</code>，就跳转到keep_as_crash</li>
<li>如果结果不是<code>FAULT_TMOUT</code>，就返回keeping，否则就使<code>unique_hangs</code>计数器加一，然后更新last_hang_time的值，并保存到<code>alloc_printf(&quot;%s/hangs/id:%06llu,%s&quot;, out_dir, unique_hangs, describe_op(0))</code>文件。</li>
</ul>
</li>
</ul>
</li>
<li>FAULT_CRASH<ul>
<li>total_crashes计数器加一</li>
<li>如果unique_crashes大于能保存的最大数量<code>KEEP_UNIQUE_CRASH</code>即5000，就直接返回keeping的值</li>
<li>同理，如果不是dumb mode，就<code>simplify_trace((u64 *) trace_bits)</code>进行规整 [[#simplify_trace(u64 *mem)]]</li>
<li>如果没有发现新的crash路径，就直接返回keeping</li>
<li>否则，代表发现了新的crash路径，unique_crashes计数器加一，并将结果保存到<code>alloc_printf(&quot;%s/crashes/id:%06llu,sig:%02u,%s&quot;, out_dir,unique_crashes, kill_signal, describe_op(0))</code>文件。</li>
<li><code>/home/wutang/Desktop/fuzz_test/fuzz_output/fuzzer1/crashes/id:000000,sig:06,src:000005,op:arith8,pos:5,val:-14</code></li>
<li>更新<code>last_crash_time</code>和<code>last_crash_execs=total_execs</code></li>
</ul>
</li>
<li>FAULT_ERROR<ul>
<li>抛出异常</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="simplify-trace-u64-mem"><a href="#simplify-trace-u64-mem" class="headerlink" title="simplify_trace(u64 *mem)"></a>simplify_trace(u64 *mem)</h4><ul>
<li>对一个64位整数数组（位图）进行简化操作,这段代码的目的是对位图中的活动位进行简化，以减少位图的复杂性，提高执行效率。</li>
<li>按8个字节为一组循环读入，直到完全读取完mem<ul>
<li>如果mem不为空<ul>
<li>i从0-7，<code>mem8[i] = simplify_lookup[mem8[i]]</code>，代表规整该路径的命中次数到指令值，这个路径如果没有命中，就设置为1，如果命中了，就设置为128，即二进制的<code>1000 0000</code></li>
</ul>
</li>
<li>否则设置mem为<code>0x0101010101010101ULL</code>，即代表这8个字节代表的path都没有命中，每个字节的值被置为1。</li>
</ul>
</li>
</ul>
<h2 id="afl-showmap"><a href="#afl-showmap" class="headerlink" title="afl-showmap"></a>afl-showmap</h2><h2 id="afl-analyze"><a href="#afl-analyze" class="headerlink" title="afl-analyze"></a>afl-analyze</h2><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://eternalsakura13.com/2020/08/23/afl/">sakuraのAFL源码全注释 | Sakuraのblog</a></li>
</ul>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/fuzzing/" rel="tag"># fuzzing</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/11/06/browser_about/CVE-2019-5782-zhaoqixun-2018-11-16%E5%8F%91-7-2/" rel="prev" title="CVE-2019-5782_zhaoqixun_2018_11_16发_7.2">
      <i class="fa fa-chevron-left"></i> CVE-2019-5782_zhaoqixun_2018_11_16发_7.2
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    
  
  <div class="comments">
  <script src="https://utteranc.es/client.js" repo="pandamac/pandamac.github.io" issue-term="title" theme="github-dark" crossorigin="anonymous" async></script>
  </div>
  
  

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-AFL%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0"><span class="nav-text">总结_AFL源码学习</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%80%E8%A6%81"><span class="nav-text">简要</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%9B%E5%BB%BAcmakelists-txt%E6%96%B9%E4%BE%BFvscode%E8%B0%83%E8%AF%95"><span class="nav-text">创建cmakelists.txt方便vscode调试</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#afl-gcc-%E5%AF%B9%E6%BA%90%E7%A0%81%E6%8F%92%E8%A3%85"><span class="nav-text">afl-gcc-对源码插装</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%91%BD%E4%BB%A4"><span class="nav-text">命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#main"><span class="nav-text">main</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#find-as%E6%9E%84%E9%80%A0afl-as%E8%B7%AF%E5%BE%84"><span class="nav-text">find_as构造afl-as路径</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%87%E8%AE%B0%E5%86%85%E5%AD%98%E6%9E%84%E9%80%A0"><span class="nav-text">标记内存构造</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#edit-params"><span class="nav-text">edit_params</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#execvp%E6%9D%A5%E6%89%A7%E8%A1%8C%E5%AE%9E%E9%99%85%E7%9A%84%E7%BC%96%E8%AF%91%E5%99%A8"><span class="nav-text">execvp来执行实际的编译器</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#afl-as"><span class="nav-text">afl-as</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%91%BD%E4%BB%A4-1"><span class="nav-text">命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#gettimeofday%E6%97%B6%E9%97%B4%E5%8A%A0%E8%BF%9B%E7%A8%8Bpid%E6%9E%84%E9%80%A0%E9%9A%8F%E6%9C%BA%E7%A7%8D%E5%AD%90"><span class="nav-text">gettimeofday时间加进程pid构造随机种子</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#edit-params%E8%AE%BE%E7%BD%AE%E5%8F%82%E6%95%B0"><span class="nav-text">edit_params设置参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#add-instrumentation"><span class="nav-text">add_instrumentation</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AF%BB%E5%8F%96%E6%B1%87%E7%BC%96%E6%96%87%E4%BB%B6%EF%BC%8C%E5%86%99%E5%85%A5afl%E6%B1%87%E7%BC%96%E6%96%87%E4%BB%B6"><span class="nav-text">读取汇编文件，写入afl汇编文件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%80%E9%87%8D%E8%A6%81%E7%9A%84%E4%BB%A3%E7%A0%81-%E6%8F%92%E5%85%A5%E9%80%BB%E8%BE%91"><span class="nav-text">最重要的代码-插入逻辑</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#32-64%E8%B7%B3%E8%BD%AC%E6%8C%87%E4%BB%A4"><span class="nav-text">32|64跳转指令</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#trampoline-fmt-64"><span class="nav-text">trampoline_fmt_64</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#64%E4%BD%8D-32%E4%BD%8D%E6%B1%87%E7%BC%96payload"><span class="nav-text">64位&amp;32位汇编payload</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#afl-maybe-log"><span class="nav-text">__afl_maybe_log</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#afl-store"><span class="nav-text">__afl_store</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#afl-return"><span class="nav-text">__afl_return</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#afl-setup"><span class="nav-text">__afl_setup</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#afl-setup-first"><span class="nav-text">__afl_setup_first</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#afl-forkserver-afl-fork-wait-loop"><span class="nav-text">__afl_forkserver&amp;__afl_fork_wait_loop</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#afl-fork-resume%E5%AD%90%E8%BF%9B%E7%A8%8B%E5%A4%84%E7%90%86"><span class="nav-text">__afl_fork_resume子进程处理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#afl-die%E9%80%80%E5%87%BA"><span class="nav-text">__afl_die退出</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#afl-setup-abort%E9%85%8D%E7%BD%AE%E5%A4%B1%E8%B4%A5"><span class="nav-text">__afl_setup_abort配置失败</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8F%98%E9%87%8F%E7%94%B3%E8%AF%B7"><span class="nav-text">变量申请</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#main-1"><span class="nav-text">main</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#afl-fast-clang"><span class="nav-text">afl-fast-clang</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%96%E8%AF%91"><span class="nav-text">编译</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B5%8B%E8%AF%95%E5%91%BD%E4%BB%A4"><span class="nav-text">测试命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#find-obj"><span class="nav-text">find_obj</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#edit-params-1"><span class="nav-text">edit_params</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%9EUSE-TRACE-PC%E6%96%B9%E5%BC%8F-%E4%BD%BF%E7%94%A8llvmpass"><span class="nav-text">非USE_TRACE_PC方式-使用llvmpass</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#test-instr-c%E6%8F%92%E6%A1%A9%E5%89%8D%E5%90%8EIR%E5%AF%B9%E6%AF%94"><span class="nav-text">test-instr.c插桩前后IR对比</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%85%E9%83%A8%E5%8F%98%E9%87%8F-afl-prev-loc-afl-area-ptr"><span class="nav-text">内部变量 __afl_prev_loc&amp;__afl_area_ptr</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#afl-llvm-rt"><span class="nav-text">afl-llvm-rt</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%87%8A%E5%86%85%E9%83%A8%E5%8F%98%E9%87%8F"><span class="nav-text">解释内部变量</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#afl-prev-loc"><span class="nav-text">__afl_prev_loc</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#afl-area-initial"><span class="nav-text">__afl_area_initial</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#deferred-instrumentation"><span class="nav-text">deferred instrumentation</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BB%B6%E8%BF%9F%E5%88%9D%E5%A7%8B%E5%8C%96%E9%85%8D%E7%BD%AE-%E4%BB%A3%E7%A0%81"><span class="nav-text">延迟初始化配置+代码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#afl-manual-init"><span class="nav-text">__afl_manual_init</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#afl-map-shm"><span class="nav-text">__afl_map_shm</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#afl-start-forkserver"><span class="nav-text">__afl_start_forkserver</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%AF%E8%83%BD%E5%A4%B1%E7%81%B5%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-text">可能失灵初始化</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#persistent-mode"><span class="nav-text">persistent mode</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8C%81%E4%B9%85%E6%A8%A1%E5%BC%8F%E9%85%8D%E7%BD%AE"><span class="nav-text">持久模式配置</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#afl-auto-init"><span class="nav-text">__afl_auto_init</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#afl-persistent-loop"><span class="nav-text">__afl_persistent_loop</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#trace-pc-guard-mode-%E6%B5%8B%E8%AF%95"><span class="nav-text">trace-pc-guard mode-测试</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8trace-pc"><span class="nav-text">使用trace-pc</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#fsanitize-coverage-trace-pc-guard"><span class="nav-text">-fsanitize-coverage&#x3D;trace-pc-guard</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AE%98%E7%BD%91%E4%BB%8B%E7%BB%8D"><span class="nav-text">官网介绍</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#afl%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95"><span class="nav-text">afl实现方法</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#afl-fuzz"><span class="nav-text">afl-fuzz</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B0%83%E8%AF%95%E9%85%8D%E7%BD%AE"><span class="nav-text">调试配置</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%97%E5%85%B8%E7%BC%96%E5%86%99%E8%A7%84%E5%88%99"><span class="nav-text">字典编写规则</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9D%E5%A7%8B%E9%85%8D%E7%BD%AE"><span class="nav-text">初始配置</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%89%80%E6%9C%89%E6%B5%81%E7%A8%8B"><span class="nav-text">所有流程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#setup-signal-handlers"><span class="nav-text">setup_signal_handlers</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#check-asan-opts"><span class="nav-text">check_asan_opts</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#fix-up-sync"><span class="nav-text">fix_up_sync</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#save-cmdline"><span class="nav-text">save_cmdline</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#fix-up-banner"><span class="nav-text">fix_up_banner</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#check-if-tty"><span class="nav-text">check_if_tty</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#get-core-count"><span class="nav-text">get_core_count</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#bind-to-free-cpu"><span class="nav-text">bind_to_free_cpu</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#check-crash-handling"><span class="nav-text">check_crash_handling</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#check-cpu-governor"><span class="nav-text">check_cpu_governor</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#setup-post"><span class="nav-text">setup_post</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#setup-shm"><span class="nav-text">setup_shm</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#init-count-class16"><span class="nav-text">init_count_class16</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#setup-dirs-fds"><span class="nav-text">setup_dirs_fds</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#maybe-delete-out-dir"><span class="nav-text">maybe_delete_out_dir</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E4%B8%BB%E7%A8%8B%E5%BA%8F"><span class="nav-text">函数主程序</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#read-testcases"><span class="nav-text">read_testcases</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#add-to-queue-u8-fname-u32-len-u8-passed-det"><span class="nav-text">add_to_queue(u8 *fname, u32 len, u8 passed_det)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#load-auto"><span class="nav-text">load_auto</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#maybe-add-auto-u8-mem-u32-len"><span class="nav-text">maybe_add_auto(u8 *mem, u32 len)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#pivot-inputs"><span class="nav-text">pivot_inputs</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#load-extras"><span class="nav-text">load_extras</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#find-timeout"><span class="nav-text">find_timeout</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#detect-file-args"><span class="nav-text">detect_file_args</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#setup-stdio-file"><span class="nav-text">setup_stdio_file</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#check-binary"><span class="nav-text">check_binary</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#perform-dry-run"><span class="nav-text">perform_dry_run</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%BE%93%E5%85%A5%E5%8F%82%E6%95%B0"><span class="nav-text">输入参数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%B5%81%E7%A8%8B"><span class="nav-text">流程</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#u8-calibrate-case-char-argv-struct-queue-entry-q-u8-use-mem-u32-handicap-u8-from-queue"><span class="nav-text">u8 calibrate_case(char **argv, struct queue_entry *q, u8 *use_mem, u32 handicap, u8 from_queue)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#init-forkserver"><span class="nav-text">init_forkserver</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#init-forkserver%E7%88%B6%E8%BF%9B%E7%A8%8B%E8%A1%8C%E4%B8%BA"><span class="nav-text">init_forkserver父进程行为</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#init-forkserver%E5%AD%90%E8%BF%9B%E7%A8%8B%E8%A1%8C%E4%B8%BA"><span class="nav-text">init_forkserver子进程行为</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#execv%E5%AD%90%E8%BF%9B%E7%A8%8B%E7%BB%A7%E7%BB%AD%E6%89%A7%E8%A1%8C%E6%8F%92%E5%85%A5%E7%9A%84%E4%BB%A3%E7%A0%81"><span class="nav-text">execv子进程继续执行插入的代码</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#void-write-to-testcase-void-mem-u32-len"><span class="nav-text">void write_to_testcase(void *mem, u32 len)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#u8-run-target-char-argv-u32-timeout"><span class="nav-text">u8 run_target(char **argv, u32 timeout)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#classify-counts-u64-mem"><span class="nav-text">classify_counts(u64 *mem)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#u32-count-bytes-u8-mem"><span class="nav-text">u32 count_bytes(u8 *mem)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#inline-u32-hash32-const-void-key-u32-len-u32-seed"><span class="nav-text">inline u32 hash32(const void* key, u32 len, u32 seed)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#char-has-new-bits-u8-virgin-map"><span class="nav-text">char has_new_bits(u8 *virgin_map)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#update-bitmap-score-struct-queue-entry-q"><span class="nav-text">update_bitmap_score(struct queue_entry *q)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#void-minimize-bits-u8-dst-u8-src"><span class="nav-text">void minimize_bits(u8 *dst, u8 *src)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#void-check-map-coverage-void"><span class="nav-text">void check_map_coverage(void)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#cull-queue"><span class="nav-text">cull_queue</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#mark-as-redundant-struct-queue-entry-q-u8-state"><span class="nav-text">mark_as_redundant(struct queue_entry *q, u8 state)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#show-init-stats"><span class="nav-text">show_init_stats</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#find-start-position"><span class="nav-text">find_start_position</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#void-write-stats-file-double-bitmap-cvg-double-stability-double-eps"><span class="nav-text">void write_stats_file(double bitmap_cvg, double stability, double eps)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#save-auto"><span class="nav-text">save_auto</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Fuzz%E6%89%A7%E8%A1%8C"><span class="nav-text">Fuzz执行</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#fuzz-%E4%B8%BB%E8%A6%81%E6%B5%81%E7%A8%8B"><span class="nav-text">fuzz-主要流程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#show-stats"><span class="nav-text">show_stats</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#fuzz-one"><span class="nav-text">fuzz_one</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%84%E4%B8%AA%E9%98%B6%E6%AE%B5"><span class="nav-text">各个阶段</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#CALIBRATION%E9%98%B6%E6%AE%B5"><span class="nav-text">CALIBRATION阶段</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#TRIMMING%E9%98%B6%E6%AE%B5"><span class="nav-text">TRIMMING阶段</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#PERFORMANCE-SCORE%E9%98%B6%E6%AE%B5"><span class="nav-text">PERFORMANCE SCORE阶段</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#SIMPLE-BITFLIP-dictionary-construction-%E9%98%B6%E6%AE%B5"><span class="nav-text">SIMPLE BITFLIP (+dictionary construction)阶段</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#ARITHMETIC-INC-DEC%E9%98%B6%E6%AE%B5"><span class="nav-text">ARITHMETIC INC&#x2F;DEC阶段</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#INTERESTING-VALUES%E9%98%B6%E6%AE%B5"><span class="nav-text">INTERESTING VALUES阶段</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#DICTIONARY-STUFF%E9%98%B6%E6%AE%B5"><span class="nav-text">DICTIONARY STUFF阶段</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#RANDOM-HAVOC%E9%98%B6%E6%AE%B5"><span class="nav-text">RANDOM HAVOC阶段</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#SPLICING%E9%98%B6%E6%AE%B5"><span class="nav-text">SPLICING阶段</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#sync-fuzzers-char-argv"><span class="nav-text">sync_fuzzers(char **argv)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#trim-case-char-argv-struct-queue-entry-q-u8-in-buf"><span class="nav-text">trim_case(char **argv, struct queue_entry *q, u8 *in_buf)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#u32-calculate-score-struct-queue-entry-q"><span class="nav-text">u32 calculate_score(struct queue_entry *q)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#u8-common-fuzz-stuff-char-argv-u8-out-buf-u32-len"><span class="nav-text">u8 common_fuzz_stuff(char **argv, u8 *out_buf, u32 len)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#u8-save-if-interesting-char-argv-void-mem-u32-len-u8-fault"><span class="nav-text">u8 save_if_interesting(char **argv, void *mem, u32 len, u8 fault)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#simplify-trace-u64-mem"><span class="nav-text">simplify_trace(u64 *mem)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#afl-showmap"><span class="nav-text">afl-showmap</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#afl-analyze"><span class="nav-text">afl-analyze</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="nav-text">参考资料</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">pandamac</p>
  <div class="site-description" itemprop="description">Android/iOS/Macos</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">7</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/pandamac/pandamac.github.io" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;pandamac&#x2F;pandamac.github.io" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:pandashellcode@gmail.com" title="E-Mail → mailto:pandashellcode@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; Sun Feb 23 2020 08:00:00 GMT+0800 (中国标准时间) – 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">pandamac</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script data-pjax async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/pjax/pjax.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>




  




  
<script src="/js/local-search.js"></script>













    <div id="pjax">
  

  

    </div>
</body>
</html>
